@relation 'AllIssues_rxjava-weka.filters.unsupervised.attribute.Remove-R2-3,7,11-12'

@attribute id numeric
@attribute title string
@attribute body string
@attribute commentsBodies string
@attribute repo {RxJava}
@attribute isPullRequest {false,true}
@attribute isLabeled {false,true}
@attribute 'Label bug' {false,true}

@data
9860665,'Refactoring conventions','','',RxJava,true,false,false
9865740,'Language adaptors','Includes Groovy and JRuby','',RxJava,true,false,false
9890781,'Clojure adaptor','','',RxJava,true,false,false
9913926,'remove wrap functionality','We no longer need this as we ve merged the interface and abstract classes together and don t need to ensure we have the abstract class','',RxJava,true,false,false
9994466,'Support multiple class types for language adaptors','','',RxJava,true,false,false
10034376,Refactoring,'convert to rx package names rx observables rx observables operations private package from javadocs rx util rx lang rx concurrency placeholder for schedulers change Func order to have return type at end T R instead of R T this matches the C# and Guava conventions added Action as Func without return value added overload subscribe methods with Action typed arguments added from alias methods in Observable','',RxJava,true,false,false
10036697,'Observable abstract or final','There is discussion about whether Observable should be a final class and only be usable via Observable create Func or whether we should leave it as abstract Discuss and decide','I vote not final If it were final then it would be impossible to extend Observable to add operators and still interoperate with other code that uses Observable Agreed We have decided to not make it final But we also have changed it from being abstract to a normal concrete class The subscribe implementation is passed in via a protected constructor or using Observable create Func1',RxJava,false,true,false
10036787,'Should filter be converted from Func T Boolean to Pred T','Should we add a new special predicate object instead of using Func T Boolean','',RxJava,false,true,false
10036869,'Documentation Introduction','','',RxJava,false,false,false
10036880,'Documentation Observables Observer','','',RxJava,false,false,false
10036948,'Operator ObserveOn','http msdn microsoft com en us library hh211920 v vs 103 aspx http msdn microsoft com en us library hh229634 v vs 103 aspx','Merged via https github com Netflix RxJava pull 225',RxJava,false,true,false
10036960,'Operator SubscribeOn','http msdn microsoft com en us library hh228963 v vs 103 aspx http msdn microsoft com en us library hh229238 v vs 103 aspx','Merged via https github com Netflix RxJava pull 225',RxJava,false,true,false
10036966,'Operator Switch','http msdn microsoft com en us library hh229197 v vs 103 aspx','',RxJava,false,true,false
10036971,'Operator Throttle','http msdn microsoft com en us library hh229298 v vs 103 aspx http msdn microsoft com en us library hh229400 v vs 103 aspx','',RxJava,false,true,false
10036977,'Operator Publish and PublishLast','http msdn microsoft com en us library hh229126 v vs 103 aspx http msdn microsoft com en us library hh211622 v vs 103 aspx http msdn microsoft com en us library hh229147 v vs 103 aspx http msdn microsoft com en us library hh229797 v vs 103 aspx http msdn microsoft com en us library hh228989 v vs 103 aspx http msdn microsoft com en us library hh211697 v vs 103 aspx','Good intro here http northhorizon net 2011 sharing in rx Thanks for linking that article very helpful Still missing publishLast This can be closed now as #407 included publishLast',RxJava,false,true,false
10036984,'Operator Buffer','http msdn microsoft com en us library hh212130 v vs 103 aspx http msdn microsoft com en us library hh229308 v vs 103 aspx http msdn microsoft com en us library hh228968 v vs 103 aspx http msdn microsoft com en us library hh229200 v vs 103 aspx http msdn microsoft com en us library hh211764 v vs 103 aspx http msdn microsoft com en us library hh211715 v vs 103 aspx http msdn microsoft com en us library hh229612 v vs 103 aspx http msdn microsoft com en us library hh229813 v vs 103 aspx http msdn microsoft com en us library hh229432 v vs 103 aspx http msdn microsoft com en us library hh229621 v vs 103 aspx','I ll have a look at this operator I ve got something ready Just finishing up documentation and making sure it meets guidelines and coding style I hope to submit a pull request for this soon and would love to get some feedback Good resource on this subject http www introtorx com content v1 0 10621 0 13_TimeShiftedSequences html#Buffer reviewing pull request',RxJava,false,true,false
10037068,'Subject implementations','http msdn microsoft com en us library hh242969 v vs 103 aspx This issue is intended to cover the implementation of various Subjects as part of Rx Net intended for placement in rx subjects','The ReplaySubject was implemented in https github com Netflix RxJava pull 218 Hey I noticed this issue is still open Did I forget to implement a Subject Looks like they are now all done Thank you @michaeldejong',RxJava,false,true,false
10037098,'Operator ToIterable','We already from toObservable Iterable from Iterable add the reverse blocking toIterable similar to the non blocking toList which already exists ToEnumerable from C# http msdn microsoft com en us library hh212132 v vs 103 aspx','ToEnumerable don t seems to be different from ToList First one returns IObservable IList TSource second one IEnumerable TSource The toList operator is non blocking as it returns Observable List T whereas to Iterable is blocking and returns Iterable T The key difference is non blocking versus blocking otherwise yes they behave similarly The other difference though is that toList will wait until the observable sequence is onCompleted and then emit the List whereas toIterable will buffer but start allowing take to be called immediately as each onNext value is emitted Merged By the way a key difference in Java is that Iterable is not an equal dual with Observable whereas IEnumerable is a dual to IObservable in Net where both have extension methods with all the functional operators Since Java doesn t have extension methods we can t do that here At best we could have another parallel framework for wrapping an Iterable',RxJava,false,true,false
10037177,'Rx Schedulers','Implementation of Rx Schedulers http msdn microsoft com en us library hh242963 v vs 103 aspx probably to go into the rx concurrency package https github com Netflix RxJava tree master rxjava core src main java rx concurrency','Interesting quote from that page If you do not use the overload which takes a scheduler as an argument Rx will pick a default scheduler by using the principle of least concurrency This means that the scheduler which introduces the least amount of concurrency that satisfies the needs of the operator is chosen For example for operators returning an observable with a finite and small number of messages Rx calls Immediate For operators returning a potentially large or infinite number of messages CurrentThread is called For operators which use timers ThreadPool is used How would an operator know how many messages it is going to have Only the origin Observable could know that a given operator along the chain won t know so how does this get accomplished I guess this would mean that things like toObservable 1 2 3 4 are a known thing and can be done immediately without a thread but merging 4 unknown sequences can t be known Obviously when Timers are used a Thread of some kind is needed java util Timer or another implementation like this https github com Netflix Hystrix blob master hystrix core src main java com netflix hystrix util HystrixTimer java For the majority of cases though where the cost of the observable sequence is unknown I don t know that I like automatically spawning them off on threads It has worked well for the Netflix API to leave that choice to the origin of the observable to be synchronous or asynchronous one thread or many etc The introduction of Schedulers makes perfect sense when an app is dealing with data structures their own synchronous IO operations or CPU bound computations but it becomes awkward when consuming from a 3rd party API exposing Observables who can and will make their own choice about being synchronous or asynchronous In fact that s been a huge part of the draw to Rx is that the API doesn t need to change when the backend implementations moves between synchronous and asynchronous for whatever reason it may choose to do so If the Observable is already asynchronous it would be inefficient to spin up another thread that in turn blocks on an async call Other than documentation on the API calls that return Observables is there a better way to handle that scenario I can imagine a scenario where some apps such as the Netflix API may want to disable any use of Schedulers so the origin retains control since Rx has allowed us to decouple the writing of business logic from the decisions of concurrency Before flaming me I DO like schedulers it s very powerful and we will definitely get them added I just have some questions about balancing that power and inevitable inefficiencies of making poor scheduler choices with the elegant simplicity of Rx Observables without them where concurrency is not a thought everything is just asynchronous I m interested in all of your perspectives so please chime in The docs say least amount of concurrency which I interpreted to mean that if the amount of work is unknown that it would it default to immediate We could still manipulate the defaults and probably ignore Schedulers passed in through a strategy Yes I think a strategy pattern will be needed to accomplish the Netflix API use case Some thoughts while working on the design of this The Scheduler interface should be capable of supporting different sources of concurrency such as Executors Threads Actors EventLoops We should be capable of supporting rxjava contrib modules with new types of Schedulers such as for Akka Scala Actors We need the ability via plugins probably of a system to override or prevent usage of Schedulers where they want For example if a system doesn t want client code starting threads they should be able to intercept and ignore or throw UnsupportedOperationException Sections 6 9 through 6 12 of the Rx Design Guidelines PDF http go microsoft com fwlink LinkID 205219 should be read by anyone involved in Schedulers design and implementation There s also this video http channel9 msdn com blogs j van gogh controlling concurrency in rx explaining the motivation behind introducing schedulers in Rx Good video thanks for the link First round of Schedulers implementation committed via pull request https github com Netflix RxJava pull 225 contribued by @mairbek It implements ObserveOn https github com Netflix RxJava issues 11 and SubscribeOn https github com Netflix RxJava issues 12 Open questions ### 1 Scheduler Time We re not using the Scheduler now value anywhere should we be or is that only for the Virtual scheduler used for testing ### 2 Use of SubscribeOn vs Scheduler scheduler I m trying to understand how operator overloads should use Scheduler Here is a potential implementation https github com Netflix RxJava pull 227 and another https github com Netflix RxJava pull 226 I have not yet found C# source code or documentation that clarifies this I have also had feedback that I agree with that it this is clearer java merge o1 o2 subscribeOn scheduler than this java merge o1 o2 scheduler So is there anything different between this ### 3 Multiple Schedulers in Sequence I m trying to understand how a sequence should work when multiple subscribeOn operators are applied at different steps of a sequence and it is unclear to me how the unit test below should behave Can someone with an Rx Net environment setup implement a test similar to this from Java and tell me the output java @Test public void testMixedSchedulers throws InterruptedException final String mainThreadName Thread currentThread getName Observable String o Observable String create new Func1 Observer String Subscription @Override public Subscription call Observer String observer System out println Origin observable is running on Thread currentThread getName assertFalse Thread currentThread getName equals mainThreadName assertTrue Actually Thread currentThread getName Thread currentThread getName startsWith RxIOThreadPool observer onNext one observer onNext two observer onNext three observer onCompleted return Subscriptions empty subscribeOn Schedulers threadPoolForIO subscribe to the source on the IO thread pool now merge on the CPU threadpool o Observable String merge o Observable String from four five subscribeOn Schedulers threadPoolForComputation map new Func1 String String @Override public String call String v opportunity to see what thread the merge is running on System out println Merge is running on Thread currentThread getName return v final CountDownLatch latch new CountDownLatch 1 final AtomicReference RuntimeException onError new AtomicReference RuntimeException subscribe on a new thread o subscribe new Observer String @Override public void onCompleted System out println received onCompleted latch countDown @Override public void onError Exception e System out println received onError e getMessage onError set RuntimeException e latch countDown @Override public void onNext String v System out println Final subscribe is running on Thread currentThread getName System out println onNext v Schedulers newThread wait for the above to finish or blow up if it s blocked latch await 5 TimeUnit SECONDS Of course Rx Net doesn t have the IO and CPU thread pools those are just helper methods to Executors which would be 2 separate threadpools for different work types so you ll need to adjust that Concerning 1 I guess it will come in handy when implementing #90 or clock like observables in general at least if I understand this correctly I m currently figuring out how working with the schedulers feels by playing around with an implementation for #74 which also requires a clock though it doesn t seem to require the current time I received the following feedback that will require a breaking change to the Scheduler interface It is essential to be able to access the scheduler inside the action to recursively schedule yourself Just having a Func1 Subscription is not very useful since there is no opportunity to return the subscription before the function terminates C# Interface IScheduler Schedule TState TState s Func IScheduler TState IDisposable a Schedule TState TState s DateTimeOffset d Func IScheduler TState IDisposable a Schedule TState TState s TimeSpan t Func IScheduler TState IDisposable a You want to be able to write something like this C# void Main var repeat Observable Create int observer while true observer OnNext 42 return var dispose repeat Subscribe Console WriteLine var dispose ObservableEx ToObservable NewThreadScheduler Default Select _ 42 Subscribe x Console WriteLine x Console ReadLine dispose Dispose Console WriteLine Bye static class ObservableEx public static IObservable Unit ToObservable this IScheduler scheduler return Observable Create Unit observer return scheduler ScheduleAsync async _scheduler token while token IsCancellationRequested observer OnNext Unit Default await _scheduler Sleep TimeSpan FromSeconds 2 Here is another use case C# var scheduler TaskPoolScheduler Default var xs Observable Generate 0 i true i i 1 i i i TimeSpan FromSeconds 1 scheduler var ys Observable Create int observer return scheduler ScheduleAsync async _scheduler cancel await _scheduler Yield for var i 0 cancel IsCancellationRequested i observer OnNext i await _scheduler Sleep TimeSpan FromSeconds 1 var dispose ys Timestamp Subscribe x Console WriteLine x ToString var dispose ys Timestamp DumpLive Subscribe Console ReadLine dispose Dispose Console WriteLine disposed Console ReadLine Note that I m unavailable to work on this until the 15th Anyone else who wants to jump in and determine the changes needed based on this feedback please do Here is some simple code I was playing with to prove out the use of subscribeOn from an Observable API and it appears to be working as we want and from what I can tell it is conforming to the Rx contract and not injecting concurrency where it shouldn t Anyone find faults in this groovy import rx import rx concurrency Schedulers PRODUCER CODE This is the Observable API Observable Video getVideos return Observable create observer Thread sleep 200 simulate network traffic 10 videos are fetched in a batch and emitted observer onNext new Video 1 observer onNext new Video 2 observer onNext new Video 3 observer onNext new Video 4 observer onNext new Video 5 observer onNext new Video 6 observer onNext new Video 7 observer onNext new Video 8 observer onNext new Video 9 observer onNext new Video 10 observer onCompleted class Video final int id public Video int id this id id Observable Rating getRating return Observable create observer Thread sleep 200 simulate network traffic observer onNext new Rating id observer onCompleted subscribeOn Schedulers threadPoolForIO Observable Bookmark getBookmark return Observable create observer Thread sleep 200 simulate network traffic observer onNext new Bookmark id observer onCompleted subscribeOn Schedulers newThread class Rating final String value public Rating int id this value ratingFor_ id class Bookmark final String value public Bookmark int id this value bookmarkFor_ id CONSUMER CODE This is a client consuming the Observable API long start System currentTimeMillis getVideos mapMany Video video fetch and transform bookmark Observable ob video getBookmark map b return transformed b value fetch ratings and zip together with bookmark return Observable zip ob video getRating b r return b value r value map tuple combine all metadata for a single Video return id video id bookmark tuple 0 rating tuple 1 forEach videoMap System out println Video videoMap id bookmark videoMap bookmark rating videoMap rating Thread Thread currentThread long end System currentTimeMillis System out println time end start Output is Video 5 bookmark transformed bookmarkFor_5 rating ratingFor_5 Thread Thread RxIOThreadPool 5 5 main Video 9 bookmark transformed bookmarkFor_9 rating ratingFor_9 Thread Thread RxIOThreadPool 9 5 main Video 10 bookmark transformed bookmarkFor_10 rating ratingFor_10 Thread Thread RxIOThreadPool 10 5 main Video 2 bookmark transformed bookmarkFor_2 rating ratingFor_2 Thread Thread RxIOThreadPool 2 5 main Video 4 bookmark transformed bookmarkFor_4 rating ratingFor_4 Thread Thread RxIOThreadPool 4 5 main Video 8 bookmark transformed bookmarkFor_8 rating ratingFor_8 Thread Thread RxIOThreadPool 8 5 main Video 6 bookmark transformed bookmarkFor_6 rating ratingFor_6 Thread Thread RxIOThreadPool 6 5 main Video 3 bookmark transformed bookmarkFor_3 rating ratingFor_3 Thread Thread RxIOThreadPool 3 5 main Video 7 bookmark transformed bookmarkFor_7 rating ratingFor_7 Thread Thread RxIOThreadPool 7 5 main Video 1 bookmark transformed bookmarkFor_1 rating ratingFor_1 Thread Thread RxIOThreadPool 1 5 main time 659 @benjchristensen I m left wondering if or how question 3 from your comment https github com Netflix RxJava issues 19#issuecomment 15979582 was addressed or whether this is still an open question In our app we haven t quite figured out yet which layer should be responsible for scheduling an observable If we schedule on the service layer which would make sense when trying to make client code oblivious as to whether code runs concurrently or not then what does that mean for reusability of observables Would say service A be able to take an observable from service B which has already been scheduled by B transform and re schedule it With the pre 0 8 Schedulers this is not possible since subscribeOn observeOn will wrap as many times as you call these methods I think the JavaDocs haven t been updated yet http netflix github io RxJava javadoc rx Scheduler html Is there any documentation examples around what the state parameter is used for Looking at the existing schedulers I only ever see it being passed through so I wonder what this accomplishes Here s an example by @mairbek using state https github com Netflix RxJava pull 229#issuecomment 16115941 I forgot to upload the new Javadocs will do so once I m at my laptop Sorry about that @mttkay I found wifi uploaded javadocs for 0 8 0 Also the example from @mairbek was incorporated into unit tests here https github com Netflix RxJava blob master rxjava core src test java rx concurrency TestSchedulers java#L255 I believe we re pretty comfortable with the Schedulers implementation and interface as of 0 11 0 12 so closing this out',RxJava,false,true,false
10037397,'Operator Aggregate','Add aggregate or alias to reduce http msdn microsoft com en us library hh229154 v vs 103 aspx','Done in pull request #257',RxJava,false,true,false
10037410,'Operator All','http msdn microsoft com en us library hh229537 v vs 103 aspx','',RxJava,false,true,false
10037427,'Operator Amb','http msdn microsoft com en us library hh229115 v vs 103 aspx http msdn microsoft com en us library hh229733 v vs 103 aspx http msdn microsoft com en us library hh211783 v vs 103 aspx','',RxJava,false,true,false
10037450,'Operator And','http msdn microsoft com en us library hh229153 v vs 103 aspx http msdn microsoft com en us library hh229905 v vs 103 aspx','This operation requires a join pattern sub framework to be created rx joins Additionally due to method arities this might require Action4 Action9 ActionN classes I have these in pull #505 if decided However I don t quite understand the join patterns as most of the Rx NET classes are internal and without documentation I can convert it to java but no idea what tests to create for them',RxJava,false,true,false
10037461,'Operator Any','http msdn microsoft com en us library hh229905 v vs 103 aspx http msdn microsoft com en us library hh211993 v vs 103 aspx','I think this issue can be closed',RxJava,false,true,false
10037522,'Operator Average','http msdn microsoft com en us library hh211950 v vs 103 aspx http msdn microsoft com en us library hh229389 v vs 103 aspx http msdn microsoft com en us library hh211732 v vs 103 aspx http msdn microsoft com en us library hh211857 v vs 103 aspx http msdn microsoft com en us library hh211744 v vs 103 aspx http msdn microsoft com en us library hh211770 v vs 103 aspx http msdn microsoft com en us library hh212005 v vs 103 aspx http msdn microsoft com en us library hh229502 v vs 103 aspx http msdn microsoft com en us library hh229070 v vs 103 aspx http msdn microsoft com en us library hh229012 v vs 103 aspx','',RxJava,false,true,false
10037578,'Operator Cast','http msdn microsoft com en us library hh211842 v vs 103 aspx','',RxJava,false,true,false
10042768,'Scala adaptor','','Reviewed by Ben C',RxJava,true,false,false
10112208,'Operator Catch','http msdn microsoft com en us library hh229103 v vs 103 aspx http msdn microsoft com en us library hh211934 v vs 103 aspx http msdn microsoft com en us library hh211765 v vs 103 aspx How does this relate to this public static T Observable T onErrorResumeNext final Observable T that final Func1 Exception Observable T resumeFunction','If this gets added it would be part of rxjava contrib rxjava computation expressions Closing out though as it is not a required operator',RxJava,false,true,false
10112222,'Operator CombineLatest','http msdn microsoft com en us library hh211991 v vs 103 aspx','What s the status on this operator There is some code but the tests look a bit different from what I would expect this operator to do Shouldn t java w1 Observer onNext 1a w1 Observer onCompleted w2 Observer onNext 2a w2 Observer onNext 2b w2 Observer onCompleted w3 Observer onNext 3a w3 Observer onNext 3b w3 Observer onNext 3c w3 Observer onNext 3d w3 Observer onCompleted generate 1a2b3a then 1a2b3b then 1a2b3c then 1a2b3d Because it starts with the latest values of w1 and w2 as soon as w3 fires its first string To me this currently looks a bit like a mixture between zip and combineLatest But maybe I m understanding the semantics of combineLatest wrong The current code seems to still wait for an onNext from each combined observable before firing its own onNext I d love to try and fix that if you can confirm that I understand combineLatest correctly As I m reading through this I m using the following to research the expected behavior http blogs microsoft co il blogs bnaya archive 2010 03 10 rx for beginners part 8 combine latest expression aspx http theburningmonk com 2010 03 rx framework iobservable combinelatest Like IObservable T Zip IObservable T CombineLatest com bines pairs of val ues from the two observ able col lec tions but unlike Zip when a new value becomes avail able on one col lec tion it does not wait till a new value to be avail able on the other col lec tion instead it takes what ever the lat est value is from the other col lec tion pro vided there is one The test case appears to be as follows x onNext 1 y onNext a x onNext 2 x onNext 3 y onNext b x onNext 4 This should result in a1 a2 a3 b3 b4 On each onNext from whatever sequence sends it the combination will be emitted using whatever the latest value is Extrapolating that into a unit test I get something like this java @Test public void testCombineLatestDifferentLengthObservableSequencesWithInterleaving1 Observer String w mock Observer class TestObservable x new TestObservable TestObservable y new TestObservable Observable String combineLatestW Observable create combineLatest y x getConcat2StringsCombineLatestFunction combineLatestW subscribe w simulate sending data x Observer onNext 1 y Observer onNext a x Observer onNext 2 x Observer onNext 3 y Observer onNext b x Observer onNext 4 x Observer onCompleted y Observer onCompleted we should have been called 5 times on the Observer InOrder inOrder inOrder w inOrder verify w onNext a1 inOrder verify w onNext a2 inOrder verify w onNext a3 inOrder verify w onNext b3 inOrder verify w onNext b4 inOrder verify w times 1 onCompleted This test fails with current code So yes the current implementation is wrong and it s crazy complicated I ll take a look at your pull request for this fix hopefully tomorrow though I have a lot of meetings so Thank you @jmhofer I agree Your test should work with my pull request as I ve added a similar test Also I simplified the code a bit but I wasn t sure how thoroughly I could should rework it so I kept the basic structure I guess the complexity mostly comes from the Zip operator it seems to have been copied from originally The one thing I m still unsure of is when the combined stream should complete That first of your links above says the Combine Latest processing will come to end either when one of the stream will complete or throw exception However I don t really see a reason why it should complete before all streams are complete I haven t found any other specification yet for cross checking this You can change the implementation to whatever makes sense as I obviously misunderstood the behavior when I implemented this long ago and stole the base functionality from zip which starts it from the wrong place altogether since it shouldn t do queuing and thus doesn t need a lot or any of the synchronization the zip requires Your last question is a good one If an onError is received at any time the whole thing should finish and propagate the error For the onCompleted question I m not sure the C# code will provide the definitive answer I ll try to review that no time right now unless you can beat me to it or find a better answer somewhere else https rx codeplex com SourceControl changeset view aa25748a430e#Rx NET Source System Reactive Linq Reactive Linq Observable CombineLatest cs Another way would be a Rx Net or RxJS test case if you have access to either of those or someone who does The C# code looks very much like they complete only when all streams are complete when there are no errors That s good then the pull request code should already handle that correctly Great then I ll proceed with the review and merge I appreciate your willingness to dive into this one and deal with that gnarly code So if I understand correctly synchrononous blocking sequences make combineLatest behavior rather odd such as this where only the last value of the first sequence will ever show up in the combined values java Observable String w Observable create combineLatest Observable toObservable one two Observable toObservable 2 3 4 combineLatestFunction w subscribe aObserver verify aObserver times 1 onNext two2 verify aObserver times 1 onNext two3 verify aObserver times 1 onNext two4 Yes I think so I came to that conclusion too latest doesn t really make much sense in the synchronous case I updated my pull request I had previously forgotten to adapt the comments Also I cleaned up the code a bit and tried to fix synchronization it s hard as always I have merged pull request https github com Netflix RxJava pull 207 to resolve this issue',RxJava,false,true,false
10112240,'Operator Concat','http msdn microsoft com en us library hh212124 v vs 103 aspx http msdn microsoft com en us library hh229289 v vs 103 aspx http msdn microsoft com en us library hh211916 v vs 103 aspx http msdn microsoft com en us library hh212146 v vs 103 aspx','',RxJava,false,true,false
10112255,'Operator Contains','http msdn microsoft com en us library hh228965 v vs 103 aspx http msdn microsoft com en us library hh229815 v vs 103 aspx','',RxJava,false,true,false
10112265,'Operator Count','http msdn microsoft com en us library hh229470 v vs 103 aspx','',RxJava,false,true,false
10112333,'Confirm Create Operator','The create operator is already implemented but need to confirm all overloads and use cases are accounted for http msdn microsoft com en us library hh229122 v vs 103 aspx http msdn microsoft com en us library hh229114 v vs 103 aspx','',RxJava,false,true,false
10112672,'Operator DefaultIfEmpty','http msdn microsoft com en us library hh229332 v vs 103 aspx http msdn microsoft com en us library hh229624 v vs 103 aspx','',RxJava,false,true,false
10112685,'Operator Defer','http msdn microsoft com en us library hh229160 v vs 103 aspx','',RxJava,false,true,false
10112709,'Operator Delay','http msdn microsoft com en us library hh229677 v vs 103 aspx http msdn microsoft com en us library hh229810 v vs 103 aspx http msdn microsoft com en us library hh229250 v vs 103 aspx http msdn microsoft com en us library hh229280 v vs 103 aspx','Once we have this operator we can implement Time Flies Like An Arrow http reactive extensions github io RxJS Examples timeflies timeflies html Pretty I ll see what I can do @benjchristensen What about implementing delay as combination of interval and first operations @lexer I don t think that can get us the needed functionality Here is the discussion https github com Netflix RxJava pull 384#issuecomment 26393612 Delay is implemented',RxJava,false,true,false
10112746,'Operator Dematerialize','http msdn microsoft com en us library hh229047 v vs 103 aspx','',RxJava,false,true,false
10112785,'Operator Distinct','http msdn microsoft com en us library hh229764 v vs 103 aspx http msdn microsoft com en us library hh211630 v vs 103 aspx http msdn microsoft com en us library hh244310 v vs 103 aspx http msdn microsoft com en us library hh229050 v vs 103 aspx','',RxJava,false,true,false
10112788,'Operator DistinctUntilChanged','http msdn microsoft com en us library hh229494 v vs 103 aspx http msdn microsoft com en us library hh229776 v vs 103 aspx http msdn microsoft com en us library hh229508 v vs 103 aspx http msdn microsoft com en us library hh229533 v vs 103 aspx','',RxJava,false,true,false
10112812,'Operator Do','http msdn microsoft com en us library hh229804 v vs 103 aspx http msdn microsoft com en us library hh229307 v vs 103 aspx http msdn microsoft com en us library hh229659 v vs 103 aspx http msdn microsoft com en us library hh229539 v vs 103 aspx http msdn microsoft com en us library hh229830 v vs 103 aspx','was trying to implement this but since do is a java keyword we ca t have it as a method name net js use Do with caps ReactiveCocoa uses doNext doError and doCompleted Should rxjava too use this naming standard I don t see how we would have all 3 of doNext doError and doCompleted as method names as those are the various overload arguments being passed in For the method name I wish forEach wasn t used for the synchronous version as that is exactly what this is Options I can think of are doForEach doOnEach for each onEach doTo This should be easy to implement using map since it seems to basically be map except it always returns the same type T instead of allowing it to be transformed Am I understanding it correctly I believe the method signatures will end up looking like this once we figure out the name java Observable T nameOfFunction Observable T source Action1 T onNext Observable T nameOfFunction Observable T source Observer T observer Observable T nameOfFunction Observable T source Action1 T onNext Action onCompleted Observable T nameOfFunction Observable T source Action1 T onNext Action1 Exception onError Observable T nameOfFunction Observable T source Action1 T onNext Action1 Exception onError Action onCompleted Does this function allow modifying the values or does it always return the exact same Observable source In other words is this only for performing side effects I think a function name with do prefix might be better Coming from a net rx rac I would expect a do method Yes it can be easily implemented using map but this would only work for onNext Migt have to use mapMany or materialize dematerialize combination for others Some info on rx do http stackoverflow com q 8732001 157260 OperationMap creates a new MapObserver with every subscription As a consequence func is evaluated for every onNext as many times as there are subscriptions While this might be ok for pure functions it would be very inconvenient for a do observable that is only there for its side effects e g something that logs events Generally operators in a sequence do execute each time they are subscribed to unless something like publish multicast replay etc caches the results of a subscription and becomes the source of a new sequence The documentation I ve read is very unclear regarding do but I don t see anything implying that it would ignore subsequence subscribe invocations For example groovy def o anObservable take 5 map transformHere merge anotherObservable do doSideEffectsHere subscribe to it once o subscribe then subscribe again with another transformation done o map anotherTransformation subscribe With sequence o being subscribed to twice I don t see anything about it that says it should cache everything before it and only be invoked once It seems to me that it will perform the side effects twice unless the sequence has publish multicast refCount etc put into def o anObservable take 5 map transformHere merge anotherObservable do doSideEffectsHere publish refCount The code above adds publish refCount which will cause the previous operators to be executed only once and shared to all subsequent subscriptions http northhorizon net 2011 sharing in rx Here is the Net code for do https rx codeplex com SourceControl changeset view 332fa75ecdb1#Rx NET Source System Reactive Linq Reactive Linq Observable Do cs I m not experienced with C# so can t guarantee I understand it but I see nothing in that code that automatically is caching the sequence Thus I think the do operator will be executed each time just like other operators when subscribed to Am I misunderstanding something about the contract specified by Rx Net @prabirshrestha It makes sense to keep the do prefix so what do you prefer of these doForEach doOnEach doTo Is there a better option I lean towards doOnEach because on fits the onNext onError onCompleted naming convention @benjchristensen Even I preferred doOnEach That was what I started to use Thus I think the do operator will be executed each time just like other operators when subscribed to Thats right I will verify this with net too @mva do operator can be used to follow divide and conquer pattern to Here is a c# sample code from http www codeproject com Articles 132966 Exploring Reactive Extensions Rx through Twitter a c# Observable FromEvent TextChangedEventArgs searchTextBox TextChanged Select e TextBox e Sender Text Where text text Length 2 Do s searchResults Opacity 0 5 reduce list opacity when typing Throttle TimeSpan FromMilliseconds 400 ObserveOnDispatcher Do s LoadingIndicator Visibility Visibility Visible show the loading indicator SelectMany txt searchTwitter txt Select searchRes ParseTwitterSearch searchRes ObserveOnDispatcher Do s LoadingIndicator Visibility Visibility Collapsed hide the loading indicator Do s searchResults Opacity 1 return the list opacity to one Subscribe tweets searchResults ItemsSource tweets I found using do in mobile apps this way really useful @benjchristensen I think I am starting to understand the distinction you are making The side effect of a do is not owned by the single observable instance but rather by its potentially many subscribers Using logging as an example this makes perfect sense for a cold passive observable because every value send to a subscriber is independent of all other values and deserves its own log entry On the other hand if I want to log the output of a hot active observable irregardless of the possibly zero number of subscribers I would put the do on the path from the observable to a Publish Connect Here exactly one log entry would be written for each value produced by the hot observable Thank you for your explanation',RxJava,false,true,false
10112836,'Operator ElementAt and ElementAtOrDefault','http msdn microsoft com en us library hh229725 v vs 103 aspx http msdn microsoft com en us library hh229845 v vs 103 aspx','I think this issue can be closed',RxJava,false,true,false
10112843,'Operator Empty with scheduler','http msdn microsoft com en us library hh229066 v vs 103 aspx','',RxJava,false,true,false
10112855,'Operator Finally','http msdn microsoft com en us library hh212133 v vs 103 aspx','@abliss Pull Request https github com Netflix RxJava pull 196 was manually merged via @joshgord s Pull Request https github com Netflix RxJava pull 222 @joshgord is working on unit tests of Exceptions getting thrown by operation in finally block Once that s done this issue will be closed Here is the test case @mattrjacobs is referring to @Test public void testFinallyError Action0 errorAction new Action0 @Override public void call throw new RuntimeException boo try Observable create finallyDo Observable toObservable foo errorAction subscribe aObserver fail catch Exception e pass We will address the exception handling in another issue and will close this one out now Thank you very much @abliss for you contribution',RxJava,false,true,false
10112874,'Operator First and FirstOrDefault','http msdn microsoft com en us library hh229177 v vs 103 aspx http msdn microsoft com en us library hh229739 v vs 103 aspx http msdn microsoft com en us library hh229320 v vs 103 aspx http msdn microsoft com en us library hh229759 v vs 103 aspx','',RxJava,false,true,false
10112884,'Operator ForEach','http msdn microsoft com en us library hh211815 v vs 103 aspx','',RxJava,false,true,false
10113055,'Operator FromAsyncPattern','http msdn microsoft com en us library hh211609 v vs 103 aspx http msdn microsoft com en us library hh212031 v vs 103 aspx http msdn microsoft com en us library hh229082 v vs 103 aspx http msdn microsoft com en us library hh229412 v vs 103 aspx http msdn microsoft com en us library hh211747 v vs 103 aspx http msdn microsoft com en us library hh229591 v vs 103 aspx http msdn microsoft com en us library hh211886 v vs 103 aspx http msdn microsoft com en us library hh244234 v vs 103 aspx http msdn microsoft com en us library hh229932 v vs 103 aspx http msdn microsoft com en us library hh229310 v vs 103 aspx http msdn microsoft com en us library hh228969 v vs 103 aspx http msdn microsoft com en us library hh229364 v vs 103 aspx http msdn microsoft com en us library hh211735 v vs 103 aspx http msdn microsoft com en us library hh211688 v vs 103 aspx http msdn microsoft com en us library hh229052 v vs 103 aspx http msdn microsoft com en us library hh229172 v vs 103 aspx http msdn microsoft com en us library hh229266 v vs 103 aspx http msdn microsoft com en us library hh211975 v vs 103 aspx http msdn microsoft com en us library hh229724 v vs 103 aspx http msdn microsoft com en us library hh211982 v vs 103 aspx http msdn microsoft com en us library hh211893 v vs 103 aspx http msdn microsoft com en us library hh229544 v vs 103 aspx http msdn microsoft com en us library hh229074 v vs 103 aspx http msdn microsoft com en us library hh229398 v vs 103 aspx http msdn microsoft com en us library hh211651 v vs 103 aspx http msdn microsoft com en us library hh244245 v vs 103 aspx http msdn microsoft com en us library hh211847 v vs 103 aspx http msdn microsoft com en us library hh229623 v vs 103 aspx http msdn microsoft com en us library hh229473 v vs 103 aspx http msdn microsoft com en us library hh229393 v vs 103 aspx','I think we don t have an equivalent concept in Java for this maybe NIO2 To adapt these one would need to implement a new mini begin end framework in parallel to the Observable Observer itself Thoughts I think we should skip this Anything relating to IO events for example should be in separate contrib modules such as Android Swing NIO',RxJava,false,true,false
10113072,'Operator FromEvent','http msdn microsoft com en us library hh244301 v vs 103 aspx http msdn microsoft com en us library hh211795 v vs 103 aspx http msdn microsoft com en us library hh229271 v vs 103 aspx http msdn microsoft com en us library hh229241 v vs 103 aspx','I think these are for NET events Java doesn t have its events on a single base neither the interfaces nor the add remove functionality Closing as this doesn t particularly apply We are instead doing this type of work in contrib modules such as for Android and Swing',RxJava,false,true,false
10113102,'Operator FromEventPattern','http msdn microsoft com en us library hh211803 v vs 103 aspx http msdn microsoft com en us library hh229424 v vs 103 aspx http msdn microsoft com en us library hh229221 v vs 103 aspx http msdn microsoft com en us library hh229251 v vs 103 aspx http msdn microsoft com en us library hh229705 v vs 103 aspx http msdn microsoft com en us library hh229017 v vs 103 aspx http msdn microsoft com en us library hh211731 v vs 103 aspx http msdn microsoft com en us library hh229922 v vs 103 aspx','I think this is the same case as #47 Closing as this doesn t particularly apply We are instead doing this type of work in contrib modules such as for Android and Swing',RxJava,false,true,false
10113165,'Operator Generate','http msdn microsoft com en us library hh229642 v vs 103 aspx http msdn microsoft com en us library hh229270 v vs 103 aspx http msdn microsoft com en us library hh212066 v vs 103 aspx http msdn microsoft com en us library hh212014 v vs 103 aspx http msdn microsoft com en us library hh244290 v vs 103 aspx http msdn microsoft com en us library hh211794 v vs 103 aspx','As per @headinthebox this is really only used in demos and super complicated and thus should not be added to RxJava Anything that can be done via generate should instead be done inside Observable create OnSubscribeFunc f optionally with a Scheduler',RxJava,false,true,false
10113174,'Operator GetEnumerator','http msdn microsoft com en us library hh211873 v vs 103 aspx','',RxJava,false,true,false
10113219,'Operator GroupBy','http msdn microsoft com en us library hh229301 v vs 103 aspx http msdn microsoft com en us library hh229261 v vs 103 aspx http msdn microsoft com en us library hh212069 v vs 103 aspx http msdn microsoft com en us library hh229578 v vs 103 aspx','',RxJava,false,true,false
10113229,'Operator GroupByUntil','http msdn microsoft com en us library hh211932 v vs 103 aspx http msdn microsoft com en us library hh229872 v vs 103 aspx http msdn microsoft com en us library hh229433 v vs 103 aspx http msdn microsoft com en us library hh229392 v vs 103 aspx','groupByUntil is implemented If we need want other overloads they can come via new issues',RxJava,false,true,false
10113239,'Operator GroupJoin','http msdn microsoft com en us library hh244235 v vs 103 aspx',Implemented,RxJava,false,true,false
10113245,'Operator IgnoreElements','http msdn microsoft com en us library hh229242 v vs 103 aspx','',RxJava,false,true,false
10113886,'Operator Interval','http msdn microsoft com en us library hh229027 v vs 103 aspx http msdn microsoft com en us library hh228911 v vs 103 aspx','It seems like Interval shares logic with the Timer from issue #92 Interval could be implemented as a Timer call http msdn microsoft com en us library hh229652 v vs 103 aspx with dueTime 0 Sure as soon as Timer is implemented or schedulers can do periodic scheduling the implementation of Interval will get a lot simpler Is the interval operator intended to work if there are several subscribers It looks as if this was simply forgotten Actually I m not sure whether interval itself should or shouldn t support this However you should always be able to use publish connect If that doesn t work then there s definitely something wrong I can go check that later I probably didn t think of that when implementing it I just tried it out in C# This code static void Main var oneNumberPerSecond Observable Interval TimeSpan FromSeconds 1 Take 5 oneNumberPerSecond Subscribe x Console WriteLine subscriber 1 got x oneNumberPerSecond Subscribe x Console WriteLine subscriber 2 got x Console ReadLine produces this output subscriber 2 got 0 subscriber 1 got 0 subscriber 2 got 1 subscriber 1 got 1 subscriber 2 got 2 subscriber 1 got 2 subscriber 2 got 3 subscriber 1 got 3 subscriber 2 got 4 subscriber 1 got 4 So I think we should update the RxJava version to support multiple subscribers Compare to Java Code public static void main String args Observable Long oneNumberPerSecond Observable interval 1 TimeUnit SECONDS take 5 oneNumberPerSecond subscribe new Action1 Long public void call Long x System out println subscriber 1 got x oneNumberPerSecond subscribe new Action1 Long public void call Long x System out println subscriber 2 got x Output subscriber 1 got 0 subscriber 2 got 1 subscriber 1 got 2 subscriber 2 got 3 subscriber 1 got 4 subscriber 2 got 5 subscriber 1 got 6 subscriber 2 got 7 subscriber 1 got 8 subscriber 2 got 9 I think this will be used a lot for small examples and so it should be fixed soon @benjchristensen could you please reopen this issue What does Rx NET do when you wait a bit before subscribing the second time Will it do this subscriber 1 got 0 subscriber 1 got 1 subscriber 1 got 2 subscriber 2 got 2 subscriber 1 got 3 subscriber 2 got 3 subscriber 1 got 4 subscriber 2 got 4 Or will it still start at 0 with subscriber 2 I added a first test for that use case here https github com jmhofer RxJava commit 2fe6da751957b41dd1b89083ec3aaed940042065 It fails as expected from your comment above The Rx Design Guidelines 5 10 say As many observable sequences are cold see cold vs hot on Channel 9 each subscription will have a separate set of side effects Certain situations require that these side effects occur only once The Publish operator provides a mechanism to share subscriptions by broadcasting a single subscription to multiple subscribers So I guess it would be okay for the second subscriber to always start at 0 too when subscribing to the same observable later and not using publish connect There are probably other operators that are affected by this too because multiple subscribers are currently normally not getting tested by the unit tests Here s another example from C# static void Main var oneNumberPerSecond Observable Interval TimeSpan FromSeconds 1 Take 5 var watch new Stopwatch watch Start Thread Sleep 2200 Console WriteLine subscriber 1 subscribes at t watch ElapsedMilliseconds oneNumberPerSecond Subscribe x Console WriteLine subscriber 1 got x at t watch ElapsedMilliseconds Thread Sleep 1300 Console WriteLine subscriber 2 subscribes at t watch ElapsedMilliseconds oneNumberPerSecond Subscribe x Console WriteLine subscriber 2 got x at t watch ElapsedMilliseconds Console ReadLine outputs subscriber 1 subscribes at t 2200 subscriber 1 got 0 at t 3322 subscriber 2 subscribes at t 3615 subscriber 1 got 1 at t 4319 subscriber 2 got 0 at t 4642 subscriber 1 got 2 at t 5329 subscriber 2 got 1 at t 5643 subscriber 1 got 3 at t 6331 subscriber 2 got 2 at t 6643 subscriber 1 got 4 at t 7344 subscriber 2 got 3 at t 7655 subscriber 2 got 4 at t 8656 So each subscriber starts at 0 Great thanks This means that my PR above should fix this Yes every new subscriber should start the Observable from the beginning I have tried to make sure that s the case everywhere but apparently missed this one If an Observable does not want that behavior that is what the various multicast options are for such as publish replay cache etc Merged in https github com Netflix RxJava pull 379 so closing again',RxJava,false,true,false
10113902,'Operator Join','http msdn microsoft com en us library hh229750 v vs 103 aspx','',RxJava,false,true,false
10113927,'Operator Last','There is already a last operator but Rx includes another overload http msdn microsoft com en us library hh229203 v vs 103 aspx','So it appears our last implementation is wrong and returns Observable T whereas the MSDN docs show it to be blocking http msdn microsoft com en us library hh229056 v vs 103 aspx This will be a breaking change to 0 5 x but needs to be done to conform to the Rx contract TakeLast is the correct non blocking operator https github com Netflix RxJava issues 85 Completed in https github com Netflix RxJava pull 184 and will be released as a breaking change in 0 6 0',RxJava,false,true,false
10114512,'Operator LastOrDefault','http msdn microsoft com en us library hh212051 v vs 103 aspx http msdn microsoft com en us library hh228948 v vs 103 aspx','',RxJava,false,true,false
10114523,'Operator Latest','http msdn microsoft com en us library hh212115 v vs 103 aspx','Is Latest same as Next I read http rx codeplex com SourceControl latest#Rx NET Source System Reactive Linq Reactive Linq Observable Latest cs and http rx codeplex com SourceControl latest#Rx NET Source System Reactive Linq Reactive Linq Observable Next cs in Rx Net But I can t find the difference I believe latest can return a value from the past but falls back the next value if one hasn t been received yet I believe latest can return a value from the past but falls back the next value if one hasn t been received yet @abersnaze Did you mean if the next value hasn t arrived the latest will return the old cached value But there are the following codes in the TryMoveNext method of Latest c# public override bool TryMoveNext out TSource current var kind default NotificationKind var value default TSource var error default Exception #if NO_CDS _semaphore Wait #else _semaphore WaitOne #endif So when TryMoveNext is called it will block the thread and wait for the incoming value I tried the following codes in Rx Next c# IObservable int ob Observable Create int o Console WriteLine Subscribed Before onNext o OnNext 1 Thread Sleep 2000 o OnNext 2 Console WriteLine Subscribed After OnNext o OnCompleted return Disposable Empty var iter ob SubscribeOn Scheduler NewThread Latest GetEnumerator Console WriteLine Before MoveNext while iter MoveNext Console WriteLine Find a value Console WriteLine Got iter Current Console WriteLine After MoveNext The output is pre Before MoveNext Subscribed Before onNext Find a value Got 1 Subscribed After OnNext Find a value Got 2 After MoveNext pre I did some tests on Rx Net about Latest and Next I draw two Marble diagrams to summary the differences between Latest and Next Latest latest https f cloud github com assets 1000778 1721588 2d63aadc 6228 11e3 8060 043cced5720e png For Latest the next of Iterator will check if there is a cached value if so returns the cached value and deleted the cached value If there is not a cached value it will blocks until the next value is emitted from the Observable and returns it Next next https f cloud github com assets 1000778 1721592 3daf6160 6228 11e3 9580 4e135e106dc2 png For Next the next method of Iterator always blocks until the next value is emitted from the Observable and returns it Please let me know if you find any mistake So next will return every value emitted by source whereas latest only those which were observed just before the hasNext call and only once Looking at OperationNext I find it strange to have the waiting atomic boolean in L132 checked in L147 and set in L162 It appears if there is no one is using takeNext the onNext skips an onNext notification L152 quotes some race condition which I don t really see as the observer ignores onError and onCompleted and the materialized source should be race free anyway Sorry that the next diagram is not clear Here is a more clear diagram next1 https f cloud github com assets 1000778 1751622 04725f9e 65f5 11e3 818a fcf1f86ff01a png So for the next operator items will be ignored if they are emitted between two next calls However as the Iterator has two methods hasNext and next it s more complicated Check the document here https github com Netflix RxJava wiki Blocking Observable Operators#next and the discussion here https github com Netflix RxJava pull 433 @zsxwing Are you going to implement this In addition I ve looked at the OperationMostRecent and if I understand it correctly it shares a single subscription to the source observable i e if I try to iterate the same source twice it won t work the second time java BlockingObservable Long source Observable interval 100 TimeUnit MILLISECONDS take 10 toBlockingObservable Iterable Long it source mostRecent 1L for Long l it System out println l Thread sleep 50 System out println for Long l it System out println l Thread sleep 50 Same goes for OperationNext next I can fix both mostRecent and next and take latest You re right The subscribe action should be created in the Iterator rather than the Iterable As I m busy at other work now it would be appreciated if you can fix this issue and the latest operator I m on it Thanks Implemented',RxJava,false,true,false
10114555,'Operator LongCount','http msdn microsoft com en us library hh229120 v vs 103 aspx Do we really need Count and LongCount Perhaps Count should just use a long so we only need one of them','',RxJava,false,true,false
10114593,'Operator Max and MaxBy','http msdn microsoft com en us library hh211633 v vs 103 aspx http msdn microsoft com en us library hh228920 v vs 103 aspx http msdn microsoft com en us library hh211789 v vs 103 aspx http msdn microsoft com en us library hh229262 v vs 103 aspx http msdn microsoft com en us library hh229205 v vs 103 aspx http msdn microsoft com en us library hh211692 v vs 103 aspx http msdn microsoft com en us library hh229793 v vs 103 aspx http msdn microsoft com en us library hh229567 v vs 103 aspx http msdn microsoft com en us library hh229001 v vs 103 aspx http msdn microsoft com en us library hh211981 v vs 103 aspx http msdn microsoft com en us library hh211837 v vs 103 aspx http msdn microsoft com en us library hh211635 v vs 103 aspx http msdn microsoft com en us library hh229058 v vs 103 aspx http msdn microsoft com en us library hh244330 v vs 103 aspx','',RxJava,false,true,false
10114705,'Operator Merge additional overloads','More overloads of merge such as with scheduler enumerable iterable and number of concurrent subscriptions http msdn microsoft com en us library hh229590 v vs 103 aspx http msdn microsoft com en us library hh229740 v vs 103 aspx http msdn microsoft com en us library hh229099 v vs 103 aspx http msdn microsoft com en us library hh229923 v vs 103 aspx http msdn microsoft com en us library hh244336 v vs 103 aspx http msdn microsoft com en us library hh211914 v vs 103 aspx http msdn microsoft com en us library hh229330 v vs 103 aspx http msdn microsoft com en us library hh229061 v vs 103 aspx http msdn microsoft com en us library hh244329 v vs 103 aspx http msdn microsoft com en us library hh229656 v vs 103 aspx','',RxJava,false,true,false
10114771,'Operator Min and MinBy','http msdn microsoft com en us library hh229286 v vs 103 aspx http msdn microsoft com en us library hh228994 v vs 103 aspx http msdn microsoft com en us library hh229117 v vs 103 aspx http msdn microsoft com en us library hh229224 v vs 103 aspx http msdn microsoft com en us library hh229230 v vs 103 aspx http msdn microsoft com en us library hh229859 v vs 103 aspx http msdn microsoft com en us library hh229084 v vs 103 aspx http msdn microsoft com en us library hh212002 v vs 103 aspx http msdn microsoft com en us library hh244289 v vs 103 aspx http msdn microsoft com en us library hh228951 v vs 103 aspx http msdn microsoft com en us library hh229715 v vs 103 aspx http msdn microsoft com en us library hh229095 v vs 103 aspx http msdn microsoft com en us library hh228970 v vs 103 aspx http msdn microsoft com en us library hh229505 v vs 103 aspx','',RxJava,false,true,false
10114785,'Operator MostRecent','http msdn microsoft com en us library hh229751 v vs 103 aspx','',RxJava,false,true,false
10114801,'Operator Multicast','http msdn microsoft com en us library hh211894 v vs 103 aspx http msdn microsoft com en us library hh229708 v vs 103 aspx','Good intro here http northhorizon net 2011 sharing in rx Is this fully implemented or do we need more work beyond what was merged',RxJava,false,true,false
10114829,'Operator Next','http msdn microsoft com en us library hh211897 v vs 103 aspx','Implemented in https github com Netflix RxJava pull 163 and merged in https github com Netflix RxJava pull 166',RxJava,false,true,false
10114873,'Operator OfType','http msdn microsoft com en us library hh229380 v vs 103 aspx','',RxJava,false,true,false
10114970,'Operator Range','http msdn microsoft com en us library hh229460 v vs 103 aspx http msdn microsoft com en us library hh211896 v vs 103 aspx','',RxJava,false,true,false
10115008,'Operator RefCount','http msdn microsoft com en us library hh211664 v vs 103 aspx','Good intro here http northhorizon net 2011 sharing in rx Think this can be closed now due to #407',RxJava,false,true,false
10115031,'Operator Repeat','http msdn microsoft com en us library hh229428 v vs 103 aspx http msdn microsoft com en us library hh212126 v vs 103 aspx http msdn microsoft com en us library hh244273 v vs 103 aspx http msdn microsoft com en us library hh229193 v vs 103 aspx http msdn microsoft com en us library hh211855 v vs 103 aspx http msdn microsoft com en us library hh229401 v vs 103 aspx',Implemented,RxJava,false,true,false
10115079,'Operator Replay','http msdn microsoft com en us library hh229288 v vs 103 aspx http msdn microsoft com en us library hh211976 v vs 103 aspx http msdn microsoft com en us library hh211699 v vs 103 aspx http msdn microsoft com en us library hh229232 v vs 103 aspx http msdn microsoft com en us library hh229814 v vs 103 aspx http msdn microsoft com en us library hh229874 v vs 103 aspx http msdn microsoft com en us library hh211811 v vs 103 aspx http msdn microsoft com en us library hh211759 v vs 103 aspx http msdn microsoft com en us library hh229653 v vs 103 aspx http msdn microsoft com en us library hh211675 v vs 103 aspx http msdn microsoft com en us library hh211644 v vs 103 aspx http msdn microsoft com en us library hh229526 v vs 103 aspx http msdn microsoft com en us library hh229928 v vs 103 aspx http msdn microsoft com en us library hh228952 v vs 103 aspx http msdn microsoft com en us library hh244327 v vs 103 aspx http msdn microsoft com en us library hh229404 v vs 103 aspx','Good intro here http northhorizon net 2011 sharing in rx We only have the single replay method implemented Missing all of the overloads I ll take these Done',RxJava,false,true,false
10115091,'Operator Retry','http msdn microsoft com en us library hh229521 v vs 103 aspx http msdn microsoft com en us library hh229233 v vs 103 aspx','',RxJava,false,true,false
10115126,'Operator Return','Looks like it is an alias to just which is already implemented plus a version supporting scheduler http msdn microsoft com en us library hh211637 v vs 103 aspx http msdn microsoft com en us library hh211704 v vs 103 aspx','',RxJava,false,true,false
10115140,'Operator Sample','http msdn microsoft com en us library hh211615 v vs 103 aspx http msdn microsoft com en us library hh211892 v vs 103 aspx http msdn microsoft com en us library hh229742 v vs 103 aspx','Still have one overload to do c# public static IObservable TSource Sample TSource TSample this IObservable TSource source IObservable TSample sampler I can take this Done',RxJava,false,true,false
10115185,'Operator Select and SelectMany alias to Map and MapMany','Add an alias for select to map http msdn microsoft com en us library hh244306 v vs 103 aspx http msdn microsoft com en us library hh244311 v vs 103 aspx http msdn microsoft com en us library hh211946 v vs 103 aspx http msdn microsoft com en us library hh229783 v vs 103 aspx http msdn microsoft com en us library hh244247 v vs 103 aspx http msdn microsoft com en us library hh229281 v vs 103 aspx http msdn microsoft com en us library hh229199 v vs 103 aspx','We have mapMany and flatMap not going to bother with also having selectMany',RxJava,false,true,false
10115202,'Operator SequenceEqual','http msdn microsoft com en us library hh229024 v vs 103 aspx http msdn microsoft com en us library hh212108 v vs 103 aspx','Looking at these implementations it seems that by using zip it will emit a sequence of true false values rather than a single boolean specifying if the entire sequence is true false I think it is supposed to emit only a single value based on reading the MSDN docs @mairbek If you re read the docs is it supposed to be a single value or sequence of values emitted If single can you submit a fix Probably a reduce type function that keeps going until it finds a false otherwise if it hits onComplete onError the same on both sides it returns true @benjchristensen okay I ll submit the patch Reduce doesn t seems to be a good choice in this case since it would wait for all pairs of events even if first two were different I will start by implementing All Operation #21 and applying it to a zip of two observables Okay thanks This happens to be more complicated that I ve expected I ve come up with a test case that fails on all zip implementation Looks like zip operation completes the observation as fast as first observable completes which leads to wrong behaviour of sequenceEqual operation java @Test public void testSequenceEqual3 Observable Integer first Observable toObservable 1 2 Observable Integer second Observable toObservable 1 2 3 @SuppressWarnings unchecked Observer Boolean result mock Observer class sequenceEqual first second subscribe result verify result times 1 onNext false verify result times 1 onCompleted verifyNoMoreInteractions result Done',RxJava,false,true,false
10115216,'Operator Single and SingleOrDefault','http msdn microsoft com en us library hh211749 v vs 103 aspx http msdn microsoft com en us library hh229425 v vs 103 aspx http msdn microsoft com en us library hh229791 v vs 103 aspx http msdn microsoft com en us library hh229517 v vs 103 aspx','Merged in pull request https github com Netflix RxJava pull 160',RxJava,false,true,false
10115228,'Operator SkipLast','http msdn microsoft com en us library hh211750 v vs 103 aspx','',RxJava,false,true,false
10115234,'Operator SkipUntil','http msdn microsoft com en us library hh229358 v vs 103 aspx','',RxJava,false,true,false
10115249,'Operator SkipWhile','http msdn microsoft com en us library hh229685 v vs 103 aspx http msdn microsoft com en us library hh211631 v vs 103 aspx','',RxJava,false,true,false
10115273,'Operator Start','http msdn microsoft com en us library hh229265 v vs 103 aspx http msdn microsoft com en us library hh211971 v vs 103 aspx http msdn microsoft com en us library hh229036 v vs 103 aspx http msdn microsoft com en us library hh211721 v vs 103 aspx','It would be nice to have the start operator not only for Action0 but also for Func0 With this we could use the Java Observable to simulate Futures java Observable Integer future Observable start new Func0 Integer public Integer call return someExpensiveCalculation Schedulers threadPoolForComputation Implemented and then moved to async util contrib module https github com Netflix RxJava blob master rxjava contrib rxjava async util',RxJava,false,true,false
10115281,'Operator StartWith','http msdn microsoft com en us library hh229340 v vs 103 aspx http msdn microsoft com en us library hh229372 v vs 103 aspx','',RxJava,false,true,false
10115347,'Operator Sum','http msdn microsoft com en us library hh212105 v vs 103 aspx http msdn microsoft com en us library hh211904 v vs 103 aspx http msdn microsoft com en us library hh212004 v vs 103 aspx http msdn microsoft com en us library hh212033 v vs 103 aspx http msdn microsoft com en us library hh229430 v vs 103 aspx http msdn microsoft com en us library hh229456 v vs 103 aspx http msdn microsoft com en us library hh229627 v vs 103 aspx http msdn microsoft com en us library hh229323 v vs 103 aspx http msdn microsoft com en us library hh229683 v vs 103 aspx http msdn microsoft com en us library hh229319 v vs 103 aspx','',RxJava,false,true,false
10115368,'Operator Synchronize overload','Another overload to the existing synchronize http msdn microsoft com en us library hh229790 v vs 103 aspx','',RxJava,false,true,false
10115378,'Operator TakeLast','http msdn microsoft com en us library hh212114 v vs 103 aspx','',RxJava,false,true,false
10115384,'Operator TakeUntil','http msdn microsoft com en us library hh229530 v vs 103 aspx','',RxJava,false,true,false
10115397,'Operator TakeWhile','http msdn microsoft com en us library hh244231 v vs 103 aspx http msdn microsoft com en us library hh229131 v vs 103 aspx','',RxJava,false,true,false
10115413,'Operator Then','http msdn microsoft com en us library hh211662 v vs 103 aspx','',RxJava,false,true,false
10115433,'Operator Throw','http msdn microsoft com en us library hh244299 v vs 103 aspx http msdn microsoft com en us library hh211711 v vs 103 aspx','',RxJava,false,true,false
10115441,'Operator TimeInterval','http msdn microsoft com en us library hh212107 v vs 103 aspx http msdn microsoft com en us library hh229092 v vs 103 aspx','',RxJava,false,true,false
10115466,'Operator Timeout','http msdn microsoft com en us library hh244331 v vs 103 aspx http msdn microsoft com en us library hh244283 v vs 103 aspx http msdn microsoft com en us library hh244232 v vs 103 aspx http msdn microsoft com en us library hh244293 v vs 103 aspx http msdn microsoft com en us library hh229512 v vs 103 aspx http msdn microsoft com en us library hh228946 v vs 103 aspx http msdn microsoft com en us library hh244303 v vs 103 aspx http msdn microsoft com en us library hh211676 v vs 103 aspx','Think this can be closed now',RxJava,false,true,false
10115477,'Operator Timer','http msdn microsoft com en us library hh212102 v vs 103 aspx http msdn microsoft com en us library hh212050 v vs 103 aspx http msdn microsoft com en us library hh229223 v vs 103 aspx http msdn microsoft com en us library hh244323 v vs 103 aspx http msdn microsoft com en us library hh229503 v vs 103 aspx http msdn microsoft com en us library hh229435 v vs 103 aspx http msdn microsoft com en us library hh229176 v vs 103 aspx http msdn microsoft com en us library hh229652 v vs 103 aspx',Done,RxJava,false,true,false
10115488,'Operator Timestamp','http msdn microsoft com en us library hh211605 v vs 103 aspx http msdn microsoft com en us library hh229003 v vs 103 aspx','the scheduler overload has not done yet Can I take this Done',RxJava,false,true,false
10115516,'Operator ToArray','Similar to existing toList or can we ignore this and just use toList http msdn microsoft com en us library hh229207 v vs 103 aspx','Closing as toList is sufficient',RxJava,false,true,false
10115615,'Operator ToAsync','http msdn microsoft com en us library hh229868 v vs 103 aspx http msdn microsoft com en us library hh229868 v vs 103 aspx http msdn microsoft com en us library hh229439 v vs 103 aspx http msdn microsoft com en us library hh229657 v vs 103 aspx http msdn microsoft com en us library hh229182 v vs 103 aspx http msdn microsoft com en us library hh229822 v vs 103 aspx http msdn microsoft com en us library hh211792 v vs 103 aspx http msdn microsoft com en us library hh229926 v vs 103 aspx http msdn microsoft com en us library hh212074 v vs 103 aspx http msdn microsoft com en us library hh211936 v vs 103 aspx http msdn microsoft com en us library hh229008 v vs 103 aspx http msdn microsoft com en us library hh229118 v vs 103 aspx http msdn microsoft com en us library hh244256 v vs 103 aspx http msdn microsoft com en us library hh229059 v vs 103 aspx http msdn microsoft com en us library hh229035 v vs 103 aspx http msdn microsoft com en us library hh212109 v vs 103 aspx http msdn microsoft com en us library hh229744 v vs 103 aspx http msdn microsoft com en us library hh229896 v vs 103 aspx http msdn microsoft com en us library hh229778 v vs 103 aspx http msdn microsoft com en us library hh229594 v vs 103 aspx http msdn microsoft com en us library hh229553 v vs 103 aspx http msdn microsoft com en us library hh211729 v vs 103 aspx http msdn microsoft com en us library hh229827 v vs 103 aspx http msdn microsoft com en us library hh211718 v vs 103 aspx http msdn microsoft com en us library hh212154 v vs 103 aspx http msdn microsoft com en us library hh228950 v vs 103 aspx http msdn microsoft com en us library hh211879 v vs 103 aspx http msdn microsoft com en us library hh228973 v vs 103 aspx http msdn microsoft com en us library hh211608 v vs 103 aspx http msdn microsoft com en us library hh211987 v vs 103 aspx http msdn microsoft com en us library hh229292 v vs 103 aspx http msdn microsoft com en us library hh244314 v vs 103 aspx http msdn microsoft com en us library hh229728 v vs 103 aspx http msdn microsoft com en us library hh229729 v vs 103 aspx http msdn microsoft com en us library hh229369 v vs 103 aspx http msdn microsoft com en us library hh229080 v vs 103 aspx http msdn microsoft com en us library hh229471 v vs 103 aspx http msdn microsoft com en us library hh211875 v vs 103 aspx http msdn microsoft com en us library hh229755 v vs 103 aspx http msdn microsoft com en us library hh229722 v vs 103 aspx http msdn microsoft com en us library hh229731 v vs 103 aspx http msdn microsoft com en us library hh229336 v vs 103 aspx http msdn microsoft com en us library hh229851 v vs 103 aspx http msdn microsoft com en us library hh211787 v vs 103 aspx http msdn microsoft com en us library hh229327 v vs 103 aspx http msdn microsoft com en us library hh229769 v vs 103 aspx http msdn microsoft com en us library hh229450 v vs 103 aspx http msdn microsoft com en us library hh229370 v vs 103 aspx http msdn microsoft com en us library hh229287 v vs 103 aspx http msdn microsoft com en us library hh229577 v vs 103 aspx http msdn microsoft com en us library hh229911 v vs 103 aspx http msdn microsoft com en us library hh212149 v vs 103 aspx http msdn microsoft com en us library hh229560 v vs 103 aspx http msdn microsoft com en us library hh211773 v vs 103 aspx http msdn microsoft com en us library hh229571 v vs 103 aspx http msdn microsoft com en us library hh212138 v vs 103 aspx http msdn microsoft com en us library hh229606 v vs 103 aspx http msdn microsoft com en us library hh211812 v vs 103 aspx http msdn microsoft com en us library hh229716 v vs 103 aspx http msdn microsoft com en us library hh229808 v vs 103 aspx http msdn microsoft com en us library hh229630 v vs 103 aspx http msdn microsoft com en us library hh228993 v vs 103 aspx http msdn microsoft com en us library hh229773 v vs 103 aspx http msdn microsoft com en us library hh229361 v vs 103 aspx http msdn microsoft com en us library hh229794 v vs 103 aspx http msdn microsoft com en us library hh211702 v vs 103 aspx http msdn microsoft com en us library hh229910 v vs 103 aspx http msdn microsoft com en us library hh229662 v vs 103 aspx http msdn microsoft com en us library hh228956 v vs 103 aspx','API surface This method in Rx NET has about 48 overloads do we need all of them 0 11 arg Action 0 11 arg Funcion x2 with scheduler overloads Schedulers In Rx NET the scheduler less overloads use the SchedulerDefaults AsyncConversions which in turn is a DefaultScheduler So do we use the Schedulers threadPoolForComputation directly or introduce a Schedulers threadPoolForAsyncConversions',RxJava,false,true,false
10115630,'Operator ToDictionary','http msdn microsoft com en us library hh229137 v vs 103 aspx http msdn microsoft com en us library hh212046 v vs 103 aspx http msdn microsoft com en us library hh212075 v vs 103 aspx http msdn microsoft com en us library hh229073 v vs 103 aspx','I believe the equivalent to IDictionary is a Map in Java but there are a lot of map classes Linked Concurrent etc Which one should be the default value type Is it okay to call the methods Observable toMap I vote for java util HashMap by default with an overload that lets you pass in a map class of any type you want public K V M extends java util Map K V Observable M toMap Class M mapClass Func1 super T extends K keySelector Func1 super T extends V elementSelector PS not sure if I got the co contra variance right on that PPS I Think the consensus was to ignore EqualityComparators overloads because the idiomatic java way is to implement equals hashCode on the class Two questions How many times will this operator call onNext Just once or every time it gets a new item Are users allowed to modify the returned map This is how I did it somewhere else below Takes a factory which returns a map instance on subscription emits the map once the source finishes no variance on the output observable s type java public class OperationToMap public static class ToMap T K V implements OnSubscribeFunc Map K V private final Observable T source private final Func1 super T extends K keySelector private final Func1 super T extends V valueSelector private final Func0 extends Map K V mapFactory public ToMap Observable T source Func1 super T extends K keySelector Func1 super T extends V valueSelector Func0 extends Map K V mapFactory this source source this keySelector keySelector this valueSelector valueSelector this mapFactory mapFactory @Override public Subscription onSubscribe Observer super Map K V t1 return source subscribe new ToMapObserver t1 public class ToMapObserver implements Observer T Map K V map private final Observer super Map K V t1 public ToMapObserver Observer super Map K V t1 map mapFactory call this t1 t1 @Override public void onCompleted Map K V map0 map map null t1 onNext map0 t1 onCompleted @Override public void onError Throwable e map null t1 onError e @Override public void onNext T args K key keySelector call args V value valueSelector call args map put key value',RxJava,false,true,false
10115675,'Operator ToLookup','http msdn microsoft com en us library hh212098 v vs 103 aspx http msdn microsoft com en us library hh211805 v vs 103 aspx http msdn microsoft com en us library hh229101 v vs 103 aspx http msdn microsoft com en us library hh211616 v vs 103 aspx','I believe this is Map K Collection V aka Multimap Same questions as for ToDictionary default value types for the map and the collection part Naming the operator as toMultimap',RxJava,false,true,false
10115685,'Operator ToObservable with scheduler','http msdn microsoft com en us library hh212140 v vs 103 aspx','',RxJava,false,true,false
10115690,'Operator Using','http msdn microsoft com en us library hh229585 v vs 103 aspx','',RxJava,false,true,false
10115700,'Operator When','http msdn microsoft com en us library hh229558 v vs 103 aspx http msdn microsoft com en us library hh229889 v vs 103 aspx','',RxJava,false,true,false
10115726,'Operator Where alias to filter','Filter already exists alias where to it http msdn microsoft com en us library hh211607 v vs 103 aspx http msdn microsoft com en us library hh229267 v vs 103 aspx','This issue looks like it could be closed as the resepctive pull request is closed too',RxJava,false,true,false
10115750,'Operator Window','http msdn microsoft com en us library hh211907 v vs 103 aspx http msdn microsoft com en us library hh212125 v vs 103 aspx http msdn microsoft com en us library hh229686 v vs 103 aspx http msdn microsoft com en us library hh228991 v vs 103 aspx http msdn microsoft com en us library hh244282 v vs 103 aspx http msdn microsoft com en us library hh229186 v vs 103 aspx http msdn microsoft com en us library hh244316 v vs 103 aspx http msdn microsoft com en us library hh212136 v vs 103 aspx http msdn microsoft com en us library hh229909 v vs 103 aspx http msdn microsoft com en us library hh211621 v vs 103 aspx','That s enough issues I think Started work on window Thanks for getting involved @bcotton Trying to figure out what the behavior should be for windows when onComplete is never called on the observer This test fails as there are hanging values and I only get back the first window java public void testNonOverlappingWindowsNoComplete Observable Observable String subject Observable create new Func1 Observer String Subscription @Override public Subscription call Observer String observer observer onNext one observer onNext two observer onNext three observer onNext four observer onNext five return Subscriptions empty window 3 List List String windows toLists subject assertEquals 2 windows size assertEquals list one two three windows get 0 assertEquals list four five windows get 1 Perhaps I m missing something about the internals of Observables and what happens at the end Each window Observable you emit will need to invoke onCompleted as that will not come from the origin As for the origin it is possible for it to never emit an onCompleted if it is an infinite stream in which case the Observable would continue emitting events and windows indefinitely However in your example above since you re not trying to do an infinite stream you need to call observer onCompleted after observer onNext five to comply with the Observable contract You can see some examples here https github com Netflix RxJava wiki How To Use#implementing an observable The contract for an Observer is that onNext can be called 0 or more times and then onError or onCompleted called once with nothing following Javadoc http netflix github io RxJava javadoc rx Observer html If it s an infinite stream then onCompleted may never be called',RxJava,false,true,false
10115781,'Add more arities to zip operator','We have up to T3 now it should have at least up to T9','Included in https github com Netflix RxJava pull 331 via commit https github com jmhofer RxJava commit ac6a0a1ad8edd25b3c17a6fbca6960e9bcdda020',RxJava,false,true,false
10173770,'Performance Optimizations','Very large compositions have a performance hit as they increase the size of the stack and call onNext at each level of composition Pursue an initial round of optimizations that collapses the composition into a sequence of functions that get applied at subscribe rather than subsequent calls of onNext UPDATED See the comments below for where this evolved to Chaining was shown through testing to not be the issue','Simple performance test to demonstrate performance issue java package testing import java util concurrent atomic AtomicInteger import rx observables Observable import rx observables Observer import rx util Func1 public class PerformanceTest public static void main String args PerformanceTest test new PerformanceTest Integer values new Integer 100001 for int i 0 i values length i values i i for int i 0 i 100 i System out println test runFunctionExecutionTest values test runCompositionTest values test runNonCompositionalTestWithDirectLoop values test runNonCompositionalTestWithArrayOfFunctions values public void runCompositionTest Integer values System out println runCompositionTest final AtomicInteger onNextSum new AtomicInteger 0 final long start System nanoTime MathFunction m new MathFunction 50 levels of composition same function so that s not the cost Observable from values map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m subscribe new TestObserver onNextSum start public void runNonCompositionalTestWithDirectLoop Integer values System out println runNonCompositionalTestWithDirectLoop final AtomicInteger onNextSum new AtomicInteger 0 final long start System nanoTime final MathFunction m new MathFunction Observable from values map new Func1 Integer Integer @Override public Integer call Integer t1 iterate the 50 times here in a loop rather than via composition for int i 0 i 50 i t1 m call t1 return t1 subscribe new TestObserver onNextSum start public void runNonCompositionalTestWithArrayOfFunctions Integer values System out println runNonCompositionalTestWithArrayOfFunctions final AtomicInteger onNextSum new AtomicInteger 0 final long start System nanoTime final MathFunction m new MathFunction final Func1 functionCalls new Func1 50 for int i 0 i 50 i functionCalls i m Observable from values map new Func1 Integer Integer @Override public Integer call Integer t1 iterate the 50 times here in a loop rather than via composition for Func1 Integer Integer f functionCalls t1 f call t1 return t1 subscribe new TestObserver onNextSum start private static final class TestObserver implements Observer Integer private final AtomicInteger onNextSum private final long start private TestObserver AtomicInteger onNextSum long start this onNextSum onNextSum this start start @Override public void onNext Integer i onNextSum addAndGet i @Override public void onError Exception e e printStackTrace @Override public void onCompleted long end System nanoTime System out println Sum onNextSum get Time double end start 1000 1000 ms private static class MathFunction implements Func1 Integer Integer @Override public Integer call Integer t1 return t1 1 On existing code the composition of 50 map calls takes 370ms whereas a single call with a list of the same 50 functions takes 23ms runCompositionTest Sum 710082754 Time 371 601ms runNonCompositionalTestWithDirectLoop Sum 710082754 Time 23 814ms runNonCompositionalTestWithArrayOfFunctions Sum 710082754 Time 23 925ms runCompositionTest Sum 710082754 Time 383 391ms runNonCompositionalTestWithDirectLoop Sum 710082754 Time 24 577ms runNonCompositionalTestWithArrayOfFunctions Sum 710082754 Time 24 65ms runCompositionTest Sum 710082754 Time 376 443ms runNonCompositionalTestWithDirectLoop Sum 710082754 Time 24 587ms runNonCompositionalTestWithArrayOfFunctions Sum 710082754 Time 26 131ms Playing with different things I got the following numbers Statically typed Without chaining Sum 710082754 Time 130 683ms runNonCompositionalTestWithDirectLoop Sum 710082754 Time 21 011ms runNonCompositionalTestWithArrayOfFunctions Sum 710082754 Time 20 84ms With chaining composition collapsing Sum 710082754 Time 28 787ms runNonCompositionalTestWithDirectLoop Sum 710082754 Time 19 525ms runNonCompositionalTestWithArrayOfFunctions Sum 710082754 Time 19 175ms Dynamically typed When going via generic Functions execute even with chained sequence runCompositionTest Sum 710082754 Time 577 3ms very bad when dynamic runNonCompositionalTestWithDirectLoop Sum 710082754 Time 31 591ms runNonCompositionalTestWithArrayOfFunctions Sum 710082754 Time 38 093ms runCompositionTest With Function memoization so we only pay dynamic price during sequence setup not in onNext Using ArrayList runCompositionTest Sum 710082754 Time 27 078ms runNonCompositionalTestWithDirectLoop Sum 710082754 Time 18 911ms runNonCompositionalTestWithArrayOfFunctions Sum 710082754 Time 18 852ms Using LinkedBlockingQueue runCompositionTest Sum 710082754 Time 46 532ms runNonCompositionalTestWithDirectLoop Sum 710082754 Time 18 946ms runNonCompositionalTestWithArrayOfFunctions Sum 710082754 Time 18 746ms By adding chaining to collapse composition into a single observable with chain of functions and improving the handling of dynamic function calls through memoization I get this runCompositionTest Sum 710082754 Time 47 184ms runNonCompositionalTestWithDirectLoop Sum 710082754 Time 17 869ms runNonCompositionalTestWithArrayOfFunctions Sum 710082754 Time 26 528ms runCompositionTest Sum 710082754 Time 47 578ms runNonCompositionalTestWithDirectLoop Sum 710082754 Time 21 692ms runNonCompositionalTestWithArrayOfFunctions Sum 710082754 Time 18 177ms runCompositionTest Sum 710082754 Time 47 93ms runNonCompositionalTestWithDirectLoop Sum 710082754 Time 18 821ms runNonCompositionalTestWithArrayOfFunctions Sum 710082754 Time 20 064ms I can get the composed version down to around 25 28ms if I use ArrayList but I need to be thread safe in this case so am using ConcurrentLinkedQueue which adds a little time but it s still far faster than before Same code now takes 48ms instead of 370ms Pretty significant performance improvements came from improved handling of function execution in particular memoizing the logic for constructing a function particularly dynamic ones The long if then conditional block for handling the many different Func Action language functions was very expensive in sequence with lots of data This was fixed in https github com Netflix RxJava pull 106 I m still testing the potential gains from chaining While playing with chaining I found that the actual performance issues were the dynamic function construction lookup and concurrency synchronization costs not the depth of stack Here is code that demonstrates that the stack depth is not a problem for performance In fact the composed version performs better than the loops java package testing import java util ArrayList import java util concurrent Callable import rx util Func1 public class TestChainPerformance public static void main String args TestChainPerformance test new TestChainPerformance Integer values new Integer 100001 for int i 0 i values length i values i i try for int i 0 i 100 i System out println test runChained values test runComposed values catch Exception e e printStackTrace public void runComposed final Integer values throws Exception long start System nanoTime Callable Integer c null for int i 0 i 250 i final Callable Integer previousC c c new Callable Integer @Override public Integer call throws Exception MathFunction f new MathFunction int sum 0 for int v values sum f call v if previousC null sum previousC call return sum int sum c call long end System nanoTime System out println Composed Sum sum Time double end start 1000 1000 ms public void runChained Integer values long start System nanoTime int sum 0 ArrayList Func1 Integer Integer functions new ArrayList Func1 Integer Integer for int i 0 i 250 i functions add new MathFunction for int v values for Func1 Integer Integer f functions sum f call v long end System nanoTime System out println Iterative Sum sum Time double end start 1000 1000 ms private static class MathFunction implements Func1 Integer Integer @Override public Integer call Integer t1 return t1 1 The performance numbers on my machine are Iterative Sum 202017114 Time 227 288ms Composed Sum 202017114 Time 172 856ms Iterative Sum 202017114 Time 230 235ms Composed Sum 202017114 Time 173 917ms Iterative Sum 202017114 Time 226 337ms Composed Sum 202017114 Time 172 932ms That is with JDK 7 JDK 6 is slower but similar difference between the two Due to this I m abandoning pursuit of chaining as a performance enhancement and focusing on functions and synchronization In pull request https github com Netflix RxJava pull 106 with function memoization we went from this Sum 710082754 Time 437 936ms to this Sum 710082754 Time 60 605ms By reducing the nested synchronization eliminating most of it it is now running at Sum 710082754 Time 22 429ms Performance is now very close to what it is without Rx Sum 710082754 Time 22 429ms vs runNonCompositionalTestWithDirectLoop Sum 710082754 Time 17 248ms runNonCompositionalTestWithArrayOfFunctions Sum 710082754 Time 17 311ms I am considering this overhead acceptable right now and not spending further time on this issue',RxJava,false,false,false
10173952,'Performance optimizations','memoize dynamic function constructions so executions are statically typed after a single dynamic lookup instead of dynamic on every execution use chained observable to reduce composition costs execute list of functions rather than compositionally invoking onNext','This pull request is for https github com Netflix RxJava issues 104 I have NOT tried this on production code yet but all unit tests are working I d like to get code reviews and feedback on the approach before I merge NOTE This is only taking effect on map calls right now I want to prove it there and then apply to other functions It is more or less hacked in on this branch to allow discussion before I do the fairly substantial refactor to apply this pattern elsewhere There are also more complicated use cases still to deal with I removed the prototype of chaining This is currently at a clean point that could merge over the dynamic function invocation optimizations I am playing more with chaining Cleaned up in new pull request with single commit with just function execution optimizations https github com Netflix RxJava pull 106 Will not merge this pull request',RxJava,true,false,false
10179861,'Performance optimizations for dynamic function execution','memoize dynamic function constructions so executions are statically typed after a single dynamic lookup instead of dynamic on every execution https github com Netflix RxJava issues 104','Test case java public void runCompositionTest Integer values System out println runCompositionTest final AtomicInteger onNextSum new AtomicInteger 0 final long start System nanoTime MathFunction m new MathFunction 50 levels of composition same function so that s not the cost Observable from values map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m subscribe new TestObserver onNextSum start Before this commit Sum 710082754 Time 437 936ms After this commit Sum 710082754 Time 60 605ms',RxJava,true,false,false
10215233,'Performance Reduce synchronization','Performance changes as part of https github com Netflix RxJava issues 104 and is an extension of work done in pull https github com Netflix RxJava pull 106 This code was used to test the performance java public void runCompositionTest Integer values System out println runCompositionTest final AtomicInteger onNextSum new AtomicInteger 0 final long start System nanoTime MathFunction m new MathFunction 50 levels of composition same function so that s not the cost Observable from values map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m map m subscribe new TestObserver onNextSum start Before it took Sum 710082754 Time 60 605ms By reducing the nested synchronization eliminating most of it it is now running at Sum 710082754 Time 22 429ms','',RxJava,true,false,false
10248913,'Adding a draft of Subject class','https github com Netflix RxJava issues 19','',RxJava,true,false,false
10249025,'Creating toObservable for Future','simple wrapper that turns a future into a observable','This code looks fine though I m curious about the implication of it blocking on the Future get It s obviously the only way to do it without spawning another thread that blocks on that future which would take us into this conversation https github com Netflix RxJava issues 19 Is this misleading to people to think it would be asynchronous I ve added comments inline in the code as well Looks good',RxJava,true,false,false
10299997,'Build fix','Getting RxJava to build all of the LanguageAdaptor sub modules correctly Upgraded to Gradle 1 3 and made changes to rxjava scala build file','',RxJava,true,false,false
10300338,'IDE Support','','',RxJava,true,false,false
10301545,'Examples Submodule','new submodule for showing examples in various languages','',RxJava,true,false,false
10431008,Concat,'','',RxJava,true,false,false
10435602,Examples,'Start of How to Use examples in Clojure Groovy and Java','',RxJava,true,false,false
10511764,'more examples','','',RxJava,true,false,false
10518081,Refactor,'','',RxJava,true,false,false
10575824,'Aligning with internal infrastructure','','I manually added the necessary changes along with a few others so closing this out instead of merging',RxJava,true,false,false
10665245,'Javadoc refers to private image URLs','http netflix github com RxJava javadoc rx Observable html Broken image referring to https confluence corp netflix com plugins gliffy viewlargediagram action name marble legend ceoid 27321465 key API pageId 27321465','',RxJava,false,false,false
10665341,'Javadoc refers to private document in for more information','http netflix github com RxJava javadoc rx Observer html For more information links to https confluence corp netflix com display API Observers 2C Observables 2C and the Reactive Pattern#Observers 2CObservables 2CandtheReactivePattern SettingupObserversinGroovy','',RxJava,false,false,false
10669349,'Fixing javadocs','https github com Netflix RxJava issues 119 added correct links to external images cleaned up some of the text improved some function memoization that was missed','',RxJava,true,false,false
10679905,'Minor cleanup of Clojure example','Cleaned up some formatting and spacing Used future cancel Future subscriptions were not being returned properly Replaced use of #_ with comment form Fixed rest args usage for hello example','',RxJava,true,false,false
10682072,'Examples Cleanup','Some cleanup on builds particularly rxjava examples I can t add Scala support while retaining Groovy and have it work in Eclipse as the plugins collide Gradle handles it fine for builds from command line but editing via text editors and not IDEs is not ideal Perhaps the examples should go in the src test folder or src examples of each of the rxjava language projects instead of rxjava examples','',RxJava,true,false,false
10700833,'Wiki Futures are Expensive to Compose','I think you refer to java concurrent Future and not other future implementations for the JVM Scala Futures http docs scala lang org overviews core futures for example have very similar goals and work just fine without the hassle of j c Future The wiki should therefore not claim that futures in general are Expensive to Compose','',RxJava,false,false,false
10716408,'trivial syntax clean up in scala adaptor','','',RxJava,true,false,false
10718691,'Implemented TakeWhile','','',RxJava,true,false,false
10726374,'How to checkpoint a Observable returned in mapMany','I have the following use case For each file in a FTP directory read file line by line filter comments parse line into a java object serialize that obj send each obj in batches to another component I also want to make sure I don t process the same files over and over so I first filter all files based off a checkpoint mechanism and after all the contents of a file have been sent add that file to the checkpoint I have tried to replicate the logic in RxJava the following way java Observable from client list basePath true recursively get all files under the path filter new Func1 FtpClient FileStats Boolean @Override public Boolean call final FtpClient FileStats fileStats return fileStats null fileStats getSize 0 checkpointer hasProcessed fileStats getPath mapMany new Func1 FtpClient FileStats Observable extends byte @Override public Observable extends byte call final FtpClient FileStats path final String location path getPath final Observable byte obs Observable from client getIterable location opens the file and returns Iterable String filter COMMENT_FILTER remove comment line map PARSE_LINE convert from String to Event map SERIALIZE_EVENT convert from Event to byte obs subscribe new CheckpointObserver checkpointer location when done processing checkpoint file return obs subscribe new EventSender cp The above code causes the following error to be passed to onError java lang IllegalStateException Can not set subscription more than once at rx util AtomicObservableSubscription wrap AtomicObservableSubscription java 58 rxjava core 0 5 0 jar na at rx operators OperationFilter Filter call OperationFilter java 48 rxjava core 0 5 0 jar na at rx operators OperationFilter Filter call OperationFilter java 36 rxjava core 0 5 0 jar na But this works java Observable from client list basePath true filter new Func1 FtpClient FileStats Boolean @Override public Boolean call final FtpClient FileStats fileStats return fileStats null fileStats getSize 0 checkpointer hasProcessed fileStats getPath mapMany new Func1 FtpClient FileStats Observable extends byte @Override public Observable extends byte call final FtpClient FileStats path final String location path getPath final Observable byte obs Observable from client getIterable location filter COMMENT_FILTER remove comment line map PARSE_LINE convert from String to Event map SERIALIZE_EVENT convert from Event to byte obs subscribe new EventSender cp obs subscribe new CheckpointObserver checkpointer location when done processing checkpoint file return obs subscribe new Observer byte @Override public void onCompleted no op just trigger execution @Override public void onError final Exception e no op just trigger execution @Override public void onNext final byte args no op just trigger execution Two things is this a bug in rx and whats the better way to handle this https github com Netflix RxJava issues 16 seems like it would really help to replace the EventSender since it really just buffers events before sending them','Closing out as this is very old reopen if you want to discuss again',RxJava,false,false,false
10727393,'Update README','','',RxJava,true,false,false
10732951,'Increase test coverage','As far as I can see in the GitHub repo as of commit a1a146930b3c5e63672a7134ca726d22c992ce52 there is not a single unit test for the framework even though according to http techblog netflix com 2013 02 rxjava netflix api html what is implemented has been in use for the past year in production within the Netflix API I don t think I needed to emphasize the importance of testing such a common use library upon which so many clients will depend','',RxJava,false,false,false
10745499,'Code cleanup','Cleaned up some warnings highlighted by Intellij Idea','',RxJava,true,false,false
10768370,'Compatibility Test Suite via port of Rx Net Unit Tests','To get to 1 0 and claim equivalence to Rx Net it would be very beneficial to have an automated way of converting the Rx Net code from C# to Java if realistic and running them as a compatibility test suite for functionality but also for feature completion https rx codeplex com SourceControl changeset view 5526a6f490db#README md It is not intended to attempt automated conversion of C# code for the actual code that has been looked at and isn t realistic The unit tests may be possible scripting search replace from C# to Java Groovy or something similar Some of the tricks will be naming idioms will be different for some things we will need to do it in such a way that compilation errors are handled as test failures rather than preventing the entire suite from running perhaps a dynamic language would be easier for this we need the ability to update the test suite whenever needed in a fully automated way so that as Rx Net code changes we can easily update the RxJava compatibility test suite schedulers will be based on Java ExecutorService and java util concurrent so this may affect unit tests from Net These tests are also not intended to replace unit tests written manually in Java Groovy Clojure etc as already doing as part of the core code these are intended to supplement and be used primarily to track completeness and demonstrate compatibility if it can even be done','Not going to happen may reincarnate as part of https github com ReactiveX but not going to keep it open here',RxJava,false,false,false
10769548,'Implemented ForEach','implement #45','Since forEach is basically just a blocking version of subscribe I d like to propose a different approach that uses subscribe but blocks until onError or onCompleted are received There is very little new code for this mostly just overloads and this blocks if the Observable is asynchronous Pull Request https github com Netflix RxJava pull 147 The interesting part of the code is here https github com Netflix RxJava pull 147 files#L1R368 It uses a CountDownLatch to block until onError or onCompleted are received',RxJava,true,false,false
10770172,'Refactoring language tests and examples layout','removed rxjava examples as it was not working having all languages in the same project started convention of having src examples in language adaptors with first implementation being rxjava groovy and rxjava clojure though the clojure one isn t compiling correctly yet moved language unit tests to actual language rather than via Java to language parsers','',RxJava,true,false,false
10770754,'Various fixes','restore performance optimization to reduce wrapping restoring null check removed in recent commit','',RxJava,true,false,false
10806195,'Adapt Groovy VideoExample to Clojure','Seems to work','',RxJava,true,false,false
10813275,'Idiomatic usage of import in ns macro in rx examples','Reference clojure core docs http clojure github com clojure clojure core api html#clojure core ns Thanks','',RxJava,true,false,false
10822260,'Add examples for jbundler and sbt','','',RxJava,true,false,false
10827839,'Implemented range operator Fixes issue #68','','',RxJava,true,false,false
10930808,'Implemented SequenceEqual Operator','Fixes issue #76 Since there is no direct analogue of IEqualityComparer in Java Func2 T T Boolean has been used','',RxJava,true,false,false
10933591,'Plugin System','Implement a plugin system similar to Hystrix https github com Netflix Hystrix wiki Plugins','',RxJava,false,false,false
10933626,'Implemented TakeLast operator','Fixes issue #85','',RxJava,true,false,false
10933693,'Error Handler Plugin','RxJavaErrorHandler plugin to allow a plugin to receive onError Exception events This allows a system to receive and log debug all Exceptions even if the subscription ignores the onError This was implemented in the Netflix internal version and was lost in the open sourcing As I m finishing the integration of RxJava back into Netflix code I m restoring this capability with a plugin It was added to allow us to have visibility and systematic logging of all errors even if the implementing code accidentally ignored or swallowed errors very easy to do by just passing an onNext closure and not the onError one','',RxJava,false,false,false
10935237,'RxJava ErrorHandler Plugin','https github com Netflix RxJava issues 141 Error Handler Plugin https github com Netflix RxJava issues 139 Plugin System','',RxJava,true,false,false
10988403,'Support provided dependencies in IntelliJ Idea build','Compile time dependencies specified by the provided property doesn t get included in the build path of Idea I tried adding idea module scopes PROVIDED plus configurations provided to rxjava code build gradle but no luck So I suggest we move all the UnitTest into the test folder This way we can specify junit and mokito as a testCompile dependency which in turn will fix the project settings This is bit of a grunt work but a quick and easy one','',RxJava,false,false,false
11004134,'Used mockito s inOrder to verify ordering instead of hand written stub','','',RxJava,true,false,false
11012101,'Support provided dependencies in IntelliJ Idea build','This adds support to the Gradle builds for IntelliJ to import the project and have classpaths set correctly Gradle documentation for these changes http www gradle org docs current dsl org gradle plugins ide idea model IdeaModule html','',RxJava,true,false,false
11014748,'Merge of Pull #125 for Issue #87 Operator TakeWhile','Manually merging https github com Netflix RxJava pull 125 from @mairbek','',RxJava,true,false,false
11017714,'Operator forEach','Issue https github com Netflix RxJava issues 45 Related to Pull https github com Netflix RxJava pull 131','',RxJava,true,false,false
11103724,'Confusing Javadoc for toObservable Future methods','The Javadoc for the Observable toObservable Future methods are messed up In particular the sentence The subscribe method on this synchronously so the Subscription returned doesn t nothing I d fix it but I have no idea what it s trying to say','',RxJava,false,false,false
11134386,'Single SingleOrDefault Operator Implemented','Fix for issue #77','',RxJava,true,false,false
11144545,'Cleaned up copy paste in OperationMerge code','','',RxJava,true,false,false
11153056,'Implemented TakeUntil operation','Fixes issue #86','This is a very elegant solution I wouldn t have considered using the Pair with map merge takeWhile like that The only thing I d like to add is an instance version java public E Observable T takeUntil final Observable E other This way I can chain off an Observable I already have instead of only statically What about having Tuple2 A B Tuple3 A B C and so on like func and actions instead of using Pair A B Even ReactiveCocoa has RACTuple @prabirshrestha that s a good thought I ve considered it but been holding off for the following reasons 1 We haven t had an operator yet need them so didn t want to eagerly add them until actually needed 2 How will they work with each of the languages Will they be idiomatic or awkward Perhaps we can be typed but also implement Iterable and List so they can be accessed dynamically like an array rather than via fields accessors 3 Will these duplicate collide with anything coming in Java8 and if so can be future proof by matching the signature and then being able to extend from those interface when they arrive For example Groovy and Closure generally prefer arrays sequence of values without strong typing and typically just return something simple like a b I probably should have noted in this review that it would be best to not put Pair in rx util but keep it private inner class perhaps until nailing down those questions above @mairbek Do you want to implement the instance method of takeUntil and re submit or do you want me to just add that myself Based on the previous question comment as well I think Pair needs to be kept private for now until decisions on Tuple are made What do you think about moving the implementation into an OperationTakeUntil class so that Observable doesn t keep growing huge Since we lack extensions methods in Java we have to put all the static and instance methods in there but we can extract implementation details and their testing into Operation classes to try and keep some sanity @benjchristensen thank you for the review I ll update the pull request You may want to start a new pull request on a new updated branch as this no longer can merge without conflicts Seems like code doesn t handle all cases When first source observable completes observer should unsubscribe immediately To be precise following test fails java @Test public void testTakeUntilCompleted Subscription sSource mock Subscription class Subscription sOther mock Subscription class TestObservable source new TestObservable sSource TestObservable other new TestObservable sOther Observer String result mock Observer class Observable String stringObservable takeUntil source other stringObservable subscribe result source sendOnNext one source sendOnNext two source sendOnCompleted verify result times 1 onNext one verify result times 1 onNext two verify sSource times 1 unsubscribe verify sOther times 1 unsubscribe I ll update the code to handle this use case I modified TakeUntil a bit It s not as elegant as it was before but it still uses merge operation to avoid dealing with concurrency And it works correctly more unit tests passed RxJava pull requests #5 https netflixoss ci cloudbees com job RxJava pull requests 5 SUCCESS This pull request looks good @teyc you are right I ll update the code RxJava pull requests #12 https netflixoss ci cloudbees com job RxJava pull requests 12 SUCCESS This pull request looks good RxJava pull requests #13 https netflixoss ci cloudbees com job RxJava pull requests 13 SUCCESS This pull request looks good Based on my reading of the code MSDN docs and the unit tests this looks good Merging',RxJava,true,false,false
11158660,'Implemented Next Operation','Fixes issue #66','Implemented #58 using next operation @mairbek thank you for submitting these they look great based on a quick glance I ve been crushed on some production work so have been delayed in reviewing these I will get to this and your other pull request definitely this week I merged https github com Netflix RxJava pull 156 which provides the toIterable functionality Closing this one due to the issues discussed above',RxJava,true,false,false
11266569,'kill target compatibility 1 5','I don t think this is really a requirement of android anymore https github com Netflix RxJava blob master rxjava core build gradle','',RxJava,false,false,false
11304083,'Add OSGi manifest headers','Those of us on OSGi environments like eclipse netbeans glassfish cannot use rxjava core or the other adapters without OSGi headers being added to the manifest This is pretty easy to do using the Maven Bundle plugin from apache Felix','I ve got a jar building with the OSGi headers but that s where I stop having any idea what to put in as the headers so I d appreciate you getting it working as needed and submitting the pull request Here is how I did it 1 Edit build gradle of the module to change For example rxjava core build gradle I added this line at the top groovy apply plugin osgi and this at the bottom groovy jar manifest name rxjava core instruction Bundle Vendor Netflix instruction Bundle DocURL https github com Netflix RxJava I then run a build gradlew clean build I then see the MANIFEST file by doing this cd rxjava core build libs jar xvf rxjava core 0 5 4 SNAPSHOT jar cat META INF MANIFEST MF I see the new manifest headers that normally aren t there without the build grade changes above Hi Ben I will give it a go next week On Wed Feb 27 2013 at 2 49 PM Ben Christensen notifications@github com wrote I ve got a jar building with the OSGi headers but that s where I stop having any idea what to put in as the headers so I d appreciate you getting it working as needed and submitting the pull request Here is how I did it 1 Edit build gradle of the module to change For example rxjava core build gradle I added this line at the top apply plugin osgi and this at the bottom jar manifest name rxjava core instruction Bundle Vendor Netflix instruction Bundle DocURL https github com Netflix RxJava I then run a build gradlew clean build I then see the MANIFEST file by doing this cd rxjava core build libs jar xvf rxjava core 0 5 4 SNAPSHOT jar cat META INF MANIFEST MF I see the new manifest headers that normally aren t there without the build grade changes above Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 154#issuecomment 14205447 I added in your jar section and it does generate OSGi headers in the manifest However the unit tests are in the source code so it inserts dependencies for junit and mockito I can strip them out with custom BND instructions to the OSGi plugin but are these tests going to stay in the main src dir or will they move to a separate tests dir Please add this one line to the jar section instruction Import Package org junit junit framework org mockito This should mask out the unit testing packages NOTE Make sure you set your version to a release name non SNAPSHOT before building the project The manifest exports specific versions of rx right now that version is version 0 5 5 SNAPSHOT which will fail if the actual maven artifact version is 0 5 5 Thanks if you do move the tests out of the main source dir then the Import Package instruction can be removed The unit tests will not be moved out They are there on purpose The JUnit dependency is marked as provided https github com Netflix Hystrix blob master hystrix core build gradle#L9 but not included as part of the runtime dependencies when published to Maven Central http search maven org #artifactdetails 7Ccom netflix hystrix 7Chystrix core 7C1 2 12 7Cjar Does the addition of just the following OSGi headers satisfy your requirements jar manifest name rxjava core instruction Bundle Vendor Netflix instruction Bundle DocURL https github com Netflix RxJava instruction Import Package org junit junit framework org mockito What about the bundle fragments that you mentioned would be needed for the language adaptors Or do I simply just add these same headers to each of those other jars as well with their appropriate names of course The provided scope still means a runtime dependency rather than a test time dependency I don t understand why they are not separated but that doesn t matter as long as it can be managed out of the dependencies As for the language adapters let me have a look at them They will need their own instructions for gradle including the fragment instruction and to answer the question for core yes that manifest instruction set is good I ll wait on your answer for the language adaptors and then commit the changes Yes it s runtime for running the tests but not for production usage which is why they are marked as provided and not needed as transitive dependencies Reasons if you care are here http benjchristensen com 2011 10 23 junit tests as inner classes How do you build the language adaptors or where do they land BenI jamin I am not having much luck building the language adaptors I am using both the top level build command as described above as well as the subproject build like this Projects RxJava gradlew language adaptors build What I get in language adaptors build libs is an anemic jar file 261 bytes with only a one line manifest Is there another way to generate the adaptor jars You can either build the entire project from the root like this cd RxJava gradlew build ls al language adaptors rxjava groovy build libs rxjava groovy 0 5 5 SNAPSHOT jar rw r r 1 bechristensen CORP Domain Users 1115 Mar 11 13 08 build libs rxjava groovy 0 5 5 SNAPSHOT jar Or you can go into an individual project and build it cd language adaptors rxjava groovy gradlew build The contents are like this jar tvf build libs rxjava groovy 0 5 5 SNAPSHOT jar 0 Mon Mar 11 13 08 14 PDT 2013 META INF 25 Mon Mar 11 13 08 14 PDT 2013 META INF MANIFEST MF 0 Thu Feb 28 12 09 40 PST 2013 rx 0 Thu Feb 28 12 09 40 PST 2013 rx lang 0 Mon Mar 11 13 08 14 PDT 2013 rx lang groovy 809 Mon Mar 11 13 08 14 PDT 2013 rx lang groovy GroovyAdaptor class Each language adaptor will have a build grade file which would be changed For example https github com Netflix RxJava blob master language adaptors rxjava groovy build gradle Is scala groovy clojure supposed to be available or installed or such It could be the reason I am getting such a small jar is that it gradle doesn t know what do to with these files I built with d to see if any error messages would surface but I couldn t spot anything obvious To wit gradlew clean build generates this Projects RxJava ls la language adaptors build libs total 24 drwxr xr x 5 matt staff 170 Mar 11 19 16 drwxr xr x 6 matt staff 204 Mar 11 19 16 rw r r 1 matt staff 261 Mar 11 19 16 language adaptors 0 5 5 SNAPSHOT javadoc jar rw r r 1 matt staff 261 Mar 11 19 16 language adaptors 0 5 5 SNAPSHOT sources jar rw r r 1 matt staff 261 Mar 11 19 16 language adaptors 0 5 5 SNAPSHOT jar Which as you can see is a set of 261 byte jars Each jar contains only an empty manifest file So until I can actually build something from the git codebase the language adaptors can t be turned into OSGi bundles I m happy to not be concerned with them in this issue as they are only used for people wanting to use them which can be considered a separate path Perhaps someone can raise a new issue when they want to use these languages That would allow you to commit your change and close this issue There is nothing beyond Java needed to build the project so I don t know what s going on with your build I have submitted a pull request with the discussed changes Please review and let me know if they look right Here is the rxjava core manifest Manifest Version 1 0 Export Package rx subjects uses rx util rx rx util functions versi on 0 5 6 SNAPSHOT rx util uses rx rx util functions version 0 5 6 SNAPSHOT rx util functions uses org slf4j version 0 5 6 SNAPS HOT rx observables uses rx util functions rx version 0 5 6 SNAPS HOT rx operators uses rx rx util functions rx util rx observables version 0 5 6 SNAPSHOT rx plugins version 0 5 6 SNAPSHOT rx uses rx util functions rx util rx plugins rx operators version 0 5 6 SNAPSHOT Ignore Package junit framework org mockito org mockito verification o rg mockito stubbing org junit Tool Bnd 1 50 0 Bundle Name rxjava core Created By 1 7 0_13 Oracle Corporation Bundle Vendor Netflix Bundle Version 0 5 6 SNAPSHOT Bnd LastModified 1363058955000 Bundle ManifestVersion 2 Bundle DocURL https github com Netflix RxJava Import Package org slf4j version 1 7 2 Bundle SymbolicName com netflix rxjava core Here is a manifest for rxjava groovy to show a language adaptor Manifest Version 1 0 Export Package rx lang groovy uses groovy lang rx util functions v ersion 0 5 6 SNAPSHOT Bundle Vendor Netflix Bundle Version 0 5 6 SNAPSHOT Tool Bnd 1 50 0 Bundle Name rxjava groovy Bnd LastModified 1363058977000 Created By 1 7 0_13 Oracle Corporation Bundle ManifestVersion 2 Bundle DocURL https github com Netflix RxJava Bundle SymbolicName com netflix rxjava groovy Import Package groovy lang version 2 1 3 rx util functions versio n 0 5 1 Of course when released the version with be correct and not have SNAPSHOT in it For the language modules please add the following instruction to the jar manifest config instruction Fragment Host com netflix rxjava core This will give the language modules the name of the rxjava core jar to attach themselves to thereby allowing their classes to be joined to core s class path and thus discoverable Otherwise looks great Okay I ll add that What does this represent com netflix rxjava core That is not a package or module name I see that it shows up as Bundle SymbolicName but I don t understand where that comes from as the module name is rxjava core @mattbishop Is that pull request correct That s the symbolic name of the rxjava core bundle jar It is generated by the OSGi plugin Matt Bishop On 2013 03 12 at 9 47 AM Ben Christensen notifications@github com wrote What does this represent com netflix rxjava core That is not a package or module name Reply to this email directly or view it on GitHub Okay merging now This will go out in the next release Ben thank you for taking the time to engage this issue so decisively even though your use has no need of OSGi It s great to see I ll pay attention to the issues and pitch in when OSGi comes up in the future On 2013 03 12 at 1 27 PM Ben Christensen notifications@github com wrote This will go out in the next release Reply to this email directly or view it on GitHub You re welcome I appreciate your patience a week of travel in the middle didn t help in that regard while I got to it I hope Hystrix can create value for you as it has for us @benjchristensen and by Hystrix you meant RxJava Ugh yes That s what I get for flipping between two projects so much they morph into the same @mattbishop Now that the code is released have you been able to confirm that it works as needed via Maven Central Considering this completed as I have received no updates or complaints since releasing it',RxJava,false,false,false
11308997,'Change target compatibility from 1 5 to 1 6','https github com Netflix RxJava issues 153','',RxJava,true,false,false
11462076,'Implemented ToIterable Operation','For issue #18 This would allow to implement other blocking methods like single lastOrDefault next','This looks good Merging',RxJava,true,false,false
11476680,'Implemented single and singleOrDefault','For issue #77','I completed this merge in https github com Netflix RxJava pull 160 since it had conflicts',RxJava,true,false,false
11497694,'Travis CI Configuration','The project would benefit by having Continuous Integration configured I ve configured travis ci for my fork it could be found at https travis ci org mairbek RxJava','I definitely agree that a CI build system is beneficial in fact we at Netflix have been working on a solution for all of the NetflixOSS projects and are very close to having it up We are going to be using CloudBees http www cloudbees com jenkins enterprise by cloudbees overview cb and I ve been working with @garethbowles the past few days to get it working It should be up shortly and allow for builds and unit tests triggered on commits and pull requests Awesome CloudBees seems to be more powerful than travis ci Let s close this one',RxJava,true,false,false
11500165,'Implemented LastOrDefault Operator','For issue #58','Looks good Of note while reviewing this I realized the last operator https github com Netflix RxJava issues 57 is wrong and needs to be fixed',RxJava,true,false,false
11517981,'Manual merge of mairbek single Pull #157','Merging https github com Netflix RxJava pull 157 which had conflicts and needed a manual merge','',RxJava,true,false,false
11518035,'Added build status badges','I m not wild about the icons that CloudBees provides but it looks fairly straightforward to change them if needed','',RxJava,true,false,false
11520200,'Test build of pull request','','RxJava pull requests #1 https netflixoss ci cloudbees com job RxJava pull requests 1 SUCCESS This pull request looks good',RxJava,true,false,false
11556836,'Implemented Next Operation','New implementation of #66','RxJava pull requests #2 https netflixoss ci cloudbees com job RxJava pull requests 2 SUCCESS This pull request looks good @mairbek Take a look at the changes I made in https github com Netflix RxJava pull 166 to make hasNext not throw an exception I also added another unit test while reviewing If you re happy with the changes I made I will merge that request which adds on top of your commits Or if you want to do things differently and update this pull request that works as well though please copy paste in my new unit test yeah I ll close this one',RxJava,true,false,false
11559105,'rx util Range createWithCount int start int count yields invalid sequence when start 1','createWithCount 1 4 correctly yields 1 2 3 4 createWithCount 2 4 yields 2 3 4 5 6 7 8 9 where it should be 2 3 4 5 createWithCount 0 4 yields where it should be 0 1 2 3 createWithCount 1 4 yields where it should be 1 0 1 2','Thanks @mairbek for the quick fix @christianbourgeois I have merged the fix https github com Netflix RxJava pull 165 and will include in the next release I just want to review one more pull request to try and get it into that release It is okay if I wait until end of day today to release the new code or do you need the fix sooner Thanks @mairbek for the quick fix and @benjchristensen for the merge You are all very fast I was in the process of sending a pull request when I saw the fix by @mairbek This issue is not critical in any way for me no worries for the release Then I ll finish up the other work before doing this release hoping either end of day or over weekend Thanks for reporting the bug and being willing to submit a pull request until @mairbek beat you to it Thank you @christianbourgeois for reporting the issue I had shortly realized what a dumb mistake I made in that code',RxJava,false,false,false
11559382,'Fixed bug in ranges','Fixed issue #164','RxJava pull requests #3 https netflixoss ci cloudbees com job RxJava pull requests 3 SUCCESS This pull request looks good',RxJava,true,false,false
11567750,'Review of Next Operation','Some changes I made while reviewing https github com Netflix RxJava pull 163','RxJava pull requests #4 https netflixoss ci cloudbees com job RxJava pull requests 4 SUCCESS This pull request looks good Looks good thank you',RxJava,true,false,false
11633861,'Reimplemented Last operation','For issue #57','RxJava pull requests #6 https netflixoss ci cloudbees com job RxJava pull requests 6 FAILURE Looks like there s a problem with this pull request This looks good holding off on merging until I m ready to release 0 6 0 with breaking changes I will bundle this with the Subscription https github com Netflix RxJava issues 173 changes as well since they will likely be breaking because they ll change the package of the Subscription object Manually merged in https github com Netflix RxJava pull 184',RxJava,true,false,false
11638631,'Implemented Most Recent','For issue #64','RxJava pull requests #6 https netflixoss ci cloudbees com job RxJava pull requests 6 SUCCESS This pull request looks good Man it is hard to understand the difference between Latest Next MostRecent etc using MSDN docs Trying to figure out the different between Observable Latest http msdn microsoft com en us library hh212115 v vs 103 aspx and Observable MostRecent http msdn microsoft com en us library hh229751 v vs 103 aspx other than the latter having an initialValue Both return IEnumerable TSource and both say Samples the most recent value in an observable sequence The Observable Next operator says Samples the next value blocking without buffering from in an observable sequence and also returns IEnumerable TSource My understanding of these operators are Latest will cache the latest value and return immediately when iterator next is called or block if no value is cached until next value when the value is emitted it is removed from the cache so only emitted once Next will not cache the latest value so will block until next value MostRecent will cache the latest value and return immediately when iterator next is called or block if no value is cached until next value the last value is always retained so if you subscribe to it multiple times it will keep returning the most recent value The initialValue guarantees it will never wait and immediately return This pull request looks good merging',RxJava,true,false,false
11639059,'Implemented GetIterator','For issue #50','RxJava pull requests #7 https netflixoss ci cloudbees com job RxJava pull requests 7 SUCCESS This pull request looks good Did some simple refactoring on top of this pull request so closing this one out and merging via pull request https github com Netflix RxJava pull 178',RxJava,true,false,false
11640630,'Add Scan Reduce with Generic Accumulator Type','There should be support for generic reducers for example to implement #32 Right now Scan restricts accumulator to be the same type as an observable scan Observable T sequence T initialValue Func2 T T T accumulator This should be changed to scan Observable T sequence A initialValue Func2 A T A accumulator NET supports this type of reducers http msdn microsoft com en us library hh212007 v vs 103 aspx','I already fixed this some time back scan and reduce are able to use accumulators of a type other than the one of Observable now Imho this issue can be closed Great thanks @jmhofer @mairbek I m going to close this if you feel otherwise about the status then please re open',RxJava,false,false,false
11663099,'Implemented Defer Operation','For issue #35','Looks good merging',RxJava,true,false,false
11688374,'Synchronous adapter methods','It would be useful for Observable T to provide List T get throws Exception and T getSingle throws Exception methods for providing synchronous interfaces on top of Observable','Many of these have recently been implemented or are being implemented Operator Single and SingleOrDefault https github com Netflix RxJava issues 77 Operator Next https github com Netflix RxJava issues 66 Operator ToIterable https github com Netflix RxJava issues 18 Operator ForEach https github com Netflix RxJava issues 45 You can see the recent releases at https github com Netflix RxJava blob master CHANGES md Silly me for expecting these to be documented in the wiki I don t like the way that toIterable and friends wrap use Exceptions propagate on errors They should either throw Exception or wrap in a subclass of RuntimeException that callers can use in a catch block just for Observer thrown errors And I think that Observable T should have been Observable T E extends Exception No one has gotten around to updating the wiki with the docs these functions were just recently submitted as contributions The try catch block is what is used on any of the blocking operators forEach toIterable etc For example see this unit test https github com Netflix RxJava blob master language adaptors rxjava groovy src test groovy rx lang groovy ObservableTests groovy#L227 What don t you like about how toIterable throws exceptions It is a blocking structure so will thrown an exception when iterable next is invoked and next from the Observable sequence was an onError instead of an onNext It can t throw an exception only on the toIterable method itself since the data is coming asynchronously behind the scenes and we may not know about an error until n elements into the iteration at which point an exception is thrown As for Observable T being Observable T E extends Exception I don t believe that could work to strongly type E on each Observable since composition results in multiple sequence all combining into a single sequence and each of those sequence could emit a different type of Exception at any time thus the common E of combined sequences would end up being Exception or RuntimeException at best anyways Note that many of these design decisions are modeled after Rx Net which has gone through a long design cycle that we re leveraging for many of these API designs and they do Observable T see https rx codeplex com for more information on the original Also there is nothing that guarantees only a single Exception type will be thrown from even a single Observable sequence for example any variety of RuntimeExceptions can still be passed via onError not just the strongly typed E if that was declared Error handlers such as public Observable T onErrorResumeNext final Func1 Exception Observable T resumeFunction allow you to use the type of the Exception to perform different logic if you desire A better way of doing that will exist once the Catch operator https github com Netflix RxJava issues 28 is implemented which will allow defining a catch for each Exception type and continuing with a different Observable similar to currently implemented onErrorResumeNext but with a catch on a specific Exception instead on all of them What I don t like about how toIterable wraps exceptions is that it wraps them in a plain RuntimeException so the caller cannot in the condition of a catch block distinguish exceptions returned by the Observable from exceptions thrown by the RxJava framework itself Furthermore one cannot distinguish in the condition of a catch block amongst different types of exceptions returned by the Observable What are you suggesting as the alternative The java util Iterator interface doesn t throw checked Exceptions so if onError receives an Exception instead of RuntimeException we still have to throw it somehow since we re now in a synchronous Iterator code flow Thus if we receive a RuntimeException we throw it as is if we receive an Exception which I would argue just shouldn t be used as checked exceptions have exactly this problem we have to wrap it in a RuntimeException so we can throw it java public static RuntimeException propagate Throwable t if t instanceof RuntimeException throw RuntimeException t else throw new RuntimeException t I do not know how to handle the checked exceptions differently but if you can offer an alternative please provide a diff or pull request that demonstrates how you would implement the following code such that it can receive either Exception or RuntimeException and conform to the Iterable Iterator interfaces https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorToIterator java#L69 https github com Netflix RxJava blob master rxjava core src main java rx operators OperationMostRecent java#L69 https github com Netflix RxJava blob master rxjava core src main java rx operators OperationNext java#L156 Here is an example unit test that receives an Exception when calling next java @Test expected TestException class public void testToIteratorWithException Observable String obs Observable create new Func1 Observer String Subscription @Override public Subscription call Observer String observer observer onNext one observer onError new TestException return Subscriptions empty Iterator String it toIterator obs assertEquals true it hasNext assertEquals one it next assertEquals true it hasNext it next This code is from https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorToIterator java#L113 Per pull #185 my proposed wrapper type is a subclass of RuntimeException so it can be thrown by an Iterator Closing this out as per the long discussion in https github com Netflix RxJava pull 185',RxJava,false,false,false
11747799,'Subscription Utilities and Default Implementations','Provide a createSubscription utility that returns a Subscription implementation that is thread safe that provides an isUnsubscribed getter to be used by most Observables via Observable create since most of the time they just need a thread safe volatile atomic boolean to check in a loop Also where should it go along with these java public static Subscription createSubscription final Action0 unsubscribe public static Subscription createSubscription final Object unsubscribe public static Subscription noOpSubscription Should this be on Observable or should a new Subscriptions utility class exist','The type of things to model in Rx are here http msdn microsoft com en us library system reactive disposables v vs 103 aspx Disposable Subscription in RxJava The Disposable name means something special in C# similar to AutoCloseable http docs oracle com javase 7 docs api java lang AutoCloseable html in Java7 which is why Subscription doesn t implement AutoCloseable yet since we are sticking to Java6 We want an rx subscriptions package Subscription is currently an interface which I like in this case since it can be a FunctionalInterface in Java8 and implemented with lambdas but it means we can t exactly model the Subscription create method signature of Rx Net I m torn as Subscription create would be a very nice method signature We could have rx subscriptions Subscriptions as the utility method but it s slightly contrived For example java rx subscriptions Subscriptions create final Action0 unsubscribe rx subscriptions Subscriptions create final Object unsubscribe rx subscriptions Subscriptions empty Then we d have a class like rx subscriptions BooleanSubscription which is what would provide the functionality most Observables want Anyone have thoughts on what decisions to make with this API This was never tackled internally at Netflix as we just had custom Subscription objects that implement the interface but that s not appropriate for a standalone library particularly when trying to comply with the Rx Net design and API I like the idea of creating Subscriptions class and moving it alongside with a Subscription interface to a separate package It seems like NET naming convention dictates that interfaces should start with I and static class should be named as a singular word IDisposable Disposable Since we are dealing with Java having Subscriptions as a utility class seems to be a natural choice because this naming style is widely used within a JDK itself e g Collection Collections Besides that I see there are several wrappers in a System Reactive Disposables some of them like CompositeDisposable seems to be particularly useful It would be nice to see whole namespace migrated to RxJava Done interested in people s review however Will be part of 0 6 0 as it involves some small breaking changes in the pursuit of trying to match Rx Net such as this https rx codeplex com SourceControl changeset view 6bf8a7952bdd#Rx NET Source System Reactive Core Reactive Disposables Disposable cs Done interested in people s review however Will be part of 0 6 0 as it involves some small breaking changes in the pursuit of trying to match Rx Net such as this https rx codeplex com SourceControl changeset view 6bf8a7952bdd#Rx NET Source System Reactive Core Reactive Disposables Disposable cs',RxJava,false,false,false
11841485,Dematerialize,'PR for #37 Someone might want to help me with proper unit tests','test RxJava pull requests #2 https netflixoss ci cloudbees com job test RxJava pull requests 2 FAILURE Looks like there s a problem with this pull request RxJava pull requests #9 https netflixoss ci cloudbees com job RxJava pull requests 9 SUCCESS This pull request looks good I would suggest you to use Mockito https code google com p mockito for the unit tests instead of coding stub observer This will make testing a lot more easier Basically what you need is to mock observer using Mockito#mock method Observer Integer aObserver mock Observer class and than verify calls to the mock object using verify method for example verify aObserver times 1 onNext 1 Mockito is widely used within the codebase so you might want take a look to the existing tests for examples @mairbek thanks updated the code to use mockit but still use observable materialize RxJava pull requests #10 https netflixoss ci cloudbees com job RxJava pull requests 10 SUCCESS This pull request looks good test RxJava pull requests #3 https netflixoss ci cloudbees com job test RxJava pull requests 3 FAILURE Looks like there s a problem with this pull request RxJava pull requests #11 https netflixoss ci cloudbees com job RxJava pull requests 11 SUCCESS This pull request looks good test RxJava pull requests #4 https netflixoss ci cloudbees com job test RxJava pull requests 4 FAILURE Looks like there s a problem with this pull request This could not be automatically merged due to conflicts with other pull requests so manually merged in https github com Netflix RxJava pull 177',RxJava,true,false,false
11854298,'JavaDoc Marble diagram for mapMany is broken','See http netflix github com RxJava javadoc rx Observable html#mapMany rx util functions Func1','Works again as of today Weird closing this I have no idea why that wouldn t work That image has been up there for over a month at https raw github com wiki Netflix RxJava images rx operators mapMany png',RxJava,false,false,false
11894326,'Implemented GroupBy','For issue #51','RxJava pull requests #14 https netflixoss ci cloudbees com job RxJava pull requests 14 SUCCESS This pull request looks good This is a difficult one with Java as maintaining GroupedObservable will require manual effort every time a new static is added and it will be very easy for it to drift away from Observable In short I m not a fan of relying on static method overrides I m going to sit on this a bit while I think about and talk to others on this I want to better understand the GroupBy operator too so need to play with it I used IDE to delegate methods to underlying observable Looks like it has generated statics methods as well let me remove them Ah so that wasn t intended In C# version Observable is an interface and GroupedObservable can simply extend it Since in java version Observable is a class I decided to make GroupedObservable to be a proxy for Observable RxJava pull requests #17 https netflixoss ci cloudbees com job RxJava pull requests 17 SUCCESS This pull request looks good Yes your approach makes sense The reason for the class rather than interface is because Java doesn t have extension methods like C# does otherwise we d also have Observable be an interface originally inside Netflix we had Observable as an interface and all implementations in AbstractObservable but everything has to work with AbstractObservable it was very awkward so we did away with it I need to spend a few more minutes to understand this operator Take a look at a different approach I took for GroupedObservable in pull request https github com Netflix RxJava pull 179 and let me know if you think that works okay Completed in https github com Netflix RxJava pull 179',RxJava,true,false,false
11898246,'Operator Dematerialize review and manual merge','Manual merge of pull request https github com Netflix RxJava pull 174 for issue https github com Netflix RxJava issues 37','RxJava pull requests #15 https netflixoss ci cloudbees com job RxJava pull requests 15 SUCCESS This pull request looks good',RxJava,true,false,false
11898880,'Review and Refactor of GetIterator','Review of pull request https github com Netflix RxJava pull 169 for issue https github com Netflix RxJava issues 50 along with a simple refactoring to reduce code in Observable java','RxJava pull requests #16 https netflixoss ci cloudbees com job RxJava pull requests 16 SUCCESS This pull request looks good',RxJava,true,false,false
11903490,'Operator GroupBy Pull Request Review and Refactor','Refactored version of pull request https github com Netflix RxJava pull 176 for issue https github com Netflix RxJava issues 51 I would like to avoid delegation if possible since it will mean it needs to be kept in sync with Observable This refactored approach allows inheritance without delegation by composing the Observable inside another operator function','RxJava pull requests #18 https netflixoss ci cloudbees com job RxJava pull requests 18 SUCCESS This pull request looks good The only thing I don t like right now about this is having GroupedObservable in the rx package It feels like an implementation detail that should live in a sub package rather than the top most package For example in Rx Net IObservable is in System and IGroupedObservable in System Reactive Linq I m wondering if we should have rx observables similar to rx subscriptions https github com Netflix RxJava issues 173 Observable belongs at rx Observable and maybe the rx Subscription interface as well but all other impls should be in a sub package I think RxJava pull requests #19 https netflixoss ci cloudbees com job RxJava pull requests 19 SUCCESS This pull request looks good',RxJava,true,false,false
11908358,'Formatting and cleanup','','RxJava pull requests #20 https netflixoss ci cloudbees com job RxJava pull requests 20 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
11908549,'Add OSGi manifest headers','https github com Netflix RxJava issues 154 I can t confirm that these work but submitting based on discussion on issue #154','RxJava pull requests #21 https netflixoss ci cloudbees com job RxJava pull requests 21 FAILURE Looks like there s a problem with this pull request Merged to become part of version 0 6 0',RxJava,true,false,false
11909031,'Subscriptions utility class and rx subscriptions package','https github com Netflix RxJava issues 173','Merging to become part of version 0 6 0 this has breaking changes RxJava pull requests #22 https netflixoss ci cloudbees com job RxJava pull requests 22 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
11909244,'Groovy VideoExample improvements','Make VideoExample more idiomatic for Groovy based on feedback Use the new BooleanSubscription object','RxJava pull requests #23 https netflixoss ci cloudbees com job RxJava pull requests 23 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
11909524,'Convert last from non blocking to blocking to match Rx Net','Merging pull request https github com Netflix RxJava pull 167 which needed manual merging Did some other cleanup while in there and added a missing generic Object override Thank you @mairbek for doing this work','RxJava pull requests #24 https netflixoss ci cloudbees com job RxJava pull requests 24 SUCCESS This pull request looks good',RxJava,true,false,false
11911148,'toIterable consistent wrapping of errors','toIterable now wraps errors reported through the Observable in a newly created ObservedException This allows a catch block to handle only the exceptions that came through the Observable not catching exceptions thrown by RxJava itself','RxJava pull requests #25 https netflixoss ci cloudbees com job RxJava pull requests 25 FAILURE Looks like there s a problem with this pull request What use case are you trying to handle here I m not understanding why we would need to wrap everything in an ObservedException I see it as far better to leave RuntimeExceptions untouched so the try catch can catch whatever RuntimeException wanted just propagate rather than have everything be inside an ObservedException This is related to the discussion over on https github com Netflix RxJava issues 172#issuecomment 14786632 I added modified unit tests to describe the use cases The problem with leaving RuntimeException s untouched is demonstrated in the testToIterableDoesntConfuseExceptionSources test If you don t always wrap with a specific exception type then you risk having a catch block intended to handle the Observable s errors unintentionally sweep up exceptions thrown by RxJava The catch block would be likely to hide the problem hinder diagnosis or cause who knows what damage The particular exception I used for the unit test is a bit contrived but I didn t have time to cast about for a plausible input dependent exception thrown by RxJava What confusion are you trying to avoid It is a truly rare scenario that an exception would be thrown that is not from the Observable sequence it would mean a very bad bug or it is something obvious like UnsupportedOperationException that should blow up and make a developer stop using that method Am I correct that you would prefer checked Exceptions and are trying to treat RuntimeExceptions emitted from an Observable onError as if they are checked Here is an example of the Rx Net implementation in C# where the error is thrown http rx codeplex com SourceControl changeset view 6bf8a7952bdd#Rx NET Source System Reactive Linq Reactive Linq Observable GetEnumerator cs C# public bool MoveNext _gate Wait if _disposed throw new ObjectDisposedException if _queue TryDequeue out _current return true _error ThrowIfNotNull Debug Assert _done _gate Release In the rare case the user calls MoveNext again we shouldn t block return false Note this line _error ThrowIfNotNull I agree with their implementation which I didn t look at until now and it does what RxJava currently does if an exception is received via onError it propagates it Exceptions of any type from any number of sequences or causes can be passed via onError so capturing and wrapping them will not accomplish any sort of isolation from only those causes by a single sequence Any RxJava or other exceptions JDK 3rd party libraries Groovy Scala Clojure JRuby whatever of any Observable sequence combined into this iterator will all be emitted via onError except for the remove method that throws UnsupportedOperationException Everything is asynchronous and thus everything is funneled via onError If when working on an Observable or iterable from an Observable you know specific exceptions to handle you can but RuntimeExceptions can and will occur and must either be handled or allowed to propagate java try it next catch AnExceptionBeingLookedFor e do something with e catch RuntimeException e generic catch all for anything else Or just let it propagate java try it next catch AnExceptionBeingLookedFor e do something with e If everything was wrapped virtually all exceptions including framework ones from the Observable onSubscribe behavior would all be wrapped and thus handled like this java try it next catch ObservedException e if e getCause instanceof AnExceptionBeingLookedFor do something with AnExceptionBeingLookedFor e else do something with generic e Is it fair to summarize the questions are these Should we propagate runtime exceptions like USOE in another runtime exception If so does using a specific subclass of RuntimeException give us more reliable error handling I also wonder if there are other sources we can look at for similar wrappiness rationale ex UncheckedExecutionException used many places in guava If it is considered extremely unlikely that the observable and the framework would send the same typed exception one possibility would be to wrap only checked exceptions in ObservedException Rare doesn t quite cut it many disasters are caused by rare occurrences I m not worried about situations such as the remove operator s UnsupportedOperationException that wouldn t escape unit testing just ones that are input dependent I need to do more research in order to respond to your other points and questions Unfortunately I m severely time constrained the next few days I agree that the rare argument is bad but that s not the intent of my point I worded that poorly My point is that almost all exceptions will be emitted via onError including non business logic exceptions The onError method is going to receive any mixture of exceptions Exception or RuntimeException coming from whatever source occurred the onSubscribe Rx itself the JVM any libraries involved in it and any Observables composed into the Observable being subscribed to thus wrapping the exception being emitted by onError is not going to buy anything it IS the source of exceptions Observables are not just for handling asynchronous values but asynchronous exceptions as well Screen Shot 2013 03 12 at 4 53 16 PM https f cloud github com assets 813492 251706 d4e6cae0 8b6f 11e2 9c19 10a5be08f178 png In that diagram note that there are 3 Observable sequences combined into 1 which is then subscribed to via the toIterable which converts an asynchronous sequence into a synchronous Iterable Any of those Observable can emit an Exception RuntimeException that originates from RxJava itself a bug an error from the onSubscribe functions what is being observed or anything underneath the onSubscribe JDK NPEs 3rd party libraries Since all of the exceptions from A B and C are funneled into D they are propagated via onError Thus all of them will be wrapped as ObservedException and nothing treated differently as there is nothing to distinguish them Here is a simple example showing an Observable with try catch behavior that correctly propagates any errors that occur groovy this is a contrived example that obviously does no real network traffic Observable VideoList getListOfLists userId return Observable create observer BooleanSubscription subscription new BooleanSubscription try this will happen on a separate thread as it requires a network call executor execute simulate network latency Thread sleep 180 for i in 0 15 if subscription isUnsubscribed break try observer onNext new VideoList i catch Exception e observer onError e observer onCompleted catch Exception e observer onError e return subscription Everything once composed under an Observable will emit via onError that s the point of onError and not be thrown because throwing exceptions in an async environments is meaningless and thus wrapping everything that comes out of onError before throwing from Iterator next does not accomplish the stated goal of differentiating between errors from the Observable versus from elsewhere since everything is funneled via onError except the top most methods on the Iterable object itself since that is after escaping the asynchronous Observable In the specific case of synchronous escapes from Observable such as toIterable remove it is the top most layer above the Observable composition so it could throw UnsupportedOperationException differently since at that point we are synchronous but if A B C or D observables invoke an iterable remove that throws UnsupportedOperationException that will be caught and emitted via onError since all exceptions must be sent via onError to comply with the Observable contract and be properly handled in an async model Screen Shot 2013 03 12 at 5 04 01 PM https f cloud github com assets 813492 251735 5529d5f2 8b71 11e2 9856 ac6fbcd27dc7 png Other than the few scenarios such as UnsupportedOperationException on the top most Iterable when escaping from the Observable I can t see any other Exceptions that would not route via onError and thus don t see how the goal of differentiating between Observable exceptions and RxJava exceptions is being accomplished by wrapping them all as ObservedException since both of those will route via onError Your example Java try it next catch AnExceptionBeingLookedFor e do something with e catch RuntimeException e generic catch all for anything else won t even compile if AnExceptionBeingLookedFor is a checked exception I don t understand what you re trying to say with the statement won t even compile if AnExceptionBeingLookedFor is a checked exception in context of an Iterator A checked exception can t be thrown from an Iterable or Observable so AnExceptionBeingLookedFor would only be a RuntimeException http docs oracle com javase 6 docs api java util Iterator html Any checked exceptions must be wrapped in a RuntimeException and thrown Can you elaborate further to help me understand Is it just that you are trying to make checked exceptions work with Iterable Iterator Observable RxJava pull requests #42 https netflixoss ci cloudbees com job RxJava pull requests 42 SUCCESS This pull request looks good John If I understand correctly what you re trying to do here it is if a RuntimeException is received then re throw it if a checked Exception is received wrap it as a RuntimeException called ObservedException instead of RuntimeException which is what it currently does and throw it Is that correct If so why The ObservedException type doesn t communicate anything more than RuntimeException except that it is a checked exception if they read the javadocs to learn that this is the only reason ObservedException would be thrown and I don t see how that changes how anyone would interact with this other than adding another type people would now need to know about With the statement won t even compile if AnExceptionBeingLookedFor is a checked exception I was pointing out that your pattern for handling specific exceptions yet allowing unhandled RuntimeExceptions to propagate doesn t work for handling checked exceptions If you then devise a corresponding pattern for checked exceptions you should then discover the need for something equivalent to ObservedException The ObservedException communicates that its cause was passed through Observer onError With the current wrapping with a plain RuntimeException it is difficult subtle or even impossible for a catch block to distinguish between a checked exception of a particular type that was passed through Observer onError and a subclass of RuntimeException passed through Observer onError that just happens to have a checked exception of that type in its cause In an attempt to bisect this discussion I have reduced the scope of the commit in this pull request to only affect the behavior of checked exceptions Should we establish the need to change the wrapping behavior of checked exceptions we can then consider whether RuntimeExceptions need to be similarly wrapped There are good arguments against wrapping RuntimeExceptions I need to audit the code to see if it is worth pressing the issue As ObservedException is a subclass of RuntimeException the revised commit doesn t break any existing callers RxJava pull requests #46 https netflixoss ci cloudbees com job RxJava pull requests 46 SUCCESS This pull request looks good I found other operators that also need to wrap checked exceptions in ObservedException I m now convinced there s no need to wrap RuntimeExceptions in ObservedException I still don t understand why checked exceptions need to be wrapped in ObservedException instead of a RuntimeException How does the following java try iterator next catch SomeTypedRuntimeException e do something specific to this runtime exception catch ObservedException e if e getCause instanceof ACheckedException do something catch RuntimeException e handle all other exceptions offer anything more than this java try iterator next catch SomeTypedRuntimeException e do something specific to this runtime exception catch RuntimeException e if e getCause instanceof ACheckedException do something else handle all other exceptions Wouldn t if check in the first sample if e getCause instanceof ACheckedException do something not be necessary because the ObservedException would only be used to wrap checked exceptions On Mar 26 2013 at 9 46 AM Ben Christensen notifications@github com wrote I still don t understand why checked exceptions need to be wrapped in ObservedException instead of a RuntimeException How does the following try iterator next catch SomeTypedRuntimeException e do something specific to this runtime exception catch ObservedException e if e getCause instanceof ACheckedException do something catch RuntimeException e handle all other exceptions offer anything more than this try iterator next catch SomeTypedRuntimeException e do something specific to this runtime exception catch RuntimeException e if e getCause instanceof ACheckedException do something else handle all other exceptions Reply to this email directly or view it on GitHub There can be any number of checked exceptions in it so you would still have to check the type if you wanted to respond to only a given checked exception An Observable can emit via onError any Exception whether it be checked or runtime thus the only thing ObservedException would tell in this case is that it extends from Exception but not RuntimeException If the observable did java ACheckedException cause observer onError new SomeOtherTypedRuntimeException cause then your first example will work correctly but your second example will incorrectly unwrap SomeOtherTypedRuntimeException and incorrectly handle cause Nested causes will not be solved by any of this It would never be wrapped in an ObservedException because SomeOtherTypedRuntimeException would be seen as a RuntimeException not the underlying cause ACheckedException We will not unwrap something we receive via onError until we hit a checked Exception if one even exists that is not our call to make as we would then be discarding information that was sent via onError Observables emit exceptions either checked or runtime It is up to the Observable what they choose to emit At the other end of the sequence where we now are breaking out of Observable into an Interable we need to throw whatever is emitted from onError The exceptions may be n levels deep with causes It may be a RuntimeException with a checked Exception cause with a RuntimeException cause with a Throwable cause If the top most object in the cause chain is a RuntimeException we just throw it If it is a checked Exception then we must wrap as a RuntimeException and throw it I still do not know of a use case that wrapping checked exceptions in a special type solves better than just leaving the behavior as is and throwing a RuntimeException No matter what is done with the checked Exception someone must query the cause to do anything with it If the Observable implementation wrapped a checked Exception in a RuntimeException already that is up to the Observable to do nothing at all with the toIterable or exception propagation logic SomeOtherTypedRuntimeException is not supposed to be wrapped in ObservedException Please re read my previous comment Unlike for RuntimeException the set of possible checked exception classes is explicitly enumerated by the API definition Consider a HystrixCheckedCommand R E extends Exception java public abstract class HystrixCheckedCommand R E extends Exception protected abstract R run throws E public R execute throws E try return new CommandObservable single catch ObservedException e throw E e getCause private class CommandObservable extends HystrixObservable R @Override protected Observable R create Observable create wrap run There is no source of checked exceptions other than run so the catch block knows any checked exception is a subclass of E To recap you presented two examples one using ObservedException and one not stating that you can t see how the first provides useful semantics not provided by the second I provided an example where the first example behaves differently than the second The first example s behavior is useful You replied that the first example would not behave like the second therefore the example is not useful That argument is a non sequitur Am I correct that in short you desire a mechanism to know that something emitted from onError and thrown via Iterable was a checked Exception at the point it was emitted from onError I see how wrapping it as a new type ObservedException could enable this However it is not required to do so If checked Exceptions are important to you and you don t like them being wrapped in a RuntimeException I suggest not using toIterable or other similar blocking calls which do not support checked Exceptions or you could instead use an operator such as Catch https github com Netflix RxJava issues 28 to catch the checked Exception and then wrap it as you wish so that your try catch block gets exactly what you re looking for Or as you did in the HystrixCheckedCommand wrap a checked Exception as you wish at the source as you did to wrap it as ObservedException so that you can then try catch what you re expecting There are many ways within your control of getting the type of Exception you wish without adding a new arbitrary Exception type to RxJava I could easily just add this type to the library but then it s one more thing to explain document support and for people to understand as it does not obviously fit in In short it is not self explanatory as to why someone would catch it instead of just RuntimeException I have tried to understand this conversation and reviewed this issue with several people in person to try and determine what use case is only accomplished by adding this new type and can not come up with a strong reason for adding it Closing this out',RxJava,true,false,false
11933539,'Add Fragment Host to submodules for OSGi','Based on discussion on issue https github com Netflix RxJava issues 154','RxJava pull requests #26 https netflixoss ci cloudbees com job RxJava pull requests 26 ABORTED',RxJava,true,false,false
11946182,'Confusing Javadoc for toObservable Future methods','https github com Netflix RxJava issues 148','RxJava pull requests #27 https netflixoss ci cloudbees com job RxJava pull requests 27 SUCCESS This pull request looks good',RxJava,true,false,false
11949175,'Subscriptions cleanup','Some things I missed in previous commit and am cleaning up related to https github com Netflix RxJava issues 173','',RxJava,true,false,false
11960691,'Handful of Improvements','Some improvements made while reviewing code add error handling to VideoExample groovy so it s a better representation of how onError is used handle errors from Func1 failures when subscribe happens handle null Subscriptions on trusted functions not just untrusted','RxJava pull requests #28 https netflixoss ci cloudbees com job RxJava pull requests 28 SUCCESS This pull request looks good',RxJava,true,false,false
11992529,'update dematerialize so can chain correctly','Just noticed this when I actually had to chain it java Observable File saveResult current java Observable Notification File a saveResult materialize dematerialize expected java Observable File a saveResult materialize dematerialize here is what is happening java Observable File x saveResult Observable Notification File y x materialize Observable Notification File currentResult y dematerialize Observable File expectedResult Observable dematerialize y workaround is to use static method to get the expected result With this change you can chain correctly Added unit test java Observable Integer obs Observable just 1 Observable Integer chained obs materialize dematerialize This will be a breaking change But I think this is the expected way','RxJava pull requests #29 https netflixoss ci cloudbees com job RxJava pull requests 29 SUCCESS This pull request looks good So it s just the generics that are wrong Yeah this works without this fix java Observable chained obs materialize dematerialize but the compiler doesn t like this because the generics are wrong java Observable Integer chained obs materialize dematerialize Released in 0 6 1 https github com Netflix RxJava blob master CHANGES md#version 061 maven central awesome thanks now need to wait for the maven repo update I did notice the Gradle Release Plugin pre tag commit rxjava 0 6 1 https github com Netflix RxJava commit 671db351559f8dd0cfe61113abfe4196fd09a69e is the jar in maven and ci the same The jar is built by internal Netflix build servers and then uploaded to Maven Central The public CI CloudBees also builds the jar but that one never goes anywhere',RxJava,true,false,false
11997968,'Where alias to filter','PR for #101','RxJava pull requests #30 https netflixoss ci cloudbees com job RxJava pull requests 30 SUCCESS This pull request looks good Thanks',RxJava,true,false,false
12002095,'dependency on com google code findbugs','Do you need a dependency on com google code findbugs outside of testing http mvnrepository com artifact com netflix rxjava rxjava core 0 5 3','It is used for these annotations http jsr 305 googlecode com svn trunk javadoc javax annotation concurrent package summary html import javax annotation concurrent GuardedBy import javax annotation concurrent ThreadSafe Not sure if we can change it from compile to provided we may be able to as these annotations should have nothing to do with normal runtime Would need to try a deployment without that jar in the runtime classpath @MasseGuillaume What exactly is the problem that this is causing Also nothing about rxjava scala should affect what version of Scala you are using as it specifically states the Scala dependency as provided rather than a compile dependency for the very reason of not forcing a particular version It could lead to transitive dependencies I was analyzing scala notebook dependencies and I saw that your Rx Project depend on findbug It s weird that a functional reactive library depends on a static analysis library so I tough it was just a mistake and you forgot to set a test dependency Understood on the transitive dependency concern the bane of existence for our production app This particular dependency has seemed safe as it doesn t pull in anything else but I m open to removing it not using the annotations finding a replacement that s better or figuring out if it can be marked as provided and not included for runtime since it s not critical for anything I have tried to keep transitive dependencies at an absolute minimum and have it at this currently for rxjava core jsr305 2 0 0 jar slf4j api 1 7 0 jar As stated above jsr305 2 0 0 jar could be eliminated if it s an issue The rxjava scala module shouldn t add anything further to this beyond the obvious rxjava core jar and rxjava scala jar artifacts The next release will remove this dependency as part of pull request https github com Netflix RxJava pull 211',RxJava,false,false,false
12019178,'Are there plans to set up a mailing list','It would be great to be able to get in touch with other developers using Rx Java and how they deal with typical problems For instance we re not sure if we re using the right granularity of Observables and we have a few other questions where we d be curious to know how others solved them','Yes that s a good idea just didn t get around to it Will do so shortly and post back here I added a link on the Readme and created a GoogleGroup https github com Netflix RxJava#communication',RxJava,false,false,false
12042410,'Add pointer regarding unit tests as inner classes','@benjchristensen If I hadn t stumbled over your respective pointer https github com Netflix RxJava issues 154#issuecomment 14544894 by chance I would have asked the same question as Matt Bishop when encountering this README Your reasoning for embedding unit tests as inner classes is inspiring thanks much and a helpful explanation for those who disagree regardless so I suggest to promote it accordingly','RxJava pull requests #31 https netflixoss ci cloudbees com job RxJava pull requests 31 SUCCESS This pull request looks good Turns out that indentation with long lines doesn t look nice in text files esp when rendered by GitHub so I ve converted this README to Markdown just like most all other text files in this project hope it hasn t been like so intentionally RxJava pull requests #32 https netflixoss ci cloudbees com job RxJava pull requests 32 SUCCESS This pull request looks good Hi @sopel thanks for submitting this you re right that it s better to make it clear why this choice was made Ben',RxJava,true,false,false
12060343,'Unwrap AtomicObservableSubscription','As far as I can tell any custom subscription that is passed to subscribe gets wrap ped in an AtomicObservableSubscription unless trusted is true a flag which can t be controlled from outside Since AOS doesn t have an unwrap method how can I pass custom subscriptions in a type safe manner Rationale is being able to maintain extra state about a subscription in the subscription','An Observable by design doesn t expose state so that it can be composed wrapped exactly as this is doing For example Observable synchronize could be used to wrap an Observable before vending it out for use if the Observable was thought to not be thread safe This is part of the principles of being functional and monadic All state within the Func1 implementation that gets converted into an Observable should be self contained So what is your use case that is causing you to want to reach back into the Observable implementation itself and how are you trying to do that Not sure if it makes a difference but small correction we don t want to track state in the Observable we want to track state in the subscription which is what the client holds on to The reason we want to do this is that on Android we need to deal with component life cycles and need to attach detach observers to prevent resource leaks or terminate observable sequence midway through I see there is a BooleanSubscription which helps terminating loops by checking the subscription for isUnsubscribed which is similar to what we want to do How would you even use this Anything I get in return from subscribe is wrapped away in an AtomicObservableSubscription The state is always hidden behind the Observable or Subscription interfaces not leaked out Thus your Func1 implementation that becomes and Observable would return an implementation of Subscription that works with your function correctly to signal an unsubscribe This is important because the sequences of Observables can be composed n levels and an unsubscribe will be propagated up the sequence and each Observable then does with it what its implementation dictates but nothing external ever knows the implementation or tries to reach inside it Here s an example of how BooleanSubscription is used https github com Netflix RxJava blob master language adaptors rxjava groovy src examples groovy rx lang groovy examples VideoExample groovy#L110 groovy Observable VideoList getListOfLists userId return Observable create observer BooleanSubscription subscription new BooleanSubscription try this will happen on a separate thread as it requires a network call executor execute simulate network latency Thread sleep 180 for i in 0 15 if subscription isUnsubscribed break try println emitting list i observer onNext new VideoList i catch Exception e observer onError e observer onCompleted catch Exception e observer onError e return subscription As for multiple observers subscribing unsubscribing that is definitely what Multicast Publish is all about https github com Netflix RxJava issues 15 and https github com Netflix RxJava issues 65 as discussed on Twitter https twitter com mttkay status 310819293166178304 It s near the top of the todo list but if you need this functionality sooner than I or someone else is getting to it perhaps you can try tackling them as they are the right way to handle these issues of state Thanks for clarifying Have to admit that I m still getting into the whole mindset of functional programming in Java the lack of supportive language constructs doesn t help and it s hard to do it in a clean way when introducing something like Rx into a grown code base But we re getting there No rush on the implementation of Multicast but sure I ll give it a shot when you guys are too busy Yes it took myself and my teammates a month or two to adapt our thinking to it and several times we tried breaking the model before we starting thinking functionally Also the lack of lambdas closures in Java until Java8 which I eagerly await is why we predominantly use RxJava in other languages that support them',RxJava,false,false,false
12108314,'New operation Finally issue #43','Hi I was looking around for some fun stuff to do for the Netflix Cloud Prize and I figured I might start by contributing some enhancements to RxJava I did my best to match your existing style and practices but I ve doubtless made some mistakes If you have time to take a quick look and give me some feedback I ll accept it gratefully Cheers abliss','This implements issue #43 but apparently github doesn t autolinkify issue numbers in pull request titles like it does in comments RxJava pull requests #33 https netflixoss ci cloudbees com job RxJava pull requests 33 SUCCESS This pull request looks good @abliss seems like you forgot to add finally0 in https github com Netflix RxJava blob master rxjava core src main java rx Observable java RxJava pull requests #34 https netflixoss ci cloudbees com job RxJava pull requests 34 FAILURE Looks like there s a problem with this pull request @prabirshrestha thanks for the comments I added a static method to Observable As for the try catch it was not at all clear to me from the MSDN documentation whether Finally would allow the error to propagate or not I figured it ought to propagate since this matches the semantics of java s finally construct Or do you mean that Finally should be using try catch to intercept exceptions in the RxJava framework This doesn t seem right to me I would expect we d rather trust the source Observable to correctly implement all the necessary try catch blocks and use onError to propagate exceptions right RxJava pull requests #35 https netflixoss ci cloudbees com job RxJava pull requests 35 SUCCESS This pull request looks good @abliss seems like you forgot to add the non static method to Observable too Even I m not sure about the try catch on finally Will have to check Hence I had put the at the end Thanks again @prabirshrestha I have added it RxJava pull requests #36 https netflixoss ci cloudbees com job RxJava pull requests 36 SUCCESS This pull request looks good @abliss Here is the net code I checked with c# new 1 2 ToObservable Finally Console WriteLine finally block throw new Exception finally Subscribe Console WriteLine ex Console WriteLine ex Message Console WriteLine completed Output 1 2 completed finally block unhanded exception occurs in finally block This mean we don t need try catch on finally but completed should be called before finally Thanks @prabirshrestha and @mairbek for your comments I have fixed the issues RxJava pull requests #37 https netflixoss ci cloudbees com job RxJava pull requests 37 SUCCESS This pull request looks good Welcome to the project @abliss and thank you @prabirshrestha and @mairbek for the reviews on this Thanks @benjchristensen If you have any suggestions for how to make this pull request more attractive or which issues to work on next I m all ears Otherwise I will probably send a pull request for issue #14 next I ve had other things taking my time this week so haven t had a chance to review and merge this yet I will get to it though Issue #14 will be good as a next item No worries at all I know it s not exactly a high priority issue Actually I realized that #14 requires a Scheduler which seems to be still under discussion Instead I m working on an enhancement to Concat issue #202 and will follow that with Switch issue #13 RxJava pull requests #58 https netflixoss ci cloudbees com job RxJava pull requests 58 SUCCESS This pull request looks good Thanks for the comments I have fixed them all',RxJava,true,false,false
12114944,'TakeWhile observables do not properly complete','See failing test case for an example This slipped through the tests because Observable toObservable uses Subscription EMPTY which means the onCompleted call after all three items are produced calls the onComplete on the takeWhile observable which already requested to be unsubscribed The undesired behaviour is shown with Observables that use subscriptions such as Subject or inifinite Observables which is how I ran into this bug Similar bugs might exist elsewhere for other operations because most tests use Observable toObservable rather than an Observable that uses subscriptions The fix follows Rx Net','RxJava pull requests #38 https netflixoss ci cloudbees com job RxJava pull requests 38 SUCCESS This pull request looks good Thank you for submitting a unit test along with the report RxJava pull requests #47 https netflixoss ci cloudbees com job RxJava pull requests 47 SUCCESS This pull request looks good This is an interesting bug in how it relates to a subject unsubscribe event Your fix looks good While confirming my understanding of the operator I looked at Rx Net and your change matches what they do https rx codeplex com SourceControl changeset view aa25748a430e#Rx NET Source System Reactive Linq Reactive Linq Observable TakeWhile cs Merging fix',RxJava,true,false,false
12192335,'Throw if no onError handler specified','If an onError handler is not provided we should throw an exception if an error occurs even though it will likely show up on some other thread','To back this up the relevant section from the Rx Design Guildelines http blogs msdn com b rxteam archive 2010 10 28 rx design guidelines aspx says E g when calling the Subscribe method that only has an onNext argument the OnError behavior will be to rethrow the exception on the thread that the message comes out from the observable sequence The OnCompleted behavior in this case is to do nothing v1 0 section 5 2 p11 Is this closed with the above PR I noticed this went into 0 9 1 1',RxJava,false,false,false
12194147,'SubscribeOn ObserveOn Implementation','Implementation SubscribeOn #11 and ObserveOn #12 alongside with basic Schedulers implementation #19','RxJava pull requests #39 https netflixoss ci cloudbees com job RxJava pull requests 39 FAILURE Looks like there s a problem with this pull request NET implementation of a Scheduler interface contains methods like C# Schedule TState TState Func IScheduler TState IDisposable To be honest I don t quite understand why it is designed to use Func IScheduler TState IDisposable function as an action I used Func0 Subscription in the implementation and it seems to fit well RxJava pull requests #40 https netflixoss ci cloudbees com job RxJava pull requests 40 FAILURE Looks like there s a problem with this pull request This is great stuff @mairbek thank you This one is going to result in a lot of discussion so won t be pulled in right away and will likely involve some changes For example a discussion is being kicked off with Erik Meijer inventor of Rx at Microsoft to clarify some design decisions on this @sgudiboina if you can join in on the review of this it would be helpful @mairbek Erik himself has stated on Twitter that RxJava needs Schedulers so this is definitely high priority Anyone else with time to get involved please do The design of Schedulers will have long lasting impact so we want to get it as close to right as possible now Anyone getting involved please review https github com Netflix RxJava issues 19 for context @mairbek This is great work thank you for the research and thought you obviously did for this and the clean and well written code I ve posted my questions and comments via the inline code mechanism so they are contextual RxJava pull requests #71 https netflixoss ci cloudbees com job RxJava pull requests 71 FAILURE Looks like there s a problem with this pull request RxJava pull requests #74 https netflixoss ci cloudbees com job RxJava pull requests 74 FAILURE Looks like there s a problem with this pull request This request can no longer be automatically merged so I have manually merged it and done some further work on top of your commits at https github com Netflix RxJava pull 225 Please review what I ve done If possible I d like to merge and release within the next 24 hours I m closing this request since all of your commits are now contained on https github com Netflix RxJava pull 225 Great work @mairbek I appreciate you taking this on',RxJava,true,false,false
12205357,'RxJava does not follow Rx design guidelines for serialized onNext calls','Observable merge is not well behaved as defined in Reactive Extensions Design Guidelines section 6 7 http go microsoft com fwlink LinkID 205219 This may hold for other operators that combine multiple Observables as well Call to onNext by observables should be synchronized the following example shows the desired behavior in Rx Net Example can be run with linqpad as C# statements CSharp Console WriteLine Starting example var o1 Observable Interval TimeSpan FromSeconds 1 Select i stream ONE i var o2 Observable Interval TimeSpan FromSeconds 2 Select i stream TWO i Observable Merge o1 o2 Subscribe x if x stream ONE0 Console WriteLine slow onNext processing start Thread Sleep TimeSpan FromSeconds 3 Console WriteLine slow onNext processing done Console WriteLine OnNext x e Console WriteLine Error e Console WriteLine Completed Output with a long wait between processing start and done No OnNextStream is interleaved Starting example slow onNext processing start slow onNext processing done OnNextstream ONE0 OnNextstream TWO0 OnNextstream ONE1 OnNextstream ONE2 OnNextstream ONE3 OnNextstream TWO1 OnNextstream ONE4 OnNextstream ONE5 OnNextstream TWO2 Etc Same example using RxJava clojure defn interval secs same as Observable Interval TimeSpan FromSeconds 1 let s Subject create index AtomicLong 0 t Thread fn while true Thread sleep secs 1000 onNext s getAndIncrement index start t s defn main args println Starting example let o1 interval 1 map fn i str stream ONE i o2 interval 2 map fn i str stream TWO i Observable merge o1 o2 subscribe fn x when x stream ONE0 println slow onNext processing start Thread sleep 3 1000 println slow onNext processing done println onNext x fn e println onError e fn println onCompleted onNext stream TWO0 shows that the onNext calls by a merge Observable are not synchronized Starting example slow onNext processing start onNext stream TWO0 slow onNext processing done onNext stream ONE0 onNext stream TWO1 onNext stream ONE1 onNext stream ONE2 onNext stream TWO2 onNext stream ONE3 onNext stream ONE4 The code for this example can be found in https github com thegeez rxjava merge behave','clojure defn main args println Starting example let o1 interval 1 map fn i str stream ONE i o2 interval 2 map fn i str stream TWO i Observable merge o1 o2 Observable synchronize subscribe fn x when x stream ONE0 println slow onNext processing start Thread sleep 3 1000 println slow onNext processing done println onNext x fn e println onError e fn println onCompleted By explicitly adding the Observable synchronize the example does produce the same output as the Rx net code Based on your code it seems that the Merge operation has a bug that it does not ensure synchronization when multiple sequences are subscribed to Good catch btw nice Clojure At a higher level since the title of the issue suggests the entire library doesn t comply here is some further information The same guidelines you refer to http go microsoft com fwlink LinkID 205219 for creating an Observable are linked to from the Javadocs http netflix github com RxJava javadoc rx Observable html#create rx util functions Func1 Section 6 7 is specifying how an Observable implementation must serialize the calls to onNext not that they will be automatically serialized as that is very bad for performance see section 6 8 Though all operators implemented in RxJava can actually support interleaved onNext calls we ve built it from the beginning to be thread safe in that regard even though the contract officially does not need that since Observables are assumed to not interleave calls An Observable implementation is responsible for serializing it s onNext calls and complying with the contract If it expects to have interleaving onNext calls and doesn t want to deal with this appropriately then the Synchronize http netflix github com RxJava javadoc rx Observable html#synchronize rx Observable operation can be used to synchronize it as you did in your Clojure example This contract allows guideline 6 8 to be applied where synchronization does not need to be done by all of the operators as it assumes the Observable complies with the guidelines For these reasons automatic synchronization is not added when an Observable is created Only certain operators like merge that subscribe concurrently to multiple sequences need to concern themselves with this issue In the case of the Merge operator it s a simple oversight not caught in a year of production usage primarily by the fact that Netflix uses this in purely functional no side effects and order doesn t matter environments where we don t care if onNext calls are interleaved and easily remedied I ll submit a fix shortly Other than the merge operator missing synchronization are there other places doing the wrong thing Thank you for reporting this issue and helping make RxJava better @thegeez Can you please review the pull request I just submitted with a unit test and fix for the Merge operator I understand why the synchronization should be but was missed in OperationMerge and not be standard for every created Observable My review of the fix pull request is at https github com Netflix RxJava pull 201 Fix has been merged',RxJava,false,false,false
12207244,'Synchronize Observer on OperationMerge','fix for Merge serialization bug reported in https github com Netflix RxJava issues 200 This is necessary because by definition Merge is subscribing to multiple sequences in parallel and is supposed to serialize them into a single Observable','RxJava pull requests #41 https netflixoss ci cloudbees com job RxJava pull requests 41 SUCCESS This pull request looks good The fix looks good However the test case does not catch the original problem First the test case tests an Observable create merge o1 o2 https github com Netflix RxJava pull 201 files#L0R409 The create wraps an AtomicObservableSubscription which defeats the purpose of checking whether OperationMerge is chronologically well behaved itself This should be new Observable merge o1 o2 false where false isTrusted or Observable merge o1 o2 This occurs in most of the test cases for OperationMerge By changing the test case to properly test OperationMerge the test still didn t fail on the original wrong implementation I don t have a test case that shows the original problem without resorting to threads with fixed sleep delays to orchestrate an interleaving The test case in this commit forces concurrent onNext invocations and demonstrates how the changed code no longer allows concurrent onNext calls When you say interleaving perhaps you re not referring to concurrent execution but instead how merge does not sequentially concatenate sequences If that s what you mean then merge is the wrong operator and you need the concat operator Here s the Rx Net doc for concat http msdn microsoft com en us library hh212146 v vs 103 aspx This operator is available in RxJava Note that concat is described as An observable sequence that contains the elements of the first sequence followed by those of the second the sequence whereas merge is The observable sequence that merges the elements of the observable sequences The merge operator subscribes to all sequences concurrently and emits them into a single serialized sequence The concat operator subscribes to each sequence once at a time and thus merges them sequentially As for the comments about AtomicObservableSubscription that is not the thing that is synchronizing it is the SynchronizedObserver that wraps the Observer to synchronize onNext calls to ensure they are serialized i e no concurrent execution of onNext The isTrusted piece has nothing to do with concurrent execution the AtomicObservableSubscription is just ensuring that onNext onCompleted onError obeys the contract it does not synchronize anything and thus has nothing to do with concurrent executing interleaving etc Am I missing something that causes you to say which defeats the purpose of checking whether OperationMerge is chronologically well behaved itself Thus with merge you can have these sequences A1 A2 A3 B1 B2 B3 If the two are asynchronously and concurrently executing then they will both begin emitting immediately but onNext will not concurrently execute which was the bug this fixes You can then end up with this A1 B1 B2 A2 B3 A3 But no longer end up with this with concurrent onNext calls like this which were possible before this commit A1 B1 B3 A3 B2 A2 If you re trying to get output like this A1 A2 A3 B1 B2 B3 then you want the concat operator instead of merge You are right I am confusing AtomicObservableSubscription with SynchronizedObserver which indeed refer to two completely different things Sorry for that I do not mean the concat operation With interleaving I meant the interleaving of the calls to onNext and countDown in the test case When I revert the change on line https github com Netflix RxJava pull 201 files#L0L121 and run the test case the test case doesn t fail mfex@mfex Programming rx ben git log head n4 commit effc08d548518df5a54c916e1b50daadb8bf4228 Author Ben Christensen benjchristensen@netflix com Date Tue Mar 19 16 23 50 2013 0700 mfex@mfex Programming rx ben gradlew rxjava core clean rxjava core clean BUILD SUCCESSFUL Total time 8 355 secs mfex@mfex Programming rx ben gradlew rxjava core test rxjava core compileJava Note Some input files use unchecked or unsafe operations Note Recompile with Xlint unchecked for details rxjava core processResources UP TO DATE rxjava core classes rxjava core compileTestJava Note Some input files use unchecked or unsafe operations Note Recompile with Xlint unchecked for details rxjava core processTestResources UP TO DATE rxjava core testClasses rxjava core test BUILD SUCCESSFUL Total time 19 126 secs edit out the bug fix mfex@mfex Programming rx ben git diff diff git a rxjava core src main java rx operators OperationMerge java b rxjava index 1e6e6e7 6ad7a51 100644 a rxjava core src main java rx operators OperationMerge java b rxjava core src main java rx operators OperationMerge java @@ 132 7 132 8 @@ public final class OperationMerge Subscribe to the parent Observable to get to the children Observ sequences subscribe new ParentObserver synchronizedObserver sequences subscribe new ParentObserver synchronizedOb sequences subscribe new ParentObserver actualObserver return our subscription to allow unsubscribing return ourSubscription mfex@mfex Programming rx ben gradlew rxjava core clean rxjava core clean BUILD SUCCESSFUL Total time 8 131 secs mfex@mfex Programming rx ben gradlew rxjava core test rxjava core compileJava Note Some input files use unchecked or unsafe operations Note Recompile with Xlint unchecked for details rxjava core processResources UP TO DATE rxjava core classes rxjava core compileTestJava Note Some input files use unchecked or unsafe operations Note Recompile with Xlint unchecked for details rxjava core processTestResources UP TO DATE rxjava core testClasses rxjava core test BUILD SUCCESSFUL Total time 19 567 secs mfex@mfex Programming rx ben That s rather odd as I see the unit test doing what I expect With this code java sequences subscribe new ParentObserver actualObserver I get the failure rx operators OperationMerge UnitTest testSynchronizationOfMultipleSequences FAILED java lang AssertionError at OperationMerge java 445 146 tests completed 1 failed rxjava core test FAILED With this code java sequences subscribe new ParentObserver synchronizedObserver the unit test passes BUILD SUCCESSFUL Total time 49 234 secs The testSynchronizationOfMultipleSequences unit test is running 2 async Observables that each spawn a thread I use a CountDownLatch in the TestASynchronousObservable instances to allow the unit test to wait for each to hit the point where they are calling onNext I then use the endLatch inside the onNext to cause the async observables to block inside the onNext call and increment the concurrentCounter AtomicInteger If onNext is not synchronized then both threads will block on endLatch and concurrentCounter will be 2 If onNext is synchronized then only one of the threads can enter so concurrentCounter will be 1 Once I perform the assertion the endLatch is released to allow the callback threads to complete execution of onNext Does this unit test correctly test the bug you originally were reporting about concurrent execution of onNext or is there something else that I am missing I just committed a few tweaks to improve the code On line 136 it is now java sequences subscribe new ParentObserver synchronizedObserver If I change this to the following the unit test breaks for me java sequences subscribe new ParentObserver actualObserver RxJava pull requests #43 https netflixoss ci cloudbees com job RxJava pull requests 43 SUCCESS This pull request looks good Just to re iterate I think the fix is good This is now about the test case included in the fix With this code sequences subscribe new ParentObserver actualObserver I get the failure rx operators OperationMerge UnitTest testSynchronizationOfMultipleSequences FAILED java lang AssertionError at OperationMerge java 445 146 tests completed 1 failed rxjava core test FAILED I don t always see FAILED sometimes the test does succeed git clone https github com benjchristensen RxJava rx 200 false positive cd rx 200 false positive git checkout issue 200 merge synchronization git log head n7 echo Remove fix from code sed i s SynchronizedObserver T synchronizedObserver test remove g rxjava core src main java rx operators OperationMerge java sed i s sequences subscribe new ParentObserver synchronizedObserver sequences subscribe new ParentObserver actualObserver g rxjava core src main java rx operators OperationMerge java git diff exit code echo Running tests for i in 1 100 do gradlew cleanTest rxjava core test Dtest single OperationMerge done test_run_results txt echo Saw success out of 100 echo grep c BUILD SUCCESSFUL test_run_results txt echo Saw fail out of 100 echo grep c BUILD FAILED test_run_results txt Output Initialized empty Git repository in home mfex Programming rx 200 false positive rx 200 false positive git Switched to a new branch issue 200 merge synchronization commit fb555df3376301595f6596861662c654d77209d2 Author Ben Christensen benjchristensen@netflix com Date Wed Mar 20 15 12 44 2013 0700 Synchronization of Merge operator fixes return AtomicSubscription not MergeSubscription which I was accidentally still returning diff git a rxjava core src main java rx operators OperationMerge java b rxjava core src main java rx operators OperationMerge java index eeb1e96 ded2383 100644 a rxjava core src main java rx operators OperationMerge java b rxjava core src main java rx operators OperationMerge java @@ 128 12 128 12 @@ public final class OperationMerge Bug report https github com Netflix RxJava issues 200 AtomicObservableSubscription subscription new AtomicObservableSubscription ourSubscription SynchronizedObserver T synchronizedObserver new SynchronizedObserver T actualObserver subscription test remove new SynchronizedObserver T actualObserver subscription Subscribe to the parent Observable to get to the children Observables sequences subscribe new ParentObserver synchronizedObserver sequences subscribe new ParentObserver actualObserver return our subscription to allow unsubscribing return subscription Running tests Saw success out of 100 98 Saw fail out of 100 2 The test succeeding while it shouldn t doesn t happen always Therefore I think that the test doesn t account for this possible interleaving of the different threads executing TestRunner o1 TestASynchronousObservable o2 TestASynchronousObservable m subscribe onNextBeingSent countDown observer onNext hello o1 onNextBeingSent await onNextBeingSent countDown o2 onNextBeingSent await assertEquals 1 concurrentCounter get observer onNext hello endLatch countDown observer onCompleted observer onCompleted Saw success out of 100 98 Saw fail out of 100 2 This was on an Ubuntu machine On a mac book I needed more samples for this result Saw success out of 1000 3 Saw fail out of 1000 997 Something to consider when trying to reproduce the results I don t have detailed specs of the test machines available at the moment Hmm not sure yet what s wrong the test case but obviously it is not deterministic Thank you for the detailed testing I ll explore what I can do If you can offer a better unit test that is deterministic not reliant on Thread sleep for this I ll gladly accept it I m holding off committing until I understand the non determinism and can fix it unless you would prefer I just commit the fix and worry about the unit test later The merge operation is also used to implement mapMany https github com Netflix RxJava blob master rxjava core src main java rx operators OperationMap java#L71 which is even more important to get right I haven t looked into the impact of the proposed fix of merge on mapMany That should work as expected since mapMany is just a composition of merge and map It is definitely via mapMany that merge gets used most often in my experience RxJava pull requests #70 https netflixoss ci cloudbees com job RxJava pull requests 70 SUCCESS This pull request looks good I see in the code how the non deterministic behavior could occur I m not quite sure of a way to solve it other than using Thread sleep to hopefully give each thread time to complete the onNext call I can t use another CountDownLatch for after the call as we want it in the middle of onNext I can t use it inside onNext as the whole point of this test is that one of them should be blocked on the synchronized onNext call thus I have no idea how to know if a thread has actually invoked but is blocked on a method other than a thread dump I can t replicate the non deterministic behavior on my machine so @thegeez could you see if the fix I just committed helps on your machine I m going to proceed with the merge instead of waiting as I want to get this fix in since it s passing unit tests and manual review by both you and me and if it s still non deterministic on your machine or elsewhere we can continue to figure out a better way to do this test The fix in https github com benjchristensen RxJava commit 169e7e06ea223bd3fdca2460b74e9cd361439fff indeed removes the false positives I saw previously for the test case Great thank you for confirming',RxJava,true,false,false
12231006,'behavior of concat Observable Observable T','I have a question about the behavior of concat when given an observable of observables Currently it seems to materialize its input into a list then concat the list This runs counter to my expectation which would be that new observables could be produced while the concat is underway In other words a elements from the first Observable T should be rendered by concat even if the Observable Observable T is blocked and b the concat ed observable should not start pulling elements from the next Observable T or call onCompleted until the current Observable T calls onCompleted I have written a failing unit test which illustrates the behavior I was expecting https gist github com abliss 5205333 My question then is 1 does this match the behavior of net 2 if so is this a design decision you re comfortable emulating and 3 if so does this match everyone else s intuition given the current documentation which is silent on this issue If the answer to any of the above is no I m happy to provide a patch','The Observable of Observable in Concat was something I put in last minute for completeness It was NOT the desired implementation I meant to update that code but never got around to it If you have patch please send it I probably will take a look at this weekend again Thanks for bringing this up On Wed Mar 20 2013 at 8 01 AM abliss notifications@github com wrote I have a question about the behavior of concat when given an observable of observables Currently it seems to materialize its input into a list then concat the list This runs counter to my expectation which would be that new observables could be produced while the concat is underway In other words a elements from the first Observable should be rendered by concat even if the Observable Observable T is blocked and b the concat ed observable should not start pulling elements from the next Observable or call onCompleted until the current Observable T calls onCompleted I have written a failing unit test which illustrates the behavior I was expecting https gist github com abliss 5205333 My question then is 1 does this match the behavior of net 2 if so is this a design decision you re comfortable emulating and 3 if so does this match everyone else s intuition given the current documentation which is silent on this issue If the answer to any of the above is no I m happy to provide a patch Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 202',RxJava,false,false,false
12274614,'All Operation Implemented','Closes issue #21','RxJava pull requests #44 https netflixoss ci cloudbees com job RxJava pull requests 44 SUCCESS This pull request looks good Looks good',RxJava,true,false,false
12282783,'Explore code generation for language adaptors','RxJava was written from the beginning to target the JVM not any specific language As a side effect of Java not having lambdas clojures yet and other considerations Netflix used dynamic languages with it predominantly for the year of its existence prior to open sourcing To bridge the rxjava core written in Java with the various languages a FunctionalLanguageAdaptor is registered at runtime for each language of interest To enable this language adaptors method overloads with Object exist in the API since Object is the only super type that works across all languages for their various implementations of lambdas and closures This downside of this is that it breaks static typing for Java Scala and other static typed languages More can be read on this issue and discussion of the subject here https groups google com forum # topic rxjava bVZoKSsb1 o I would like to pursue the following remove all Object overload methods from rxjava core so it remains statically typed modify FunctionalLanguageAdaptors to not register with a lookup map but instead to trigger a code generation process at registration time the code generation would create the overload methods on rx Observable for the types needed by that languages such as groovy lang Closure or clojure lang IFn The benefits of this are 1 Everything is statically typed so compile time checks for Java Scala etc work correctly 2 Method dispatch is now done via native Java bytecode using types rather than going via Object which then has to do a lookup in a map Memoization helped with the performance but each method invocation still required looking in a map for the correct adaptor With this approach the appropriate methods will be compiled into the rx Observable class to correctly invoke the right adaptor without lookups The byte code generation step would happen once the first time a LanguageAdaptor is registered which is normally only at the first point of access to RxJava','Some background on why the current design was chosen rather than having each language with a separate version of Observable The approach of having language specific packages classes was pursued but did not work well because Rx is a composable library It means that every time an Observable is used it needs to be re wrapped or un wrapped by whichever language is using it For example From Java a library is exposed that has a method like this java rx Observable getData From Groovy a library is exposed with a method like java rx groovy GroovyObservable getOtherData Then from Scala you need to wrap them again java rx scala ScalaObservable from getOtherData This means we have an rx Observable wrapped as rx groovy GroovyObservable wrapped as rx scala ScalaObservable To compose the two we would have java rx scala ScalaObservable zip rx scala ScalaObservable from getOtherData rx scala ScalaObservable from getData scala closure here Now what does ScalaObservable return from its operators ScalaObservable or Observable Should the above zip operator return rx scala ScalaObservable or rx Observable What happens if this library is consumed from another language If Observable each step along the way it must be wrapped yet again If ScalaObservable it has now changed all of the return types of rx Observable to a subtype In short for interop between languages it very quickly becomes a mess and our primary polyglot goal was that rx Observable was usable across all libraries as the single type and because the whole point of Rx is chained composition it s not as simple as just a single decoration at the beginning It affects every single method in an API and step of the chaining For this reason we chose the current language adaptor model where it is made to understand the closure lambda types of each of the languages so rx Observable can remain the sole interface across languages The reason we did not use an interface such as FuntionalLanguageAdaptor instead of Object is that not all languages automatically reify to functional interfaces Java8 does but it s already type safe and works fine with the Func Action interfaces Clojure Groovy JRuby and Scala all require awkward non idiomatic java interop or interface implementation syntax instead of their native lambda closure syntax thus Object is unfortunately the first super type they all have in common especially to handle the different arities Func1 Func2 Func3 etc that can be passed in Playing with this the 3 approaches I can see are 1 Java agent can be loaded dynamically without manually injecting javaagent at command line to use the Java Attach API to intercept rx Observable being loaded and do bytecode generation 2 Custom classloader to intercept rx Observable being loaded and do bytecode generation 3 Compile time step to perform bytecode generation after compiling rx Observable and replace Observable class with the new typed methods for each language before packaging as a Jar Options 1 and 2 are nice in that they only add the methods needed by the desired languages at runtime but they are bad in that they both need an initialization hook something that is a lot to ask for a plain library not a full framework controlling entire lifecycle so I don t think they are appropriate here Option 3 would include at compile time all of the methods needed for each language This means that all runtimes would have that bytecode but if they don t have a particular language runtime loaded those methods could never be invoked The benefit is that all languages would use static types for method dispatch The downside is that all the overloads would always exist even if someone is using just one of the languages A possible solution would be to generate different versions of the binary for each language which would work fine if an environment is using only one language but if more than one is being used it would be very confusing because someone couldn t just load the two separate binaries they d collide in the same namespace A single binary with support for each language would need to be used I think the drawbacks of having all overloads for all languages in a single binary are small enough that it s worth pursuing to see how it works The only awkward drawback I know of that can t easily be overcome is that while working on the RxJava source itself in an IDE and running Groovy Clojure JRuby etc it would be hitting directly compiled classes not the binaries put through bytecode generation so they would fail It would mean that tests can only be run from the full build process or by supporting option 1 or 2 for the development cycle while in an IDE This impacts a limited number of people though so is not a big enough reason to avoid pursuing the bigger benefits of maintain static typing and avoiding use of instanceof for dynamically determining what language adaptor to use to execute a function This is very exploratory and something I m researching as I go I generally do not like code generation or bytecode manipulation so have not used this approach before so feedback is much appreciated If you re going with option 3 why not directly add these methods in the source instead of adding them after compilation Probably I m missing something here Anyway instead of overloading the method with a single one where closures are mapped to java lang Object you could add a method for each supported JVM language closure type Let s take subscribe as an example Instead of java public Subscription subscribe final Object o for all dynamic languages you could introduce java public Subscription subscribe final groovy lang Closure cls and java public Subscription subscribe final org jruby RubyProc proc and java public Subscription subscribe final clojure lang IFn cls for each dynamic language It wouldn t even be absolutely necessary to support Scala directly as Scala can always hook itself in via implicits Now undoubtedly that s a lot of work but I don t think you can get around that anyway But probably I m overlooking something which makes this impossible The only big drawback I can think of atm is that it s not possible in that way to add another JVM based language without touching the core This doesn t worry me much but maybe that s just me Also there would be another easy way out You probably already thought of that It s not pretty though Keep the methods taking objects but instead of overloading the typesafe methods name those differently For example pair java public Subscription subscribe final Object o with java public Subscription typedSubscribe final Action1 T onNext Though it s certainly not ideal I could live with that We could add all of the overloads directly to the source but we re talking about 48 methods already and eventually probably double that and then multiplying that by the number of languages It makes the javadoc source code and maintenance rather ridiculous and it becomes very error prone that every time a method is added or touched the overload for every language must also be done It would severely impede people getting involved and touching the Observable java class For these reasons I feel it s not a great approach though it is a valid one I also strongly want to avoid different names as that breaks the API across languages and doesn t really solve the real problem as people now need to know the different naming conventions in order to stay type safe The amount of code to generate the methods is actually quite small here s a prototype of me playing with it java public class LanguageAdaptorCodeGenerator static ClassPool pool ClassPool getDefault public static void addSupportFor Class types CtClass cc try cc pool get rx Observable class getName catch NotFoundException e throw new RuntimeException Failed to add language adaptor methods as could not find rx Observable e try for CtMethod method cc getMethods CtClass argTypes method getParameterTypes boolean containsFunctionType false for CtClass argType argTypes if isRxFunctionType argType containsFunctionType true if containsFunctionType try addMethod cc method types catch Exception e e printStackTrace throw new RuntimeException Failed to add language adaptor method method getName e will need to output to filesystem here cc toClass catch Exception e e printStackTrace throw new RuntimeException Failed to add language adaptor methods e private static boolean isRxFunctionType CtClass type throws Exception look for the Function argument if type getName equals Function class getName return true look for arguments implementing Function for CtClass implementedInterface type getInterfaces if implementedInterface getName equals Function class getName return true return false private static void addMethod CtClass ctClass CtMethod method Class types throws Exception for Class cls types ArrayList CtClass parameters new ArrayList CtClass CtClass argTypes method getParameterTypes System out print method method getName args for CtClass argType argTypes System out print argType getName if isRxFunctionType argType needs conversion parameters add pool get cls getName else no conversion copy through parameters add argType System out println CtClass newArgs parameters toArray new CtClass parameters size String params for CtClass a newArgs params a getName System out println Add method method getName params with arg type converted to cls getName CtMethod newMethod new CtMethod method getReturnType method getName newArgs ctClass newMethod setModifiers method getModifiers newMethod setBody System out println hello world return null ctClass addMethod newMethod Here are the methods that get overloads for just Groovy in this output Add method create groovy lang Closure with arg type converted to groovy lang Closure Add method defer groovy lang Closure with arg type converted to groovy lang Closure Add method filter groovy lang Closure with arg type converted to groovy lang Closure Add method filter rx Observable groovy lang Closure with arg type converted to groovy lang Closure Add method forEach groovy lang Closure with arg type converted to groovy lang Closure Add method groupBy groovy lang Closure with arg type converted to groovy lang Closure Add method groupBy groovy lang Closure groovy lang Closure with arg type converted to groovy lang Closure Add method groupBy rx Observable groovy lang Closure with arg type converted to groovy lang Closure Add method groupBy rx Observable groovy lang Closure groovy lang Closure with arg type converted to groovy lang Closure Add method last groovy lang Closure with arg type converted to groovy lang Closure Add method last rx Observable groovy lang Closure with arg type converted to groovy lang Closure Add method lastOrDefault java lang Object groovy lang Closure with arg type converted to groovy lang Closure Add method lastOrDefault rx Observable java lang Object groovy lang Closure with arg type converted to groovy lang Closure Add method map groovy lang Closure with arg type converted to groovy lang Closure Add method map rx Observable groovy lang Closure with arg type converted to groovy lang Closure Add method mapMany groovy lang Closure with arg type converted to groovy lang Closure Add method mapMany rx Observable groovy lang Closure with arg type converted to groovy lang Closure Add method onErrorResumeNext groovy lang Closure with arg type converted to groovy lang Closure Add method onErrorResumeNext rx Observable groovy lang Closure with arg type converted to groovy lang Closure Add method onErrorReturn groovy lang Closure with arg type converted to groovy lang Closure Add method onErrorReturn rx Observable groovy lang Closure with arg type converted to groovy lang Closure Add method reduce groovy lang Closure with arg type converted to groovy lang Closure Add method reduce java lang Object groovy lang Closure with arg type converted to groovy lang Closure Add method reduce rx Observable groovy lang Closure with arg type converted to groovy lang Closure Add method reduce rx Observable java lang Object groovy lang Closure with arg type converted to groovy lang Closure Add method scan groovy lang Closure with arg type converted to groovy lang Closure Add method scan java lang Object groovy lang Closure with arg type converted to groovy lang Closure Add method scan rx Observable groovy lang Closure with arg type converted to groovy lang Closure Add method scan rx Observable java lang Object groovy lang Closure with arg type converted to groovy lang Closure Add method sequenceEqual rx Observable rx Observable groovy lang Closure with arg type converted to groovy lang Closure Add method single groovy lang Closure with arg type converted to groovy lang Closure Add method single rx Observable groovy lang Closure with arg type converted to groovy lang Closure Add method singleOrDefault java lang Object groovy lang Closure with arg type converted to groovy lang Closure Add method singleOrDefault rx Observable java lang Object groovy lang Closure with arg type converted to groovy lang Closure Add method subscribe groovy lang Closure with arg type converted to groovy lang Closure Add method subscribe groovy lang Closure groovy lang Closure with arg type converted to groovy lang Closure Add method subscribe groovy lang Closure groovy lang Closure groovy lang Closure with arg type converted to groovy lang Closure Add method takeWhile groovy lang Closure with arg type converted to groovy lang Closure Add method takeWhile rx Observable groovy lang Closure with arg type converted to groovy lang Closure Add method takeWhileWithIndex groovy lang Closure with arg type converted to groovy lang Closure Add method takeWhileWithIndex rx Observable groovy lang Closure with arg type converted to groovy lang Closure Add method toSortedList groovy lang Closure with arg type converted to groovy lang Closure Add method toSortedList rx Observable groovy lang Closure with arg type converted to groovy lang Closure Add method where groovy lang Closure with arg type converted to groovy lang Closure Add method where rx Observable groovy lang Closure with arg type converted to groovy lang Closure Add method zip rx Observable rx Observable groovy lang Closure with arg type converted to groovy lang Closure Add method zip rx Observable rx Observable rx Observable groovy lang Closure with arg type converted to groovy lang Closure Add method zip rx Observable rx Observable rx Observable rx Observable groovy lang Closure with arg type converted to groovy lang Closure I haven t yet made the method body do the right thing it s printing hello world right now but it s basically taking what is already in the language adaptors and just inlining it The part I haven t figured out yet is hooking into the Gradle build process but it s just busy work I need to spend time on Awesome I expected a lot more work to be necessary to generate those additional methods But this looks quite manageable You re right the code generation approach looks better in this case than manually adding all those methods Another option a colleague suggested is to generate the source code before compilation instead of doing bytecode manipulation after Generating source code isn t as clean as using Javassist like that code above but the benefit would be that source code is then shipped that matches the bytecode so that stacktraces and clicking through to source goes to the right place when debugging That may be a strong enough value to do source code generation rather than bytecode generation I ve got some work in progress up on my fork at https github com mattrjacobs RxJava commit f5f84a8de6e96005a42ee4164c753d2cda3ed460 The commit log describes what s been done and what s left to do before I ll feel comfortable submitting it Would it be possible to use the @Deprecated annotation for the Object versions This would cause java scala to atleast warn when we are accidentally using the Object overload but might not translate out to the dynamic languages We are getting close to eliminating these methods week or two more at most I hope I was planning on providing an update on it tonight or tomorrow to give people a heads up On Tue Jul 2 2013 at 9 55 PM samhendley notifications@github com wrote Would it be possible to use the @Deprecated https github com Deprecated annotation for the Object versions This would cause java scala to atleast warn when we are accidentally using the Object overload but might not translate out to the dynamic languages Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 204#issuecomment 20395690 Ben Christensen API Team 1 310 781 5511 @benjchristensen After implementing and throwing away a few different approaches we have landed on a solution we feel will balance the various competing priorities Our goals are support static typing for Java Scala Kotlin etc by removing the Object overloads support any JVM language static or dynamically typed allow all languages to use the same rx Observable class so that we don t divide libraries with helpers such as GroovyObservable ClojureObservable etc that then need to be converted back and forth when doing interop do not require special classloaders or agents to enable runtime bytecode generation do not remove static operators to enable proxying small jars and limited or no dependencies The solution we have arrived at will work as follows The rxjava core source code will delete all Object overload methods and be pure static java Any language that supports functional interfaces directly such as Java 8 and XTend can use the Java core version directly Languages needing specific lambda clojure type mapping to the Func Action types will have language specific Jars created via build time bytecode generation Any method with a Func Action argument will be overloaded with a version supporting the language requirements For example The default Java version java public static T Observable T filter Observable T that Func1 T Boolean predicate A Groovy version java public static T Observable T filter Observable T that groovy lang Closure predicate A jar per language will be created as follows rxjava x y z jar rxjava groovy x y z jar rxjava clojure x y z jar rxjava scala x y z jar rxjava jruby x y z jar rxjava kotlin x y z jar A project will include just the jar that meets their language needs there will no longer be a core jar plus the language adaptor The drawback of this is that mixing two of these in a classpath will result in non deterministic loading whichever is loaded last wins and that is the version that will be used This means if a library depends on rxjava jar but is using Groovy and needs rxjava groovy jar it is up to the developer of that project to make sure they have only the rxjava groovy jar version This is not ideal but is a one time pain setting up a build and is better than the constant pain of missing static typing or converting to from different Observable implementations for different languages At this time we are optimizing for projects using a single language or Java another language If there are use cases where people are trying to mix multiple languages in a very polyglot manner we have two options include an rxjava dynamic jar version that re adds the Object overloads include build configs for common combinations of languages such as rxjava groovy clojure jar Language adaptations such as clojure which has preferred idioms that necessitate wrapping will still be possible through the language adaptor projects and be included in the appropriate language jars This should not break any code but will require a slight change to the build dependencies in your project when we release this We hope that this enables the RxJava project to better achieve its goal of being polyglot and targeting the JVM in general and not any specific languages without sacrificing interop or idiomatic usage in each of the languages Byte code generation ended up not being used We instead went with the solution in https github com Netflix RxJava pull 323',RxJava,false,true,false
12344478,'Reimplementation of Concat improved handling of Observable Observable T','The old version required all of the Observable T s to be generated and buffered before the concat could begin If the outer Observable was asynchronous items could be dropped test added The new version passes the test and does the best job I could after examining several possible strategies of achieving clear and consistent semantics in accordance with the principle of least surprise My attempt to fix issue #202','RxJava pull requests #45 https netflixoss ci cloudbees com job RxJava pull requests 45 ABORTED There is another issue with this implementation The countdown latch will always block the calling thread which is not desirable Anything that returns an observable should never be blocking Rx is meant to support composition of operations and allows each operation to run concurrently While reviewing this I started playing with the unit tests and added 2 new ones I also made them use inOrder verify so they ensure correct ordering I ve pasted it below so you can merge into your branch instead of me complicating the merge with another branch The tests pass pass except testConcatUnsubscribe which deadlocks It does this because a List Observable won t return the subscription asynchronously so it can t unsubscribe meanwhile a countDownLatch is waiting for the change to trigger and the two latches end up waiting on each other I haven t thought through enough yet to determine if there is a way to solve that or if the unit test is just testing the wrong thing and thus a bad test The comment above from @billy about CountDownLatch originated from a discussion between him and I but while reviewing this it is probably the right approach I was playing with other approaches that are purely non blocking while retaining the correct concat sequential behavior but they all seem to require either another wrapping thread stealing work from one of the child Observable threads and making it do work that is queued on the others and that seems like a bad idea even though it can be hacked to work but it does so in a way that is very unexpected and thus not something I want to pursue queueing all onNext values which could be a bad memory issue and also means we eagerly subscribe which is not what we want My biggest issue right now is that concat o1 o2 is a very common usage but that results in List Observable which will be blocking and unsubscribe doesn t work I ll think through this more but I d appreciate your thoughts on how to handle testConcatUnsubscribe java public static class UnitTest @Test public void testConcat @SuppressWarnings unchecked Observer String observer mock Observer class final String o 1 3 5 7 final String e 2 4 6 final Observable String odds Observable toObservable o final Observable String even Observable toObservable e @SuppressWarnings unchecked Observable String concat Observable create concat odds even concat subscribe observer verify observer times 7 onNext anyString @Test public void testConcatWithList @SuppressWarnings unchecked Observer String observer mock Observer class final String o 1 3 5 7 final String e 2 4 6 final Observable String odds Observable toObservable o final Observable String even Observable toObservable e final List Observable String list new ArrayList Observable String list add odds list add even Observable String concat Observable create concat list concat subscribe observer verify observer times 7 onNext anyString @Test public void testConcatUnsubscribe final CountDownLatch callOnce new CountDownLatch 1 final CountDownLatch okToContinue new CountDownLatch 1 final TestObservable String w1 new TestObservable String one two three final TestObservable String w2 new TestObservable String callOnce okToContinue four five six @SuppressWarnings unchecked Observer String aObserver mock Observer class @SuppressWarnings unchecked Observable String concat Observable create concat w1 w2 System out println before subscribe Subscription s1 concat subscribe aObserver System out println after subscribe try Block main thread to allow observable w1 to complete and observable w2 to call onNext once System out println before callOnce await callOnce await System out println after callOnce await s1 unsubscribe System out println after s1 unsubscribe Unblock the observable to continue okToContinue countDown System out println after countDown w1 t join w2 t join catch Exception e e printStackTrace fail e getMessage InOrder inOrder inOrder aObserver inOrder verify aObserver times 1 onNext one inOrder verify aObserver times 1 onNext two inOrder verify aObserver times 1 onNext three inOrder verify aObserver times 1 onNext four inOrder verify aObserver never onNext five inOrder verify aObserver never onNext six inOrder verify aObserver times 1 onCompleted @Test public void testMergeObservableOfObservables @SuppressWarnings unchecked Observer String observer mock Observer class final String o 1 3 5 7 final String e 2 4 6 final Observable String odds Observable toObservable o final Observable String even Observable toObservable e Observable Observable String observableOfObservables Observable create new Func1 Observer Observable String Subscription @Override public Subscription call Observer Observable String observer simulate what would happen in an observable observer onNext odds observer onNext even observer onCompleted return new Subscription @Override public void unsubscribe unregister will never be called here since we are executing synchronously Observable String concat Observable create concat observableOfObservables concat subscribe observer verify observer times 7 onNext anyString Simple concat of 2 asynchronous observables ensuring it emits in correct order @SuppressWarnings unchecked @Test public void testSimpleAsyncConcat Observer String observer mock Observer class TestObservable String o1 new TestObservable String one two three TestObservable String o2 new TestObservable String four five six Observable concat o1 o2 subscribe observer try wait for async observables to complete o1 t join o2 t join catch Exception e throw new RuntimeException failed waiting on threads InOrder inOrder inOrder observer inOrder verify observer times 1 onNext one inOrder verify observer times 1 onNext two inOrder verify observer times 1 onNext three inOrder verify observer times 1 onNext four inOrder verify observer times 1 onNext five inOrder verify observer times 1 onNext six Test an async Observable that emits more async Observables @SuppressWarnings unchecked @Test public void testNestedAsyncConcat throws Exception Observer String observer mock Observer class final TestObservable String o1 new TestObservable String one two three final TestObservable String o2 new TestObservable String four five six final TestObservable String o3 new TestObservable String seven eight nine final CountDownLatch allowThird new CountDownLatch 1 final AtomicReference Thread parent new AtomicReference Thread Observable Observable String observableOfObservables Observable create new Func1 Observer Observable String Subscription @Override public Subscription call final Observer Observable String observer final BooleanSubscription s new BooleanSubscription parent set new Thread new Runnable @Override public void run try emit first if s isUnsubscribed System out println Emit o1 observer onNext o1 emit second if s isUnsubscribed System out println Emit o2 observer onNext o2 wait until sometime later and emit third try allowThird await catch InterruptedException e observer onError e if s isUnsubscribed System out println Emit o3 observer onNext o3 catch Exception e observer onError e finally System out println Done parent Observable observer onCompleted parent get start return s Observable create concat observableOfObservables subscribe observer wait for parent to start while parent get null Thread sleep 1 try wait for first 2 async observables to complete while o1 t null Thread sleep 1 System out println Thread1 started waiting for it to complete o1 t join while o2 t null Thread sleep 1 System out println Thread2 started waiting for it to complete o2 t join catch Exception e throw new RuntimeException failed waiting on threads e InOrder inOrder inOrder observer inOrder verify observer times 1 onNext one inOrder verify observer times 1 onNext two inOrder verify observer times 1 onNext three inOrder verify observer times 1 onNext four inOrder verify observer times 1 onNext five inOrder verify observer times 1 onNext six we shouldn t have the following 3 yet inOrder verify observer never onNext seven inOrder verify observer never onNext eight inOrder verify observer never onNext nine we should not be completed yet verify observer never onCompleted verify observer never onError any Exception class now allow the third allowThird countDown try while o3 t null Thread sleep 1 wait for 3rd to complete o3 t join catch Exception e throw new RuntimeException failed waiting on threads e inOrder verify observer times 1 onNext seven inOrder verify observer times 1 onNext eight inOrder verify observer times 1 onNext nine inOrder verify observer times 1 onCompleted verify observer never onError any Exception class @SuppressWarnings unchecked @Test public void testBlockedObservableOfObservables Observer String observer mock Observer class final String o 1 3 5 7 final String e 2 4 6 final Observable String odds Observable toObservable o final Observable String even Observable toObservable e final CountDownLatch callOnce new CountDownLatch 1 final CountDownLatch okToContinue new CountDownLatch 1 TestObservable Observable String observableOfObservables new TestObservable Observable String callOnce okToContinue odds even Func1 Observer String Subscription concatF concat observableOfObservables Observable String concat Observable create concatF concat subscribe observer try Block main thread to allow observables to serve up o1 callOnce await catch Exception ex ex printStackTrace fail ex getMessage The concated observable should have served up all of the odds verify observer times 1 onNext 1 verify observer times 1 onNext 3 verify observer times 1 onNext 5 verify observer times 1 onNext 7 try unblock observables so it can serve up o2 and complete okToContinue countDown observableOfObservables t join catch Exception ex ex printStackTrace fail ex getMessage The concatenated observable should now have served up all the evens verify observer times 1 onNext 2 verify observer times 1 onNext 4 verify observer times 1 onNext 6 private static class TestObservable T extends Observable T private final Subscription s new Subscription @Override public void unsubscribe subscribed false private final List T values private Thread t null private int count 0 private boolean subscribed true private final CountDownLatch once private final CountDownLatch okToContinue public TestObservable T values this null null values public TestObservable CountDownLatch once CountDownLatch okToContinue T values this values Arrays asList values this once once this okToContinue okToContinue @Override public Subscription subscribe final Observer T observer t new Thread new Runnable @Override public void run try while count values size subscribed observer onNext values get count count Unblock the main thread to call unsubscribe if null once once countDown Block until the main thread has called unsubscribe if null once okToContinue await if subscribed observer onCompleted catch InterruptedException e e printStackTrace fail e getMessage t start return s Thanks for the comments and the extra tests I have merged them and uploaded a new version Regarding testConcatUnsubscribe I m still not entirely sure of my footing but I believe the test is in error It is demonstrating exactly the issue which I mentioned in the new javadoc for OperationConcat Specifically it sets up a situation wherein the inner observable s thread is blocked on the outer observable s thread the inner thread cannot proceed until the test calls okToContinue countDown which happens after concat subscribe aObserver which blocks until the list has delivered both w1 and w2 Am I right that in general an observer should block onNext until it has finished processing the item This pushes the flow control upstream rather than excessive buffering or throttling which can be done explicitly in the operation chain if desired If that s right then I think concat must block the outer onNext until it has finished servicing the inner sequence I do find it a little strange that Observable from Iterable is a shotgun observable i e the subscribe blocks until all downstream operations have completed on all items which means it is impossible to ever unsubscribe But given that this is correct behavior I think that it makes sense that concat o1 o2 also cannot be unsubscribed from I added a cautionary comment to the javadoc I have updated the test case to call concat subscribe aObserver in a background thread which fixes the deadlock and to expect all items to be delivered despite an unsubscribe which makes the test pass I had also tried those three non blocking approaches before uploading this version Thanks for checking my work On Mar 27 2013 6 56 AM Ben Christensen notifications@github com wrote While reviewing this I started playing with the unit tests and added 2 new ones I also made them use inOrder verify so they ensure correct ordering I ve pasted it below so you can merge into your branch instead of me complicating the merge with another branch The tests pass pass except testConcatUnsubscribe which deadlocks It does this because a List won t return the subscription asynchronously so it can t unsubscribe meanwhile a countDownLatch is waiting for the change to trigger and the two latches end up waiting on each other I haven t thought through enough yet to determine if there is a way to solve that or if the unit test is just testing the wrong thing and thus a bad test The comment above from @billy https github com billy about CountDownLatch originated from a discussion between him and I but while reviewing this it is probably the right approach I was playing with other approaches that are purely non blocking while retaining the correct concat sequential behavior but they all seem to require either another wrapping thread stealing work from one of the child Observable threads and making it do work that is queued on the others and that seems like a bad idea even though it can be hacked to work but it does so in a way that is very unexpected and thus not something I want to pursue queueing all onNext values which could be a bad memory issue and also means we eagerly subscribe which is not what we want My biggest issue right now is that concat o1 o2 is a very common usage but that results in List which will be blocking and unsubscribe doesn t work I ll think through this more but I d appreciate your thoughts on how to handle testConcatUnsubscribe public static class UnitTest @Test public void testConcat @SuppressWarnings unchecked Observer String observer mock Observer class final String o 1 3 5 7 final String e 2 4 6 final Observable String odds Observable toObservable o final Observable String even Observable toObservable e @SuppressWarnings unchecked Observable String concat Observable create concat odds even concat subscribe observer verify observer times 7 onNext anyString @Test public void testConcatWithList @SuppressWarnings unchecked Observer String observer mock Observer class final String o 1 3 5 7 final String e 2 4 6 final Observable String odds Observable toObservable o final Observable String even Observable toObservable e final List Observable String list new ArrayList Observable String list add odds list add even Observable String concat Observable create concat list concat subscribe observer verify observer times 7 onNext anyString @Test public void testConcatUnsubscribe final CountDownLatch callOnce new CountDownLatch 1 final CountDownLatch okToContinue new CountDownLatch 1 final TestObservable String w1 new TestObservable String one two three final TestObservable String w2 new TestObservable String callOnce okToContinue four five six @SuppressWarnings unchecked Observer String aObserver mock Observer class @SuppressWarnings unchecked Observable String concat Observable create concat w1 w2 System out println before subscribe Subscription s1 concat subscribe aObserver System out println after subscribe try Block main thread to allow observable w1 to complete and observable w2 to call onNext once System out println before callOnce await callOnce await System out println after callOnce await s1 unsubscribe System out println after s1 unsubscribe Unblock the observable to continue okToContinue countDown System out println after countDown w1 t join w2 t join catch Exception e e printStackTrace fail e getMessage InOrder inOrder inOrder aObserver inOrder verify aObserver times 1 onNext one inOrder verify aObserver times 1 onNext two inOrder verify aObserver times 1 onNext three inOrder verify aObserver times 1 onNext four inOrder verify aObserver never onNext five inOrder verify aObserver never onNext six inOrder verify aObserver times 1 onCompleted @Test public void testMergeObservableOfObservables @SuppressWarnings unchecked Observer String observer mock Observer class final String o 1 3 5 7 final String e 2 4 6 final Observable String odds Observable toObservable o final Observable String even Observable toObservable e Observable Observable String observableOfObservables Observable create new Func1 Observer Observable String Subscription @Override public Subscription call Observer Observable String observer simulate what would happen in an observable observer onNext odds observer onNext even observer onCompleted return new Subscription @Override public void unsubscribe unregister will never be called here since we are executing synchronously Observable String concat Observable create concat observableOfObservables concat subscribe observer verify observer times 7 onNext anyString Simple concat of 2 asynchronous observables ensuring it emits in correct order @SuppressWarnings unchecked @Test public void testSimpleAsyncConcat Observer String observer mock Observer class TestObservable String o1 new TestObservable String one two three TestObservable String o2 new TestObservable String four five six Observable concat o1 o2 subscribe observer try wait for async observables to complete o1 t join o2 t join catch Exception e throw new RuntimeException failed waiting on threads InOrder inOrder inOrder observer inOrder verify observer times 1 onNext one inOrder verify observer times 1 onNext two inOrder verify observer times 1 onNext three inOrder verify observer times 1 onNext four inOrder verify observer times 1 onNext five inOrder verify observer times 1 onNext six Test an async Observable that emits more async Observables @SuppressWarnings unchecked @Test public void testNestedAsyncConcat throws Exception Observer String observer mock Observer class final TestObservable String o1 new TestObservable String one two three final TestObservable String o2 new TestObservable String four five six final TestObservable String o3 new TestObservable String seven eight nine final CountDownLatch allowThird new CountDownLatch 1 final AtomicReference Thread parent new AtomicReference Thread Observable Observable String observableOfObservables Observable create new Func1 Observer Observable String Subscription @Override public Subscription call final Observer Observable String observer final BooleanSubscription s new BooleanSubscription parent set new Thread new Runnable @Override public void run try emit first if s isUnsubscribed System out println Emit o1 observer onNext o1 emit second if s isUnsubscribed System out println Emit o2 observer onNext o2 wait until sometime later and emit third try allowThird await catch InterruptedException e observer onError e if s isUnsubscribed System out println Emit o3 observer onNext o3 catch Exception e observer onError e finally System out println Done parent Observable observer onCompleted parent get start return s Observable create concat observableOfObservables subscribe observer wait for parent to start while parent get null Thread sleep 1 try wait for first 2 async observables to complete while o1 t null Thread sleep 1 System out println Thread1 started waiting for it to complete o1 t join while o2 t null Thread sleep 1 System out println Thread2 started waiting for it to complete o2 t join catch Exception e throw new RuntimeException failed waiting on threads e InOrder inOrder inOrder observer inOrder verify observer times 1 onNext one inOrder verify observer times 1 onNext two inOrder verify observer times 1 onNext three inOrder verify observer times 1 onNext four inOrder verify observer times 1 onNext five inOrder verify observer times 1 onNext six we shouldn t have the following 3 yet inOrder verify observer never onNext seven inOrder verify observer never onNext eight inOrder verify observer never onNext nine we should not be completed yet verify observer never onCompleted verify observer never onError any Exception class now allow the third allowThird countDown try while o3 t null Thread sleep 1 wait for 3rd to complete o3 t join catch Exception e throw new RuntimeException failed waiting on threads e inOrder verify observer times 1 onNext seven inOrder verify observer times 1 onNext eight inOrder verify observer times 1 onNext nine inOrder verify observer times 1 onCompleted verify observer never onError any Exception class @SuppressWarnings unchecked @Test public void testBlockedObservableOfObservables Observer String observer mock Observer class final String o 1 3 5 7 final String e 2 4 6 final Observable String odds Observable toObservable o final Observable String even Observable toObservable e final CountDownLatch callOnce new CountDownLatch 1 final CountDownLatch okToContinue new CountDownLatch 1 TestObservable Observable String observableOfObservables new TestObservable Observable String callOnce okToContinue odds even Func1 Observer String Subscription concatF concat observableOfObservables Observable String concat Observable create concatF concat subscribe observer try Block main thread to allow observables to serve up o1 callOnce await catch Exception ex ex printStackTrace fail ex getMessage The concated observable should have served up all of the odds verify observer times 1 onNext 1 verify observer times 1 onNext 3 verify observer times 1 onNext 5 verify observer times 1 onNext 7 try unblock observables so it can serve up o2 and complete okToContinue countDown observableOfObservables t join catch Exception ex ex printStackTrace fail ex getMessage The concatenated observable should now have served up all the evens verify observer times 1 onNext 2 verify observer times 1 onNext 4 verify observer times 1 onNext 6 private static class TestObservable T extends Observable T private final Subscription s new Subscription @Override public void unsubscribe subscribed false private final List T values private Thread t null private int count 0 private boolean subscribed true private final CountDownLatch once private final CountDownLatch okToContinue public TestObservable T values this null null values public TestObservable CountDownLatch once CountDownLatch okToContinue T values this values Arrays asList values this once once this okToContinue okToContinue @Override public Subscription subscribe final Observer T observer t new Thread new Runnable @Override public void run try while count values size subscribed observer onNext values get count count Unblock the main thread to call unsubscribe if null once once countDown Block until the main thread has called unsubscribe if null once okToContinue await if subscribed observer onCompleted catch InterruptedException e e printStackTrace fail e getMessage t start return s Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 205#issuecomment 15496596 RxJava pull requests #59 https netflixoss ci cloudbees com job RxJava pull requests 59 SUCCESS This pull request looks good RxJava pull requests #60 https netflixoss ci cloudbees com job RxJava pull requests 60 SUCCESS This pull request looks good Thanks for update Let me take a look and I will do some more research thought on the testConcatSubscribe test case On Fri Mar 29 2013 at 2 22 AM CloudBees pull request builder plugin notifications@github com wrote RxJava pull requests #60 https netflixoss ci cloudbees com job RxJava pull requests 60 SUCCESS This pull request looks good Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 205#issuecomment 15633763 RxJava pull requests #72 https netflixoss ci cloudbees com job RxJava pull requests 72 SUCCESS This pull request looks good My original test case was intended to test the unsubscribe inside one of child observable The countdownlatch was used so that the code will have a chance to unsubscribe in a predicable manner unsubscribe after four In a normal case there should be no blocking between inner and outer observable I rewrote the case for better clarity and having the outer Observable is in a separate thread so the test will pass now You brought up a good point about when you can unsubscribe Should it only allow unsubscribe to happen during the outer onNext I need to do more research on it Here is the test I plan to add @Test public void testConcatUnsubscribeObservableOfObservable final CountDownLatch callOnce new CountDownLatch 1 final CountDownLatch okToContinue new CountDownLatch 1 final TestObservable String w1 new TestObservable String one two three final TestObservable String w2 newTestObservable String callOnce okToContinue four five six @SuppressWarnings unchecked Observer String aObserver mock Observer class @SuppressWarnings unchecked TestObservable Observable String observableOfObservables newTestObservable Observable String w1 w2 Func1 Observer String Subscription concatF concat observableOfObservables Observable String concat Observable create concatF Subscription s1 concat subscribe aObserver try Block main thread to allow observable w1 to complete and observable w2 to call onNext exactly once callOnce await four has been processed by onNext s1 unsubscribe five and six will NOT be processed by onNext Unblock the observable to continue okToContinue countDown w1 t join w2 t join catch Exception e e printStackTrace fail e getMessage InOrder inOrder inOrder aObserver inOrder verify aObserver times 1 onNext one inOrder verify aObserver times 1 onNext two inOrder verify aObserver times 1 onNext three inOrder verify aObserver times 1 onNext four inOrder verify aObserver never onNext five inOrder verify aObserver never onNext six verify aObserver never onCompleted verify aObserver never onError any Exception class On Tue Apr 2 2013 at 8 55 PM CloudBees pull request builder plugin notifications@github com wrote RxJava pull requests #72 https netflixoss ci cloudbees com job RxJava pull requests 72 SUCCESS This pull request looks good Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 205#issuecomment 15816463 The RX NET version of Concat uses the ImmediateScheduler to execute the operation which will execute the operation on the same calling thread So if the observables are running on the same thread it will be synchronous blocked I have pulled in your changes from your fork and added the additional unit test to test unsubscribe with observables running in different thread I have also updated the javadoc about the blocking with observable on the same thread From my side it looks good On Wed Apr 3 2013 at 10 20 AM Billy Yuen billyy@gmail com wrote My original test case was intended to test the unsubscribe inside one of child observable The countdownlatch was used so that the code will have a chance to unsubscribe in a predicable manner unsubscribe after four In a normal case there should be no blocking between inner and outer observable I rewrote the case for better clarity and having the outer Observable is in a separate thread so the test will pass now You brought up a good point about when you can unsubscribe Should it only allow unsubscribe to happen during the outer onNext I need to do more research on it Here is the test I plan to add @Test public void testConcatUnsubscribeObservableOfObservable final CountDownLatch callOnce new CountDownLatch 1 final CountDownLatch okToContinue new CountDownLatch 1 final TestObservable String w1 new TestObservable String one two three final TestObservable String w2 newTestObservable String callOnce okToContinue four five six @SuppressWarnings unchecked Observer String aObserver mock Observer class @SuppressWarnings unchecked TestObservable Observable String observableOfObservables newTestObservable Observable String w1 w2 Func1 Observer String Subscription concatF concat observableOfObservables Observable String concat Observable create concatF Subscription s1 concat subscribe aObserver try Block main thread to allow observable w1 to complete and observable w2 to call onNext exactly once callOnce await four has been processed by onNext s1 unsubscribe five and six will NOT be processed by onNext Unblock the observable to continue okToContinue countDown w1 t join w2 t join catch Exception e e printStackTrace fail e getMessage InOrder inOrder inOrder aObserver inOrder verify aObserver times 1 onNext one inOrder verify aObserver times 1 onNext two inOrder verify aObserver times 1 onNext three inOrder verify aObserver times 1 onNext four inOrder verify aObserver never onNext five inOrder verify aObserver never onNext six verify aObserver never onCompleted verify aObserver never onError any Exception class On Tue Apr 2 2013 at 8 55 PM CloudBees pull request builder plugin notifications@github com wrote RxJava pull requests #72 https netflixoss ci cloudbees com job RxJava pull requests 72 SUCCESS This pull request looks good Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 205#issuecomment 15816463 I do find it a little strange that Observable from Iterable is a shotgun observable i e the subscribe blocks until all downstream operations have completed on all items which means it is impossible to ever unsubscribe But given that this is correct behavior I think that it makes sense that concat o1 o2 also cannot be unsubscribed from I added a cautionary comment to the javadoc Rx does not or rarely does add concurrency see guideline 6 12 thus Observable from is wrapping a synchronous Iterable therefore the Observable will be synchronous A Scheduler could be used to make the subscription to an Iterable happen on another Thread or a custom Observable could be created that handles an Iterable asynchronously All Rx operators must be capable of handling both synchronous and asynchronous sequences and if it s synchronous that means unsubscribe will not work which means it s up to the implementor of an Observable to understand this and decided if it s okay to firehose the results For the case of concat my concern is that if all the sequences being combined are async then we need to retain the async behavior and not block and prevent unsubscription For example async or synchronous ObservableA with 10 items async or synchronous ObservableB with 20 items async ObservableC with infinite items hot observable that never completed I should be able to do this concat a b c take 50 This should get the 10 items from A 20 items from B and first 20 items from C and then unsubscribe and continue Does this work with the current implementation and correctly unsubscribe from ObservableC Good point The best way to tell is to build an unit test for this case I can expand my new test to include this case and see what happen On Wed Apr 3 2013 at 2 29 PM Ben Christensen notifications@github com wrote I do find it a little strange that Observable from Iterable is a shotgun observable i e the subscribe blocks until all downstream operations have completed on all items which means it is impossible to ever unsubscribe But given that this is correct behavior I think that it makes sense that concat o1 o2 also cannot be unsubscribed from I added a cautionary comment to the javadoc Rx does not or rarely does add concurrency see guideline 6 12 thus Observable from is wrapping a synchronous Iterable therefore the Observable will be synchronous A Scheduler could be used to make the subscription to an Iterable happen on another Thread or a custom Observable could be created that handles an Iterable asynchronously All Rx operators must be capable of handling both synchronous and asynchronous sequences and if it s synchronous that means unsubscribe will not work which means it s up to the implementor of an Observable to understand this and decided if it s okay to firehose the results For the case of concat my concern is that if all the sequences being combined are async then we need to retain the async behavior and not block and prevent unsubscription For example async or synchronous ObservableA with 10 items async or synchronous ObservableB with 20 items async ObservableC with infinite items hot observable that never completed I should be able to do this concat a b c take 50 This should get the 10 items from A 20 items from B and first 20 items from C and then unsubscribe and continue Does this work with the current implementation and correctly unsubscribe from ObservableC Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 205#issuecomment 15866540',RxJava,true,false,false
12379107,'Observable toList breaks with multiple subscribers','clojure let i1 Subject create out Observable toList i1 subscribe out partial prn first observer subscribe out partial prn second observer subscribe out partial prn third observer onNext i1 1 onNext i1 2 onNext i1 3 onNext i1 4 onNext i1 5 onNext i1 6 onCompleted i1 Output first observer 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 6 6 6 second observer 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 6 6 6 third observer 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 6 6 6 Should be first observer 1 2 3 4 5 6 second observer 1 2 3 4 5 6 third observer 1 2 3 4 5 6','RxJava pull requests #48 https netflixoss ci cloudbees com job RxJava pull requests 48 SUCCESS This pull request looks good Good change that was a silly mistake on my part sorry about that and thank you for submitting a fix',RxJava,true,false,false
12419085,'Implemented combineLatest semantics','at least if I understand them correctly This is an attempt at resolving #29','RxJava pull requests #49 https netflixoss ci cloudbees com job RxJava pull requests 49 SUCCESS This pull request looks good RxJava pull requests #52 https netflixoss ci cloudbees com job RxJava pull requests 52 SUCCESS This pull request looks good RxJava pull requests #53 https netflixoss ci cloudbees com job RxJava pull requests 53 SUCCESS This pull request looks good This looks good and fixes the behavior Thank you @jmhofer for first finding this issue and then tackling the solution as I imagine it wasn t fun code to dig into The only thing I would want to look at changing and it originates from my original code that you were modifying is try to move away from blocking synchronization towards non blocking atomics if possible to reduce contention while still retaining the atomicity required for the contract But that is an optimization that may or may not warrant the effort and certainly does not need to hold up accepting this code as is to fix the fundamental problem',RxJava,true,false,false
12421954,'More formal support for Scala','I m still in the middle of fleshing this out but roughly 1 Removal of all Object methods from rx core 2 Scala RxJava usage doesn t depend on runtime class lookup instead it uses some implicits from Scala function types to Rx Func1 Func2 FuncN to assert type safety while using native Scala closures 3 Unit tests to demonstrate full coverage of Observable methods using Scala Given the first point above this will have to be combined with #204 so that support for dynamic languages continues','Small addition For comprehension for observable should be supported as well It means that Observable should have flatMap map and withFilter methods Good idea At first glance I think this could be accomplished by the introduction of an implicit class ScalaObservable wrapping Observable that implements flatMap map and withFilter by delegating to mapMany map and filter respectively As long as all the methods still return an Observable then we should be OK',RxJava,false,false,false
12488348,'Implement cache operator','Returns an Observable that repeats the original Observable sequence to all subscribers The source Observable is subscribed to at most once When looking into integrating Hystrix and RxJava the need for this operator became apparent It appears to be of general use so should be considered for RxJava core','RxJava pull requests #50 https netflixoss ci cloudbees com job RxJava pull requests 50 FAILURE Looks like there s a problem with this pull request How does this relate to Publish https github com Netflix RxJava issues 15 and Multicast https github com Netflix RxJava issues 65 RxJava pull requests #51 https netflixoss ci cloudbees com job RxJava pull requests 51 SUCCESS This pull request looks good My understanding is that Publish and Multicast don t remember or replay events that the source Observable generated before a given subscriber subscribed I think you re right How about Replay https github com Netflix RxJava issues 71 Reading through your code submission now I really like how many unit tests there are very nice I need to think through the implications of this compared with Replay RefCount Publish Multicast etc In other words if Rx Net doesn t have this operator for such a common case it seems that it should already be covered by one of the ones we have not yet implemented Replay could be what this is modulo Replay s connect semantics which I can t quite decipher from the documentation That part is still somewhat confusing to me as well as I haven t yet spent the time to fully grok these operators and what it will take to implement Perhaps though a cache operator would be a good cover method for the typical usecase that underneath is using replay and takes care of connections etc perhaps similar to how RefCount does the connection disconnect by counting subscriptions What I m trying to accomplish is first achieve the functionality provided by Rx and only then add new functionality if it s not already accounted for Rx Net has years of thought into the API design and functionality and there is value in common knowledge across implementations if we can maintain the same behavior I can see why one would need a connect method for Publish one would want to be able to subscribe multiple observers to a Publish before having the Publish subscribe to its source If the Publish subscribed to its source upon the first subscription it got its second subscriber wouldn t get the initial set of notifications The connect method makes a lot less sense for Replay as the second and later subscribers would get the initial set of notifications either way The only things I can think of are A desire to have the initial set of notification calls interleaved across the initial set of observers But I see nothing in the contract preventing an implementation from sending a batch of notifications to one observer before sending any of them to another A roundabout way of allowing the Replay to be forcibly unsubscribed from its source But this is not nearly as useful as a way to inform the Replay that it will have no new subscribers allowing it to unsubscribe from its source when its last current subscriber unsubscribes Some useful semantic around multiple connections The Microsoft documentation does not specify what happens if connect is called a second time either with or without the first connection being disposed I believe cache is a wrapper around Replay that calls the Replay s connect upon the first subscription Are you interested in exploring what an implementation of Replay would look like not necessarily all of the overloads that we eventually want but whatever is necessary for this use case and perhaps submitting that implementation to accomplish cache functionality while retaining our goal of complying to the Rx Net API I think so I would need to know what the behavior of a second call to connect is supposed to be both with and without the first call being unsubscribed If you can play with Rx Net or RxJS that would be the best way to determine the correct behavior You can also take a look at the Rx Net source ReplaySubject https rx codeplex com SourceControl changeset view 1174cce8e949bfe00879c437cab7ac3ef728042b#Rx NET Source System Reactive Linq Reactive Subjects ReplaySubject cs RefCount https rx codeplex com SourceControl changeset view 1174cce8e949bfe00879c437cab7ac3ef728042b#Rx NET Source System Reactive Linq Reactive Linq Observable RefCount cs Connecting without previous disconnect is idempotent Disconnecting is idempotent and generates no events Connecting after a disconnect re subscribes to the source Is this going away because of https github com Netflix RxJava pull 218 or does this still make sense A variant of Replay that connects on first subscription could make sense but might not meet the threshold for adding a new operator In any case it wouldn t use the commit in this request I think I figured out when the ConnectableObservable would come into play with Replay in a cache scenario source emits 10 values subscriberA subscribes and receives the 10 values source emits 5 values and subscriberA receives them subscribeB subscribes and receives the 15 values subscriberA unsubscribes Now what do we do We can t unsubscribe from source because subscriberB still expects to receive values source emits 5 new values and subscriberB receives them subscriberB unsubscribes Do we unsubscribe from source now That s how the refcount operator works subscriberC subscribes and receives 20 values subscriberC unsubscribes source keeps emitting values that keep getting cached and it never goes away In other words the cache operator we re discussing here would ONLY work if the source sequence correctly completed at some point If it was an infinite or very long running observable it would keep filling up the ReplaySubject in the background and likely become a memory leak Thus the ConnectableObservable is a way to unsubscribe I still think a cache operator is useful but it can be misused easily but so can toList which has the exact same problem on an infinite sequence I was thinking about adding a method to the Cache operator to notify it when it gets evicted and can rely on having no additional subscribers That way it could unsubscribe from its source when all of the existing subscribers unsubscribed As gravy it could even drop references to events that have been sent to all existing subscribers but that s less important Unsubscribing once all subscribers are unsubscribed is what the refCount operator does and I can t see how to make that work for the use cases where cache is intended Here is an example timeline using cache origin starts onNext 1 A subscribes receives 1 onNext 2 A receives 2 B subscribes receives 1 2 origin onCompleted A B receives onCompleted C subscribes receives 1 2 onCompleted Using a refCount system that unsubscribes from the origin would result in re executing the origin which is exactly what this operator is there to prevent Same problem with dropping references to events that have been sent to all existing subscribers C wouldn t receive anything in that case Here is the same timeline with refCount or something else that unsubscribes when all subscribers leave or the origin completes which is the same origin starts onNext 1 A subscribes receives 1 onNext 2 A receives 2 B subscribes receives 1 2 origin onCompleted A B receives onCompleted C subscribes origin is subscribed to again onNext 1 C receives 1 onNext 2 C receives 2 origin onCompleted C receives onCompleted Both of the use cases you suggest seem like they are exactly what refCount is intended for and its many overloads for max number of events to store time windows etc refCount works great for hot observables infinite sequences or very long running ones from what I can tell but it s not very good for a sequence that emits 1 or a handful of responses and completes Am I misunderstanding your meaning A Cache would differ from a refCount in that it would stay subscribed until after it is explicitly notified by this new method that it has been evicted and there will be no more subscribers So in your example timeline C would get 1 2 Completed as there was no eviction notification call The use case is that the creator of the Cache e g Hystrix would place the Cache Observable into some sort of data structure e g HystrixRequestCache from which the Cache Observable can gain new subscribers When the data structure expires or otherwise evicts the Cache Observable it would use this new method to notify the Cache Observable that it will receive no more subscribers At that point the Cache Observable can unsubscribe from its source when its reference count reaches zero This is only worth doing if subscribers are likely to unsubscribe before the sequence completes or if it is worth discarding early history while existing subscribers remain post eviction I think the key line you said is this This is only worth doing if subscribers are likely to unsubscribe before the sequence completes or if it is worth discarding early history while existing subscribers remain post eviction Since Hystrix will always complete onError or onCompleted it doesn t really matter nor is there a reliable hook to know when to cause eviction since even HystrixRequestContext is not a required thing Thus it seems that an object being dereferenced and then garbage collected is sufficient for the Hystrix case since the Observable would have terminated and have no resources to clean up Of note it was my working on Hystrix to support RxJava that drove me to add cache How would your proposed changes modify the method signature of cache in case we want to add the behavior you re describing Would it need to return a CachedObservable with the eviction hook How would your proposed changes modify the method signature of cache in case we want to add the behavior you re describing Would it need to return a CachedObservable with the eviction hook Pretty much Also the code maintaining the data structure would have to control subscriptions to the Cache so that it would be able to know when there are no more subscribers I had decided this embellishment probably wasn t worth doing but it was relevant to your question about sequences that never complete I m going to stick with cache as a simple thing without the eviction support and if needed we can evolve over time since returning a CachedObservable instead of Observable would be a non breaking change I think I also want to better understand how combinations of things like replay refCount may provide similar functionality to what we were discussing before inventing a new type of Observable Thanks for the feedback',RxJava,true,false,false
12492070,'Intermittent OperationTake UnitTest testUnsubscribeAfterTake test failure','rx operators OperationTake UnitTest testUnsubscribeAfterTake FAILED org mockito exceptions verification WantedButNotInvoked Wanted but not invoked subscription unsubscribe at rx operators OperationTake UnitTest testUnsubscribeAfterTake OperationTake java 253 Actually there were zero interactions with this mock at rx operators OperationTake UnitTest testUnsubscribeAfterTake OperationTake java 253','22 42 25 806 DEBUG TestEventLogger 22 42 25 808 DEBUG TestEventLogger rx operators OperationTake UnitTest testUnsubscribeAfterTake STARTED 22 42 25 808 DEBUG TestEventLogger 22 42 25 809 DEBUG TestEventLogger rx operators OperationTake UnitTest testUnsubscribeAfterTake STANDARD_OUT 22 42 25 809 DEBUG TestEventLogger TestObservable subscribed to 22 42 25 808 DEBUG org gradle messaging remote internal WorkerProtocol Dispatching request to worker Request consumer 6004969e 021a 4e9f 968d dfc84b2f583c payload MethodInvocation method output 22 42 25 809 DEBUG TestEventLogger starting TestObservable thread 22 42 25 815 DEBUG org gradle messaging remote internal WorkerProtocol Dispatching request to worker Request consumer 6004969e 021a 4e9f 968d dfc84b2f583c payload MethodInvocation method output 22 42 25 816 DEBUG TestEventLogger running TestObservable thread 22 42 25 816 DEBUG org gradle messaging remote internal WorkerProtocol Dispatching request to worker Request consumer 6004969e 021a 4e9f 968d dfc84b2f583c payload MethodInvocation method output 22 42 25 822 DEBUG org gradle messaging remote internal WorkerProtocol Dispatching request to worker Request consumer 6004969e 021a 4e9f 968d dfc84b2f583c payload MethodInvocation method output 22 42 25 822 DEBUG org gradle messaging remote internal WorkerProtocol Dispatching request to worker Request consumer 6004969e 021a 4e9f 968d dfc84b2f583c payload MethodInvocation method output 22 42 25 823 DEBUG org gradle messaging remote internal WorkerProtocol Dispatching request to worker Request consumer 6004969e 021a 4e9f 968d dfc84b2f583c payload MethodInvocation method output 22 42 25 823 DEBUG org gradle messaging remote internal WorkerProtocol Dispatching request to worker Request consumer 6004969e 021a 4e9f 968d dfc84b2f583c payload MethodInvocation method output 22 42 25 822 DEBUG TestEventLogger TestObservable onNext one 22 42 25 824 DEBUG TestEventLogger TestObservable onNext two 22 42 25 830 DEBUG TestEventLogger TestObservable onNext three 22 42 25 831 DEBUG TestEventLogger done starting TestObservable thread 22 42 25 831 DEBUG TestEventLogger TestObservable thread finished 22 42 25 836 QUIET system out 22 42 25 836 DEBUG org gradle messaging remote internal WorkerProtocol Dispatching request to worker Request consumer 3f00e622 9121 4171 ae82 b025e097f81b payload MethodInvocation method processTestClass 22 42 25 841 QUIET system out 22 42 25 841 DEBUG org gradle api internal tasks testing junit JUnitTestClassProcessor Executing test rx operators OperationTakeLast UnitTest 22 42 25 861 QUIET system out 22 42 25 861 DEBUG 22 42 25 866 DEBUG org gradle messaging remote internal WorkerProtocol Dispatching request to worker Request consumer 6004969e 021a 4e9f 968d dfc84b2f583c payload MethodInvocation method failure 22 42 25 866 DEBUG org gradle messaging remote internal WorkerProtocol Dispatching request to worker Request consumer 6004969e 021a 4e9f 968d dfc84b2f583c payload MethodInvocation method completed 22 42 25 867 QUIET system out org gradle messaging remote internal WorkerProtocol Dispatching request to worker Request consumer 3f00e622 9121 4171 ae82 b025e097f81b payload MethodInvocation method processTestClass 22 42 25 868 QUIET system out 22 42 25 867 DEBUG org gradle api internal tasks testing junit JUnitTestClassProcessor Executing test rx operators OperationToObservableFuture UnitTest 22 42 25 872 DEBUG TestEventLogger 22 42 25 872 DEBUG TestEventLogger rx operators OperationTake UnitTest testUnsubscribeAfterTake FAILED 22 42 25 876 DEBUG TestEventLogger org mockito exceptions verification WantedButNotInvoked 22 42 25 877 DEBUG TestEventLogger Wanted but not invoked 22 42 25 881 DEBUG TestEventLogger subscription unsubscribe 22 42 25 881 DEBUG TestEventLogger at rx operators OperationTake UnitTest testUnsubscribeAfterTake OperationTake java 285 22 42 25 887 DEBUG TestEventLogger Actually there were zero interactions with this mock 22 42 25 888 DEBUG TestEventLogger at rx operators OperationTake UnitTest testUnsubscribeAfterTake OperationTake java 285 22 42 25 901 DEBUG TestEventLogger at sun reflect NativeMethodAccessorImpl invoke0 Native Method 22 42 25 902 DEBUG TestEventLogger at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 39 22 42 25 906 DEBUG TestEventLogger at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 25 22 42 25 907 DEBUG TestEventLogger at java lang reflect Method invoke Method java 597 22 42 25 907 DEBUG TestEventLogger at org junit runners model FrameworkMethod 1 runReflectiveCall FrameworkMethod java 45 22 42 25 907 DEBUG TestEventLogger at org junit internal runners model ReflectiveCallable run ReflectiveCallable java 15 22 42 25 907 DEBUG TestEventLogger at org junit runners model FrameworkMethod invokeExplosively FrameworkMethod java 42 22 42 25 908 DEBUG TestEventLogger at org junit internal runners statements InvokeMethod evaluate InvokeMethod java 20 22 42 25 908 DEBUG TestEventLogger at org junit runners ParentRunner runLeaf ParentRunner java 263 22 42 25 909 DEBUG TestEventLogger at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 68 22 42 25 909 DEBUG TestEventLogger at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 47 22 42 25 909 DEBUG TestEventLogger at org junit runners ParentRunner 3 run ParentRunner java 231 22 42 25 909 DEBUG TestEventLogger at org junit runners ParentRunner 1 schedule ParentRunner java 60 22 42 25 909 DEBUG TestEventLogger at org junit runners ParentRunner runChildren ParentRunner java 229 22 42 25 910 DEBUG TestEventLogger at org junit runners ParentRunner access 000 ParentRunner java 50 22 42 25 910 DEBUG TestEventLogger at org junit runners ParentRunner 2 evaluate ParentRunner java 222 22 42 25 910 DEBUG TestEventLogger at org junit runners ParentRunner run ParentRunner java 300 22 42 25 910 DEBUG TestEventLogger at org gradle api internal tasks testing junit JUnitTestClassExecuter runTestClass JUnitTestClassExecuter java 55 22 42 25 910 DEBUG TestEventLogger at org gradle api internal tasks testing junit JUnitTestClassExecuter execute JUnitTestClassExecuter java 42 22 42 25 911 DEBUG TestEventLogger at org gradle api internal tasks testing junit JUnitTestClassProcessor processTestClass JUnitTestClassProcessor java 75 22 42 25 911 DEBUG TestEventLogger at org gradle api internal tasks testing SuiteTestClassProcessor processTestClass SuiteTestClassProcessor java 49 22 42 25 911 DEBUG TestEventLogger at sun reflect GeneratedMethodAccessor11 invoke Unknown Source 22 42 25 911 DEBUG TestEventLogger at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 25 22 42 25 912 DEBUG TestEventLogger at java lang reflect Method invoke Method java 597 22 42 25 912 DEBUG TestEventLogger at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 35 22 42 25 912 DEBUG TestEventLogger at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 24 22 42 25 912 DEBUG TestEventLogger at org gradle messaging dispatch ContextClassLoaderDispatch dispatch ContextClassLoaderDispatch java 32 22 42 25 912 DEBUG TestEventLogger at org gradle messaging dispatch ProxyDispatchAdapter DispatchingInvocationHandler invoke ProxyDispatchAdapter java 93 22 42 25 913 DEBUG TestEventLogger at com sun proxy Proxy2 processTestClass Unknown Source 22 42 25 913 DEBUG TestEventLogger at org gradle api internal tasks testing worker TestWorker processTestClass TestWorker java 103 22 42 25 913 DEBUG TestEventLogger at sun reflect GeneratedMethodAccessor10 invoke Unknown Source 22 42 25 913 DEBUG TestEventLogger at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 25 22 42 25 913 DEBUG TestEventLogger at java lang reflect Method invoke Method java 597 22 42 25 922 DEBUG TestEventLogger at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 35 22 42 25 922 DEBUG TestEventLogger at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 24 22 42 25 923 DEBUG TestEventLogger at org gradle messaging remote internal TypeCastDispatch dispatch TypeCastDispatch java 30 22 42 25 924 DEBUG TestEventLogger at org gradle messaging remote internal WorkerProtocol handleIncoming WorkerProtocol java 53 22 42 25 924 DEBUG TestEventLogger at org gradle messaging remote internal WorkerProtocol handleIncoming WorkerProtocol java 31 22 42 25 927 DEBUG TestEventLogger at org gradle messaging remote internal ProtocolStack ProtocolStage handleIncoming ProtocolStack java 167 22 42 25 928 DEBUG TestEventLogger at org gradle messaging remote internal ProtocolStack BottomStage handleIncoming ProtocolStack java 277 22 42 25 928 DEBUG TestEventLogger at org gradle messaging remote internal ProtocolStack BottomConnection 1 run ProtocolStack java 299 22 42 25 929 DEBUG TestEventLogger at org gradle messaging remote internal ProtocolStack ExecuteRunnable dispatch ProtocolStack java 120 22 42 25 929 DEBUG TestEventLogger at org gradle messaging remote internal ProtocolStack ExecuteRunnable dispatch ProtocolStack java 116 22 42 25 930 DEBUG TestEventLogger at org gradle messaging dispatch AsyncDispatch dispatchMessages AsyncDispatch java 132 22 42 25 930 DEBUG TestEventLogger at org gradle messaging dispatch AsyncDispatch access 000 AsyncDispatch java 33 22 42 25 930 DEBUG TestEventLogger at org gradle messaging dispatch AsyncDispatch 1 run AsyncDispatch java 72 22 42 25 934 DEBUG TestEventLogger at org gradle internal concurrent DefaultExecutorFactory StoppableExecutorImpl 1 run DefaultExecutorFactory java 66 22 42 25 934 DEBUG TestEventLogger at java util concurrent ThreadPoolExecutor Worker runTask ThreadPoolExecutor java 895 22 42 25 935 DEBUG TestEventLogger at java util concurrent ThreadPoolExecutor Worker run ThreadPoolExecutor java 918 22 42 25 935 DEBUG TestEventLogger at java lang Thread run Thread java 680 22 42 25 868 DEBUG org gradle messaging remote internal WorkerProtocol Dispatching request to worker Request consumer 6004969e 021a 4e9f 968d dfc84b2f583c payload MethodInvocation method completed 22 42 25 940 DEBUG TestEventLogger I ll be investigating further Hmm hopefully just a bad test implementation involving thread sleep instead of using join or CountDownLatch If you don t beat me to it I ll eventually look at this The problem is the TestObservable sequence makes its last onNext notification before TakeWhile T call can stuff the ItemObserver s subscription into the AtomicObservableSubscription In other words I think the verify s times 1 unsubscribe assertion is an invalid test I do think there should be a verify aObserver times 1 onCompleted assertion in that test One possibility would be to have AtomicObservableSubscription wrap unsubscribe its parameter if AtomicObservableSubscription unsubscribe had been previously called That would require a single guard around both unsubscribed and actualSubscription Perhaps the Runnable inside TestObservable subscribe should sleep or wait on a latch before generating output The Thread within subcribe pattern is used in a lot of unit tests and this problem probably needs to be fixed in all of them I am seeing intermittent failures in other tests it s just that this particular one is what shows up most frequently By the way I hate the Tests as Inner Classes pattern as it means I can t run the tests from within the IntelliJ IDE Running tests in IntelliJ for a selected package running tests in intellij https f cloud github com assets 813492 315596 d0351b6c 97ec 11e2 81e4 468e0c68f1f5 png If I try to run an individual test or tests for a given class it craps out with Exception in thread main java lang NoClassDefFoundError junit textui ResultPrinter at java lang Class forName0 Native Method at java lang Class forName Class java 171 at com intellij rt execution application AppMain main AppMain java 113 Caused by java lang ClassNotFoundException junit textui ResultPrinter at java net URLClassLoader 1 run URLClassLoader java 202 at java security AccessController doPrivileged Native Method at java net URLClassLoader findClass URLClassLoader java 190 at java lang ClassLoader loadClass ClassLoader java 306 at sun misc Launcher AppClassLoader loadClass Launcher java 301 at java lang ClassLoader loadClass ClassLoader java 247 3 more Which makes debugging a failing test difficult So fix the classpath It can t find JUnit which suggests IntelliJ has a bug since it can run it from the package but not the individual test level I was able to replicate your issue and then fix it by changing the the Module Settings Dependencies Scope from Provided to Compile Apparently the test runner knows to include Provided when run at the package level but not at the individual test level I found a bunch of chatter on Google about the issue as well without any clear resolution This is an issue for any dependency which is Provided which is most of them on the language adaptor side of things Perhaps the Gradle build file idea task could be tweaked to work around this issue so it sets IntelliJ up differently https github com Netflix RxJava blob master rxjava core build gradle#L28 Another example but from a language adaptor https github com Netflix RxJava blob master language adaptors rxjava groovy build gradle#L41 Note how Provided is used for the language dependencies https github com Netflix RxJava blob master language adaptors rxjava groovy build gradle#L10 Screenshot of running a single test Screen Shot 2013 03 28 at 10 33 20 PM https f cloud github com assets 813492 316659 c934a5e0 9831 11e2 84fc 75af955d3e5a png I m also getting random test failures when I run tests from CLI These are at least the tests that are failing randomly rx operators OperationConcat UnitTest testConcatUnsubscribe FAILED org mockito exceptions verification NeverWantedButInvoked at OperationConcat java 222 rx operators OperationTake UnitTest testUnsubscribeAfterTake FAILED org mockito exceptions verification WantedButNotInvoked at OperationTake java 243 rx operators OperationTakeWhile UnitTest testUnsubscribeAfterTake FAILED org mockito exceptions verification WantedButNotInvoked at OperationTakeWhile java 311 rx plugins RxJavaPlugins UnitTest testObservableExecutionHookViaProperty FAILED java lang AssertionError at RxJavaPlugins java 211 rx plugins RxJavaPlugins UnitTest testObservableExecutionHookDefaultImpl FAILED java lang AssertionError at RxJavaPlugins java 195 To me it looks like a threading problem I ll take a closer look after I get my environment set up Here s the setup I m using Gradle 1 5 Gradle build time Wednesday March 27 2013 1 51 06 PM UTC Groovy 1 8 6 Ant Apache Ant TM version 1 8 4 compiled on May 22 2012 Ivy 2 2 0 JVM 1 7 0_17 Oracle Corporation 23 7 b01 OS Mac OS X 10 7 5 x86_64 Fixed by #230',RxJava,false,false,false
12541593,'Remove use of JSR 305 and dependency on com google code findbugs','fixes https github com Netflix RxJava issues 192 The library and annotations were being used for trivial reasons so removing the usage so we don t have the dependency','RxJava pull requests #54 https netflixoss ci cloudbees com job RxJava pull requests 54 SUCCESS This pull request looks good I just cloned version 0 15 1 and the build process complains about the missing dependency Artifact com google code findbugs jsr305 1 3 9@jar not found I thought this dependency was removed Maybe it s another instance of this https github com Netflix RxJava issues 406 Yes it is thank you very much Samuel',RxJava,true,false,false
12548771,'Operation take leaks errors','The take operator improperly propagates an error from its source after the count has been exhausted Test cases exhibiting the bug attached','RxJava pull requests #55 https netflixoss ci cloudbees com job RxJava pull requests 55 FAILURE Looks like there s a problem with this pull request java @Test public void testTakeZeroDoesntLeakError Observable String source Observable String error new Exception test failed Observable create take source 0 lastOrDefault ok In that test Observable error will immediately throw when subscribed to so the count logic never even fires since the Observer never even gets to perform it s logic When 0 is used it s basically saying don t execute this sequence Now whether that means onError should be ignored is an interesting question onError and onCompleted are terminal states not part of the take count which applies to onNext So it could be argued that for this use case it s doing exactly what it should it doesn t emit any onNext values but terminates with either onError or onCompleted So should take 0 be special cased to always just fire onComplete immediately and not even subscribe to the sequence I m interested in what Rx Net and RxJs do in this case On the other unit test java @Test public void testTakeDoesntLeakErrors Observable String source Observable concat Observable from one Observable String error new Exception test failed Observable create take source 1 last This is an interesting one because concat will throw the error not take This is because these are all synchronous and thus eager observables so unsubscribe will not take effect and concat will process the second Observable which will cause onError to be called 1 Can concat be made lazy even when it is synchronous so an unsubscribe can happen and prevent the second sequence from being subscribed to 2 The take operator is performing all of it s logic inside onNext which means even if concat was lazy or asynchronous it would still receive the onError because it doesn t know to ignore an onNext until it is called Thus it seems the logic of ItemObserver needs to be changed to perform the counter logic after EACH onNext not before In other words after each onNext it decides if it is done not when it receives the next one which opens up the door for an onError I ll explore that change Good finds @johngmyers My quick attempt fixed this test case but broke others The challenge is that the take overload with item count converts into a predicate function that is used by the implementation The predicate actually uses the onNext argument to allow the predicate to determine if it should be emitted or not This works for that case but not the count case The predicate can t be applied in the onError case either for the count since there isn t an arg to pass in Perhaps some special case logic needs to exist for the count use case I need to punt on this for now as I don t have time to work on it so if you can work on the fix or someone else such as @mairbek who worked on this code once already that would be great I believe the concat implementation currently is asynchronous lazy In any case I believe take as with other operators should produce the same output sequence regardless of whether its source sequence is synchronous or asynchronous That means the implementations of take takeWhile etc cannot depend on unsubscribing their source to prevent pass through of subsequent events The onError callback needs to check some isCompleted state for filtering pass through As take is trusted the onCompleted callback needs to do the same I believe that take cannot be implemented on top of the takeWhile implementation as is currently done This is what my test cases demonstrate take 0 should be special cased to fire onCompleted immediately Per the contract it needs to emit the first zero items emitted by the source Observable which happens immediately The existing contract does not state that take is required to subscribe to its source so I didn t write a test for that I do think it should be required to subscribe to its source as subscription can have external side effects RxJava pull requests #57 https netflixoss ci cloudbees com job RxJava pull requests 57 SUCCESS This pull request looks good What I meant about concat was not that the implementation of concat was synchronous but that the observable sequences being concatenated were synchronous and that does change behavior because unsubscribe generally doesn t work on synchronous sequences However as you said the output result should be the same but on a synchronous origin observable it may end up firehosing all of the onNext values even if an unsubscribe happened early in the sequence and all after the unsubscribe will still be sent but end up ignored which is different behavior than an async sequence Taking a look at your code now There s a lot of code there and my brain is done for the night so I ll have to catch up on this later By the way I agree with your points in your last comment You can t unsubscribe from a synchronous Observable because you don t have a Subscription until after all the synchronous notifications are done An unwrapped AtomicObservableSubscription is not a subscription to the Observable You agree that take 0 should subscribe to its source I ll generate another commit Is the semantic of AtomicObserver T onNext of catching exceptions from its target s onNext and relaying them to onError in the contract Is it a bug that none of the trusted observables I ve looked at implement that semantic except empty error and never which implement it vacuously Github s diff doesn t show this well but I renamed OperatorTake to OperatorTakeWhile hopefully preserving commit history changed the class javadoc and then deleted the take code from it You can t unsubscribe from a synchronous Observable because you don t have a Subscription until after all the synchronous notifications are done An unwrapped AtomicObservableSubscription is not a subscription to the Observable Yes I know That was my point You agree that take 0 should subscribe to its source I ll generate another commit I think so though if the subscribe emits an error such as on Observable throw then take 0 will result in onError and not onCompleted Is the semantic of AtomicObserver T onNext of catching exceptions from its target s onNext and relaying them to onError in the contract Rx Design Guidelines 6 5 dictates that subscribe should not throw The try catch around an onNext is ensuring that this contract is met even if the implementation of an onNext by a provided Observer does not do proper error handling most user provided Observers Guideline 6 6 discusses onError abort semantics so the AtomicObserver also makes sure unsubscribe happens when the terminal state occurs onError onCompleted even if the Observer doesn t handle it correctly in their error handling which most don t have It counts on unsubscribe being idempotent guideline 6 17 which AtomicObservableSubscription also ensures RxJava pull requests #61 https netflixoss ci cloudbees com job RxJava pull requests 61 SUCCESS This pull request looks good Guideline 6 4 explicitly states Note do not protect calls to Subscribe Dispose OnNext OnError and OnCompleted methods These calls are on the edge of the monad Calling the OnError method from these places will lead to unexpected behavior This seems to expressly contraindicate the AtomicObserver onNext protection code I merged these changes via https github com Netflix RxJava pull 215 Thank you for finding demonstrating via unit test and fixing these issues @johngmyers I have created a separate issue to discuss the other possible issue you brought up https github com Netflix RxJava issues 216',RxJava,true,false,false
12587119,'More formal support for Scala','This allows for type safety in statically typed languages This prevents dynamically typed languages from hooking into rxjava core See #204 for details on code generation for dynamic languages Added Scala implicits into rx lang scala RxImplicits Added tests of most methods on Observable using Scala functions Fixed Scala Gradle ScalaTest build','RxJava pull requests #56 https netflixoss ci cloudbees com job RxJava pull requests 56 FAILURE Looks like there s a problem with this pull request This pull request is for issue https github com Netflix RxJava issues 208 The Scala implicits look good to me Adding the ability to use observables the for comprehension way is awesome Maybe it s better in the long run to use the enrich my library pattern and add explicit toRx methods instead of all the automatic implicit conversions see JavaConversions vs JavaConverters I m not sure about that Imho it s an argument of convenience vs explicitness However as all this only concerns the Rx utility ActionX and FuncX classes I think I d also prefer direct implicit conversions because the intent of those classes is very specific and they match the Scala functions very naturally @jmhofer I considered the toRx approach as well but in the end I agreed with your point about the scope of these implicits Since we re only converting into rx FuncX and rx ActionX it seems like it s hard to hit some unintended consequences The only thing holding this up is the work on #204 which I m making good progress on Just checking in this is still on hold while waiting on https github com Netflix RxJava issues 204 Good progress has been made by @mattrjacobs but completion has been held up for a bit higher priority work',RxJava,true,false,false
12638905,'Take Operator Error Handling','The take operator from pull request https github com Netflix RxJava pull 212 and merged in https github com Netflix RxJava pull 215 does not handle Observer onNext throwing exceptions This unit test reveals it java @Test public void testTakeWithErrorInObserver final AtomicInteger count new AtomicInteger final AtomicReference Exception error new AtomicReference Exception Observable from 1 2 three 4 take 3 subscribe new Observer String @Override public void onCompleted System out println completed @Override public void onError Exception e error set e System out println error e printStackTrace @Override public void onNext String v int num Integer parseInt v System out println num doSomething num count incrementAndGet assertEquals 2 count get assertNotNull error get if error get instanceof NumberFormatException fail It should be a NumberFormatException It silently fails with a count of 2 and never prints an exception or throws anything','@johngmyers can you take a look at this please since you have been involved in this code See https github com Netflix RxJava issues 216 for a discussion related to this In the supplied unit test the take operator has already delivered three onNext notifications so it has completed It can t deliver an onError after onComplete Change the test to a take 4 and it passes So in my opinion it s an invalid test Note that none of the trusted operators handle asynchronous Observer onNext notifications throwing exceptions It is Observer subscribe that is catching the exception and delivering it through onNext and that only works because the notifications are synchronous For an amusing test replace the take 3 with materialize So in my opinion it s an invalid test Let me amend that statement The test was bug dependent it depended on the very bug that was fixed in order to pass Furthermore if the test had applied take 3 to an asynchronous trusted Observer generating the same sequence it would not have passed Operators must work on both synchronous and asynchronous sequences including error handling and I understand that this issue exists on all kinds of operators This issue is to demonstrate that there are challenging implementation details and nuanced behavior even when an operator implementation looks correct The discussion at https github com Netflix RxJava issues 216 will carry this forward In the supplied unit test the take operator has already delivered three onNext notifications so it has completed It can t deliver an onError after onComplete Change the test to a take 4 and it passes With take 3 it does not successfully deliver 3 onNext notifications It delivers 2 and attempts the 3rd and fails and then when onError is invoked it thinks it has terminated based solely on the count but it has not because the 3rd onNext failed and should have instead emitted an onError Whether this gets fixed in the operator or part of https github com Netflix RxJava issues 216 is an open question I think it should be done outside of the operator because too much error prone boilerplate will need to exist in every single operator to try and get every use case handled I ll hold this issue open until https github com Netflix RxJava issues 216 is finalized but theoretically no code changes should be needed for the take operator directly I just tested the unit test above and it works 1 2 error java lang NumberFormatException For input string three at java lang NumberFormatException forInputString NumberFormatException java 65 at java lang Integer parseInt Integer java 492 at java lang Integer parseInt Integer java 527 at rx TestIssue 1 onNext TestIssue java 32 at rx TestIssue 1 onNext TestIssue java 1 at rx operators SafeObserver onNext SafeObserver java 121 at rx operators OperationTake Take ItemObserver onNext OperationTake java 140 at rx operators OperationToObservableIterable ToObservableIterable onSubscribe OperationToObservableIterable java 55 at rx Observable subscribe Observable java 186 at rx operators OperationTake Take onSubscribe OperationTake java 110 at rx operators OperationTake 1 onSubscribe OperationTake java 59 at rx Observable subscribe Observable java 196 at rx TestIssue testTakeWithErrorInObserver TestIssue java 16 at sun reflect NativeMethodAccessorImpl invoke0 Native Method for java @Test public void testTakeWithErrorInObserver final AtomicInteger count new AtomicInteger final AtomicReference Throwable error new AtomicReference Throwable Observable from 1 2 three 4 take 3 subscribe new Observer String @Override public void onCompleted System out println completed @Override public void onError Throwable e error set e System out println error e printStackTrace @Override public void onNext String v int num Integer parseInt v System out println num doSomething num count incrementAndGet assertEquals 2 count get assertNotNull error get if error get instanceof NumberFormatException fail It should be a NumberFormatException Unit test added in https github com Netflix RxJava pull 353',RxJava,false,false,false
12639956,'Implement ReplaySubject with infinite history','','RxJava pull requests #64 https netflixoss ci cloudbees com job RxJava pull requests 64 FAILURE Looks like there s a problem with this pull request RxJava pull requests #65 https netflixoss ci cloudbees com job RxJava pull requests 65 FAILURE Looks like there s a problem with this pull request RxJava pull requests #66 https netflixoss ci cloudbees com job RxJava pull requests 66 SUCCESS This pull request looks good I m unavailable this week but will review this when I get back I was focusing on getting schedulers done last week and wasn t able to get to this one I need to spend more time than I have right now to come up to speed on this code and what Net does my focus has been on Schedulers https github com Netflix RxJava issues 19 still which hopefully is close https github com Netflix RxJava pull 235 but not quite done yet Once Schedulers is done I ll turn my attention to this Please weigh in on this https github com Netflix RxJava issues 242 I would appreciate some feedback on UnsubscribeTester I left some comments in the commits above Note there were todo comments asking about desired semantics in the added unit tests',RxJava,true,false,false
12653113,'OperationTakeWhile doesn t protect calls to predicate','Per RX guideline 6 4 calls to selector functions passed in to the operator should be caught and fed through to the subscribed observer Operator TakeWhile doesn t do this with the passed in predicate java @Test public void testTakeWhileProtectsPredicateCall TestObservable source new TestObservable mock Subscription class one final RuntimeException testException new RuntimeException test exception @SuppressWarnings unchecked Observer String aObserver mock Observer class Observable String take Observable create takeWhile source new Func1 String Boolean @Override public Boolean call String s throw testException take subscribe aObserver wait for the Observable to complete try source t join catch Exception e e printStackTrace fail e getMessage verify aObserver never onNext any String class verify aObserver times 1 onError testException','Might as well supply the fix Sent pull #220',RxJava,false,false,false
12653204,'TakeWhile protect calls to predicate','Per RX guideline 6 4 calls to selector functions passed in to the operator should be caught and fed through to the subscribed observer Operator TakeWhile doesn t do this with the passed in predicate','RxJava pull requests #67 https netflixoss ci cloudbees com job RxJava pull requests 67 SUCCESS This pull request looks good Thanks',RxJava,true,false,false
12681063,'Error Handling Improvements User Provided Observers Functions','Improve error handling as per discussion in issue https github com Netflix RxJava issues 216 This is by no means exhaustive in the search for places needing this protection but gets the most obvious ones entering via subscribe and forEach The intention is to protect against exceptions being thrown and ensure onNext onError onCompleted contract compliance','RxJava pull requests #68 https netflixoss ci cloudbees com job RxJava pull requests 68 SUCCESS This pull request looks good RxJava pull requests #69 https netflixoss ci cloudbees com job RxJava pull requests 69 SUCCESS This pull request looks good I ve incorporated the change to restrict internal identification to rx operators Merging as this seems to be a good step forward further changes can always come in via another pull request',RxJava,true,false,false
12764963,'Pull issue 43 merge','Manual merge of https github com Netflix RxJava pull 196','RxJava pull requests #73 https netflixoss ci cloudbees com job RxJava pull requests 73 SUCCESS This pull request looks good This finished https github com Netflix RxJava issues 43',RxJava,true,false,false
12780756,'Concat merge','1 Update javadoc on subscribe blocking if observables are running on the same thread 2 Add test case with infinity observable 3 Add test case to unsubscribe with all observables running in different thread non blocking','RxJava pull requests #75 https netflixoss ci cloudbees com job RxJava pull requests 75 SUCCESS This pull request looks good Is this all good to go now @billyy and @abliss Are you both happy with its conformance to the Net implementation and the various use cases we discussed on previous pull requests This fixed https github com Netflix RxJava issues 202',RxJava,true,false,false
12823368,RxJavaObservableExecutionHook,'Allow a plugin to intercept invocations of an Observable via its subscribe method Use cases extra logging or metrics for start return and error events when subscribing decorate or replace an onSubscribe function with additional behavior decorate an Exception decorate a Subscription This is modeled after Hystrix Plugins http netflix github com Hystrix javadoc index html com netflix hystrix strategy executionhook HystrixCommandExecutionHook html Javadocs will be at http netflix github com RxJava javadoc','RxJava pull requests #76 https netflixoss ci cloudbees com job RxJava pull requests 76 SUCCESS This pull request looks good',RxJava,true,false,false
12831992,'Schedulers merge of pull #199','Manual merge of https github com Netflix RxJava pull 199 by @mairbek plus the following changes made some classes non public so they don t become part of the published API if we find they have value in the public API we can make them so but once published it s hard to remove them so I d rather keep them implementation details until then consolidated ExecutorScheduler and ScheduledExecutorScheduler made ExecutorScheduler use a system wide ScheduledExecutorScheduler for handling delayed events when only an Executor is available made the IOThreadPool use a non bounded cached thread pool Next step from here is to review all operator implementations and add the Scheduler overloads','RxJava pull requests #77 https netflixoss ci cloudbees com job RxJava pull requests 77 SUCCESS This pull request looks good RxJava pull requests #78 https netflixoss ci cloudbees com job RxJava pull requests 78 FAILURE Looks like there s a problem with this pull request The unit test is poorly written non deterministic I ll fix in the morning Awesome work With this it should be easy to implement operators like sample etc Yes it should open the gates to many operators we haven t been able to pursue Committed a few tweaks and fixes Open questions for me are we re not using the Scheduler now value anywhere should we be or is that only for the Virtual scheduler used for testing not quite sure how the overloads should work on merge etc I ve implemented them but the behavior might not yet match C# Can someone with an Rx Net environment setup implement a test similar to this from Java and tell me the output java @Test public void testMixedSchedulers throws InterruptedException final String mainThreadName Thread currentThread getName Observable String o Observable String create new Func1 Observer String Subscription @Override public Subscription call Observer String observer System out println Origin observable is running on Thread currentThread getName assertFalse Thread currentThread getName equals mainThreadName assertTrue Actually Thread currentThread getName Thread currentThread getName startsWith RxIOThreadPool observer onNext one observer onNext two observer onNext three observer onCompleted return Subscriptions empty subscribeOn Schedulers threadPoolForIO subscribe to the source on the IO thread pool now merge on the CPU threadpool o Observable String merge o Observable String from four five subscribeOn Schedulers threadPoolForComputation map new Func1 String String @Override public String call String v opportunity to see what thread the merge is running on System out println Merge is running on Thread currentThread getName return v final CountDownLatch latch new CountDownLatch 1 final AtomicReference RuntimeException onError new AtomicReference RuntimeException subscribe on a new thread o subscribe new Observer String @Override public void onCompleted System out println received onCompleted latch countDown @Override public void onError Exception e System out println received onError e getMessage onError set RuntimeException e latch countDown @Override public void onNext String v System out println Final subscribe is running on Thread currentThread getName System out println onNext v Schedulers newThread wait for the above to finish or blow up if it s blocked latch await 5 TimeUnit SECONDS I m trying to understand how a sequence should work when multiple subscribeOn operators are applied at different steps of a sequence Of course Rx Net doesn t have the IO and CPU thread pools those are just helper methods to Executors which would be 2 separate threadpools for different work types so you ll need to adjust that RxJava pull requests #79 https netflixoss ci cloudbees com job RxJava pull requests 79 SUCCESS This pull request looks good Is there any reason to use Scheduler schedule on an internal operator implementation instead of just leveraging subscribeOn other than when we need the delay arguments of course For example on a method overload of merge is this okay java return merge source subscribeOn scheduler or is there some reason to inside the OperationMerge do this java return scheduler schedule new Func0 Subscription @Override public Subscription call return new MergeObservable T o call observer They seem to accomplish the same thing but would like to know if there s a reason to prefer one over the other I prefer just reusing subscribeOn I can t tell from reading C# code what it does as I can t find the extensions that implement the override methods I m pulling the trigger and merging this into master so people can start playing with it and providing feedback The public API changes are fairly limited still so most changes which I fully expect will be implementation details RxJava pull requests #80 https netflixoss ci cloudbees com job RxJava pull requests 80 SUCCESS This pull request looks good',RxJava,true,false,false
12862712,'Merge overload possibility B','A possible implementation of scheduler overloads on the merge operator Related to Schedulers pulled in https github com Netflix RxJava pull 225 and issue https github com Netflix RxJava issues 19','This implementation uses Scheduler schedule See https github com Netflix RxJava pull 227 for another implementation using subscribeOn Is there any reason to use Scheduler schedule on an internal operator implementation instead of just leveraging subscribeOn other than when we need the delay arguments of course For example on a method overload of merge is this okay java return merge source subscribeOn scheduler or is there some reason to inside the OperationMerge do this java return scheduler schedule new Func0 Subscription @Override public Subscription call return new MergeObservable T o call observer They seem to accomplish the same thing but would like to know if there s a reason to prefer one over the other I prefer just reusing subscribeOn I can t tell from reading C# code what it does as I can t find the extensions that implement the override methods RxJava pull requests #81 https netflixoss ci cloudbees com job RxJava pull requests 81 SUCCESS This pull request looks good',RxJava,true,false,false
12862745,'Merge overload possibility A','A possible implementation of scheduler overloads on the merge operator Related to Schedulers pulled in https github com Netflix RxJava pull 225 and issue https github com Netflix RxJava issues 19','This implementation uses subscribeOn See https github com Netflix RxJava pull 226 for another implementation using Scheduler schedule Is there any reason to use Scheduler schedule on an internal operator implementation instead of just leveraging subscribeOn other than when we need the delay arguments of course For example on a method overload of merge is this okay java return merge source subscribeOn scheduler or is there some reason to inside the OperationMerge do this java return scheduler schedule new Func0 Subscription @Override public Subscription call return new MergeObservable T o call observer They seem to accomplish the same thing but would like to know if there s a reason to prefer one over the other I prefer just reusing subscribeOn I can t tell from reading C# code what it does as I can t find the extensions that implement the override methods RxJava pull requests #82 https netflixoss ci cloudbees com job RxJava pull requests 82 SUCCESS This pull request looks good',RxJava,true,false,false
12947090,Interval,'I have attempted to implement the Interval operator #55 here As far as I can see it seems to work This is based on the quite fresh work on schedulers It doesn t work with the currentThread or newThread schedulers I guess due to the simple SleepingAction It does work with a ScheduledExecutorService though For testing this conveniently I also wrote a test scheduler with adjustable time Looking forward to any review comments','RxJava pull requests #83 https netflixoss ci cloudbees com job RxJava pull requests 83 FAILURE Looks like there s a problem with this pull request RxJava pull requests #84 https netflixoss ci cloudbees com job RxJava pull requests 84 SUCCESS This pull request looks good Let s consider adding new method to the Scheduler java schedulePeriodically Action0 action long initialDelay long period TimeUnit unit It would allow to leverage ScheduledExecutorService#scheduleAtFixedRate for the ExecutorScheduler For other schedulers we could use recursive Action scheduling from pull request #229 I agree schedulePeriodically would be helpful here @jmhofer do you plan to work on this feature I m thinking about implementing Buffer operator #16 and this one will be very helpful for me I ll have a look at it Maybe we should also combine all the longs and units into a Timespan class It doesn t feel right to always have them as separate parameters Anyone know why Net wouldn t have a schedulePeriodically concept If we were to add that it would only really work with ScheduledExecutorService and thus most Scheduler implementations would have to rely upon the generic ScheduledExecutorService that I ve added in https github com Netflix RxJava pull 235 called GenericScheduledExecutorService This suggests to me that it isn t the right solution to add another interface method as it seems very tied to a particular implementation Can t this be achieved with recursive schedulers which now work after the changes you did in https github com Netflix RxJava pull 229 I m curious about this It doesn t work with the currentThread or newThread schedulers I guess due to the simple SleepingAction It does work with a ScheduledExecutorService though It seems that this operator needs to be async and must default to using something like Schedulers threadPoolForComputation Documentation at MSDN http msdn microsoft com en us library hh228911 v vs 103 aspx suggests that this defaults to using a thread pool scheduler The following example code uses the Interval operator to generate a sequence of long integers staring at zero Each integer in the sequence is generated after the two second period has expired Each integer is written to the console window along with the current time to show the period parameter in effect The generation of the integer sequence is scheduled to run on a thread from the Net thread pool so the main thread is not blocked and can process the enter key being pressed to stop the interval Perhaps NewThreadScheduler will work as of https github com Netflix RxJava pull 235 because it now uses GenericScheduledExecutorService when a delay is passed in instead of SleepingAction What happens in Net if someone tries to use ImmediateScheduler or CurrentThreadScheduler Anyone have access to Net to try that Maybe we should also combine all the longs and units into a Timespan class It doesn t feel right to always have them as separate parameters If we re going to consider doing this then we should do it as part of https github com Netflix RxJava pull 235 before I release another version since this would change the Schedulers interface Java itself always keeps the 2 separate though so perhaps the idiomatic thing to do in Java is to keep them separate I don t have a strong opinion on this one but the decision made now will last a very long time Actually Net does have SchedulePeriodic See here https rx codeplex com SourceControl changeset view e24677887e1727fb3b5dd614d996aa6d113b3834#Rx NET Source System Reactive Interfaces Reactive Concurrency ISchedulerPeriodic cs Imho it s useful to avoid recursive scheduling where the schedulers support this directly as well as to do the slightly messy recursive scheduling ourselves for other types of schedulers so that the user doesn t have to Ah interesting thanks for educating me on that This doesn t look like it s been integrated into Observable but I m going to merge as it looks useful to get this in the TestScheduler especially while Interval continues getting work done Great thanks this still needs a bit of work if when we do periodic scheduling Are you okay with me releasing current code on the master branch and then the rest of interval coming later Is there anything else about master branch as it stands that should be changed before I release I d like to do so today That s alright with me @benjchristensen now the interval operators in RxJava and Rx Net have different behaviors when the scheduler is CurrentThread In Rx Net the following codes c# var o Observable Interval TimeSpan FromMilliseconds 100 Scheduler CurrentThread o Take 5 Subscribe x Console WriteLine x o Take 4 Subscribe x Console WriteLine x Console ReadLine output 0 1 2 3 4 0 1 2 3 In RxJava the following codes java Observable Long o Observable interval 100 TimeUnit MILLISECONDS Schedulers currentThread o take 5 subscribe new Action1 Long @Override public void call Long t1 System out println t1 o take 4 subscribe new Action1 Long @Override public void call Long t1 System out println t1 output 0 1 2 3 4 and the current thread is blocked at the first subscribe Is it OK or the interval operator should not be used with CurrentThread',RxJava,true,false,false
12972362,'Trying to extend the Scheduler interface according to the comments at','I ve tried to extend the Scheduler interface according to the discussion at issue #19 If I understand this correctly most of it can be done via the AbstractScheduler I hope this helps Please have a look','RxJava pull requests #85 https netflixoss ci cloudbees com job RxJava pull requests 85 SUCCESS This pull request looks good Awesome Looks like it doesn t break a Scheduler interface I thought about two examples java final Scheduler scheduler Schedulers currentThread Observable Integer obs Observable create new Func1 Observer Integer Subscription @Override public Subscription call final Observer Integer observer return scheduler schedule 0 new Func2 Scheduler Integer Subscription @Override public Subscription call Scheduler scheduler Integer i if i 42 observer onCompleted return Subscriptions empty observer onNext i return scheduler schedule i 1 this obs subscribe new Observer Integer @Override public void onCompleted System out println Completed @Override public void onError Exception e System out println Error @Override public void onNext Integer args System out println args and java final Scheduler scheduler Schedulers threadPoolForComputation Observable Integer obs Observable create new Func1 Observer Integer Subscription @Override public Subscription call final Observer Integer observer return scheduler schedule new BooleanSubscription new Func2 Scheduler BooleanSubscription Subscription @Override public Subscription call Scheduler scheduler BooleanSubscription cancel if cancel isUnsubscribed observer onCompleted return Subscriptions empty observer onNext 42 try Thread sleep 1000 catch InterruptedException e e printStackTrace scheduler schedule cancel this return cancel Subscription subscribe obs subscribe new Observer Integer @Override public void onCompleted System out println Completed @Override public void onError Exception e System out println Error @Override public void onNext Integer args System out println args Thread sleep 10000 subscribe unsubscribe System out println unsubscribe Thread sleep 10000 And they worked well for me I m wondering if the Scheduler interface really needs all of these overloads Rx has 3 primary methods the rest are extension methods that look like they do transformations http msdn microsoft com en us library hh211963 v vs 103 aspx Thus the 2 key ones are java T Subscription schedule T state Func2 Scheduler T Subscription action T Subscription schedule T state Func2 Scheduler T Subscription action long dueTime TimeUnit unit We don t have one with an explicit time to run only relative at this time It appears the overloads all make sense but again Net is able to use extension methods to make the design much more elegant where only the main 3 are part of the interface and the rest come along for the ride It means we end up with a Scheduler AbstractScheduler Interface Abstract pairing to make this work Should we just make Scheduler an Abstract I m very tempted to do so because of the following problems adding methods to Scheduler will be breaking changes requiring major version increments people implementing Schedulers will basically always have to also extend AbstractScheduler or copy paste all of those method overloads Or should be remove all but the main 3 methods from Scheduler and put all the overloads as utility functions on the Schedulers class instead The precedent for using abstract or concrete classes instead of interfaces which Net then augments with extension methods is already done Observable is a concrete class instead of interface for this very reason All plugins are done as abstracts instead of interfaces for this reason as well Thoughts While reviewing and playing with this I considered some changes I d like to propose I have submitted another pull request https github com Netflix RxJava pull 235 that builds on top of your work @jmhofer and includes the unit tests from @mairbek I would appreciate your thoughts on it and whether they are beneficial changes or just pedantic Merged manually via https github com Netflix RxJava pull 235',RxJava,true,false,false
13002114,'An unsubscribed AtomicObservableSubscription wrap unsubscribes its argument','Fixes #210','RxJava pull requests #86 https netflixoss ci cloudbees com job RxJava pull requests 86 SUCCESS This pull request looks good Interesting use case suggests either the wrap is being done at the wrong time or a race condition where a Subscription is being returned before a subscription is invoked not sure when that would occur but there s probably some use case I m not thinking of Per #210 the TestObservable sequence makes its last onNext notification on another thread before TakeWhile call can stuff the ItemObserver s subscription into the AtomicObservableSubscription Thus the AtomicObservableSubscription gets unsubscribed before the wrap call',RxJava,true,false,false
13122773,Multicast,'Implemented Multicast operation working on issue #65','RxJava pull requests #87 https netflixoss ci cloudbees com job RxJava pull requests 87 FAILURE Looks like there s a problem with this pull request RxJava pull requests #88 https netflixoss ci cloudbees com job RxJava pull requests 88 SUCCESS This pull request looks good One minor thing here We don t have Observable publish yet Should probably be easily implemented',RxJava,true,false,false
13177396,'Corrected naming','Renamed Operator to Operation to be consistent','RxJava pull requests #89 https netflixoss ci cloudbees com job RxJava pull requests 89 SUCCESS This pull request looks good',RxJava,true,false,false
13237356,'ScheduledObserver doesn t Guaranty Ordering','ScheduledObserver should be reimplemented the way that it guaranties ordering of the events Right now this test prints values in different ordering java @Test public void testToIteratorObserveOn Observable String obs Observable from one two three four Iterable String it obs observeOn Schedulers threadPoolForComputation toIterable for String s it System out println s','This is used as a pass thru for ObserveOn to a Scheduler so why does this need to ensure ordering That should be up to the scheduler implementation should it not For example if I need to ensure ordering then I probably don t sent it to a thread pool but send it to a single thread such as the UI thread If I choose to send something to a thread pool for execution on multiple threads why should I expect the events to all be processed and returned in order when I am specifically injecting concurrency I can t find anything in the Rx Design Guidelines that dictates that order should be retained and it s not at all guaranteed by all operators for example merge definitely does not retain order whereas concat does Quote from the _4 2 Assume observer instances are called in a serialized fashion_ Consumers of observables can safely assume that messages arrive in a serialized fashion var count 0 xs Subscribe v count Console WriteLine OnNext has been called 0 times count In this sample no locking or interlocking is required to read and write to count as only one call to OnNext can be in flight at any time If ordering is not guarantied we might observe onComplete event before onNext In this case operators like toIterator doesn t work correctly But I don t read that to mean ordered We must ensure the contract of onNext onCompleted onError but I don t see how we need to or should ensure that execution of onNext events arrive in the same order once they ve been thrown off on a thread pool and multiple threads Do you think otherwise You can take a look at an Observer wrapper we used in production in our internal version before open sourcing that allows concurrent onNext executions but ensures the onCompleted onError contract https gist github com benjchristensen 5400653 We were more lenient in our internal version about allowing concurrent execution of onNext since we forced everything to be functional and without state which I still actually prefer and think onNext should be allowed to be concurrent but when we open sourced I removed this since it is against the contract of official Rx and do not allow concurrent onNext execution However it shows the principle of how onNext calls could interleave be out of order but still be serialized while ensuring onCompleted onError occur only at the end after all onNext calls are completed Thinking about this more the ordering still isn t the part that concerns me though maybe it should but the real issue here is that each onNext onCompleted onError could be triggered on a separate thread We need to not only ensure only one of those is running at a time but then we ensure visibility memory consistency This means we are basically forced into wrapping this in SynchronizedObserver so only a single onNext onCompleted onError call is happening at any given time correct Without that I can t see ObserveOn complying with the Rx contract I thought if onNext calls are sequential it makes sense to make them sequencial in the order they have appeared I ve tried to implement non blocking algorithm to make it work #234 We need to not only ensure only one of those is running at a time but then we ensure visibility memory consistency This means we are basically forced into wrapping this in SynchronizedObserver so only a single onNext onCompleted onError call is happening at any given time correct Using only SynchronizedObserver itself wouldn t be helpful since it doesn t guaranty the ordering of the events OnCompleted could be called before OnNext It is a good question whether memory consistency visibility should be responsibility of the library or of the observer It would guarantee ordering if the synchronization happens BEFORE putting the event on to the Scheduler since they would enter and leave the Scheduler in the same order they hit the SynchronizedObserver It should only be permitted to schedule one event at a time It can t schedule more than one at a time because then you can no longer prevent them from running concurrently I believe this was fixed in https github com Netflix RxJava commit f1be5f4addf30f47b1d915ca708566bf49beb7f8 and https github com Netflix RxJava commit 071b8943520dd8aa3b05c2b3c6c452a81778ebae',RxJava,false,false,false
13249332,'ScheduledObserver Ordering','Fixing issue #233 Blocking solution for now thinking about non blocking alternatives','RxJava pull requests #90 https netflixoss ci cloudbees com job RxJava pull requests 90 FAILURE Looks like there s a problem with this pull request RxJava pull requests #91 https netflixoss ci cloudbees com job RxJava pull requests 91 FAILURE Looks like there s a problem with this pull request RxJava pull requests #92 https netflixoss ci cloudbees com job RxJava pull requests 92 ABORTED RxJava pull requests #93 https netflixoss ci cloudbees com job RxJava pull requests 93 SUCCESS This pull request looks good This looks like an elegant solution @mairbek I can t quite figure out if there s a chance for a race condition on the counter but am merging it for now since I can t prove one way or another and this is way better than what we have I m manually merging via https github com Netflix RxJava pull 238 since I added some unit tests I m not sure if this is a really working solution as well looks too simple Need to think about use cases to break this code Thanks I d appreciate that as I haven t had time to think through those Okay this seems to be working Assuming that underlying observable implemented correctly this means that OnNext OnCompleted and OnError events will be called sequentially The solution itself is inspired by the way a CurrentThreadScheduler works except that it relies on concurrent primitives instead of ThreadLocal I can see 4 cases 1 Enqueue when queue was empty Counter is set to 1 and queue processing is started Since counter is atomic two processes cannot start 2 Enqueue when queue is not empty Counter is set to 1 queue processing is already going on Queue processing cannot stop since counter is atomic 3 Dequeue when queue has more than one element This would recursively schedule queue processing 4 Dequeue when queue has one item When item is processed counter would be set to 0 Queue processing stopped Next enqueue will schedule out new queue processing @benjchristensen what do you think',RxJava,true,false,false
13281936,'Schedulers Interface Merging and Adding to Pull Request 229','Merging and adding to pull request https github com Netflix RxJava pull 229 from @jmhofer which adds functionality discussed in the Scheduler issue https github com Netflix RxJava issues 19 Work done in https github com Netflix RxJava pull 229 added the following methods to Scheduler Subscription schedule T state Func2 Scheduler T Subscription action long delayTime TimeUnit unit Subscription schedule T state Func2 Scheduler T Subscription action These are in fact the primary methods from RxNet http msdn microsoft com en us library hh211963 v vs 103 aspx and the others are just helper overloads It seems beneficial to use these 2 methods for actual implementation logic while all other methods are just decorating and forwarding from AbstractScheduler to these methods I propose these changes on top of pull request https github com Netflix RxJava pull 229 to achieve this I also added unit tests that @mairbek created https github com Netflix RxJava pull 229#issuecomment 16115941 All unit tests are passing but we don t yet have enough unit test coverage so I won t be surprised if bugs are found','RxJava pull requests #94 https netflixoss ci cloudbees com job RxJava pull requests 94 SUCCESS This pull request looks good @jmhofer @mairbek and any others of course I have added various inline comments and questions about the Scheduler code and would appreciate your thoughts even if it s stating agreement but especially if you disagree to determine if our approaches to these various things are correct Thank you both for your involvement in this so far and continuing to do so @mairbek and @jmhofer I think this pull request is ready to merge though I m not yet ready to release I d like to leave some more time to review consider and fix things Agree Disagree RxJava pull requests #96 https netflixoss ci cloudbees com job RxJava pull requests 96 SUCCESS This pull request looks good 1 from me to merging but not releasing yet',RxJava,true,false,false
13289827,'Fixed Sleeping Action','Sleeping action wasn t working correctly','RxJava pull requests #95 https netflixoss ci cloudbees com job RxJava pull requests 95 SUCCESS This pull request looks good RxJava pull requests #98 https netflixoss ci cloudbees com job RxJava pull requests 98 SUCCESS This pull request looks good',RxJava,true,false,false
13359157,'Implement ConnectableObservable and Observable publish','Hi I hope you appreciate this implementation Most of it is a quite straightforward mimic of the NET version Could you perhaps verify if I used the lock and the subscription wrapper correctly Following the behaviour of the NET Rx implementation a ConnectableObservable consists of a Subject that can be connected to its source Observable by calling the connect method The Observable publish method can be used to create a new ConnectableObservable for the given Observable Greetings Gerben','RxJava pull requests #97 https netflixoss ci cloudbees com job RxJava pull requests 97 SUCCESS This pull request looks good Hi @Treora thanks for contributing Reviewing now Since multicast operation is already merged publish could be defined as multicast new PublishingSubject A ConnectableObservable should work with any subject not just Subject It should indeed work with any type of subject but I think it does A difference between RxJava and Rx Net is that Observable is used as a class here instead of an interface and similarly Subject has no interface but is just a subclass of Observable To make ConnectableObservables with other subject implementations you can make them subclasses of Subject This should already work with this code there are just no alternative subjects yet I added the constructor ConnectableObservable Observable T source to make it simpler to construct it with a plain new Subject which I guessed would be the usual case Shall I remove this extra constructor to not show preference for a particular type of subject RxJava pull requests #104 https netflixoss ci cloudbees com job RxJava pull requests 104 FAILURE Looks like there s a problem with this pull request This should be ConnectableObservable I O to allow the subject to have different input and output types Different input and output types should indeed be possible but I am not sure which approach should be taken here Turning it into a ConnectableObservable S R is an option but when instantiated the source type is not relevant anymore so it would be nicer to see it as a ConnectableObservable R Not having an interface for this like Rx Net has IConnectableObservable TResult a solution could be to create a subclass ConnectableObservable2 S R that extends the current ConnectableObservable T Since multicast operation is already merged publish could be defined as multicast new PublishingSubject I do not see any multicast implementation yet When it will be there it would indeed provide an even simpler way to implement publish Ah now I see you already implemented the whole thing great Things can change a lot in a few hours Seems that my patch is superfluous then',RxJava,true,false,false
13361094,'ScheduledObserver ObserveOn Manual Merge of Pull 234','Manual merge of https github com Netflix RxJava pull 234 with some unit test tweaks and additions','RxJava pull requests #99 https netflixoss ci cloudbees com job RxJava pull requests 99 SUCCESS This pull request looks good This pull request resolved outstanding issues reported for Schedulers https github com Netflix RxJava issues 19 released in version 0 7 0',RxJava,true,false,false
13362360,'CurrentThreadScheduler Delayed Execution Fix','Added unit tests for the delayed execution for CurrentThreadScheduler Re implemented queueing in order to make those tests pass','RxJava pull requests #100 https netflixoss ci cloudbees com job RxJava pull requests 100 SUCCESS This pull request looks good Thanks for improving this',RxJava,true,false,false
13367983,'Update TestScheduler to match merged Scheduler changes','I accidentally merged this code before fixing it to match the changes to AbstractScheduler Scheduler','RxJava pull requests #101 https netflixoss ci cloudbees com job RxJava pull requests 101 SUCCESS This pull request looks good',RxJava,true,false,false
13370013,'ReplaySubject Manual Merge of Pull 218','Manual merge of ReplaySubject from pull request https github com Netflix RxJava pull 218 merged DefaultSubject and PublishedSubject which were the same thing lots more unit tests though from this pull request still not sure what the right name is for DefaultSubject PublishSubject renamed RepeatSubject to ReplaySubject to match Net tweaked unit tests with InOrder while reviewing them to understand behavior moved UnsubscribeTester into a package private class as I m still undecided on long term placement of this and the OperatorTester class','I have some open questions but want to get this merged so we can unblock progress in this area of subjects RxJava pull requests #102 https netflixoss ci cloudbees com job RxJava pull requests 102 SUCCESS This pull request looks good',RxJava,true,false,false
13370266,'Name for DefaultSubject','In Net there is ISubject and Subject Right now we have Subject as the abstract instead of interface since we don t prefix with I but that means our concrete class needs a different name What should it be called It s DefaultSubject right now and I don t like that @johngmyers had the name PublishSubject which I think I like better but want to make sure it truly represents what it does and won t interfere with anything else we need to use in the future My hesitance on it and why I stuck with DefaultSubject right now is how does this relate to the publish operator we need to add I ll need to read up more on the overall Net API Subjects and Publish but if anyone else can weigh in I d appreciate it','@johngmyers @mairbek and @jmhofer if you have opinions on this I d appreciate them since you are all involved in and touching code in this area I believe the publish operator will wrap a ConnectableObservable around a PublishSubject I ll like the PublishSubject name instead of DefaultSubject Then I ll rename this to PublishSubject before I release 0 8 0 which I want to do today to get improved Schedulers into people s hands @johngmyers Thanks for clarifying this I believe the publish operator will wrap a ConnectableObservable around a PublishSubject If that s the case the name PublishSubject makes sense and shouldn t collide elsewhere',RxJava,false,false,false
13370490,'Can we eliminate or reduce blocking synchronization in ReplaySubject','The current implementation of ReplaySubject https github com Netflix RxJava blob master rxjava core src main java rx subjects ReplaySubject java#L145 relies heavily on synchronized and blocking synchronized for everything This warrants exploration of non blocking approaches','The current implementation of ReplaySubject tries to ensure it doesn t hold locks while making synchronous notifications to new subscriber The current implementation relies on infinite history as expiration adds the issue of events expiring in the middle of a sequence being delivered to a new subscriber The current implementation synchronizes subscriptions over notifications in order to comply with the contract mentioned in guideline 5 9 that states that after an unsubscribe call completes no more messages will arrive It appears to be an existing bug that DefaultSubject violates this contract term I understand the requirement but these can be done without synchronization in many cases For example AtomicObserver https github com Netflix RxJava blob master rxjava core src main java rx util AtomicObserver java ensures no events can be sent after onCompleted onError with the use of AtomicBoolean so we rely on compareAndSet to ensure atomicity instead of mutex locks Beyond that 1 The subscriptions https github com Netflix RxJava blob master rxjava core src main java rx subjects ReplaySubject java#L64 HashMap could be replaced with a ConcurrentHashMap to be thread safe without needing locking 2 The history https github com Netflix RxJava blob master rxjava core src main java rx subjects ReplaySubject java#L65 list could be a ConcurrentLinkedQueue http docs oracle com javase 6 docs api java util concurrent ConcurrentLinkedQueue html instead of a Synchronized ArrayList AtomicBoolean and compareAndSet are synchronization While a notification to a subscriber is in progress on another thread an unsubscription of that subscriber has to block Additionally either an unsubscription has to block for a concurrent notification of all subscribers or a notification loop has to double check that each subscriber is still subscribed before delivering the notification to it history and subscriptions have to be under the same lock in order to safely move a new subscriber from the synchronous notification path to the asynchronous notification path AtomicBoolean and compareAndSet are synchronization It s a very different kind compareAndSet is not mutex locking Use of compareAndSet such as this https github com Netflix RxJava blob master rxjava core src main java rx util AtomicObserver java#L54 allows 1 thread to go through a code path while all others skip over it and does not put the threads to sleep and thus does not cause the context switching and scheduling to occur under conflict Synchronization is expensive under contention and requires the system to do more work compareAndSet is far cheaper as it allows either completely skipping if it loses the compareAndSet or just a quick busy spin to retry If something is always heavily contended such as 2 threads in a tight loop incrementing an integer then synchronized and compareAndSet won t have much difference but that s not what we re doing If you don t want to pursue these improvements that s fine I will at some point I am aware of the preference for non blocking forms of synchronization Your use of the term synchronization to mean only blocking synchronization makes communication difficult and obscures some substantial differences in design between RxJava and Rx I am attempting to explain the constraints that drove the existing implementation It would be unfortunate if an attempted improvement introduced a bug where say an event could be dropped or duplicated when it comes in on one thread while another is moving a subscriber from the synchronous path to the asynchronous one That sort of race condition is a bit difficult to catch in unit tests I believe per the contract unsubscribe has to at least block on a concurrent notification to that subscriber It might be possible to devise a complicated protocol to handle the other cases but I d suggest first figuring out a protocol that allows for safe expiration of history I will try to remember to be more explicit in referring to blocking synchronization when referring to the use of synchronized I m used to a team of people who refer to synchronized as synchronization and explicitly call out non blocking data structures compareAndSet and other such things I apologize for not being clear in my communication It would be unfortunate if an attempted improvement introduced a bug Of course I agree with you here hence the title of this issue Can we Note that I merged this code into master branch with the use of synchronized so I m not against the use of blocking synchronization I simply felt it warranted a second look for possible performance improvements so opened this issue substantial differences in design between RxJava and Rx Can you elaborate on this statement I d like to understand what you re referring to',RxJava,false,false,false
13407412,'Pre 0 8 0 Release Changes','Some cleanup before releasing','This fixes https github com Netflix RxJava issues 242 @johngmyers @mairbek and @jmhofer is there anything else needing to be done before I release 0 8 0 I d like to release it today so that the new Schedulers behavior is useable RxJava pull requests #103 https netflixoss ci cloudbees com job RxJava pull requests 103 SUCCESS This pull request looks good I know of no release blockers Go ahead my other branches still need work anyway I ll proceed with the release Thanks for the feedback @johngmyers and @jmhofer',RxJava,true,false,false
13530253,'Moved state from Observable to Observer','','RxJava pull requests #105 https netflixoss ci cloudbees com job RxJava pull requests 105 SUCCESS This pull request looks good Is this fixing the ability to subscribe more than once Could you add unit tests that validate these fixes so we don t accidentally re add the bug you re fixing in the future',RxJava,true,false,false
13689691,'Scheduling actions periodically','As proposed earlier by @mairbek in https github com Netflix RxJava pull 228#issuecomment 16254526 I extended the Scheduler by yet another method schedulePeriodically This has a default implementation that works via recursion I tried it out with all existing schedulers and it seems to work fine I also wrote a unit test for it using the TestScheduler I switched scheduled executor services to use their fixed rate scheduling instead of the recursive default implementation And I also switched the OperationInterval implementation to use periodic scheduling','RxJava pull requests #106 https netflixoss ci cloudbees com job RxJava pull requests 106 SUCCESS This pull request looks good From what I can tell this looks functionally correct and like a valid addition based on previous discussions in #228 so I m merging Thank you @jmhofer this is a nice addition and good quality code',RxJava,true,false,false
13708387,'Add flatMap alias to mapMany','This is to match with what Java 8 is adding to Stream so we support the duality of Iterable Collection to Observable http download java net lambda b86 docs api java util stream Stream html#flatMap java util function Function','RxJava pull requests #107 https netflixoss ci cloudbees com job RxJava pull requests 107 SUCCESS This pull request looks good',RxJava,true,false,false
13725392,'Implemented Sample Operation','Now that OperationInterval is in OperationSample see #74 was kind of straightforward I also added a unit test against sampling and allowed for specifying a scheduler used by the sample operation','RxJava pull requests #108 https netflixoss ci cloudbees com job RxJava pull requests 108 SUCCESS This pull request looks good We want methods on Observable don t we Sure I just completely forgot about that I ll add them RxJava pull requests #113 https netflixoss ci cloudbees com job RxJava pull requests 113 SUCCESS This pull request looks good',RxJava,true,false,false
13737467,'Timestamp operation','Straightforward implementation of issue #93 based on OperationMap without the scheduler version as map doesn t take a scheduler yet either','RxJava pull requests #109 https netflixoss ci cloudbees com job RxJava pull requests 109 FAILURE Looks like there s a problem with this pull request The failing test has nothing to do with my changes I guess it s a sporadic test problem as there s not much difference between 10 and 30 milliseconds This should also be added to Observable shouldn t it RxJava pull requests #112 https netflixoss ci cloudbees com job RxJava pull requests 112 FAILURE Looks like there s a problem with this pull request My Eclipse configuration also automatically added a lot of @Override annotations I hope you don t mind Otherwise I can remove them again of course The @Override annotations are fine they are standard Java They may be missing in some places because this project started with Java 5 compliance and it had the annotations in less places than Java 6',RxJava,true,false,false
13739987,'Initial implementation of AsyncSubject','I ve done some work on AsyncSubject T including unit tests and I m looking for feedback I don t expect to get this pull request immediately accepted But I hope to find out if this is the correct workflow for this repository and if the code is up to your standards before I start pouring in more hours into issue #17 If you guys are ok with the AsyncSubject T implementation I ll start working on the others Looking forward to some feedback','RxJava pull requests #110 https netflixoss ci cloudbees com job RxJava pull requests 110 SUCCESS This pull request looks good Hi @michaeldejong thanks for getting involved Based on my reading of the MSDN docs for AsyncSubject and your code this looks good Thank for you following the coding style of the project and making sure the copyright unit tests etc are all in place Merging now',RxJava,true,false,false
13789696,'Error executing gradlew test','You should modify the language adaptors rxjava scala build gradle file on line 34 and replace the property runpath with the following property value sourceSets test output classesDir otherwise the build stops with an error when executing gradlew test command The gradlew help output is Gradle 1 3 Gradle build time Ter a feira 20 de Novembro de 2012 11h37min38s UTC Groovy 1 8 6 Ant Apache Ant TM version 1 8 4 compiled on May 22 2012 Ivy 2 2 0 JVM 1 6 0_43 Apple Inc 20 14 b01 447 OS Mac OS X 10 7 5 x86_64','@leogsilva I also encountered this error while modifying the Scala language adaptor I believe I addressed it in https github com mattrjacobs RxJava commit 520bedf1e757ad829056cc50adc57b75ec134516 but this is blocked on issue #204 from making it in to master I ll make sure to leave comments on this issue as I get #204 and #208 merged into master',RxJava,false,false,false
13838417,'Observable toFuture','','RxJava pull requests #111 https netflixoss ci cloudbees com job RxJava pull requests 111 SUCCESS This pull request looks good',RxJava,true,false,false
13864117,'Fix multiple subscription bug on operation filter','A new subscription must be created on every subscribe call otherwise any subscribe call after the first directly fails','RxJava pull requests #114 https netflixoss ci cloudbees com job RxJava pull requests 114 SUCCESS This pull request looks good Thanks @Treora',RxJava,true,false,false
13886724,'Swing scheduler','I ve added a Swing specific scheduler to RxJava However it probably doesn t belong to rxjava core and therefore I ve created a subfolder named extensions with currently one single subproject rxjava swing with currently one single class SwingScheduler I ve tried to create a build for this too but I m not very familiar with Gradle so somebody should probably check that it s okay like this Also I m not very happy with the subfolder name extensions Maybe somebody has a better idea for a more specific name','RxJava pull requests #115 https netflixoss ci cloudbees com job RxJava pull requests 115 FAILURE Looks like there s a problem with this pull request The failing test on Cloudbees says that the test should probably use longer delays RxJava pull requests #116 https netflixoss ci cloudbees com job RxJava pull requests 116 FAILURE Looks like there s a problem with this pull request I m not the only one who used too short delays in the tests This is a good addition I imagine we ll also end up with something like SwingObservables for utility methods wrapping listeners and other Swing based behavior being added to this module On Hystrix I called it hystrix contrib https github com Netflix Hystrix tree master hystrix contrib Not sure if that s better or worse We could go with extensions rxjava ext rxjava extensions rxjava contrib None of these affects the Maven Central published name though so it s just the organization of the code This module in extensions rxjava swing will be published as rxjava swing For the test delays I ve started to try and use CountDownLatch wherever I can so that tests are deterministic and I control when things wait and proceed so it runs as fast as the CPU and I don t have to set really long delays to account for different machines and non deterministic scheduling When specifically testing a scheduler though it can be tricky sometimes to do it this way I vote for rxjava contrib if only to be consistent with hystrix Also rxjava extensions sounds like plugins or something rather than just additional helper code written on top of rxjava Dave On Thu May 2 2013 at 9 01 AM Ben Christensen notifications@github com wrote This is a good addition I imagine we ll also end up with something like SwingObservables for utility methods wrapping listeners and other Swing based behavior being added to this module On Hystrix I called it hystrix contrib https github com Netflix Hystrix tree master hystrix contrib Not sure if that s better or worse We could go with extensions rxjava ext rxjava extensions rxjava contrib None of these affects the Maven Central published name though so it s just the organization of the code This module in extensions rxjava swing will be published as rxjava swing Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 254#issuecomment 17347038 I m good with rxjava contrib too I m also okay with rxjava contrib Do you want to make the change @jmhofer or do you want me to do it as a custom merge I can do it give me an hour not at my computer right now RxJava pull requests #117 https netflixoss ci cloudbees com job RxJava pull requests 117 SUCCESS This pull request looks good',RxJava,true,false,false
13904971,'Cleaning up fixing a lot of build warnings mostly javadoc','I m not good at ignoring warnings there are lots of them in the build output mostly due to invalid javadoc link syntax or missing @return descriptions This is my attempt at fixing them','RxJava pull requests #118 https netflixoss ci cloudbees com job RxJava pull requests 118 SUCCESS This pull request looks good Thanks for taking to time to make things better',RxJava,true,false,false
13956592,'Created the initial implementation of BehaviorSubject','I ve been trying to implement the BehaviorSubject Functionally it works as it should but I m not entirely happy with the static createWithDefaultValue T method I can t create a static method create T because Subject extends Observable which has a static create Object method So to resolve that I had to give the static method in BehaviorSubject a different name Additionally I m using an AtomicReference T in this static method to keep track of the last published value I tried coming up with different solutions to push the last published value to the Observer when it s subscribing but this seems to be the most clean solution If there s any feedback on either issue please let me know','RxJava pull requests #119 https netflixoss ci cloudbees com job RxJava pull requests 119 SUCCESS This pull request looks good I agree it s obnoxious that the create method can t be used but I can t see a way around it when it s also an Observable If anyone else has other ideas on how to deal with this please suggest them otherwise I think the createWithDefaultValue T name is fine RxJava pull requests #127 https netflixoss ci cloudbees com job RxJava pull requests 127 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
13964393,'Improved scan reduce aggregate','scan is currently restricted to accumulators of type Func2 T T T where Func2 R T R would be possible for initial values of type R This pull request tries to fix this by generalizing the scan implementation I had to restructure the scan operator a bit for this to stay typesafe Imho it s more readable now though This indirectly leads to generalized reduce too Also aggregate is added as an alias for reduce see #20','RxJava pull requests #120 https netflixoss ci cloudbees com job RxJava pull requests 120 SUCCESS This pull request looks good RxJava pull requests #121 https netflixoss ci cloudbees com job RxJava pull requests 121 FAILURE Looks like there s a problem with this pull request RxJava pull requests #122 https netflixoss ci cloudbees com job RxJava pull requests 122 SUCCESS This pull request looks good Thank you for working on this Observable had not had any changes done to it to expose the new reduce or scan methods so that should probably be added to this pull request What names should we use on the public API Rx Net never used reduce it uses aggregate Others call it fold accumulate etc more here http en wikipedia org wiki Fold_ higher order_function Java 8 is using the reduce and collector names http download java net lambda b74 docs api java util stream Stream html What names should we use and what aliases if any should we include in Observable About Observable hmm seems that the changes got lost somehow I ll go dig them out again And about the names to use imho RxJava should have the Java 8 names as well as the orginial Rx Net names Agreed with your opinion on naming Can you add those when you update the Observable and make sure the Javadocs of the methods are clear in linking to each other when they are aliases of each other I ve had a look at the Java 8 stream operations To me it looks like there s no explicit scan equivalent in Java 8 Or am I missing something collect seems to be specifically made for mutable operations I don t see where we would use that So I would just alias reduce with aggregate and scan stays unaliased if that s okay That works for me we can always add more aliases if Java 8 adds a scan equivalent I plan on doing a release tomorrow about 12 hours from now if you want to try and have this ready for that RxJava pull requests #131 https netflixoss ci cloudbees com job RxJava pull requests 131 SUCCESS This pull request looks good As soon as this is in my swing branch becomes finally ready for a merge It offers a few simple observables created from button click keyboard and mouse events Looking forward to this',RxJava,true,false,false
13975695,'Added throttle operation to Observable','This pull request adds the throttle operation to the Observable T class see issue #14 In order to test it I also added support for unsubscribing from subscriptions produced by the TestScheduler As always feedback is welcome','Awesome Btw I m not entirely convinced about implementation and usage of Notification T what if T is Exception but that s a completely different story Yes I had some doubts about that too I think the easiest way to fix this is to make three distinct ThrottleAction classes for onNext onError and onCompleted That way we could avoid using Notification all together RxJava pull requests #123 https netflixoss ci cloudbees com job RxJava pull requests 123 SUCCESS This pull request looks good RxJava pull requests #124 https netflixoss ci cloudbees com job RxJava pull requests 124 FAILURE Looks like there s a problem with this pull request Hmm that s strange Locally I don t have any build failures but when looking at the console output of the failed CloudBees build I can see that the rx operators OperatorTester UnitTest testConcurrentNextNext failed Unless I m not aware of it this doesn t seem to be related to the throttle operator Could this test case be faulty RxJava pull requests #125 https netflixoss ci cloudbees com job RxJava pull requests 125 FAILURE Looks like there s a problem with this pull request Afaik a few of the tests fail sporadically quite often though This is one of them Yes CloudBees the CI server has odd thread scheduling it seems very slow machines We have unit tests that rely on Thread sleep timing instead of using latches and barriers to deterministically control when threads are released waited upon etc In general I also question whether we even need a Scheduler for this other than getting now There is extreme overhead in scheduling every single event especially when most will be immediately cancelled Instead we just remember the last value and time since we last sent it on and each time we pass lastSent timeout we emit the next event we receive onCompleted onError we emit immediately regardless of time and skip events until timeout has passed again That way we skip all the scheduling overhead Yes but what happens that when events are few and far apart Without a Scheduler or some sort of timer wouldn t it take extremely long for events to propagate I envision a scenario like this Timeout 1000ms onNext at 50ms delivered immediately onNext at 750ms skipped onNext at 3000ms delivered immediately onNext at 3999ms skipped onNext at 10000ms delivered immediately onNext at 45600ms delivered immediately onCompleted at 45601ms delivered immediately The only time something is skipped is when it s within 1000ms of the previously sent value So the question is are we trying to delivery the latest value within each time window or just deliver a single value per each time window If we choose latest then the above would now look like this Timeout 1000ms onNext at 50ms skipped onNext at 750ms delivered after 250ms delay onNext at 3000ms skipped onNext at 3999ms delivered after 1ms delay onNext at 10000ms delivered after 1000ms delay onNext at 45600ms delivered after 1000ms delay onCompleted at 45601ms delivered immediately I don t know that this behavior is necessary for functionality what we re doing is by definition a race condition anyways and it means that each value waits for timeout to pass before delivery which I think is worse Using a timer for every onNext also means we get all the non determinism of the thread scheduler which on a busy system can be all over the map 10s or 100s of milliseconds of drift easily timers are not very accurate Even if latest in window is the required behavior I d like to look at making it less costly and just changing the value to be delivered in each scheduled onNext via a compareAndSet flip on the currently scheduled ThrottledOnNext rather than cancelling and re scheduling each time We can also do it without the use of synchronized and instead just a CAS operation Before those implementation details though is there strong documentation somewhere dictating whether throttle give the first or last value of a time window The links to MSDN in the issue state the following Ignores the values from an observable sequence which are followed by another value before due time with the specified source and dueTime What I m reading here is that any value which is proceeded so after with another value within a specified period of time will not be published If the value is proceeded after this period of time it is published Although both throttle events they each do it in another way I m all for better performance but I think this breaks a bit too far away from the original specification I believe I m having a hackathon with Erik Meijer next week so I can try to pick his brain on this subject too But I d like to hear more thoughts on this I ll hold off on making changes to this pull request until we have a better view on what we want here Feedback from Erik would be great particularly with the use cases in this discussion shared with him and the performance impact of the decision So I ve been talking with Erik about throttling To make it easier to discuss this operator he suggested making some marble diagrams I ve come up with the following How Rx Net throttles events image https dl dropboxusercontent com s cc5sk7djboqut2j throttle png But I ve also been looking for other throttling schemes Throttling alternative 1 image https dl dropboxusercontent com s ag7jeoeq6wgi8qj throttle passive png Throttling alternative 2 image https dl dropboxusercontent com s j9l0xh1of64qyfn throttle current png To me alternative 1 makes the least sense This publishes an old event in favor of a new event when an event is received And this alternative suffers when the source Observable doesn t publish any events for a while However I do believe there could be a valid use case for it Alternative 2 makes a more sense to me It s very similar to the sample operator This publishes the received event as long as it has not published anything within the timeout period However this operator will not propagate the last event which might be important if the timeout condition was not met I think it s easy to come up with different use cases for each of these three throttling operators which make sense However that said I don t think it would be wise to break consistency with the Net implementation of Rx At the very least I think we should offer the Net version of throttle Alternatively we could offer multiple implementations of throttle using an additional enum parameter This somewhat breaks with the Net implementation different method signature but allows users to pick their own throttling scheme source throttle Scheme ACTIVELY_DELAYED 100 TimeUnit MILLISECONDS source throttle Scheme PASSIVELY_DELAYED 100 TimeUnit MILLISECONDS source throttle Scheme MOST_RECENT 100 TimeUnit MILLISECONDS I d love to hear some thoughts on this I like your thoughts on this I need to spend more time on this than I have right now so will delay a little more We definitely need different implementations the trick is the naming as throttle as named in Rx Net is not at all what anyone I ve asked doing server side Java expects it to do but we want to also match Rx Net as much as possible Your proposed solution is an interesting one I appreciate some other input on the design and naming choices for this before proceeding Anyone else able to get involved since this thread is a bit long it would be easier for folks to jump in and help review if the current design and naming choices were summarized in the PR description I ve updated the PR description with the current state We re basically trying to figure out if we need to support additional different schemes of throttling Observable objects We could use some help nailing down the naming convention for different throttle schemes @mairbek @jmhofer @mttkay would you mind weighing in please The naming convention being proposed is source throttle Scheme ACTIVELY_DELAYED 100 TimeUnit MILLISECONDS source throttle Scheme PASSIVELY_DELAYED 100 TimeUnit MILLISECONDS source throttle Scheme MOST_RECENT 100 TimeUnit MILLISECONDS This addresses the point that throttle is ambiguous and there are different approaches that can be applied with very different behavior These could be given names instead like throttleFirst throttleLast etc but I have yet to determine proper names to handle these I also think an alias for debounce makes sense to represent the throttle solution that UIs use that is the ACTIVELY_DELAYED scheme I believe and I ve seen debounce become normal for describing this in the Javascript community if I understand it correctly I find these operations and names difficult That 2nd alternative doesn t look useful enough to me to include it at all But maybe that s just me Any already established names for these schemes from people already using them would be great to hear Personally I d call the 1st alternative throttleWithDelay or delayedThrottle and throttle for Rx compatibility The 2nd I d probably call throttleToMostRecent I don t know about JS but I agree that it s a good idea to take their naming schemes into account too First I d just like to add that the NET version as illustrated in the first marble diagram if I understand the marble diagram correctly I haven t actually worked with Rx NET before is extremely useful when dealing with user input events It s a pattern I ve used plenty of times before whenever an asynchronous operation needs to be triggered based on user input that changes rapidly A good example is a suggest as you type input field every key stroke triggers an event scheduled for execution but may become obsolete with the next keystroke By cancelling out events that are superseded by subsequent keystrokes and at the same time rescheduling a new one with the same delay t as soon as there are no more keystrokes arriving in t time the next event emitted will reflect the most recent state from the perspective of the user Which brings me to the naming In a way I see variant 0 the NET implementation to carry most recent semantics which sort of conflicts with the naming of alternative 2 If I understand correctly variant 2 works on an absolute time scale rather than a relative one so perhaps that should be reflected in the name I think throttle or say its possible variants carries some similarities to Java s Timer 0 class and variants of the schedule method since it resembles similar notions of time and delays In Timer the schedule method schedules on a relative time scale if the task is scheduled with a delay t but is further delayed for some reason e g garbage collection the next will still be executed with the same delay t With scheduleAtFixedRate time is absolute so if an event execution is delayed further than it should be the the next scheduled execution based on t will account for that by bringing as close as possible to when it should have happened Replacing the potential source of unexpected delays in TimerTasks with a source Observable that may emit events at random points in time the problems bear a lot of similarities I have to say I don t really understand alternative 1 or what it accomplishes So I guess my vote would be source throttle Scheme RELATIVE_DELAY 100 TimeUnit MILLISECONDS source throttle Scheme 100 TimeUnit MILLISECONDS how useful is this anyway source throttle Scheme ABSOLUTE_DELAY 100 TimeUnit MILLISECONDS Hope I m not adding further to the confusion since this seems to go in a different direction in terms of naming and might not align well with alternative 1 either Take it for what it s worth 0 http docs oracle com javase 6 docs api java util Timer html I think the use of enums for giving the schema is awkward considering how different that is compared with the patterns everywhere else in the library though I understand how it could be useful I prefer the throttleLatest throttleRecent style naming convention I agree with @jmhofer and think alternative 1 is likely not worth pursuing at this time unless someone can give a real reason for its existence I suggest the following Rx Net debounce style behavior as throttleLast or throttleWithDelay and have an alias for debounce which as far as I can tell is the same thing from the JS community rate limiting alternative 2 behavior as throttleFirst or throttleToMostRecent Since this is very subjective and arbitrary can folks weigh in one last time with voting on the following options 1 Rx Net Behavior This allows the last value through for a defined time window delaying the delivery until the window is completed to ensure it is the last and provide a regular rhythm of delivery This uses a scheduler a throttleLast b throttleWithDelay c throttleLastWithDelay 2 Rate Limiting without Delay This will allow the first value through for the defined time window without any delay This does not require a scheduler a throttleFirst b throttleWithoutDelay c throttleToMostRecent I d vote for 1b and 2c',RxJava,true,false,false
13984755,'Added the switch operator to Observable','I ve implemented the switch operator for Observable sequences see issue #13 Because switch is a keyword in Java I have opted for switchDo This matches to the finallyDo method which represents the finally operator and has the same naming problem Please let me know if you have any feedback','RxJava pull requests #126 https netflixoss ci cloudbees com job RxJava pull requests 126 SUCCESS This pull request looks good RxJava pull requests #128 https netflixoss ci cloudbees com job RxJava pull requests 128 SUCCESS This pull request looks good Since the onError discussion is now part of an outdated diff moving it here I believe it needs to be this the error should be propagated and all future sequences produced by the parent sequence should be ignored unsubscribed It s the same way with merge zip etc If an error occurs on any sequence it immediately kills the entire sequence and passes the error I could see an overload of switch existing that could add behavior such as onErrorResumeNext so that the user can choose whether to ignore the error and just switch to the next sequence or handle it with a default or something else before switching etc We can t just swallow errors though so if an onError is received from a child sequence it must behave as if the parent received an onError and unsubscribe and pass on the error I ve modified the OperationSwitch class to handle errors in subsequences However I m not entirely convinced yet that unsubscribing from the parent sequence will always work Example If right after subscribing to the parent sequence an error is thrown in a subsequence I ll try to unsubscribe from the parent sequence but it s not guaranteed that the parent variable containing the Subscription to the parent sequence has already been set Ideas thoughts RxJava pull requests #146 https netflixoss ci cloudbees com job RxJava pull requests 146 SUCCESS This pull request looks good RxJava pull requests #147 https netflixoss ci cloudbees com job RxJava pull requests 147 SUCCESS This pull request looks good That s a good point there could be a race condition very unlikely but possible The only way I can think of checking it is keeping a boolean flag that we re supposed to be finished and if we receive more onNext onError notifications we continue to unsubscribe each time and not send those events through I ll make that change as I do some other cleanup before 0 9 is released Thank you @michaeldejong for this submission Actually AtomicObservableSubscription already handles this case in the wrap method java public AtomicObservableSubscription wrap Subscription actualSubscription if this actualSubscription compareAndSet null actualSubscription if this actualSubscription get UNSUBSCRIBED actualSubscription unsubscribe return this throw new IllegalStateException Can not set subscription more than once return this If the wrap occurs after an unsubscribe occurs it will immediately unsubscribe',RxJava,true,false,false
14036779,'Publish Replay and Cache Operators','Added basic Publish https github com Netflix RxJava issues 15 and Replay https github com Netflix RxJava issues 71 operators to Observable I have not done any of the overloads particularly Replay which has 10 in Net I also added a new Cache operator as discussed by @johngmyers and I at https github com Netflix RxJava pull 209 Playing with Replay and ConnectableObservable it does not cater well to the typical use case of needing to just de dupe calls cache the responses so this Cache operator can be thought of as an automatic version of Replay It comes with the same risk as toList if used with infinite or very large sequences as you can not unsubscribe from it','RxJava pull requests #129 https netflixoss ci cloudbees com job RxJava pull requests 129 FAILURE Looks like there s a problem with this pull request RxJava pull requests #130 https netflixoss ci cloudbees com job RxJava pull requests 130 SUCCESS This pull request looks good If anyone has comments on this I d appreciate them in the next 12 hours otherwise I ll release a new version with these and the last few pull requests I ve merged Completed in https github com Netflix RxJava pull 263 after merging with other pull requests that caused conflicts',RxJava,true,false,false
14050025,'Multicast Observable publish','A very little API addition publishing observables without requiring a Subject See #65 and http northhorizon net 2011 sharing in rx','I happened to implement this last night as well as replay and cache in https github com Netflix RxJava pull 260 RxJava pull requests #132 https netflixoss ci cloudbees com job RxJava pull requests 132 SUCCESS This pull request looks good Oh haha funny then this pull request is superfluous Could you take a quick look at the other pull request to confirm correctness of the 3 operators I added a unit test for each of them as well As far as I can see this looks good Thanks @jmhofer',RxJava,true,false,false
14050661,'A few basic Swing observables','This adds a few observables for observing common button click keyboard and mouse events','I haven t played with Swing in a very long time but this looks great RxJava pull requests #133 https netflixoss ci cloudbees com job RxJava pull requests 133 SUCCESS This pull request looks good I don t know I intuitively placed it directly under rx to avoid the rx swing SwingObservable naming redundancy because it s already called SwingObservable I would also be okay with putting everything under rx swing This would mean moving the SwingScheduler too though to something like rx swing concurrency Do we want a parallel package structure for each contributed library A namespaced package makes sense for things that don t fit in the other packages as you ve done but I agree with your assessment of rx swing SwingObservable and rx swing concurrency SwingScheduler being awkward and redundant Perhaps SwingObservable moves into rx observables SwingObservable so that it matches the convention of all Observables other than the main one being inside rx observables Placing it inside rx observables makes sense to me too I guess it s probably better than putting it directly under rx according to the principle of least surprise I ll move it there Okay sorry about being pedantic on this but whatever we do here sets precedent for all modules we add in the future Even this decision leaves open the possibility of naming collisions between modules but I m fine with dealing with that as this approach leaves the usage more natural The only other thing I ve considered is whether it should be SwingObservables with an s at the end similar to Schedulers and Subscriptions since this is just a factory class It doesn t actually extend from Observable so is not an Observable like ConnectedObservable or GroupedObservable No problem I agree that these decisions are quite important I don t mind at all changing this around in order to make the API better Concerning SwingObservable vs SwingObservables I called it like that so that the methods are more DSL like for example SwingObservable fromButtonAction I m okay with naming it SwingObservables too but how to call the methods then Maybe observeButtonActions Or buttonActionObservable assuming the user will probably want to statically import SwingObservables Interesting consideration Subscriptions and Schedulers don t do that great a job in this regard I like the observe verb prefix though it implies it immediately subscribes which it does not it returns a lazy Observable you then observe by subscribing to it I think from toObservable create are the right type of prefixes Still thinking Another consideration nothing prevents extending from Observable in the future to add custom operators specific to Swing Keep it as SwingObservable with from factory methods I think Alright good',RxJava,true,false,false
14052647,'Publish Replay and Cache Operators','Redo of https github com Netflix RxJava pull 260 after merging Added basic Publish https github com Netflix RxJava issues 15 and Replay https github com Netflix RxJava issues 71 operators to Observable I have not done any of the overloads particularly Replay which has 10 in Net I also added a new Cache operator as discussed by @johngmyers and I at https github com Netflix RxJava pull 209 Playing with Replay and ConnectableObservable it does not cater well to the typical use case of needing to just de dupe calls cache the responses so this Cache operator can be thought of as an automatic version of Replay It comes with the same risk as toList if used with infinite or very large sequences as you can not unsubscribe from it','RxJava pull requests #134 https netflixoss ci cloudbees com job RxJava pull requests 134 FAILURE Looks like there s a problem with this pull request Hi I noticed that calling Observable replay doesn t merely wrap the given observable into a ReplaySubject but also combines this with OperationMulticast I have several questions around this 1 Why do this Aren t multicasting and caching replaying both independent concepts in their own right 2 When combined it raises questions about how to deal with the different Subscription instances returned from replay subscribe and replay connect Unfortunately there are no samples or unit integration tests that I m aware of which actually combine both operators so looking at the tests didn t help More precisely ConnectableObservable obs sourceObservable replay Subscription s1 obs subscribe observer Subscription s2 obs connect s1 and s2 are entirely different subscriptions Looking at the sources s1 is a RepeatSubjectSubscription which is put in an internal map and removed upon unsubscription s1 however is an anonymous inner class instance in OperationMulticast which delegates to the subscription the sourceObservable would return normally Now to which one do I hold on and unsubscribe from when I want to go through a disconnect reconnect cycle I actually tried a few combinations and none worked for me I either ended up triggering the sourceObservable twice upon reconnection which I don t want or I end up not getting previous emissions replayed on my observer Any insight around this would be great Have you read this http northhorizon net 2011 sharing in rx It helped me understand it quite a bit Here is a snippet from it Fortunately we have Replay for this It literally has 15 overloads which cover just about every permutation of windowing by count and or time and supplying an optional scheduler and or selector The parameterless call however just remembers everything Replay is just like Publish in the sense that it also forwards a call to Multicast but this time with a ReplaySubject T The reason multicast is involved is because it gives a ConnectedObservable associated with a Subject It supports multiple subscriptions to a single Observable which is exactly what replay and publish both want Anything with ConnectedObservable has the underlying source managed by the ConnectedObservable itself Thus in your example it would be s2 which you then unsubscribe from when you want to shut down the source If you just want simple caching behavior then the cache operator may help since it does not require the ConnectedObservable interaction The ConnectedObservable behavior is important for use cases when the start stop of the underlying sequence needs to be controlled independently of when child subscriptions subscribe unsubscribe The refcount operator is another example we haven t yet implemented this one of controlling this situation I have found cache to be exactly what I need for most use cases though we need to add overloads for time count limits etc as I just want everything replayed as long as the reference is not garbage collected but that is not how ConnectedObservable behaves Hope this helps Thanks @benjchristensen as always this was very helpful I think what got me confused was the terminology The fact that both replay and cache are implemented in terms of ReplaySubject is a little confusing at first the name replay clearly implies that items will be re emitted while cache doesn t make that clear The former wraps the ReplaySubject in a ConnectableObservable using OperationMulticast while the latter simply forwards the subscription to ReplaySubject Re reading the article you posted I did read it before but that was before ReplaySubject had been released so it had slipped off my mind and looking at the implementation would you say this summary is correct replay Creates a connectable event stream where upon reconnection events that had been in flight during the period of disconnection will be replayed onto the observer cache Creates an event stream where upon subscription events will be replayed onto the observer publish Creates a connectable event stream where upon reconnection new events will be received by the observer but events that were in flight during the period of disconnection will not be replayed Sorry I lost this question in my backlog Yes those summaries make sense to me The cache one could be expanded further though Creates an event stream where upon subscription all previously emitted events will be replayed onto the observer and future events if not completed 1',RxJava,true,false,false
14057397,'Merge BehaviorSubject from Pull 256','Manual merge of https github com Netflix RxJava pull 256 Additionally removes SynchronizedObserver usage from Subject implementations We don t need to add synchronization as the subjects can trust their source Observables to comply with the Rx contract This optimization follows Rx Design Guidelines 6 8 Avoid serializing operators This was discussed at https github com Netflix RxJava pull 256','',RxJava,true,false,false
14070730,'Swing component event observables and minor cleanup','Here s another small pull request concerning the Swing contrib With this I think I m very well equipped to start with my little Swing Pong demo','RxJava pull requests #135 https netflixoss ci cloudbees com job RxJava pull requests 135 FAILURE Looks like there s a problem with this pull request Huh Looking into this I amended that latest commit I think I tripped up Cloudbees with that No it s not the amend I m at a loss here Why doesn t gradle compile this RxJava pull requests #136 https netflixoss ci cloudbees com job RxJava pull requests 136 FAILURE Looks like there s a problem with this pull request That s more like it Just one of the sporadic test failures',RxJava,true,false,false
14073638,'change from junit to junit dep','removes Hamcrest dependencies http saltnlight5 blogspot com 2012 10 whats up with junit and hamcrest html solves conflicts on our CI server blocking release to Maven Central','RxJava pull requests #137 https netflixoss ci cloudbees com job RxJava pull requests 137 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
14149889,'CombineLatest without synchronization','Finally I managed to get rid of all the synchronization in CombineLatest it all boils down to two atomics and one concurrent map As concurrency is always hairy to get right Can someone please check that it s okay like that I also added static methods to Observable for it and fixed the handling of exceptions within the combining function','RxJava pull requests #138 https netflixoss ci cloudbees com job RxJava pull requests 138 SUCCESS This pull request looks good Nice Thank you for spending time on this I ll review this as it fits into performance work I need to do such as figuring out non blocking approaches to serialization It will probably not be in the next couple days that I can spend the time as I m deep in integrating RxJava into Hystrix but once my mind and time are cleared I ll definitely get on this and I have family coming into town tonight for the next few days Great and no problem Meanwhile my family is on the road so I m hard at work pushing my Rx Swing Samples https github com jmhofer rxjava samples I look forward to seeing that On Thu May 9 2013 at 10 26 AM Joachim Hofer notifications@github com wrote Great and no problem Meanwhile my family is on the road so I m hard at work pushing my Rx Swing Samples https github com jmhofer rxjava samples Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 267#issuecomment 17677165 Ben Christensen API Team 1 310 781 5511 @benjchristensen RxJava pull requests #139 https netflixoss ci cloudbees com job RxJava pull requests 139 FAILURE Looks like there s a problem with this pull request Sporadic test failure due to Cloudbees slowness RxJava pull requests #142 https netflixoss ci cloudbees com job RxJava pull requests 142 SUCCESS This pull request looks good Sorry to nag but do you still see any problems with this pull request Or are you just swamped with other stuff Sorry it s that I ve been swamped When I started reviewing this it became clear that I needed to dedicate some serious time to understanding it and I haven t gotten back to it I will Alright kind of thought so Anyone else comfortable with concurrency and able to review these changes @jmhofer happy to help review but ask a couple things first add usage example into the PR description undo accidental method reorganization which distracts from your changes rebase and squash into one commit deal @adriancole Thanks for offering to help with the review I added a very simple example This PR doesn t do anything revolutionarily new in regards to usage It just adds direct access to the CombineLatest operator via Observable combineLatest but mostly it s about concurrency Also there are tests that show the usage in quite a lot of detail I don t see any accidental method reorganization I could split this PR up into maybe three even smaller PRs one just introducing the method in Observable one doing the extends super stuff one improving the concurrency but up to now this didn t seem necessary I mean it s 123 90 Could you please detail what you refer to here What would be gained by that You re just losing some admittedly quite optional information about how I went about creating this PR I generally avoid rebasing and all that if there isn t a good reason I mostly agree with http paul stadig name 2010 12 thou shalt not lie git rebase ammend html The combined changes of this PR should be quite clear thanks to git s and github s awesome features https github com Netflix RxJava pull 267 files',RxJava,true,false,false
14207878,'Fix concurrency bug in ScheduledObserver','found a concurrency bug while working on https github com Netflix Hystrix issues 123 the following code would lock up occasionally due to onCompleted not being delivered java public class RunTest public static void main String args System out println Starting test final ArrayList String strings new ArrayList String 200000 int num 10000 while true long start System currentTimeMillis final AtomicInteger count new AtomicInteger for int i 0 i num i new TestService1 2 5 toObservable forEach new Action1 Integer @Override public void call Integer v count addAndGet v new TestService2 hello toObservable forEach new Action1 String @Override public void call String v strings add v long time System currentTimeMillis start long executions num 2 System out println Time time ms for executions executions time 1000 executions microseconds System out println Count count System out println Strings strings size strings clear Also made OperationObserveOn not use ScheduledObserver if the ImmediateScheduler is chosen to allow an optimization I believe this optimization is safe because ScheduledObserver does not require knowledge of a Scheduler such as for now and all we do is emit data to the Observer on a scheduler and if we know it s Immediate we can go direct and skip the enqueuing step This allows shaving off a noticable number of microseconds per execution in the loop above','RxJava pull requests #140 https netflixoss ci cloudbees com job RxJava pull requests 140 SUCCESS This pull request looks good',RxJava,true,false,false
14221858,'Fix concurrency bug in ScheduledObserver','This is a followup to https github com Netflix RxJava commit 1fa6ae3be23200c787cc1c25c0bb8cac99ae0d17 that fixed one issue concurrency and created another broke Rx contract by allowing concurrent execution of onNext I have reverted back to the previous implementatio and then attempted to fix the concurrency issue again I think it ended up being a simple fix just re ordering the enqueue method to remove the race condition between the logic protected by the AtomicInteger and adding to the queue It s not an atomic operation adding then processing so we need to just add to the queue and treat it as an async data structure and keep the AtomicInteger portion to only protecting the process or not process logic java this must happen before counter is used to provide synchronization between threads queue offer notification This may still have issues but it s now working in all of my concurrency tests the ones that broken with the original and then my modified version The tests are not easy to build unit tests out of as they require running for many seconds and non deterministically causing a race condition so I have not yet spend the time to try and figure out a deterministic unit test hence them not being committed','RxJava pull requests #141 https netflixoss ci cloudbees com job RxJava pull requests 141 SUCCESS This pull request looks good',RxJava,true,false,false
14306355,'Blocking behaviour in RxJava','Firstly thanks for a great library I am in the process of getting RxJava to play nicely with Vert x http vertx io If you don t know Vert x it s very roughly a polyglot reactor implementation for the JVM I guess you can think of it superficially as a Node js for the JVM Vert x provides 100 asynchronous APIs for our users and everything is executed on an event loop the exact same thread is always used for any piece of user code Vert x like Node js APIs generally take the form of void doSomething someParam Handler handler where Handler is a callback handler that gets executed asynchronously on the event loop when the result is available The idea with the RxJava module I am developing for Vert x is we can wrap these Vert x APIs so instead of taking Handlers they instead return Observable This means they become composable with RxJava and we can get rid of callback hell Since everything is executed on the event loop in Vert x it s essential that the RxJava API is 100 non blocking Most things do indeed seem to be non blocking but I hit a snag with the concat operation where the subscribe seems unfortunately to be blocking e g Observable Message String concatenated Observable concat obs1 obs2 obs3 concatenated subscribe action This blocks Unfortunately this will cause Vert x to hang since the thread that blocks is the same thread that the events will be delivered on so they will never arrive Looking at the code in OperationConcat java I can see that a CountDownLatch is being used I can t see a good reason why any of the main operations in RxJava including concat can t be implemented in a 100 non blocking way and this would be essential for Vert x to use them Do you have any plans to refactor concat to work in a non blocking way We would love to use RxJava in Vert x and I think Vert x would be a good vehicle to push RxJava to an even bigger audience Thanks in advance Also I noticed that last is also blocking which makes it unusable in Vert x or any non blocking system Again I can t see a reason why it has to be','In Rx NET all blocking operators are deprecated so perhaps we should not have Last in RxJava however if you really want the last value of a stream you ultimately need to block somewhere your main program cannot terminate before seeing it You may also see some operators blocking when you use their default schedulers where the assumption is that in the typical case they perform a small amount of work which is debatable In addition to providing await support for observable sequences we ve also added Async variants of a number of operators First of all we ve deprecated blocking operations in favor of asynchronous ones Those include First OrDefault Async Last OrDefault Async Single OrDefault Async ForEachAsync On May 14 2013 at 5 03 AM Tim Fox notifications@github com wrote Firstly thanks for a great library I am in the process of getting RxJava to play nicely with Vert x http vertx io If you don t know Vert x it s very roughly a polyglot reactor implementation for the JVM I guess you can think of it superficially as a Node js for the JVM Vert x provides 100 asynchronous APIs for our users and everything is executed on an event loop the exact same thread is always used for any piece of user code Vert x like Node js APIs generally take the form of void doSomething someParam Handler handler where Handler is a callback handler that gets executed asynchronously on the event loop when the result is available The idea with the RxJava module I am developing for Vert x is we can wrap these Vert x APIs so instead of taking Handlers they instead return Observable This means they become composable with RxJava and we can get rid of callback hell Since everything is executed on the event loop in Vert x it s essentially that the RxJava is 100 non blocking Most things do indeed seem to be non blocking but I hit a snag with the concat operation where the subscribe seems unfortunately to be blocking e g Observable concatenated Observable concat obs1 obs2 obs3 concatenated subscribe action This blocks Unfortunately this will cause Vert x to hang since the thread that blocks is the same thread that the events will be delivered on so they will never arrive Looking at the code in OperationConcat java I can see that a CountDownLatch is being used I can t see a good reason why any of the main operations in RxJava including concat can t be implemented in a 100 non blocking way and this would be essential for Vert x to use them Do you have any plans to refactor concat to work in a non blocking way We would love to use RxJava in Vert x and I think Vert x would be a good vehicle to push RxJava to an even bigger audience Thanks in advance Also I noticed that last is also blocking which makes it unusable in Vert x or any non blocking system Again I can t see a reason why it has to be Reply to this email directly or view it on GitHub Thanks I m not to bothered about last it s really the blocking nature of the concat operator which is the main problem On 14 05 13 16 12 headinthebox wrote In Rx NET all blocking operators are deprecated so perhaps we should not have Last in RxJava however if you really want the last value of a stream you ultimately need to block somewhere your main program cannot terminate before seeing it You may also see some operators blocking when you use their default schedulers where the assumption is that in the typical case they perform a small amount of work which is debatable In addition to providing await support for observable sequences we ve also added Async variants of a number of operators First of all we ve deprecated blocking operations in favor of asynchronous ones Those include First OrDefault Async Last OrDefault Async Single OrDefault Async ForEachAsync On May 14 2013 at 5 03 AM Tim Fox notifications@github com wrote Firstly thanks for a great library I am in the process of getting RxJava to play nicely with Vert x http vertx io If you don t know Vert x it s very roughly a polyglot reactor implementation for the JVM I guess you can think of it superficially as a Node js for the JVM Vert x provides 100 asynchronous APIs for our users and everything is executed on an event loop the exact same thread is always used for any piece of user code Vert x like Node js APIs generally take the form of void doSomething someParam Handler handler where Handler is a callback handler that gets executed asynchronously on the event loop when the result is available The idea with the RxJava module I am developing for Vert x is we can wrap these Vert x APIs so instead of taking Handlers they instead return Observable This means they become composable with RxJava and we can get rid of callback hell Since everything is executed on the event loop in Vert x it s essentially that the RxJava is 100 non blocking Most things do indeed seem to be non blocking but I hit a snag with the concat operation where the subscribe seems unfortunately to be blocking e g Observable concatenated Observable concat obs1 obs2 obs3 concatenated subscribe action This blocks Unfortunately this will cause Vert x to hang since the thread that blocks is the same thread that the events will be delivered on so they will never arrive Looking at the code in OperationConcat java I can see that a CountDownLatch is being used I can t see a good reason why any of the main operations in RxJava including concat can t be implemented in a 100 non blocking way and this would be essential for Vert x to use them Do you have any plans to refactor concat to work in a non blocking way We would love to use RxJava in Vert x and I think Vert x would be a good vehicle to push RxJava to an even bigger audience Thanks in advance Also I noticed that last is also blocking which makes it unusable in Vert x or any non blocking system Again I can t see a reason why it has to be Reply to this email directly or view it on GitHub Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 270#issuecomment 17882444 Hi Tim Great to hear from you Vert x is what I tell everyone they should use when they talk about Node js and I d be happy to work with you to resolve any issues preventing adoption of Rx inside Vert x as I feel they are a perfect fit for each other it s unfortunate to see promises become the standard in many other libraries and frameworks when Rx Observable Observer can handle the promise use cases plus sequences event notifications infinite streams scheduling etc while still retaining a simple mental model The idea with the RxJava module I am developing for Vert x is we can wrap these Vert x APIs so instead of taking Handlers they instead return Observable This sounds perfect and exactly what I would like to see when using the Vert x APIs Most things do indeed seem to be non blocking but I hit a snag with the concat operation where the subscribe seems unfortunately to be blocking The blocking nature of concat is a bug as it is supposed to be non blocking I or someone else can get on fixing that As for the blocking operators I d really like to remove them from Observable and perhaps put them in a BlockingObservable where people can use them if they want For example java BlockingObservable from normalObservable single When we started with RxJava internally we didn t have any blocking operators as the whole point of this library for us was non blocking composition of asynchronous Observables They have been contributed since becoming open source and I ve been allowing them in so far since that is how Rx Net does it and we ve been trying to conform to Rx Net as closely as possible but I ve been wanting to find a way to separate them that still maintains the spirit of that principle @headinthebox Thanks Erik for getting involved For anyone who does not know who Erik Meijer is he is the inventor of Rx and was behind the original implementation at Microsoft Erik due to your statement would you be comfortable with me pulling all of the blocking operators into a separate BlockingObservable that people can use if they want The benefit to me is that they are still there for people consciously choosing to use them so they don t lose that functionality but they would not be part of the main Observable behavior and thus not confuse people and cause people to accidentally block such as the difference between last and takeLast I would like to do this soon as part of version 0 9 and get the breaking changes out of the way before major systems get too far integrated example at Netflix I ve been struggling with how to prevent use of blocking operators in a graceful way in our API layer I have reserved the right to do breaking changes for things such as this until we hit 1 0 which is still a bit out to ensure we get the long term design correct I think this deserves the change as I m not happy with where we ve ended up mixing blocking and non blocking operators Hi Ben Thanks for the reply Glad to hear that the blocking nature of concat is not intended 1 on the idea to move all the blocking stuff out I think it would be cleaner to keep it nice and 100 non blocking @purplefox Once we get these issues resolved both have pull requests for review right now is there anything else preventing adoption Now that 0 9 0 is released can you confirm whether this issue is resolved or not Thanks Ben I will take it for a spin ASAP Closing out as I believe this is resolved If anything is blocking in 0 9 or later other than in BlockingObservable then please file another issue or re open this one',RxJava,false,false,false
14330613,'Rewrite concat operation to not block on subscribe','Hi While trying to stop the subscribe function from blocking I ended up rewriting the most of the concat operation From related issue discussions it appears the desired behaviour is still under debate so I hope you agree on the chosen approach See the explanation below Because practically it implements two asynchronous observers that interact with eachother there are quite a few possible race conditions and other possibilities to break the Rx grammar but I hope I fixed all of them Regards Gerben The concat operator previously blocked on calling subscribe until all the sequences had finished In quite some cases this results in unwanted and unexpected behaviour such as when prefixing an infinite Observable with a fixed one for example when using startWith which calls concat someInputStream startWith 123 subscribe x print x This statement will block indefinitely if the input stream is infinite Also on finite sequences it seems silly to have to wait for them to finish In this new approach the incoming observables are put into a queue instead of waiting for the whole sequence to finish When the first observable completes the next one is taken from the queue and subscribed to and so on The queue can be extended while processing the observables and onCompleted is only called when both the source of observables has completed and all observables in the queue have been read','RxJava pull requests #143 https netflixoss ci cloudbees com job RxJava pull requests 143 SUCCESS This pull request looks good That sounds like exactly what we want and discussed this morning at https github com Netflix RxJava issues 270 I don t have time to review right this minute but will do so this week as I d like concat to be non blocking for the 0 9 release Thank you Thanks for the fix The code looks good and I have added new unit test to check for subscribe returning before the Observable of Observable onComplete is called',RxJava,true,false,false
14331541,BlockingObservable,'Move all blocking operators to BlockingObservable This has breaking changes for anything using blocking operators part of the pursuit of establishing a clean API on our path to 1 0 This is something I ve been wanting to do for a while but got the push over the ledge via discussion at https github com Netflix RxJava issues 270 This strays from match Rx Net as closely as possible but feels justified for the following reasons Rx is primarily intended for asynchronous event handling and composition mixing blocking and non blocking operators is confusing and leads to poor usage patterns mixing blocking operators like take and takeLast is non obvious Rx Net intends on deprecating or has already blocking operators as per Erik Meijer @headinthebox in this discussion https github com Netflix RxJava issues 270#issuecomment 17882444 I have removed all blocking operators from Observable and put them in BlockingObservable I have left Observable toBlockingObservable as a means of going from one to the other as it is an obvious communication of what is now being permitted While doing this I also cleaned up some odd API artifacts such as toObservable vs from and moved implementation specific code from rx util into the internal package rx operators where all code reserves the right to change at any time I intend on releasing this as version 0 9','RxJava pull requests #144 https netflixoss ci cloudbees com job RxJava pull requests 144 FAILURE Looks like there s a problem with this pull request RxJava pull requests #145 https netflixoss ci cloudbees com job RxJava pull requests 145 SUCCESS This pull request looks good Apparently another non deterministic test testConcatUnsubscribe revealed by the always non deterministically slow CloudBees second attempt succeeded and it passes on my machine I plan on merging this tomorrow morning Thursday May 16th Pacific time if no strong reasons are given for not proceeding No feedback to argue against proceeding so merging now',RxJava,true,false,false
14384628,Concat,'Add new unit test to cover non blocking subscribe for Concat operator','RxJava pull requests #148 https netflixoss ci cloudbees com job RxJava pull requests 148 SUCCESS This pull request looks good Thank you @Treora for fixing this and @billyy for the code review and new unit tests',RxJava,true,false,false
14430736,'0 9 cleanup','','RxJava pull requests #149 https netflixoss ci cloudbees com job RxJava pull requests 149 SUCCESS This pull request looks good',RxJava,true,false,false
14431119,'Move forEach to BlockingObservable','was missed in previous refactoring','RxJava pull requests #150 https netflixoss ci cloudbees com job RxJava pull requests 150 SUCCESS This pull request looks good',RxJava,true,false,false
14564897,'Adding a no op action','I m honestly not convinced this is even the Rx way of doing things but I ended up adding a pre defined no op action to our codebase that I found myself using quite a bit It s basically the counterpart to Observable empty and allows you to register an empty Observer by supplying a no op onNext Action I guess the problem is that once you adopt Rx throughout the codebase you will want to use it to schedule work that you may not actually want to observe i e fire and forget As far as I know there is no way to subscribe a no op to an Observable yet so similarly to the Functions class would it be useful to have an Actions class with predefined reusable action objects such as Actions empty Sample use serviceObject createThing subscribe Actions empty Depending on what Thing is I might not actually be interested in the result so an empty callback is what I want','In a somewhat related idea I have used an Observable Void for a creation API The Observable doesn t call the onNext but does call onError or onComplete This has been implemented with an empty subscribe https github com Netflix RxJava blob master rxjava core src main java rx Observable java#L323',RxJava,false,false,false
14649105,'Finally Happens after onCompleted','Looks like finallyDo is behaving wrong groovy package rx lang groovy examples import rx Observable class Testing static class myActionClass implements rx util functions Action0 void call println Finally static main args def myAction new myActionClass def numbers Observable toObservable 1 2 3 4 5 numbers finallyDo myAction subscribe onNext println it onCompleted println Sequence complete onError println Error encountered Output 1 2 3 4 5 Sequence complete Finally I believe Finally should happen before Sequence Completed','This issues was raised when finally PR was being sent https github com Netflix RxJava pull 196#issuecomment 15026180 Here is the C# equivalent code I just checked with c# using System using System Reactive Linq var members new 1 2 3 4 5 ToObservable members Finally Console WriteLine Finally Subscribe Console WriteLine next Console WriteLine exception Console WriteLine Sequence Completed Output 1 2 3 4 5 Sequence Completed Finally Current behavior is correct Great Thank you for confirming with C# code',RxJava,false,true,true
14770037,'Rx Guideline 6 5 Subscribe implementations should not throw','Some flavours of subscribe seem to ignore this guideline in the case that the given final Object onNext is null for example Observable java 366 public Subscription subscribe final Object onNext final Object onError lookup and memoize onNext if onNext null throw new RuntimeException onNext must be implemented final FuncN onNextFunction Functions from onNext This behaviour could be deliberately chosen but then I wonder why other flavours of subscribe those where an Action1 T is passed do neatly follow this guideline and only throw when onNext is actually being called Observable java 428 public void onNext T args if onNext null throw new RuntimeException onNext must be implemented onNext call args Moreover I would actually expect both cases to call onError instead of throwing an Exception though this could perhaps be defended and for sure you would want to fix issue #198 first It seems strange to me however that there is this difference in behaviour between passing an Object and passing an Action1 for onNext or am I missing something','The idea is that if calling a method with specific arguments for handlers that null should not be passed in and that this is considered a programmer error thus throwing an exception rather than invoking onError In short this is argument validation Any difference between Action1 or Object being passed in is a bug they should behave the same and we re actively working on getting rid of the Object overloads while still supporting the various languages While glancing through the code I see for example what appears to be the result of refactoring placing the null check inside the onNext call instead of at the top of the method as an argument validation https github com Netflix RxJava blob master rxjava core src main java rx Observable java#L428 I consider that incorrect as these are basically intended to be checking that the handlers passed in are valid and thus should be done before any actual Observable logic is invoked Okay it s clarifying to hear the incongruity between Objects and Action1 s is an error Whether they should throw an exception or call onError is defensible in favor of either and perhaps not very important I would actually choose the latter as it allows to handle all errors in one place and makes calling subscribe a bit simpler try catch never needed but having to do a null check before calling subscribe sounds tolerable If both onNext and onError are null then an exception will still be thrown anyway if #198 gets fixed',RxJava,false,false,false
14858824,'Adding marble diagrams','several new marble diagrams for previously undiagrammed methods','Awesome Thanks David RxJava pull requests #151 https netflixoss ci cloudbees com job RxJava pull requests 151 SUCCESS This pull request looks good',RxJava,true,false,false
14859978,'Diagrams and some new javadoc content for Observable subclasses','Some marble or marblish diagrams and a bit of new documentation for the BlockingObservable and ConnectableObservable subclasses','RxJava pull requests #152 https netflixoss ci cloudbees com job RxJava pull requests 152 SUCCESS This pull request looks good',RxJava,true,false,false
14915166,'Operation buffer','This was quite a big one but I ve managed to implement all buffer operations as referenced in issue #16 For convenience I ve opted to make BufferClosing and BufferOpening interfaces and provided simple implementations in BufferClosings and BufferOpenings As always feedback is welcome','RxJava pull requests #153 https netflixoss ci cloudbees com job RxJava pull requests 153 SUCCESS This pull request looks good Thank you @michaeldejong I will review and either merge or provide feedback This is a great piece of code @michaeldejong I don t fully understand all the nuances yet but I m going to start posting some questions inline on the code The code looks good and is very well documented and the unit tests are awesome very key to me understanding the code Alright let me try to explain this There are two parameters to this specific buffer operation Observable BufferOpening Func1 BufferOpening Observable BufferClosing The Observable BufferOpening produces a BufferOpening object at times 50 and 200 The Func1 BufferOpening Observable BufferClosing when called produces an Observable BufferClosing which produces a BufferClosing object after a delay of 100 So in essence this test should see two non connected buffers being created Buffer 1 from 50 to 150 Buffer 2 from 200 to 300 If we apply this operator with these parameters to the source Observable String then Buffer 1 should contain two three and Buffer 2 should contain five I m not entirely sure why they Rx NET opted for a Func1 over a single Observable but this is the only thing that made sense to me Suppose for instance the following You create a buffer t 50 and you create another buffer at t 100 At t 150 you want to close the buffer created at t 100 and at t 200 you want to close the buffer created at t 50 The only way to do this is with multiple Observable BufferClosing s one for each buffer dictating when to close it I hope this makes some sense RxJava pull requests #166 https netflixoss ci cloudbees com job RxJava pull requests 166 FAILURE Looks like there s a problem with this pull request @michaeldejong Sorry for not responding to this yet I will but have become very busy on some other things for a bit Anyone else interested and able to provide a code review @michaeldejong at nearly 1500 concise lines of code and tests this PR could be daunting for someone to start reviewing I d estimate review at somewhere around an hour minimum Why don t you draw in folks in by adding usage examples into your PR description as a first step Ask someone who uses javarx if they don t mind taking a pass at review I can make time next week sometime too RxJava pull requests #169 https netflixoss ci cloudbees com job RxJava pull requests 169 FAILURE Looks like there s a problem with this pull request I ve updated the PR description with an explanation of what each operator variation does and how it does it I hope this helps in understanding the concepts behind this operator FYI might want to bump this commit as I think the above failure might be transient @michaeldejong Can you respond to Ben s question about the test returning 3 empty events RxJava pull requests #179 https netflixoss ci cloudbees com job RxJava pull requests 179 FAILURE Looks like there s a problem with this pull request RxJava pull requests #180 https netflixoss ci cloudbees com job RxJava pull requests 180 SUCCESS This pull request looks good',RxJava,true,false,false
14949804,'PublishSubject s HashMap makes groupBy and such non deterministic','In a few cases already I noticed unexpected and non deterministic behaviour occurring when subscribing directly or via a chain of observables to a PublishSubject source This happens when subscribing from within an onNext method that is directly or indirectly triggered by that same source The newly subscribed observer may or may not directly receive the onNext call from the same event An example where this is annoying connectToEventStream publish groupBy event event source subscribe eventStream LogFile log new LogFile eventStream getKey log eventStream subscribe event log write event getMessage In this example the first event of each source might be skipped and not be logged but other times it will work fine To me this seems undesired behaviour There may be cases where it actually is preferable that the current item will be skipped when subscribing from an onNext method but this happening unpredictably is never a good idea The cause of the unpredictability is the implementation of Map that is used in PublishSubject which when iterating on the map s values sometimes includes new items Similarly Iterators and Enumerations return elements reflecting the state of the hash table at some point at or since the creation of the iterator enumeration And supposedly whether an item will be iterated over or not depends on the hashes of the subscriptions thus totally unpredictable A sensible option would be to use a different implementation of Map that does iterate over any items that are added during the iterating loop but it looks like this implementation then has to be written or found first as java seems not to provide anything like this As a quick hack I added this code to the PublishSubject but I considered this solution too ugly to be worth a pull request commit a7fc861 public void onNext T args int observersSize Set Observer T notifiedObservers new HashSet Observer T do observersSize observers size for Observer T observer observers values if notifiedObservers contains observer observer onNext args notifiedObservers add observer while observers size observersSize','Short Version It looks like a bug with groupBy not publish Long Version PublishSubject will send events through to whatever subscribers it currently has and not replay past events as new subscribers arrive This is why the publish operator returns a ConnectedObservable that allows a developer to wait for all Observers to subscribe and then connect the source that is publishing The ConcurrentHashMap implementation of Map used by PublishSubject is the correct thread safe implementation to be using It allows concurrent modifications and each time values is invoked on each onNext call it gives the current state of the data all subscribers in the map in a thread safe manner Thus it is thread safe for the onNext call to continue being invoked while subscribers come and go but it will naturally be a race condition as to whether the subscription occurs before or after the onNext if they are done concurrently As to the issue you re seeing I think it s not PublishSubject with the issue but the implementation of groupBy which seems to re subscribe to the underlying Observable on each group that gets emitted That would definitely not work well with publish since it would not receive the item previously emitted only subsequent ones I have replicated the issue and see this in my output Subscribing to EventStream PublishSubject onNext Event source 0 message Event 0 observers 1 GroupedObservable Key 0 PublishSubject onNext Event source 1 message Event 1 observers 2 GroupedObservable Key 1 Source 1 Message Event 1 PublishSubject onNext Event source 0 message Event 2 observers 3 Note how the observers count increases as each group is triggered The first observer is the groupBy and the following two are the observer for each of the 2 groups Removing the publish operator this is confirmed here Subscribing to EventStream GroupedObservable Key 0 Subscribing to EventStream Source 0 Message Event 0 GroupedObservable Key 1 Subscribing to EventStream I don t have time tonight to figure out what needs to change with groupBy but from what I can tell this is definitely a bug Regarding the given sample code since the publish operator is not going to publish anything unless connect is invoked on it so I assume that sample code is just representative as it will not actually emit any data The code would need to look more like this java ConnectableObservable Event es connectToEventStream publish es groupBy event event source subscribe eventStream eventStream subscribe event System out println event message es connect I also generally recommend not doing nested subscribes as the control of the subscriptions is lost java ConnectableObservable Event es connectToEventStream publish es groupBy event event source mapMany eventGroupedObservable return eventGroupedObservable map event return Source event source Message event message subscribe outputMessage System out println outputMessage es connect Are you using publish just to handle groupBy subscribing to it multiple times or do you have multiple legit subscribers to the same eventstream Following is the full test case I built in normal Java so it fits into the Java 6 project and not Java 8 so it is far more verbose java package rx subjects import static org junit Assert import java util concurrent CountDownLatch import java util concurrent TimeUnit import java util concurrent atomic AtomicInteger import org junit Test import rx Observable import rx Observer import rx Subscription import rx observables ConnectableObservable import rx observables GroupedObservable import rx subscriptions Subscriptions import rx util functions Func1 public class TestPublishSubject @Test public void testPublishCount throws Exception final AtomicInteger counter new AtomicInteger final CountDownLatch latch new CountDownLatch 1 int count 100 ConnectableObservable Event es connectToEventStream count publish Observable Event es connectToEventStream count es groupBy new Func1 Event Integer @Override public Integer call Event e return e source mapMany new Func1 GroupedObservable Integer Event Observable String @Override public Observable String call GroupedObservable Integer Event eventGroupedObservable System out println GroupedObservable Key eventGroupedObservable getKey return eventGroupedObservable map new Func1 Event String @Override public String call Event event return Source event source Message event message subscribe new Observer String @Override public void onCompleted latch countDown @Override public void onError Exception e e printStackTrace latch countDown @Override public void onNext String outputMessage System out println outputMessage counter incrementAndGet es connect latch await 5000 TimeUnit MILLISECONDS assertEquals count counter get public static Observable Event connectToEventStream final int count return Observable create new Func1 Observer Event Subscription @Override public Subscription call final Observer Event observer System out println Subscribing to EventStream new Thread new Runnable @Override public void run for int i 0 i count i Event e new Event e source i 2 e message Event i observer onNext e try Thread sleep 50 catch Exception ex ignore start return Subscriptions empty public static class Event int source String message @Override public String toString return Event source source message message Thanks for the elaborate reply From your answer I draw the conclusion that both PublishSubject and groupBy contain an error PublishSubject You say that on a call to onNext PublishSubject should take its current list of subscribed observers and iterate over those However your following assumption looks incorrect each time values is invoked on each onNext call it gives the current state of the data all subscribers in the map in a thread safe manner ConcurrentHashMap values 1 however does not return a snapshot of the map s values The collection is backed by the map so changes to the map are reflected in the collection and vice versa And as quoted before the iterator does not make guarantees about including or excluding items that are added to the map after creation of the iterator from the same doc 2 Similarly Iterators and Enumerations return elements reflecting the state of the hash table at some point at or since the creation of the iterator enumeration Those two properties combined allow PublishSubject onNext to sometimes include observers that are added while iterating And at least in the implementation I am using OpenJDK8 it does this unpredictably presumably based on hash values I guess this bug should be fixed either by always including the newly added observers or by always excluding them You say they should be excluded I think this does sound like the most intuitive behaviour but maybe it would be more practical to opt for including them as for example it would directly fix the problem with groupBy I do not know which behaviour would be desired in other cases that means any case where one possibly indirectly subscribes to a PublishSubject as a reaction to an indirect onNext from that same PublishSubject via nested subscribes or mapMany or whatever A reason to include them could be that you can always use skip 1 to exclude them Actually the other way around can also be realised by calling onNext on the new observer when subscribing it to the PublishSubject though this looks a bit more hacky as you re calling onNext from a different place and maybe even a different thread 1 http docs oracle com javase 6 docs api java util concurrent ConcurrentHashMap html#values 2 http docs oracle com javase 6 docs api java util concurrent ConcurrentHashMap html groupBy If you choose to exclude newly added observers then there indeed also is a bug in groupBy I do not know how to solve this if you would want groupBy to keep re subscribing to the underlying source for each new group A possibility would be that groupBy dispatches the incoming items to the appropriate self produced observables which would then behave like or be PublishSubjects As an example what should this rather contrived code do java randomIntSource groupBy x x 2 mapMany subsource Counter counter new Counter return subsource map x counter subscribe counter counter increment It would currently create a new random source for the even numbers and one for the odds though my first expectation would be that it would allow to count the amount of evens and odds in a single random source About my example code in the first post I indeed forgot the connect call Are you using publish just to handle groupBy subscribing to it multiple times or do you have multiple legit subscribers to the same eventstream That was just to keep the example short In real code I usually have one observable that reads incoming events and then I publish it to allow several observers to read the events some of which may want to use groupBy Thanks for the tip to use mapMany I had not used it before When more group dependent variables are used in the observer I guess mapMany becomes less convenient though and nesting subscribes becomes the more legible way Why do you consider the following to be a bug and how does this have anything to do with the groupBy issue Those two properties combined allow PublishSubject onNext to sometimes include observers that are added while iterating This is done in a thread safe manner as that is the point of ConcurrentHashMap and seems perfectly reasonable and correct for concurrent pub sub behavior The nature of PublishSubject is that it will receive subscriptions concurrently with onNext invocations Thus as expected with concurrent pub sub it is always a race as to whether a given observer will be part of a given onNext event If the pub sub always occurs between onNext boundaries then there will be no race If the pub sub is not being concurrently modified then none of this applies Here is a flow showing concurrent subscriptions publish subject https f cloud github com assets 813492 592913 28bffd84 ca28 11e2 9f5b c783cef0eb81 png nesting subscribes becomes the more legible way I would suggest you re consider as you lose the subscription and it can result in memory leaks observable sequences never closing and other such behavior You can read others saying the same thing here http www introtorx com content v1 0 10621 0 07_Aggregation html The code above would work but it is not good practice to have these nested subscribe calls We have lost control of the nested subscription and it is hard to read When you find yourself creating nested subscriptions you should consider how to apply a better pattern Why do you consider the following to be a bug and how does this have anything to do with the groupBy issue When one subscribes to the pubsub from a different thread it is indeed totally reasonable that he may or may not receive the item that is currently being handled What I am talking about is the case where one subscribes to the pubsub from the _same_ thread as where the pubsub onNext is being handled This happens when in the image B onNext 8 will subscribe a new observer D to the pubsub The question is then whether this D will or will not receive the value 8 As this is all happening in a single thread there is no need for this action to be unpredictable The subscription of D is undoubtably happening _after_ pubsub onNext was called because it was _caused_ by it That makes it weird that D only _might_ receive 8 because there is no race condition It either should or it should not include D in the set of obervers that receive 8 depending on which behaviour you want pubsub to have as discussed in my last post To extend the image publishsubjectissue https f cloud github com assets 4191409 593119 5f4498ea ca2f 11e2 8639 5dda6c06e8c8 png The relation to groupBy What groupBy does is emitting observables that are descendents of its own source When using groupBy on a pubsub when one subscribes to these emitted observables using nested subscribes or mapMany or whatever the situation described above occurs perhaps with some operators between B onNext and pubsub subscribe D This results in not knowing whether or not the first item of the group will be received I hope my explanation is clear enough just let me know if it is not or if you find some flaw in my thoughts That makes it weird that D only might receive 8 because there is no race condition Can you give me a test case when an onNext action re subscribes to the same PublishSubject on the same thread and it behaves non deterministically the situation described above occurs perhaps with some operators between B onNext and pubsub subscribe D That is the bug with groupBy it should not re subscribe Please review these changes https github com Netflix RxJava pull 283 This unit test in particular was derived from this discussion https github com Netflix RxJava pull 283 files#L0R365 That commit looks like a good step on first impression I will scrutinize it tomorrow or Monday I just read the Rx Net implementation of groupBy which works in a similar way as your newly committed one but I also still have to figure out if there are some bugs in there or if I just don t fully understand it yet I will also write an example for PublishSubject I replaced pull #283 with https github com Netflix RxJava pull 284 Hi I did not have time to scrutinize your code today I will do so tomorrow Here https gist github com Treora 5699048 is an example that shows the unpredictable results of PublishSubject Implemented once using nested subjects and once using mapMany It does use lambda expressions I hope that s not a problem for you Thanks for those code examples I m able to replicate the issue and working on a fix I updated PublishSubject to take snapshots of the subscribed observers before iterating so that it behaves deterministically and only emits value to observers already subscribed once onNext starts This makes the nested subscription behavior deterministic What it was doing before was allowing new subscriptions from the nested subscribes to get into the iteration and that is based on the internal data structure and likely as you suggest the hashing of the object id which is the only variant that changes between each run The unit test for this is at https github com Netflix RxJava pull 288 files#L0R479 The specific fix for onNext is this line https github com Netflix RxJava pull 288 files#L0R162 Please review these changes #283 I first looked into how the Rx Net implementation of groupBy works which took longer than I wanted because of some bugs in there more on this below and then read your committed code #284 and tested it I have four comments on your code 1 There was a small error in using the numGroupSubscriptions counter causing it to drop the parent subscription too eagerly I added a unit test for it and then fixed it in commit 22cd318 Maybe it still needs some locking though to prevent race conditions 2 Is there a reason to allow only one observer to listen to a group I guess the alternative would be to use a PublishSubject for each GroupedObservable Rx Net also works this way it wraps a Subject the equivalent of PublishSubject into a GroupedObservable object No need to worry about the problem of PublishSubject omitting the current item as it will not occur here because observer onNext gs 1 is finished before gs onNext value value 2 is called I did not make this change 3 The same question can be asked for GroupBy itself it also does not allow subscribing more than once I assume this is an error and fixed this commit fc89a79 by putting some fields and methods into the spawned Observer instead of in the GroupBy class I named this formerly anonymous class GroupByObserver The GroupedObservables now regard this GroupByObserver instead of the GroupBy object as their parent Perhaps it would be nice to create a RefCountSubscription class like Rx Net has to group the reference counting logic in there instead of scattering it around GroupBy and GroupByObserver 4 Should it maybe be disallowed to subscribe to a group after the primary observer the one receiving the GroupedObservables has been unsubscribed See the thoughts on this further below 1 https github com benjchristensen RxJava commit e14449ac44210c292a796ca34b5beab5ed975691#L0R110 2 https github com benjchristensen RxJava commit e14449ac44210c292a796ca34b5beab5ed975691#L0R116 Rx Net Actually it looks like Rx Net suffers some problems with the subscriptions itself so I spent a while trying to figure out how it should work Could someone with a NET development environment and more C# skills than I have perhaps test whether I really found some bugs here or if I am talking nonsense @headinthebox Erik what do you think about the groupBy issues described below 1 GroupBy GroupBy cs creates a Sink an Observer on subscribe which spawns GroupedObservables which keep references to the _refCountDisposable field in GroupBy while instead this field should be in the Sink that spawned them If I understand correctly when subscribing two observers to one groupBy operator this will lead to being unable to unsubscribe the first one This is problem is similar to my third comment above 2 Apart from that it looks like a subscription to a GroupBy Observable will keep emitting new GroupedObservables even when it has been unsubscribed from The used RefCountDisposable RefCountDisposable cs is made to unsubscribe from the source only when the primary observable and all emitted observables have been unsubscribed from which is fine but then the created Sink should check if it has been disposed of before it emits a new GroupedObservable In essence it needs a line like this if _refCountDisposable isPrimaryDisposed before doing this _observer OnNext group GroupBy cs 3 A third quirk in Rx Net is that whether one can still subscribe to a GroupedObservable can depend on if any other GroupedObservables are still having any subscribers The RefCountDisposable disposes of its core disposable when both the primary observer and all emitted observables have unsubscribed If one subscribes to a GroupedObservable hereafter no items will be received anymore However if some other subscription to some GroupedObservable of another group is still keeping the RefCountDisposable alive the new subscription will receive items This could lead to unexpected behaviour Behaviour of groups after unsubscribing the primary observer A question to be answered here for both Rx Net and RxJava is how the groupBy should behave after unsubscribing the primary observer Should we still be able to subscribe to the GroupedObservables that were emitted earlier If not the mentioned third quirk in Rx Net could be fixed by allowing to subscribe to a GroupedObservable only when the RefCountDisposable s _isPrimaryDisposed is false again we need an isPrimaryDisposed method A similar thing can be done in RxJava by checking unsubscribeRequested when subscribing to a GroupedObservable If you do want to allow storing the GroupedObservables for later use after the GroupByObservable has been disconnected from the approach of groupBy forms a problem because then we can never know if we can unsubscribe so it may be better to opt for the first type of behaviour The most normal usage of groupBy is to subscribe directly anyway so the issue is probably not noticed often but still it would be best if it does not produce weird results when it is used differently GroupBy cs http rx codeplex com SourceControl latest#Rx NET Source System Reactive Linq Reactive Linq Observable GroupBy cs RefCountDisposable cs http rx codeplex com SourceControl latest#Rx NET Source System Reactive Core Reactive Disposables RefCountDisposable cs @zsxwing This is another if you have the interest that could use someone s attention and is rather important @benjchristensen I ll try to handle it Thank you @zsxwing Closing this and it will be addressed via https github com Netflix RxJava issues 570',RxJava,false,false,false
15017303,'GroupBy GroupedObservables should not re subscribe to parent sequence','https github com Netflix RxJava issues 282 Refactored to maintain a single subscription that propagates events to the correct child GroupedObservables','RxJava pull requests #154 https netflixoss ci cloudbees com job RxJava pull requests 154 FAILURE Looks like there s a problem with this pull request RxJava pull requests #155 https netflixoss ci cloudbees com job RxJava pull requests 155 FAILURE Looks like there s a problem with this pull request Replaced with https github com Netflix RxJava pull 284',RxJava,true,false,false
15036158,'GroupBy fixes as reported in Issue 282','Issue https github com Netflix RxJava issues 282 Refactored to maintain a single subscription that propagates events to the correct child GroupedObservables make unsubscribe work correctly for parent child sequences add language adaptor support','RxJava pull requests #156 https netflixoss ci cloudbees com job RxJava pull requests 156 FAILURE Looks like there s a problem with this pull request Not quite sure yet what s causing the test to fail on CloudBees RxJava pull requests #160 https netflixoss ci cloudbees com job RxJava pull requests 160 FAILURE Looks like there s a problem with this pull request That failing test has nothing to do with GroupBy and is not one I ve seen issues with before CloudBees is really harsh on thread scheduling RxJava pull requests #162 https netflixoss ci cloudbees com job RxJava pull requests 162 SUCCESS This pull request looks good',RxJava,true,false,false
15081984,'Several new or more precise marble diagrams','Add several new or more specific marble diagrams correct two bad image links correct some typos','RxJava pull requests #157 https netflixoss ci cloudbees com job RxJava pull requests 157 SUCCESS This pull request looks good',RxJava,true,false,false
15084667,'Scan Operator with and without initial value behave wildly different Intended','I m quite new to this RX stuff so forgive me if there something simple I m missing here I was trying to use scan and found that it did not behave as I expected This code illustrates how java public class ScanIssue public static void main String args throws InterruptedException PublishSubject Integer source PublishSubject create Func2 Integer Integer Integer accumulator new Func2 Integer Integer Integer @Override public Integer call Integer a Integer b return a b Observable Integer scan Observable scan source accumulator Observable Integer scan Observable scan source 0 accumulator print A scan print B scan print C scan print D scan print E scan Thread sleep 1000 source onNext 1 Thread sleep 1000 source onNext 1 private static T void print final String prefix Observable T source source subscribe new Action1 T @Override public void call T s System out println prefix s I would expect it to output nothing on the first onNext and this on the second A 2 B 2 C 2 Where I don t care about the order of A B C But instead it outputs this on the first one B 1 B 2 B 3 and this on the second B 4 B 5 B 6 B can be any of A B and C but always the same all 6 times If I switch to the one with initial value it works as I expect The more subscriptions I add the worse it gets The type of source does not seem to matter tried with a hand rolled one','The first value is always passed through as the first onNext If no initial value is given then the first source onNext is passed through and then fed as the initial value along with the next onNext So for this one java source scan 0 accumulator We see 0 come through first and then be accumulated with 1 and 2 onNext A 0 FUNC a 0 b 1 onNext A 1 FUNC a 1 b 2 onNext A 3 In this one java Observable Integer scan source scan accumulator it s now actually only passing in 2 values 1 and 2 instead of 0 as initial then 1 and 2 so we get onNext A 1 FUNC a 1 b 2 onNext A 3 The first value is still passed directly through and then the next accumulated If I change the Observable to emit 0 1 2 it looks the same as when setting initialValue to 0 java source onNext 0 source onNext 1 source onNext 2 now emits this onNext A 0 FUNC a 0 b 1 onNext A 1 FUNC a 1 b 2 onNext A 3 Javadocs http netflix github io RxJava javadoc rx Observable html#scan rx util functions Func2 Returns an Observable that applies a function of your choosing to the first item emitted by a source Observable then feeds the result of that function along with the second item emitted by an Observable into the same function and so on until all items have been emitted by the source Observable emitting the result of each of these iterations scan https f cloud github com assets 813492 1100793 5df1bc0a 1789 11e3 9fd9 a8e9f901ee9b png',RxJava,false,false,false
15093980,'Error handling and validation','Refactoring related to arg validation and error handling https github com Netflix RxJava issues 198 Throw if no onError handler specified https github com Netflix RxJava issues 278 Subscribe argument validation','RxJava pull requests #158 https netflixoss ci cloudbees com job RxJava pull requests 158 SUCCESS This pull request looks good',RxJava,true,false,false
15103958,'Fix PublishSubject non deterministic behavior on concurrent modification','changed to take snapshot of observers values before iterating in onNext onError onCompleted so that nested subscriptions that add to observers can t change the values iteration single threaded nested subscriptions are now deterministic multi threaded subscriptions will no longer be allowed to race to get into an interating onNext onError onCompleted loop they will always wait until the next also improved terminal state behavior when subscribing to a PublishSubject that has already received onError onCompleted https github com Netflix RxJava issues 282','RxJava pull requests #159 https netflixoss ci cloudbees com job RxJava pull requests 159 SUCCESS This pull request looks good RxJava pull requests #161 https netflixoss ci cloudbees com job RxJava pull requests 161 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
15197784,'Fixes on #284 groupBy','See my previous comment https github com Netflix RxJava issues 282#issuecomment 19013992','RxJava pull requests #163 https netflixoss ci cloudbees com job RxJava pull requests 163 SUCCESS This pull request looks good I apologize for not being able to act on this right now I ve been swamped with other work but I will definitely return to this once I get through my other work squash into a single commit then check with @benjchristensen LGTM RxJava pull requests #170 https netflixoss ci cloudbees com job RxJava pull requests 170 SUCCESS This pull request looks good Hi Ben et alii Regarding the issues at the end of the previous discussion I mentioned the quirks I found to Erik who actually considered the current terminating behaviour of groupBy in Rx Net which is similar to RxJava s to be undesirable His opinion was that when one unsubscribes from the GroupBy observable one should still be able to subscribe to the GroupedObservables that were emitted before because otherwise seemingly unrelated actions can cause unexpected changes in behaviour His example was like this source groupBy x x 2 take 2 subscribe group new Thread group subscribe someObserver start In this example the take 2 may cause termination of the groupBy s upstream subscription because the GroupedObservables still have no subscribers It actually creates a race between the spawned and spawning thread I guess the solution to this would be to not automatically terminate the upstream subscription when one might still connect to a GroupedObservable This would lead to some memory pollution if the stream is infinite and not terminated manually for example using takeWhile A nice solution could perhaps be to do some juggling with weak references in order to detect when all emitted GroupedObservables have been forgotten about by the rest of the program in which case the upstream subscription may be ended too if the primary observer already unsubscribed of course previous discussion https github com Netflix RxJava issues 282#issuecomment 19013992 I tried looking at this again this morning but again ran out of time trying to understand what the issue is and what is being fixed it s still on my list for a more focused review at some point Here s another problem with groupBy This code scala val firstOnly false val numbersByModulo3 Observable interval 1000 millis take 9 groupBy _ 3 for modulo numbers numbersByModulo3 yield println Observable for modulo modulo started if firstOnly numbers take 1 else numbers merge toBlockingObservable foreach println _ outputs if val firstOnly false this expected Observable for modulo0 started 0 Observable for modulo1 started 1 Observable for modulo2 started 2 3 4 5 6 7 8 and if val firstOnly true it outputs this unexpected Observable for modulo0 started 0 But I would expect that it takes the first element of each modulo class Observable for modulo0 started 0 Observable for modulo1 started 1 Observable for modulo2 started 2 Can anyone start from scratch on reviewing this and providing feedback @headinthebox Can you also provide input on what the behavior should be compared to Rx Net You ve mentioned to both @Treora and myself that you feel something is wrong with the Rx Net implementation so I d like to know what unit tests we should have so we can change RxJava to match the correct functionality Hi As @headinthebox appears to not have replied yet I will try to answer From what I know the only issue is that it is impossible to subscribe to GroupedObservables after their producer has terminated I think I explained the whole issue earlier in this thread https github com Netflix RxJava pull 289#issuecomment 20248743 The reason why it is like this in Rx Net is because there seems to be no elegant solution to this issue The point is that the GroupBy observable cannot know whether or not at some point in the future somebody will subscribe to one of the GroupedObservable s that it has emitted Therefore it cannot know whether or not it can unsubscribe from its source The easy solution would be to simply not unsubscribe at all but with the drawback that unused streams will also stay alive for eternity if not terminated further upstream Let me know if you would like me to explain more My work involving RxJava finished but it would be nice if this issue will be fixed Also it seems these fixes I wrote #289 have still not been merged so doing that could already fix some bugs If then the small issue mentioned in point 2 in https github com Netflix RxJava issues 282#issuecomment 19013992 is also fixed the RxJava implementation should be at least as good as the current Rx Net implementation or probably a bit better as their code looks somewhat buggy too as mentioned before @zsxwing Since you have become familiar with a lot of the codebase if you want to help tackle this I d appreciate it @benjchristensen I ll try to solve it Thanks @zsxwing I ve implemented GroupByUntil #528 which can be turned into GroupBy by using Observable never as its group duration selector With the recent PublishSubject fixes any escaped group will either onCompleted or onError d if the main source has been terminated So given the example source groupBy x x 2 take 2 subscribe group new Thread group subscribe someObserver start someObserver will likely get just an onCompleted If I understand the problem correctly you d want to receive Xs for the first two groups until they cancel even if there won t be any new groups due to take 2 How about source groupBy x x 2 take 2 subscribe group new Thread source where a a 2 group getKey subscribe someObserver This way we ll know what the first two group keys would be then filter the source based on that in each group However lets assume source emits System currentTimeMillis in which case the someObserver receives different Xs that were used in creating the groups To fix that we would need source to be replayable ConnectableObservable co source replay co groupBy x x 2 take 2 subscribe group new Thread co where a a 2 group getKey subscribe someObserver Subscription s0 co connect Thread sleep 1000 or other wait mechanism s0 unsubscribe Closing this and it will be addressed via https github com Netflix RxJava issues 570',RxJava,true,false,false
15199909,'Issue 103','Adding the zip operator that works on collection of Observables and a FuncN https github com Netflix RxJava issues 103','RxJava pull requests #164 https netflixoss ci cloudbees com job RxJava pull requests 164 SUCCESS This pull request looks good RxJava pull requests #168 https netflixoss ci cloudbees com job RxJava pull requests 168 SUCCESS This pull request looks good So is the idea here that someone will use this with or Object types and it will up to them to handle the typing of the arguments passed in rather than having overloads for all possible arities ie T1 T2 T3 T4 T5 Tn It doesn t prevent us from adding them and maintaining type safety for more situations Type safety is also lost when use zip Observable lt Observable lt FuncN',RxJava,true,false,false
15215224,'Should Observable range and Observable from be in BlockingObservable','I imagine Observable range and Observable from are so primitive that they are expected to be in the normal Observable but they are really blocking on subscribe which can be unexpected In fact it took me a while wondering why my groupBy unit test 4f68c5a did not work at first using range instead of a custom CounterSource before I figured out that it is simply impossible to unsubscribe from range According to the plan of moving blocking operators to BlockingObservable #272 it seems the correct place for these methods and maybe others too although strictly speaking they might not be operators but generators I see two possibilities Moving from and range to BlockingObservable BlockingObservable T source BlockingObservable from items or keeping them in Observable but changing their return type to give the hint to the user BlockingObservable T source Observable from items','That would be wrong Range is blocking because the default scheduler as is return and other operators Moreover encoding this in the return type is totally useless since after you compose it with another operator that knowledge is lost Encoding properties of an observable in the return type just does not work My guess us that it is probably ok to always use newthreadscheduler as the default for net we had long discussions on what to use as the defaults but never measured Sent from my iPhone On Jun 6 2013 at 3 11 AM Gerben notifications@github com wrote I imagine Observable range and Observable from are so primitive that they are expected to be in the normal Observable but they are really blocking on subscribe which can be unexpected In fact it took me a while wondering why my groupBy unit test 4f68c5a did not work at first using range instead of a custom CounterSource before I figured out that it is simply impossible to unsubscribe from range According to the plan of moving blocking operators to BlockingObservable #272 it seems the correct place for these methods and maybe others too although strictly speaking they might not be operators but generators I see two possibilities Moving from and range to BlockingObservable BlockingObservable T source BlockingObservable from items or keeping them in Observable but changing their return type to give the hint to the user BlockingObservable T source Observable from items Reply to this email directly or view it on GitHub Range is blocking because the default scheduler It would of course be the nicest solution if from and range would not block in general but my first guess was that this blocking behaviour was intended I now see Rx Net solves Range by scheduling the loop function which would probably be nice to do in RxJava to Currently from works like this in RxJava java public Subscription call Observer T observer for T item iterable observer onNext item observer onCompleted return Subscriptions empty We have chosen to not add concurrency and that matches Rx Design Guideline 6 12 Avoid introducing concurrency when Observables are created It is up to the developer to choose to do so This can be done within the Observable itself or using subscribeOn and observeOn Beyond this I m interested in exploring lazy iterable implementations a feature that is far easier in C# which supports async await as part of the language This is of particular interest to me on range and from for the reasons you bring up It is not correct though to move from and range to BlockingObservable as that represents the operators on the Observable being blocking instead of non blocking Non blocking operators can be applied to a blocking or non blocking Observable it is the source Observable that chooses and there are times when it makes perfect sense to be blocking such as when pulling data from an in memory cache and immediately emitting it without the overhead of thread scheduling',RxJava,false,false,false
15301038,'Kotlin Language Adaptor','Langauge adaptor for kotlin','RxJava pull requests #165 https netflixoss ci cloudbees com job RxJava pull requests 165 FAILURE Looks like there s a problem with this pull request Is a problem with the Perm Gen memory size when compiling the scala module after you download the kotlin libraries for the first time The problem disappear growing up the Perm Gen size or running the whole process a second time Thank you for submitting this I am not ignoring it due to lack of interest I m just overly busy at the moment but I will get around to this No problem @MarioAriasC you might want to redo this on a feature branch as there s a lot of clutter merge commits whoops I forgot this here I ll review anyway but we are interested in merging concise complete commits make sense Let me know if you need git syntax help looks good to me sufficient unit tests etc cleanup the files build gradle and commit then ask @benjchristensen @adriancole Any help with git syntax and other things will be very appreciated sure It looks like you are 7 commits ahead of master merges plus the other things you ve added do git reset HEAD 7 which should unstage your changes Then you do git pull upstream master to reset your head to latest Then redo your commit and you ll need to do git push f origin master to overwrite the commits here hope this helps We are getting very close to being able to pull this in with some refactoring now that pull https github com Netflix RxJava pull 300 is coming Does Kotlin support closure function coercion like Java 8 or Groovy 2 2 http docs codehaus org display GROOVY 2013 07 09 First beta of Groovy 2 2 available or allow dynamic generation of extension methods I see that Kotlin has extension methods but every method must be defined manually I m interested in a mechanism to automatically coerce from Kotlin functions to RxJava Function Action classes or dynamically generate the extension methods Here s how I generate the extension methods dynamically in Groovy https github com Netflix RxJava blob master language adaptors rxjava groovy src main java rx lang groovy RxGroovyExtensionModule java#L84 For background on the previous questions and why it has been so long in responding to this pull request look at release 0 11 0 which significantly changes how we do language adaptors https github com Netflix RxJava releases tag rxjava 0 11 0 Kotlin support function coercion is called SAM Single Abstract Method Conversions this support was introduced in M5 2 and completed in M6 http blog jetbrains com kotlin 2013 08 kotlin m6 is here Personally I used it in other project and works fine but sometimes the compiler can infer the actual type of the interface in those cases we could fall back on Extension methods That sounds like it could just work without anything special then If not then perhaps the extension methods can fix where we have issues Can you give it a try against the new rxjava core If coercion is all that s needed then it s simple If you find issues and extension methods would help or there are extras that would benefit Kotlin make it more idiomatic etc that can be added through a utility class extension methods etc it would be great to get an updated pull request If nothing else examples of Kotlin code using RxJava would be great if coercion handles all needed cases @benjchristensen I ll close this pull request and open a new one I have several problems with Git and gradle related to my changes I want to start fresh will be more easy for all of us',RxJava,true,false,false
15644757,'Expose ScheduledSubscription on the public API','I understand it should be transparent for a client where an observable was scheduled However we d actually like to ensure that our service objects schedule operations on an appropriate scheduler we use different schedulers for e g API requests and local storage I O This is not possible at the moment since there is no way to obtain information about this by inspecting the observable or the subscription Since subscribeOn effectively creates a new observable there is also no simple way to use mock objects other than to spy into the implementation using partial mocks which is not great I was wondering if it would make sense to change ScheduledSubscription so that a ScheduledSubscription is a public top level class b exposes a method getScheduler that returns the currently private scheduler instance so that clients can test subscriptions in unit tests in the following way Subscription sub serviceObject performJob subscribe assertThat sub instanceOf ScheduledSubscription class assertThat sub ScheduledSubscription sub getScheduler equalTo expectedScheduler','Answered in https github com Netflix RxJava pull 294',RxJava,false,false,false
15645363,'Make ScheduledSubscription public expose scheduler field','As proposed in issue #293 This will make it easier to verify proper scheduling behavior of services implemented using rx','RxJava pull requests #167 https netflixoss ci cloudbees com job RxJava pull requests 167 SUCCESS This pull request looks good Anyone else able to do a code review on this Beside variable setting this class is only a few lines of code I don t think it is worth exposing as it would require us to maintain the constructors etc which the private access currently doesn t There could be more said for exposing a scheduler accessor on an interface @mttkay you mind noting the specific use case here is it testing or validation at runtime This was purely for testing We had a few occurrences of devs forgetting to schedule an Observable on an appropriate scheduler and disk IO was performed on the main application thread It would be good to catch these errors early by being able to write a unit test That said how do you guys do it Just rely on developer diligence We re still trying to discover the right idioms practices for us both in the context of Android and Rx in general @mttkay We generally rely on developer diligence and them doing their own unit testing We have some light abstractions on top of RxJava that we use in our codebase that encourage the right way for how we use it such as avoiding the use of schedulers in almost all cases For the reasons @adriancole mentions I d rather not make this class public as I consider it an implementation detail for the onSubscribe operator Also since Subscription is already the top level interface there is nothing that would force people to use ScheduledSubscription and thus it still wouldn t enable you to achieve the goal of asserting what scheduler is being used It gets more complicated with composition as well as a ScheduledSubscription could be inside another Subscription so instanceof checks don t mean much when composition is used I am not aware of a generally applicable solution to what you re looking for asserting IO only happens where it should but it s a great thing to pursue Perhaps this could be a discussion over on the Google Groups https groups google com forum # forum rxjava Another thought something I ve considered but not yet pursued is the use of execution hooks http netflix github io RxJava javadoc rx plugins RxJavaObservableExecutionHook html for testing and smoke tests to perform assertions against each step of an Rx composition You could assert each instance of a Subscription or Observable instance at each step of composition helping get around the inheritance versus composition issue I stated above Not sure yet if it could achieve what you re trying to do but it might For example if in your code base you always want a certain type of Subscription uses this could assert that Closing as I would prefer this stay an implementation detail and not part of the public API @benjchristensen that link to the execution hooks is very useful I wasn t aware of this Thanks Not a big deal at all to not have this It seemed reasonable to me but I understand there might be better ways to accomplish this without escalating ScheduledSubscription to the public API',RxJava,true,false,false
15676075,'Flatten operator','This is more a request for discussion I m not sure NET s Rx has something like this but one thing I miss in RxJava is an operator to flatten an Observable List T to Observable T As far as I can tell this currently requires one to write somewhat clunky code using flatMap Observable from toList flatMap new Func1 List Observable @Override public Observable call List list return Observable from list i e there seems to be no standard reverse operation for toList Is this something you would deem worth having in the library itself It would simplify the above call to Observable from toList flatten','It looks a bit similar to the switch operator on Observable That takes Observable Observable T and turns it into Observable T But perhaps a new operator which enumerates entries from an Observable Collection T is not such a bad idea Not only would this be the reverse operation of toList it would also be a reverse operation for the buffer operation which buffers incoming elements into lists of elements which are then propagated Note that this does have some limitations To me Observable from toList flatten seems impossible The flatten operator should only be available usable for Observables which produce Collections of elements and not for Observables which produce non Collection objects The only usable syntax I can come up with is Observable flatten Observable from toList Note that this does have some limitations To me Observable from toList flatten seems impossible The flatten operator should only be available usable for Observables which produce Collections of elements and not for Observables which produce non Collection objects that s a good point actually didn t think about this If we can t have the extra readability by flatten being an instance method it might even suffice to have a flatten Func1 for now which could be used like this have to check if T could actually be inferred by Java here Observable from 1 2 3 toList flatMap Functions flatten This is not much longer doesn t read much worse and would have the benefit of not impacting the Observable class interface I don t have much opinion on the syntax but I d find this useful I end up doing this operation on the result of toSortedList to switch back to an observable sequence and continue processing Dave On Tuesday June 18 2013 Matthias K ppler wrote Note that this does have some limitations To me Observable from toList flatten seems impossible The flatten operator should only be available usable for Observables which produce Collections of elements and not for Observables which produce non Collection objects that s a good point actually didn t think about this If we can t have the extra readability by flatten being an instance method it might even suffice to have a flatten Func1 for now which could be used like this have to check if T could actually be inferred by Java here Observable from 1 2 3 toList flatMap Functions flatten This is not much longer doesn t read much worse and would have the benefit of not impacting the Observable class interface Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 295#issuecomment 19610646 Here is how to flatten IObservable int to IObservable int in NET c# var observable Observable Return new 1 2 3 4 5 observable IObservable int observable SelectMany x x returns Observable int Subscribe Console WriteLine Here is the SelectMany operator being used c# public static IObservable TResult SelectMany TSource TResult this IObservable TSource source Func TSource IEnumerable TResult selector Can anyone see a way of doing this that is type safe Perhaps flatten Class type is the only way to do it so that we pass in the type that it should return If it can t cast everything to that then it would onError a ClassCastException Perhaps flatten could exist but would have to emit Observable Object I m slightly confused by this discussion and I m not sure if everyone is talking about the same thing But I think @benjchristensen you re looking for something like this java in Observable java public static T Observable T flatten Observable extends List extends T source Func1 List extends T Observable T f new Func1 List extends T Observable T public Observable T call List extends T t1 return Observable from t1 return Observable concat source map f in some test file @Test public void testFlattenFromList Observable List Integer o Observable from Arrays asList 1 2 Arrays asList 3 4 Arrays asList 5 6 for Integer i flatten o toBlockingObservable toIterable System out println i Yes this looks straightforward Rx NET has a SelectMany overload http msdn microsoft com en us library hh211809 aspx for this kind of operation I think using a List is too strong type here maybe an Iteratable will suffice With new lift operation on Observables it s quite easy to create flatten operator I ve created something like this public static class ListToItemsOperator T implements Operator T Iterable T @Override public Subscriber super Iterable T call final Subscriber super T child return new Subscriber Iterable T child @Override public void onCompleted child onCompleted @Override public void onError Throwable e child onError e @Override public void onNext Iterable T list for T t list if child isUnsubscribed break try child onNext t catch Exception e onError OnErrorThrowable addValueAsLastCause e t return Usage Observable List Integer listObs Observable from Arrays asList 1 2 3 4 5 6 toList listObs lift new ListToItemsOperator Integer subscribe DumpObs make listObs lift new ListToItemsOperator Integer take 2 subscribe Dump Obs make I m not sure how good is that code but it looks doable with type safety so It might be good moment to add it do core operators That works well to pull in via lift because you can provide the correctly typed implementation for the Observable you re working on but it can t be put on Observable as an instance method unless we do casting and blow up if invalid since that only works when T is Iterable T i e Observable Iterable T and an Observable can be anything It could be done as a static Observable flatten Observable Iterable T o as @samuelgruetter mentions above but then we d need many different overloads of flatten and that doesn t work with the chaining pattern that is wanted In short Java doesn t allow conditional extension methods on a class based on its generic type so a flatten instance method can t be typed to Iterable T or Iterable Iterable T or other such variants It will always only receive whatever T is Sure we shouldn t force to add that to Observable I was rather thinking to expand rx operators package with FlattenOperator Since this implementation is immutable we might might have single instance of this operator to slightly reduce objects creation Other notable places where we ve done this are MathObservable and StringObservable The contradiction is the that dematerialize is an instance method on Observable T when it should only exist on instances Observable Notification T We could go crazy with the overloads to make things type safe class Observable T NotificationObservable T materialize Observable R map Func1 T R NotificationObservable R map Func1 T Notification R a billion methods later class NotificationObservable T extends Observable Notification T Observable T dematerialize just in case someone materializes a materialized Observable turtles all the way down NotificationNotificationObservable T materialize class NotificationNotificationObservable T extends NotificationObservable Notification T NotificationObservable T dematerialize ok that was a silly idea Yes dematerialize is the counter example where we do casting an throw an error if the type is not a Notification I was rather thinking to expand rx operators package with FlattenOperator We have yet to start exposing custom operators for use via lift like this and the rx operators package is not the right place since those are internal implementations and can change at any time Originally from https github com Netflix RxJava issues 1408 by @ccmtaylor In my code I often make API calls that return Observable Iterable T and then I want to process each element of the returned collection To do this I keep having to write something like java moviesService listMovies flatMap movies Observable from movies map movie doSomethingWith movie In Java 8 scala this isn t too bad but with Java 7 Android syntax the flatMap call is not pretty Since we can t add a flatten instance method that only applies to Observable Iterable T in java I see two solutions 1 Add Observable T flatten Observable Iterable T obs to rx Observable java Observable flatten moviesService listMovies map movie doSomethingWith movie 2 Add Func1 Iterable T Observable T flatten to rx functions Functions java moviesService listMovies flatMap Functions Movie flatten because Java can t figure out the generics map movie doSomethingWith movie As this discussion continues some items to keep in mind If we re going to have a collection of static functions we need a set of conventions that let it scale well and not become just a random catch all This is why I am not okay yet with just adding Functions flatten This is why so far we have put things like this in separate contrib modules where they are optionally brought in as desired for example the StringObservable Optimizing for languages without lambdas is not necessarily a reason to do something Whatever we do we re stuck with for a very long time Note that here you can use mergeMapIterator https github com Netflix RxJava wiki Transforming Observables#mergemap and mergemapiterable That said I agree with Ben it is painful that Java has no extension methods so it becomes either or the saving grace mmm is that static methods do not need a receiver it is less ugly to write f xs than FooBar f xs but of course you just want to write xs f',RxJava,false,false,false
15945954,'Observer#onError should use Throwable','current signature https github com Netflix RxJava blob master rxjava core src main java rx Observer java#L45 uses Exception instead lets use Throwable','Throwable only has 2 sub classes Error and Exception and generally the convention is to not catch Error An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch http docs oracle com javase 6 docs api java lang Error html Thus all application Exceptions capable of being handled should extend from Exception not Throwable or Error This was the reasoning behind not using Throwable What are the use cases in which we should be catching and passing Error via Observer#onError and thus require Throwable as the signature Also of note this is a breaking change not a deal breaker since we are pre 1 0 but it s a factor theoretically speaking you are right one practical use case would be when I want to allow observer to react to OOME as a way to preserve jvm when OOME is not really that bad there are cases when it is OK for large block heap allocations to fail with OOME for a given large object which affects only given object execution path and is not detrimental the rest of the JVM I have handled that use case before years ago when working on search engines where it made sense to catch OOME However I d suggest that is an edge case that should be caught by the specific code and turned into an Exception or RuntimeException before being thrown to other code to handle Developers should not be expected to handle an Error including an OOME as they wouldn t know it could be handled Here is an example of what I d suggest to comply with the principle of not throwing Error for developers to handle while still handling the OOME for this edge case groovy return Observable create new Func1 Observer String Subscription def Subscription call Observer String observer try allocate memory observer onNext some value observer onCompleted catch OutOfMemoryError e observer onError new RuntimeException Recoverable OutOfMemory on optional return Subscriptions empty I agree with the general sentiment that Error isn t something you recover from as part of your business logic but rather a fundamental flaw in app execution usually due to developer failure think divide by zero That said I don t think onError should take a Throwable One problem we ran into however was that throwing Error s such as AssertionError in an observable scheduled on a background thread didn t terminate the app It would simply continue to execute in what I guess can only be called undefined state I am not sure yet whether this is something particular about our app or RxJava My 2p on the issue If there s a chance of user code being in the stack leading to onError then we should prefer Throwable as devs can and do raise AssertionErrors intentionally or unintentionally Other reasons to prefer Throwable is that the cause of any exception is a throwable Apis that try to coerce to exception often wrap throwables sometimes incorrectly just to handle exception getCause This implies that those using or maintaining the system need to carefully review all try catch blocks before they know that onError will in fact be called and not just propagate stuff and leave them hanging While there are still cases onError won t be called due to JVM crash etc I think it is still an advantage It is possible that Observer writers could be turned off due to throwable This could be good or bad I see this as hey you really should pay attention Those who insist they don t like to receive throwable can punt using or making utilities such as propagate http docs guava libraries googlecode com git javadoc com google common base Throwables html#propagateIfInstanceOf java lang Throwable java lang Class Summary is that if we allow onError to receive a throwable we are being more honest to the observer about their failures It will be called more often for example it can accept an Error or would be called with less wrapped things The try blocks maintaining the stack until onError are simpler and can directly correspond to exception getCause The benefits of onError Throwable are worth it One thing to clarify here is that whether or not to send a throwable signal to the observer is a different issue than whether the code managing the observer propagates errors If we decide to notify observers when an error or any other throwable caused their request to cease this doesn t imply we are swallowing errors in the RXjava code that calls onError if that makes sense I m strongly against catching Error s A library shouldn t encourage or even tolerate that its users use Error s in a wrong way sticking to Oracle s definition here In all normal use cases I wouldn t want to handle any errors in onError which makes the name a bit strange admittedly Also calling onError for an Error and at the same time rethrowing it would be confusing imho @jmhofer onError is basically a message It doesn t imply the receiver should propagate it It only informs them what happened right Choosing to restrict onError from accepting throwable is a choice to not know why or if your observer was cancelled I can t side with that wrt Also calling onError for an Error and at the same time rethrowing it would be confusing imho It isn t confusing if we understand onError is a signal Without a callback the observer could block forever wait some timeout etc as they were not informed they will never complete The Observable can certainly raise an error after signaling its observers I don t see a disconnect if we agree on the intent of onError I agree that raising the error after signaling is better than swallowing it Still wouldn t want to handle what basically comes down to a developer s error in onError though @jmhofer do you mean stick to traditional single method observer and don t have an onError callback hence no discussion about it @adriancole No I just think that onError should keep signalling exceptions not errors as it does right now there s several examples of where Throwable is validly sent to callers even defined by Oracle 1 and former JCP members 2 I ll defer to Ben for the final decision but I am obviously not in favor of status quo and wouldn t want to be a consumer of it with this in mind 1 http docs oracle com javaee 7 api javax websocket Endpoint html#onError javax websocket Session java lang Throwable 2 https github com square retrofit blob master retrofit src main java retrofit RestAdapter java catch Throwable t throw RetrofitError unexpectedError url t If we wished to keep the interface and avoid the error made me hang forever problem we could update the javadoc and impl such that onCompleted will also be called on an Error admittedly a confusing compromise Possibly dead horse at this point but every current java async web callback chose throwable not exception for error signals If we chose to retain Exception as opposed to Throwable converting to or from these interfaces will be lossy Servlet 3 0 AsyncListener http docs oracle com javaee 6 api javax servlet AsyncListener html JAX RS 2 0 InvocationCallback https jax rs spec java net nonav 2 0 apidocs javax ws rs client InvocationCallback html Websocket Endpoint http docs oracle com javaee 7 api javax websocket package summary html Those are some very strong arguments and I m mostly convinced that it s worth changing to Throwable I still don t think Error s should be handled most of the time but I agree that wrapping an Observable around something that throws a Throwable is very awkward if onError only supports Exception as that means contrived Exceptions wrapping Throwable or they are thrown from somewhere else and could leave the Observable Observer permanently blocked waiting on a terminal state To adopt onError Throwable means a breaking change but version 0 10 0 is a good time for this since we re changing the builds significantly and requiring people to change their build target from rxjava core to rxjava as part of it and that s why we re still not at version 1 x I don t like however that onErrorResumeNext will now start handling Throwable and Error not just Exception Perhaps we should create a new onExceptionResumeNext that should be what people normally use I d love to make onErrorResumeNext be that way but the naming is wrong so onErrorResumeNext needs to receive all errors passed by onError which means Throwable whereas onExceptionResumeNext could catch only Exception and allow Throwable Error past What other implications are there if we proceed with this change Anyone have further thoughts on this issue particularly the use cases I explained in my last comment regarding onErrorResumeNext and onExceptionResumeNext sounds like a good idea using only one onExceptionResumeNext @Andrei Pozolotin @adriancole @jmhofer @mttkay @michaeldejong @mairbek I have submitted a pull request https github com Netflix RxJava pull 315 with the breaking change of onError Exception to onError Throwable based on the discussion in this issue I would appreciate your review and confirmation before I proceed I would like to merge and release within 24 hours if possible',RxJava,false,false,false
15990587,'Remove unit tests from distribution JAR','Embedded unit tests make up 50 of the rxjava core JAR size Factoring these out into a separate source tree would allow for a more manageable library size for distribution in size constrained applications Removing the unit tests from the JAR dropped the size from 600K to 315K','1 I noticed a line that was put in comments which excluded unit tests in the build gradle https github com Netflix RxJava blob master rxjava core build gradle I do know that there are unit tests residing in src main java so you would need to move those first The unit tests are internal classes of the objects they test Separating them out would eliminate the junit and mockito dependencies in the core source Indeed Some very good points in that article The one problematic unforeseen consequence that I currently see is that the Scala compiler actually checks for the existence of those internal classes In contrast to Java It doesn t allow them to just be absent even if they re not used anywhere This means that the idea of simply removing all those inner test classes during packaging doesn t work anymore for any libraries that want to be usable in Scala which is a pity This was also discussed at https groups google com forum # topic rxjava b4DYjvUTazI For Android specifically is it not common to use tools such as Proguard http proguard sourceforge net index html and http developer android com tools help proguard html to reduce jars to only include classes used by an app I have been told that is the case but I don t developer for Android so can t speak to this Unfortunately due to Groovy Scala and possibly other languages the general solution of stripping the UnitTest classes before creating the jar has been disabled otherwise the issue of Jar file size would not exist At this time however the intent is to leave things as they are What dependencies They are provided and not runtime RxJava has 0 dependencies beyond the JVM and is a single jar library You re right I missed this thing about provided dependencies Then checked my own build and found no unit test dependencies understood the idea and removed my comment Sorry about that It s okay it s what I get for doing something unconventional',RxJava,false,false,false
16136609,'LINQ Stream','Hi Will this add LINQ like functionality in the future This is one thing that makes NET Rx very attractive Suminda','We have no intention of attempting to create a DSL in Java as the language does not afford those capabilities If someone wanted to pursue it in a different language such as Groovy Scala or Clojure it could be a great contrib module https github com Netflix RxJava tree master rxjava contrib',RxJava,false,false,false
16334472,'OperationToObservableIterable should call onError','It seems a bit odd that the OperationToObservableIterable class doesn t catch exceptions and call onError All of the other wrappers at that level catch exceptions and call onError It seems to break the contract of what happens when you pump a value into an observer In my use case I am trying to test error handling by returning badly formatted data with Observable just badResponseObject and the exception was bubbling out of the call and none of the onError cases were being executed Perhaps I am missing something','Not sure how I missed responding to this can you provide a unit test to demonstrate the issue Anyone able to replicate this This test succeeds due to the fact that Observable subscribe catches the exception from the immediate iteration of the source sequence java @Test public void testFailOnNext Observable Integer source Observable create toObservableIterable Arrays asList 1 2 3 @SuppressWarnings unchecked final Observer Object observer mock Observer class Observer Integer failer new Observer Integer @Override public void onNext Integer args if args 1 throw new RuntimeException Forced failure observer onNext args @Override public void onError Throwable e observer onError e @Override public void onCompleted observer onCompleted source subscribe failer verify observer times 1 onNext 1 verify observer times 1 onError any RuntimeException class verify observer never onCompleted But when moved to another thread via observeOn the exception is just swallowed by the threadpool It is not a problem with the toObservableIterable but with the observeOn not expecting not accept observer to throw java @Test public void testFailOnNextScheduled throws InterruptedException Observable Integer source Observable create toObservableIterable Arrays asList 1 2 3 observeOn Schedulers threadPoolForComputation @SuppressWarnings unchecked final Observer Object observer mock Observer class Observer Integer failer new Observer Integer @Override public void onNext Integer args if args 1 throw new RuntimeException Forced failure observer onNext args @Override public void onError Throwable e observer onError e @Override public void onCompleted observer onCompleted source subscribe failer Thread sleep 1000 verify observer times 1 onNext 1 verify observer times 1 onError any RuntimeException class verify observer never onCompleted No response on this in 6 months so closing out re open if still an issue Many improvements occurred related to error handling in that time This test is passing now java @Test public void testFailOnNextScheduled throws InterruptedException Observable Integer source Observable from Arrays asList 1 2 3 observeOn Schedulers computation @SuppressWarnings unchecked final Observer Object observer mock Observer class Observer Integer failer new Observer Integer @Override public void onNext Integer args if args 1 throw new RuntimeException Forced failure observer onNext args @Override public void onError Throwable e observer onError e @Override public void onCompleted observer onCompleted source subscribe failer Thread sleep 1000 verify observer times 1 onNext 1 verify observer times 1 onError any RuntimeException class verify observer never onCompleted',RxJava,false,false,false
16353704,'Type safety in rxjava core dynamic language support via compile time code generation and Scala support via implicits','Implementation of ideas here https groups google com forum # topic rxjava g6Z9KyMM8zs This addresses #204 and #208','RxJava pull requests #171 https netflixoss ci cloudbees com job RxJava pull requests 171 ABORTED Manually merging in https github com Netflix RxJava pull 304 since it had conflicts with 0 9 1 changes',RxJava,true,false,false
16357762,'Implementation of mapManyDelayError','There is already a documentation of mapManyDelayError but I can t find an implementation I would like to use mapManyDelayError in a project If there is no implementation yet I may contribute it','Sounds like a good idea Renamed from mapManyDelayError to flatMapDelayError as we removed mapMany naming conventions Closing out due to inactivity If wanted please re open',RxJava,false,false,false
16381003,'Update Observable isInternalImplementation get rid of NullPointerExcept','ion NullPointerException has been encountered during my tests It is because java lang Class getPackage may return null if no package information is available from the archive or codebase documented feature','RxJava pull requests #172 https netflixoss ci cloudbees com job RxJava pull requests 172 FAILURE Looks like there s a problem with this pull request Thanks',RxJava,true,false,false
16420095,'Pull 267 Merge combineLatest','Spent some time reviewing it and it seems good Any bugs can be dealt with as people start playing with it instead of me holding this up as a pull request any longer since this exposes combineLatest in Observable for I believe the first time and is thus a low risk to breaking any existing users','RxJava pull requests #173 https netflixoss ci cloudbees com job RxJava pull requests 173 SUCCESS This pull request looks good I noticed there is no marble diagram in the documentation I find these extremely helpful to understand how an operator works Is combineLatest different from zip only in how events are timed It looks like it accomplishes something very similar It s different in that it doesn t keep the sources synced How do you create those diagrams I d draw one if I knew how There s a marble diagram for combineLatest at https github com Netflix RxJava wiki Combining Observables#combinelatest and it should also be in the javadocs as of the next release On Sat Jul 20 2013 at 1 37 AM Joachim Hofer notifications@github com wrote It s different in that it doesn t keep the sources synced How do you create those diagrams I d draw one if I knew how Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 303#issuecomment 21290348 Thanks that clarifies it a lot',RxJava,true,false,false
16422986,'Version 0 10 0 Static Language Support','Manual merge of pull https github com Netflix RxJava pull 300 from @mattrjacobs This will make RxJava completely static by removing all Object overloads see https github com Netflix RxJava issues 208 and https github com Netflix RxJava issues 204 I m submitting this before it being 100 ready so people can review and provide feedback Open items to append to this pull request before merging 1 subscribe with map is not handled yet The following signature needs to be made static Right now the lack of this combined with removal of Functions from dynamic language functionality has broken this java public Subscription subscribe final Map String Object callbacks 2 Core artifact naming convention Should rxjava core x y x jar become rxjava x y z jar since the concept of core language no longer applies I think I d prefer this rxjava x y z jar rxjava groovy x y z jar rxjava clojure x y z jar rxjava scala x y z jar rxjava jruby x y z jar rxjava kotlin x y z jar rxjava dynamic x y z jar object overload for any language rxjava groovy clojure x y z jar multi language jar Only one of those jars is needed hence the reason why I think the core term is no longer needed as it communicated the fact it was always needed Any contrib modules would be rxjava contrib module name x y x jar 3 Dependencies from languages to core still exist The build still will result in Maven Central POM files requires rxjava core from the language version despite that not being the case Need to eliminate this dependency in the artifact Implementation notes originally posted at https github com Netflix RxJava issues 204#issuecomment 20396621 After implementing and throwing away a few different approaches we have landed on a solution we feel will balance the various competing priorities Our goals are support static typing for Java Scala Kotlin etc by removing the Object overloads support any JVM language static or dynamically typed allow all languages to use the same rx Observable class so that we don t divide libraries with helpers such as GroovyObservable ClojureObservable etc that then need to be converted back and forth when doing interop do not require special classloaders or agents to enable runtime bytecode generation do not remove static operators to enable proxying small jars and limited or no dependencies The solution we have arrived at will work as follows The rxjava core source code will delete all Object overload methods and be pure static java Any language that supports functional interfaces directly such as Java 8 and XTend can use the Java core version directly Languages needing specific lambda clojure type mapping to the Func Action types will have language specific Jars created via build time bytecode generation Any method with a Func Action argument will be overloaded with a version supporting the language requirements For example The default Java version java public static T Observable T filter Observable T that Func1 T Boolean predicate A Groovy version java public static T Observable T filter Observable T that groovy lang Closure predicate A jar per language will be created as follows rxjava x y z jar rxjava groovy x y z jar rxjava clojure x y z jar rxjava scala x y z jar rxjava jruby x y z jar rxjava kotlin x y z jar A project will include just the jar that meets their language needs there will no longer be a core jar plus the language adaptor The drawback of this is that mixing two of these in a classpath will result in non deterministic loading whichever is loaded last wins and that is the version that will be used This means if a library depends on rxjava jar but is using Groovy and needs rxjava groovy jar it is up to the developer of that project to make sure they have only the rxjava groovy jar version This is not ideal but is a one time pain setting up a build and is better than the constant pain of missing static typing or converting to from different Observable implementations for different languages At this time we are optimizing for projects using a single language or Java another language If there are use cases where people are trying to mix multiple languages in a very polyglot manner we have two options include an rxjava dynamic jar version that re adds the Object overloads include build configs for common combinations of languages such as rxjava groovy clojure jar Language adaptations such as clojure which has preferred idioms that necessitate wrapping will still be possible through the language adaptor projects and be included in the appropriate language jars This should not break any code but will require a slight change to the build dependencies in your project when we release this We hope that this enables the RxJava project to better achieve its goal of being polyglot and targeting the JVM in general and not any specific languages without sacrificing interop or idiomatic usage in each of the languages','RxJava pull requests #174 https netflixoss ci cloudbees com job RxJava pull requests 174 SUCCESS This pull request looks good 1 I don t think I follow your point about making the subscribe Map String Object method static Wouldn t that break all existing scripts that use this method Could we add a subscribe Map String Closure or subscribe Map String IFn variant in the dynamic JARs That would also suggest tightening up the core signature to subscribe Map String Function 2 This naming convention makes sense to me I will change rxjava core to rxjava in the artifact name at least I think I will leave the directory rxjava core alone since it makes more sense there and IMO it would be confusing to have a dir like RxJava rxjava I don t plan on bringing rxjava kotlin along with this pull request but I can review #292 to help fit that into the 0 10 world 3 I think I understand this though I m already at the edge of my Gradle ability If I m understanding this correctly we should not change the build steps for a project we just need to change the generated Maven POM That makes sense I ll figure out a way to accomplish that Looks good all in all I ll try this out with my Scala sample as soon as possible Thanks for the awesome work Thanks @jmhofer for stepping in to test out these changes @mattrjacobs Answers to your questions 1 subscribe Map If we leave the Map String Object then the Functions from capability needs to keep working The other option is we change that to be Map String Function as you suggest and then auto generate the versions for each language 2 Thanks and agreed on the directory name but that can change if we want in the future without impacting the artifact name once you set the name 3 Maven POM I think the simplest solution is just not have any compile dependencies only provided I believe your Gradle scripts just need to adjust to include provided dependencies not just compile runtime dependencies and then it will work I would not try messing with POM files directly If something is specified as provided then it is used for compilation but not included in the POM when pushed to Maven Central RxJava pull requests #175 https netflixoss ci cloudbees com job RxJava pull requests 175 SUCCESS This pull request looks good RxJava pull requests #176 https netflixoss ci cloudbees com job RxJava pull requests 176 FAILURE Looks like there s a problem with this pull request RxJava pull requests #177 https netflixoss ci cloudbees com job RxJava pull requests 177 SUCCESS This pull request looks good Currently if you publish RxJava to your local Maven repo you ll find that the rxjava scala and rxjava swing POMs include a dependency on rxjava core which doesn t exist anymore as a module as it was renamed to rxjava Unfortunately I don t know enough about Gradle to be able to fix this My guess would be that it s not enough to set the baseName of the JAR to just rxjava There should be a way to tell gradle that the module is called rxjava even though the directory is called rxjava core Here s another problem Excluding UnitTest from JARs that might be included by Scala will cause the Scala compiler to crash with a Typer error because it expects defined inner classes to exist This means that at least in rxjava swing the exclude can t be done I ve created a mini PR against the unit test problem here https github com benjchristensen RxJava pull 1 I got my little sample https github com jmhofer rxjava samples working with this PR The code itself was very easy to adapt The implicits seem to be working fine One small thing I noticed The very long names of the implicits are a bit distracting imho Should I want to use one of these functions explicitly I d prefer shorter names like simply func1 instead of scalaFunction1ToRxFunc1 for example Responses to @jmhofer 1 POM references to rxjava core In the Scala case I prefer including all of the core Rx classes directly in the rxjava scala jar so that there is no dependency at all This avoids the problem entirely For rxjava swing I ll work on the Gradle side to make the reference correct This might take the form of changing the reference or actually changing the name of rxjava core to rxjava we ll see how friendly Gradle is 2 Excluding inner classes I ve also come across the Scala compiler error on Classfile parsing with excluded inner classes At the moment unit tests exist in rxjava core jar and rxjava scala jar only Going forward rxjava core These unit tests only exist so that rxjava scala can be built I will exclude them add a new unfilteredJar Gradle task and build rxjava scala off of unfilteredJar rxjava scala I will continue to include UnitTests since it s pretty likely that Scala projects are consuming this rxjava swing I hadn t considered the case of Scala consuming this but you re obviously right For now I ll err on the side of caution and unilaterally add the UnitTests back to the jar At some later point we might want to re examine rxjava swing scala jar rxjava swing filtered jar But adding them back is the safe thing to do Your PR is exactly what I will do thanks for that 3 Implicit names In my experience it s rare that I call implicit conversions by name but I can see your point My only concern is ambiguous namings Would changing scalaFunction1ToRxFunc1 to toRxFunc1 and other similar naming changes be satisfying Responses to @jmhofer 1 POM references to rxjava core In the Scala case I prefer including all of the core Rx classes directly in the rxjava scala jar so that there is no dependency at all This avoids the problem entirely For rxjava swing I ll work on the Gradle side to make the reference correct This might take the form of changing the reference or actually changing the name of rxjava core to rxjava we ll see how friendly Gradle is 2 Excluding inner classes I ve also come across the Scala compiler error on Classfile parsing with excluded inner classes At the moment unit tests exist in rxjava core jar and rxjava scala jar only Going forward rxjava core These unit tests only exist so that rxjava scala can be built I will exclude them add a new unfilteredJar Gradle task and build rxjava scala off of unfilteredJar rxjava scala I will continue to include UnitTests since it s pretty likely that Scala projects are consuming this rxjava swing I hadn t considered the case of Scala consuming this but you re obviously right For now I ll err on the side of caution and unilaterally add the UnitTests back to the jar At some later point we might want to re examine rxjava swing scala jar rxjava swing filtered jar But adding them back is the safe thing to do Your PR is exactly what I will do thanks for that 3 Implicit names In my experience it s rare that I call implicit conversions by name but I can see your point My only concern is ambiguous namings Would changing scalaFunction1ToRxFunc1 to toRxFunc1 and other similar naming changes be satisfying @mattrjacobs All your suggestions seem sensible to me Concerning implicit naming It may be relatively rare however using the implicits often leads to your having to specify the parameter types of the closures being implicitely converted which can be more verbose and confusing than making the conversion explicit and then being able to shorten the closure syntax Names like toRxFunc1 are ok with me not too long and still unambiguous sounds like a good compromise RxJava pull requests #181 https netflixoss ci cloudbees com job RxJava pull requests 181 SUCCESS This pull request looks good RxJava pull requests #182 https netflixoss ci cloudbees com job RxJava pull requests 182 SUCCESS This pull request looks good RxJava pull requests #183 https netflixoss ci cloudbees com job RxJava pull requests 183 SUCCESS This pull request looks good RxJava pull requests #188 https netflixoss ci cloudbees com job RxJava pull requests 188 FAILURE Looks like there s a problem with this pull request Replaced by https github com Netflix RxJava pull 319',RxJava,true,false,false
16472825,'Getting rid of one of the Gradle 1 6 deprecation warnings','This PR addresses one of Gradle s new deprecation warnings The other warning is caused by the LicensePlugin as far as I can see','RxJava pull requests #178 https netflixoss ci cloudbees com job RxJava pull requests 178 SUCCESS This pull request looks good Thanks @jmhofer',RxJava,true,false,false
16570150,'issue with onErrorResumeNextFunction and async Observable','This may be a problem with MapObserver or OnErrorResumeXXX and is probably related to https github com Netflix RxJava issues 216 If the function returned by OnErrorResumeXXX returns an async Observable then there is some unpredictable behavior with operators eg Map that rely on the AtomicObserver to generate a valid event stream I ve created a UnitTest below to demonstrate the problem java @Test public void testMapError Observable String observable Observable from one error two three Observable String m Observable create map observable new Func1 String String @Override public String call String in if error equals in throw new RuntimeException Simulated error return in Add error handler m m onErrorResumeNext new Func1 Exception Observable String public Observable String call Exception e return createSlowSequence new String II III m subscribe stringObserver verify stringObserver times 1 onNext one Should be caught be OnErrorResumeNext verify stringObserver never onError any Exception class verify stringObserver never onNext error verify stringObserver never onNext two verify stringObserver never onNext three Resume output verify stringObserver times 1 onNext II verify stringObserver times 1 onNext III verify stringObserver times 1 onCompleted private Observable String createSlowSequence final String seq return Observable create new Func1 Observer String Subscription public Subscription call final Observer String ob new Thread Delay for a given time public void waitFor int ms try Thread sleep ms catch InterruptedException e Slowly emit a sequence public void run for int i 0 i seq length i waitFor 100 ob onNext seq i ob onCompleted start return Subscriptions empty There are two issues I see causing the problem so two potential fixes 1 MapObserver continues to emit onNext onCompleted even after it has emitted onError This pushes the problem downstream 2 OnErrorResumeNext continues to propogate onNext onCompleted even after it has subscribed the Observer s to the resume Observable This means that if the resume Observable is async OnErrorResumeNext will emit one more onNext and potentially onCompleted from the source Observable unless the resume Observable completes It could also trigger multiple subscriptions if the MapObserver produced another onError _A side note here is that the AtomicObserver fixes this issue if the resume Observable is sync because it ignores the source Observable events after the resume Observable has completed This effectively masks the problem in the OnErrorResumeNext unit test Perhaps the unit tests should disable this behavior or detect it via a plugin _','',RxJava,false,false,false
16928879,'Async Observable from future','I was surprised that Observable from future doesn t return a truly async future I wrote one for my own purposes and thought it might be useful as a core part of rxJava https gist github com samhendley 6030565 java Observable T obs Observable future future would be converted to class level or static members probably FutureWatcher futureWatcher new FutureWatcher Executor callbackPool new ThreadPoolExecutor 5 Observable T obs futureWatcher watchFuture future callbackPool I imagine the most straightforward implementation would be something like Observable from future executor a bit like the scheduleOn method from Hystrix I would also suggest that you update the documentation on Observable from future to reflect that the observable are effectively blocking I had assumed otherwise and was very disappointed in the performance of my system as a whole when I integrated with a library that returned futures hystrix in this case A co worker was asking some probing questions and it made me actually look at the implementation and once I integrated the FutureWatcher our performance was back to where I expected it to be','Thanks for getting involved A Java Future does not support callbacks thus it can only block when dereferencing the value The only way to make this asynchronous is wrapping yet another thread around it as you are doing which means a thread waiting on a thread It s a legit thing to do when you must deal with a Java Future but obviously not ideal For this enhancement instead of accepting an Executor in the overload it should use a Scheduler which is the Rx abstraction for concurrency Regarding Hystrix you ll appreciate the work being done here https github com Netflix Hystrix pull 151 Yeah I saw that ticket a while ago Can t wait to see it I just needed a temporary shim in my code until that support is added I am trying to convince my group here to build some systems based on rxJava and hystrix and am building some samples demos to first convince myself that it will be workable So far I am very impressed with both of them keep up the good work I am actually trying to move our group entirely onto the netflix stack for all of our SOA oriented components Wish you guys had an office out in North Carolina your infrastructure team seems to really have its act together looks like it would be a fun place to work I understand the need for the shim that s where the Observable from future came from actually the implementor just chose to only do it in a blocking manner and not wrap a scheduler around it but that should definitely exist Thanks for the kind words about our teams Hystrix and RxJava I m glad they are serving you well Do you want to submit a pull request with an Observable from Future f Scheduler s overload Yes I can do that I am hoping to start contributing soon but haven t actually checked out the project yet so far been getting just browsing the downloaded sources There are a few more helpers that we are working on SettableFuture that you may also find useful Sam On Fri Jul 19 2013 at 4 07 PM Ben Christensen notifications@github com wrote I understand the need for the shim that s where the Observable from future came from actually the implementor just chose to only do it in a blocking manner and not wrap a scheduler around it but that should definitely exist Thanks for the kind words about our teams Hystrix and RxJava I m glad they are serving you well Do you want to submit a pull request with an Observable from Future f Scheduler s overload Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 307#issuecomment 21274113 This has been implemented for several of the from methods For example from java util concurrent Future extends T future Scheduler scheduler from java lang Iterable extends T iterable Scheduler scheduler',RxJava,false,false,false
17017173,'Ensure now is always updated in TestScheduler advanceTo By','The TestScheduler advanceTimeTo and advanceTimeBy methods only update now correctly if there is a scheduled event in the work queue after the target time If the queue is empty now is not updated at all If it has no items after the target time then now is updated to the time of the last event on the queue The pull request ensures now is always updated to the target time There is no check to make sure time always moves forwards but then that check is not in the current implementation either','RxJava pull requests #184 https netflixoss ci cloudbees com job RxJava pull requests 184 SUCCESS This pull request looks good Makes sense to me thanks @NorthNick',RxJava,true,false,false
17052794,'A little typo in a comment in the Clojure examples','','RxJava pull requests #185 https netflixoss ci cloudbees com job RxJava pull requests 185 FAILURE Looks like there s a problem with this pull request Thanks @josephwilk',RxJava,true,false,false
17130170,'How to observe perpetually changing Iterable','Hi guys Can you explain how to observer a perpetually changing Iterable For instance here is some code java public class ReportConnector private ConcurrentLinkedQueue String eventList new ConcurrentLinkedQueue String private Observable String observable public ReportConnector observable Oberservable toObservable eventList observable subscribe new Action1 String @Override public void call String event System out println Val sent event public addEvent String event eventList add event The problem is the observable immediately calls onComplete in the constructor after adding the subscriber and then subsequent additions to my linked queue through the addEvent method never get processed by the subscriber I m sure I m missing a big concept here so any help in pointing me to how to do this correctly would be greatly appreciated Thanks','The Oberservable toObservable eventList method captures the current state of the Iterable emits it and completes There is no builti in mechanism for observing an Iterable for future changes If the source Iterable must exist and can t be wrapped modified then something likely a thread would need to poll that Iterable for new values that are then emitted to an Observable via onNext and never call onCompleted If the source Iterable can be wrapped or replaced I d make it so whenever something is offered to the ConcurrentLinkedQueue that it also gets sent to the Observable onNext This is obviously far more efficient than polling an Iterable Basically wherever the events originally come from it is better to capture that event and push it to the Observable rather than route them through an Iterable if you can The Observable from Iterable method is just a bridge from a snapshot of a List Collection The monitoring approach could theoretically be done with a signature such as Observable monitor Iterable i Scheduler s with the Scheduler giving it the thread to perform the monitoring on Ben On Tue Jul 23 2013 at 3 41 PM Eric Nelson notifications@github com wrote Hi guys Can you explain how to observer a perpetually changing Iterable For instance here is some code public class ReportConnector private ConcurrentLinkedQueue String eventList new ConcurrentLinkedQueue String private Observable String observable public ReportConnector observable Oberservable toObservable eventList observable subscribe new Action1 String @Override public void call String event System out println Val sent event public addEvent String event eventList add event The problem is the observable immediately calls onComplete in the constructor after adding the subscriber and then subsequent additions to my linked queue through the addEvent method never get processed by the subscriber I m sure I m missing a big concept here so any help in pointing me to how to do this correctly would be greatly appreciated Thanks Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 310 Ben Christensen API Team 1 310 781 5511 @benjchristensen You might want to look at the Subject and friends A subject is both and observable and observer at the same time PublishSubject String events PublishSubject create events subscribe new Action1 String @Override public void call String event System out println Val sent event events onNext one events onNext two Thanks so much for your quick responses I really appreciate it',RxJava,false,false,false
17248369,'Various Javadoc improvements and corrections','I ve been exploring the rxjava source code for the last week or two in my spare time and along the way I cleaned up and made minor corrections and improvements to the Javadocs Here s the changes if they re of interest','RxJava pull requests #186 https netflixoss ci cloudbees com job RxJava pull requests 186 SUCCESS This pull request looks good',RxJava,true,false,false
17291802,'Fix for OperatorOnErrorResumeNextViaObservable and async Resume','This patch is to ensure that OnErrorResumeNextViaObservable handles source Observables that emit invalid sequences of onNext onError onCompleted Please see #306 for a more detailed description of how this can occur and what other fixes might be needed To re create the issue the provided resume Observable itself must be async Because it does not complete immediately there is a window where the source Observable can produce additional events which are then propogated into the output The fix ensures the operator only propogates onNext onCompleted as long as the original subscription is valid It also prevents the resume subscription happening more than once even if multiple onError events being received','RxJava pull requests #187 https netflixoss ci cloudbees com job RxJava pull requests 187 SUCCESS This pull request looks good Looks like a good fix Thanks @petermd for catching and fixing this and including unit tests',RxJava,true,false,false
17345758,'Operation mergeDelayError Observable Observable T does not delay onError of parent observable','Shouldn t all onError calls including a possible onError call of the parent observable being delayed till all child observables have successfully finished emitting items or called onError themselves To get my desired behaviour I changed the code so now the onError method adds the error to the error queue and calls the onCompleted method which already does the propagation of received errors','If this is still an issue can you provide a unit test I wrote a unit test An Observable of asynchronous child Observables is calling onError after emitting the child Observables I created 2 branches https github com EmteZogaf RxJava tree mergeDelayErrorNotDelayingParentOnError having the unit test added and is failing https github com EmteZogaf RxJava tree mergeDelayErrorFix having the unit test and my proposed fix added and is succeeding Under what circumstances can the parent emit an error The use cases you provide seem contrived as mergeDelayError is a static method and therefore there is not a parent Observable to emit an error java Observable mergeDelayError o1 o2 o3 subscribe In that code there are 3 Observable instances being merged but no parent to emit an error Reviewing this again the signature where this could be an issue is java public final static T Observable T mergeDelayError Observable extends Observable extends T source Marking to be included in 1 0 work I m sorry for this late reply I haven t looked into this issue for a while as our project using RxJava is running without any problems But I will try to update to the new version next month and use base RxJava only without any customizations we made to it back then If this is still an issue I ll report here',RxJava,false,false,false
17481187,'Map Error Handling','While reviewing pull request https github com Netflix RxJava pull 312 I noticed that the behavior of Map didn t seem right in how it continued emitting values and necessitated the changes to onErrorResumeNext Digging in it seems the onNext was manually doing error handling but in a non comprehensive manner whereas now I am letting the SafeObserver previously called AtomicObserver handle it which does unsubscribes and ignores subsequent events if it doesn t unsubscribe correctly This is also related to https github com Netflix RxJava issues 216','RxJava pull requests #189 https netflixoss ci cloudbees com job RxJava pull requests 189 SUCCESS This pull request looks good',RxJava,true,false,false
17490218,'Change onError Exception to onError Throwable Issue #296','This changes Observer#onError Exception e to Observer#onError Throwable e See Observer#onError should use Throwable https github com Netflix RxJava issues 296 for discussion that led to this change This is a breaking change and will result in a version bump from 0 9 x to 0 10 x','RxJava pull requests #190 https netflixoss ci cloudbees com job RxJava pull requests 190 SUCCESS This pull request looks good diff isn t easy to unveil pitfalls as catch Throwable e diffs don t have a large enough window to show whether or not error propagation occurs after signaling Might be worthwhile doing a visual scan via reference check or string search in the ide where catch Throwable e to see if errors are propagated after signaling or not We could possibly assume that a catch Throwable e conversion is more likely to imply a change in the next line or two than not Not sure another option would be to make static utility methods like guava s Throwables propagate and use in common cases such as coercing to Exception RuntimeException or propagating errors ex java catch Throwable e thingThatTakesException signal asException e propagateIfError e @adriancole diff isn t easy to unveil pitfalls as catch Throwable e diffs don t have a large enough window to show whether or not error propagation occurs after signaling This change is very bad for reviewing with a diff that only include a couple lines on either side When I review the 60 files before submitting the pull request I had to keep flipping back to the full source code to read the context It s just the nature of the change RxJava pull requests #191 https netflixoss ci cloudbees com job RxJava pull requests 191 SUCCESS This pull request looks good @adriancole another option would be to make static utility methods like guava s Throwables propagate and use in common cases such as coercing to Exception RuntimeException or propagating errors This already exists in RxJava Exceptions propagate Throwable but I just updated it to also throw Error now as I d missed doing that change last night https github com benjchristensen RxJava commit 87e308ad16e0e9649efa773f5056f373c7b95336#L0L25 RxJava pull requests #192 https netflixoss ci cloudbees com job RxJava pull requests 192 SUCCESS This pull request looks good Cool sounds like an easy adjustment then On Thursday August 1 2013 Ben Christensen wrote @adriancole https github com adriancole another option would be to make static utility methods like guava s Throwables propagate and use in common cases such as coercing to Exception RuntimeException or propagating errors This already exists in RxJava Exceptions propagate Throwable but I just updated it to also throw Error now as I d missed doing that change last night benjchristensen@87e308a#L0L25 https github com benjchristensen RxJava commit 87e308ad16e0e9649efa773f5056f373c7b95336#L0L25 Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 315#issuecomment 21952181 RxJava pull requests #193 https netflixoss ci cloudbees com job RxJava pull requests 193 SUCCESS This pull request looks good Moving forward with the merge',RxJava,true,false,false
17520132,'Remove thread sleep from unit test to speed it up','and apparently formatting and imports changed a bunch','RxJava pull requests #194 https netflixoss ci cloudbees com job RxJava pull requests 194 SUCCESS This pull request looks good',RxJava,true,false,false
18026992,'AndroidScheduler java','Initial spike for AndroidScheduler java Been using this for quite some time But I don t like the concept using calling observer observeOn AndroidScheduler getInstance as it sort of puts Android specific stuffs Should RxJava support some concept of Schedulers mainScheduler We can then set the default main schedulers using Schedulers setMainScheduler AndroidScheduler getInstance when app starts','RxJava pull requests #195 https netflixoss ci cloudbees com job RxJava pull requests 195 FAILURE Looks like there s a problem with this pull request Thanks @prabirshrestha for the submission Support for Android is something several people will be happy about getting Since I don t work with Android I d like to pull @mustafasezgin into this conversation as he s using RxJava on Android at SoundCloud Mustafa can you review contribute and or answer questions Mustafa gave a presentation that hinted at the use of Schedulers for Android http backstage soundcloud com 2013 08 responsive android applications with sane code android schedulers soundcloud https f cloud github com assets 813492 958852 530a5bd4 0470 11e3 88c3 1c0ef2be88f8 png I don t like the idea of global settings like Schedulers setMainScheduler as libraries would be stepping on each other I think something such as the following is a good approach similar to the Schedulers factory class in Rx core java AndroidScheduler MAIN_SCHEDULER or AndroidScheduler mainScheduler AndroidScheduler mainScheduler definitely sounds better then AndroidScheduler getInstance I named the method as getInstance so that the AndroidScheduler is similar to the SwingScheduler which uses getInstance I would also need help on writing the gradle build scripts Android SDK should also be installed in the CI server Android dependencies should be in a repo such as Maven Central so that someone does not need to configure their environment correctly to build Is this what it needs http search maven org #artifactdetails 7Ccom android tools 7Csdk common 7C22 1 3 7Cjar The gradle file will be similar to this https github com Netflix RxJava blob master rxjava contrib rxjava swing build gradle but you will add this dependency compile com android tools sdk common 22 1 3 Also add your module to this file https github com Netflix RxJava blob master settings gradle For example place this on the 2nd to last line before rxjava swing rxjava contrib rxjava android @benjchristensen happy to help out @mttkay from the SoundCloud Android team will also be valuable to the discussion We use the first method outlined by @benjchristensen to set a the main thread scheduler on an observable The main thread scheduler is similar to the one submitted by @prabirshrestha with the second method being implemented using the Handler postDelayed method For consistency with the core package I think the static method approach for the scheduler is more suited in this instance @mttkay wrote some helpful components related to fragments which we were also looking to opensource Maybe we should look to getting that out sooner @mttkay thoughts Also you should only need to add the main android sdk dependency http search maven org #search 7Cgav 7C1 7Cg 3A 22com google android 22 20AND 20a 3A 22android 22 using the provided maven scope Thanks @mustafasezgin for getting involved Nice to know you and @mttkay work together Yes we only need the SDK as a provided not compile dependency So like this in the build gradle file provided com google android android 4 1 1 4 Awesome I was playing around with Android and RxJava already too But I guess for me it ll be a libgdx integration mostly Hey guys indeed we have been using a more complete scheduler for a while one that has an implementation for delayed messages too My suggestion is to rename AndroidScheduler to AndroidSchedulers plural since there may be more schedulers to be implemented for Android down the road like scheduling via AsyncTasks So we should have AndroidSchedulers mainThread I m also missing tests and build integration with this PR It seems like it s a WIP maybe we should combine our efforts around this Have a look at the above PR I ve pulled the scheduler component out of our production app code and into rxjava contrib The build should pass the Scala adaptor seems to be causing trouble though Seems to neither build on the public CI nor on my local machine Test execution time is slightly up due to the addition of Robolectric which goes through a start up procedure to initialize a fake Android application environment for testing closing in favor of #318',RxJava,true,false,false
18045350,'Initial support for scheduling on Android Handler threads','To add to the discussion in https github com Netflix RxJava pull 317 this is pretty much what we re using in our production app since a few weeks now It used to live in our app project but since we ve already started talking about adding to rxjava contrib I ve pulled out the code in question and integrated it into RxJava under rxjava android This comprises x a Scheduler implementation which schedules work on Android s Handler threads including the main UI thread x an AndroidSchedulers class which provides factory methods to instantiate Handler schedulers especially the main thread scheduler x unit test support via Robolectric x build integration There is some discussion needed around both test support and build integration @mustafasezgin will want to weigh in on this In order to write Android unit tests you re unfortunately required to take a few obstacles so we had to add some cruft to the production code an empty Android R class and a custom test runner','RxJava pull requests #196 https netflixoss ci cloudbees com job RxJava pull requests 196 FAILURE Looks like there s a problem with this pull request RxJava pull requests #197 https netflixoss ci cloudbees com job RxJava pull requests 197 FAILURE Looks like there s a problem with this pull request Unit testing in Android land is a bit tricky as the sources for android are all stubs which throw exceptions There are quite a few final methods that exist as well in many components making mocking not possible with libraries like mockito As a result a framework which is popular called Robolectric has tried to help developers by providing a barebones implementation of the android sdk using some classloader magic which is helpful when wanting to write unit tests Other option is to write integration tests which run on device which is slow and not useful in this instance Why is this relevant in this case To get robolectric up and running we need some default folders and files along with a custom test runner To be consistent with the rest of rx core we have to put these in the main src package but really we should be not shipping these folders files with the release artifact So one solution is to have a custom build step to strip these out which is probably preferred and the other is to break convention and have a separate test directory @benjchristensen would be good to get your thoughts on how you would want to move forward with this @mustafasezgin go ahead and put the unit tests in src test if that s what makes sense for this module I mix and match as needed The RxJava build files should pick up tests in both src main and src test and run them via the gradlew build scripts already Also we should be stripping UnitTest files from the published artifacts but aren t right now because of an odd issue with Scala That will be solved when we start publishing different artifacts for different languages once this pull request finally hits https github com Netflix RxJava pull 304 In short put your tests where you need want in this rxjava android module @mttkay and @mustafasezgin Is there anything else needed before merging and releasing this @prabirshrestha Since you had a similar pull request can you weigh in on whether this is meeting your needs and functions correctly Anyone else with Android experience able to comment Looks good to me @benjchristensen Just to respond to your comments to keep close to existing convention I will keep the tests where they are but will try to move the test driver and empty R file into the test package so they are not bundle with the release artifact Will try to get that in tonight and then we should be good to go We actually have a few more components to add but they need a little more cleanup before they are ready Sounds good I ll await your final go ahead before merging RxJava pull requests #198 https netflixoss ci cloudbees com job RxJava pull requests 198 FAILURE Looks like there s a problem with this pull request @benjchristensen I have modified the build script to exclude the test support package at jar build time and doc generation time by adding the exclude option to the gradle tasks If this looks good to you then happy to have it merged RxJava pull requests #199 https netflixoss ci cloudbees com job RxJava pull requests 199 FAILURE Looks like there s a problem with this pull request RxJava pull requests #200 https netflixoss ci cloudbees com job RxJava pull requests 200 FAILURE Looks like there s a problem with this pull request @benjchristensen Just to let you know this is all ready to be merged from my perspective Great thank you @mustafasezgin I will aim to have this done this week Also working on getting https github com Netflix RxJava pull 319 out the door which will benefit Android This builds successfully and unit tests pass on my machine so I m merging this I m held up on releasing this while dealing with an internal build issue that posts to Maven Central handling the new com google android and org roboelectric dependencies Do you need help with this What s the problem No it s an internal issue it s related to how the Netflix build system supports multiple different repos and expects the dependencies from Maven Central to also be available in the internal repo which is a headache for this type of thing as these dependencies have never been seen by it before I know what I need to do just ran out of time last night will try to deal with it today This is released in 0 10 1 making its way to Maven Central now Announced on Twitter at https twitter com RxJava status 371124391590887424 I ve added a README at https github com Netflix RxJava blob master rxjava contrib rxjava android README md It would be helpful to show people usage examples and some documentation Can one of you contribute any of that Here are examples of contrib modules in the Hystrix project with README files if you want to model after any of them https github com Netflix Hystrix tree master hystrix contrib hystrix request servlet https github com Netflix Hystrix tree master hystrix contrib hystrix network auditor agent https github com Netflix Hystrix tree master hystrix contrib hystrix metrics event stream Would probably make sense to have something on the wiki as well that at least links to the README Great thanks Ben I ll look after the documentation',RxJava,true,false,false
18223552,'typesafe core','Here s another attempt at making rx core typesafe and still supporting dynamic languages The previous attempt was https github com Netflix RxJava pull 304 Enough changed including the 0 10 release since I submitted #304 that it made more sense to start fresh with this one All the comments from that PR still apply and the subscribe on map issue is now handled','RxJava pull requests #201 https netflixoss ci cloudbees com job RxJava pull requests 201 FAILURE Looks like there s a problem with this pull request When trying to build I get Could not find property ideaProject on task set for language adaptors rxjava scala What can I do against that Are you building using gradle or gradlew gradlew is a wrapper script at the root of RxJava that allows for consistent builds pins to gradle 1 6 For more context on why this is a useful convention see http www gradle org docs current userguide gradle_wrapper html Matt On Tue Aug 20 2013 at 12 02 AM Joachim Hofer notifications@github com wrote When trying to build I get Could not find property ideaProject on task set for language adaptors rxjava scala What can I do against that Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 319#issuecomment 22926217 Thanks with gradlew it works I simply didn t know about the wrapper script RxJava pull requests #202 https netflixoss ci cloudbees com job RxJava pull requests 202 FAILURE Looks like there s a problem with this pull request Replacing with https github com Netflix RxJava pull 323',RxJava,true,false,false
18473377,'JRuby examples don t work JRuby picks the wrong overloaded method','The JRuby adapter doesn t work because JRuby can t figure out which overloaded Observable#subscribe method to pick It ends up picking Observable#subscribe Map String Object which raises an error because the argument doesn t respond right ruby require rxjava core 0 10 0 jar require rxjava jruby 0 10 0 jar observable Java Rx Observable toObservable one two three observable take 2 subscribe lambda x puts x the code above prints the following errors in JRuby 1 7 4 ruby rxjava rb rxjava rb 6 warning ambiguous Java methods found using subscribe java util Map onNext Observable java 278 in subscribe java lang RuntimeException onNext key must contain an implementation from NativeMethodAccessorImpl java 2 in invoke0 from NativeMethodAccessorImpl java 57 in invoke from DelegatingMethodAccessorImpl java 43 in invoke from Method java 601 in invoke from JavaMethod java 455 in invokeDirectWithExceptionHandling from JavaMethod java 316 in invokeDirect from InstanceMethodInvoker java 61 in call from MethodHandle java 599 in invokeWithArguments from InvocationLinker java 153 in invocationFallback from rxjava rb 5 in __file__ from rxjava rb 1 in load from Ruby java 807 in runScript from Ruby java 800 in runScript from Ruby java 669 in runNormally from Ruby java 518 in runFromMain from Main java 390 in doRunFromMain from Main java 279 in internalRun from Main java 221 in run from Main java 201 in main in JRuby 1 6 8 it prints a less verbose version of the same error Notice the line which reads onNext That s actually the puts from lambda x puts x in action JRuby wraps the lambda in something that looks like a Map and then when RxJava calls get on that map JRuby calls call on the lambda So if you modify the example code to read lambda x lambda y puts y this is what happens ruby rxjava rb rxjava rb 6 warning ambiguous Java methods found using subscribe java util Map RxJava Could not find function language adaptor Groovy with path rx lang groovy GroovyAdaptor RxJava Successfully loaded function language adaptor JRuby with path rx lang jruby JRubyAdaptor RxJava Could not find function language adaptor Clojure with path rx lang clojure ClojureAdaptor RxJava Could not find function language adaptor Scala with path rx lang scala ScalaAdaptor one two Which kind of works but it s not as smooth as the ideal API would be ruby observable subscribe x puts x But that would probably require a real JRuby native extension if I get the time I ll send you a pull request with one','Glad to have you involved we haven t had much use of JRuby that I m aware of so I m not surprised we have some issues I would appreciate your involvement Can you check out code from this pull request https github com Netflix RxJava pull 319 build the rxjava jruby jar and try it We are working on a very different approach in this pull request for language adaptors that is statically typed As for the subscribe Map overload I m not thrilled by that one and it has caused other issues I ve considered getting rid of it before we hit 1 0 but I know it s used in a variety of places so haven t pulled that trigger It works better but not perfect JRuby seems to pick a working overload but it still warns about there being multiple overloads which is hard to fix without adding JRuby metadata to the Observable class An upside is that you can skip the lambda and use the more Ruby ish obs subscribe x puts x i e pass a block to #subscribe Since there will be a version generated to work specially for JRuby how much can the code generation things add Ideally it would add JRuby metadata to the class to make it work as a JRuby native extension Can you give me any hints on how to dig into that Where should I start to look in the code to understand the code generation If the generated Observable could be something like this but lots more obviously it could integrate with JRuby even better ruby @JRubyClass name Rx Observable public class Observable T static class Allocator implements ObjectAllocator public IRubyObject allocate Ruby runtime RubyClass klass return new JRubyObservable runtime klass @JRubyMethod meta true rest true public static T Observable T from ThreadContext ctx IRubyObject receiver IRubyObject args @JRubyMethod name subscribe public IRubyObject subscribeRuby ThreadContext ctx Block block There would be some more code needed that registered the class with the runtime and created the Rx module and some more things but that wouldn t need to be generated Can you take a look at pull request https github com Netflix RxJava pull 323 and suggest how to re add JRuby support correctly We have decided against doing byte code generation We can not add anything such as the annotations in your example to rxjava core it needs to be in a separate submodule similar to Groovy Scala and Clojure So this means using something like extension methods implicits or other such tools if JRuby supports them I will have a look With some small patches at least some of the basics work ruby require rxjava core build libs rxjava 0 10 1 SNAPSHOT jar class Java Rx Observable java_alias subscribe subscribe Java RxUtilFunctions Action1 java_class end module Rx include_package rx end o Rx Observable from 1 2 3 o map n n 2 subscribe n puts n I haven t tested any more than that but it looks like it could work #323 should be 0 11 0 SNAPSHOT afaik not 0 10 1 SNAPSHOT Are you sure you re using the correct version of RxJava Good catch I m not used to gradle or even having to compile stuff so I didn t clean up from the last build I did so the old jars were still around The Ruby patch works with 0 11 0 too which means that those small patches would have make the old version work too so that s good to know Without the patch it works as with #319 the code runs but it prints a warning about not finding the right overloaded method The boring part of doing it this way is that each method on Observable and any other classes needed for interoperability will need to be annotated with java_alias On the other hand I don t see any other way of doing it which wouldn t involve writing even more code Does JRuby have a way to apply these aliases programmatically For example in Groovy we use reflection to determine all methods that need extensions and then programmatically create all of the MetaMethod implementations to bridge Groovy and Java You can see an example here https github com mattrjacobs RxJava blob 8c87c29bea5e076bdc4202af5626d474ab1c7117 language adaptors rxjava groovy src main java rx lang groovy RxGroovyExtensionModule java#L103 Otherwise every time a new method is added to core someone will have to maintain the JRuby java_alias mappings Maybe I m not sure I ll have to look into more about how JRuby s native extensions work So far I ve only done it by creating classes and adding metadata but I guess that it should be possible to do it on existing classes to somehow If I understand the code you linked to correctly it s looking through the Observable and BlockingObservable classes for methods that take subclasses of Function and somehow makes the Groovy runtime prefer those over any other overloads That s what would be needed for JRuby too and since the Groovy version just uses Java reflection to do it I think it should be possible in JRuby too All that the java_alias thing does is that it looks up a Java method by reflection and adds that method into a cache that JRuby will look in before it looks at the Java class which is kind of similar to what the Groovy extension thing does I think So yes probably maybe hopefully but I m not sure exactly how right now This isn t complete yet but here s a first pass at an implementation I think will work @benjchristensen can you take a look and let me know if this is the direction you re looking for It s largely cribbed from the Groovy implementation https github com ragalie RxJava commit fc0a706faaa27d1d797cfb8c43080a3b68e1cb1f I m getting warnings about overloads This is my code ruby require rxjava core build libs rxjava core 0 14 2 SNAPSHOT jar require language adaptors build libs language adaptors 0 14 2 SNAPSHOT sources jar module Rx include_package rx end o Rx Observable from 1 2 3 o map n n 2 subscribe n puts n and this is the output JRuby 1 7 4 rxjava rb 14 warning ambiguous Java methods found using subscribe rx util functions Action1 2 4 6 Just to be clear the commit I posted doesn t work yet I just want to make sure that the approach is sane before investing more time in it Ok Yeah it might work Not sure how well the generated methods will work though they are added on the classes but call super to call the original method but I m not sure that super is actually what you think it is it might be I assume you ve run the code and I have not so I could be completely wrong In other words you re adding a method on Observable and then you call super in that method to call the original method on Observable but that should call a method on the superclass of Observable not the original method unless JRuby tries to be clever and figures out that your added method is on the eigenclass and super should refer to Observable but I don t think it does And either way once you call super JRuby still has to look up the right Java method to call and it doesn t have any more type information to do it so it will pick one at random and print out the ambiguous Java methods found warning Even if you ve wrapped the proc in an Action I m not sure that JRuby will pick the right overloaded method In my experience it tries but it doesn t always succeed in picking the right method I think a better way to solve the problem is to use java_alias as in one of my examples above That way JRuby will always pick the right overload I m not sure all the wrapper classes would be needed in that case because JRuby will wrap a proc in a proxy class that implements whatever interface is required and since Function and Action interfaces only really have one method that also just happens to map straight to interface of proc I think letting JRuby do it makes sense There might be a slight performance loss from letting JRuby generate proxies instead of having Java classes but I think it s greatly outweighted by skipping a large part of the work that JRuby otherwise would have done in finding the right overload You re right the super approach won t work I tried the java_alias approach first and the problem I ran into is that it didn t seem to work correctly when a method had multiple signatures with the same number of arguments For instance I tested it with RxJava 0 10 which has subscribe Hash and subscribe Action1 or something like that I tried just running java_alias on the methods that had Function arguments and it threw an error when I tried to use the Hash argument I tried running java_alias on all methods but running it first on the non function methods and second on the function methods and that didn t work either threw an error with a Hash argument I m a relative newbie at JRuby so totally possible I m doing something wrong But from my basic understanding I don t understand how java_alias will be a solution if there are two signatures with the same number of arguments and we want to allow access to both of them I spent some more time researching this evening and I think the easiest path forward is to leverage the JRuby method dispatching as much as possible Outside of the Proc Action OnSubscribeFunc Function casts which we can reliably do but which the JRuby dispatch logic is having trouble reliably doing the default dispatch logic is likely to be far better at sussing out the method signature we want to invoke than we would be The first thing the dispatch logic checks for when trying to find a method signature match is whether the Java class of the argument provided is an exact match with the parameter type specified in the method signature see https github com jruby jruby blob master core src main java org jruby java dispatch CallableSelector java#L321 While it isn t guaranteed that this will always be true JRuby could change the dispatch logic I think it s a safe bet that it will continue to preference exact class matches when selecting overloads I think that means that as long as we pass in arguments that implement the exact interfaces JRuby should have a much easier time finding the matching method signature Assuming that s true I think we should implement an algorithm like the following on load Select the methods that have any signatures that contain a parameter type that is a sub interface of rx util functions Function Determine the sub interfaces of Function that are possibilities for each argument position for a given method If any given argument position has more than one possibility e g Action1 or Action0 ignore If any given argument position has only one possibility then note that we should convert any Proc we see in that argument position into the Function subclass we ve identified Then I think we should implement the following to occur at runtime Upon invoking a method where we ve noted that we should convert Proc s replace the Proc arguments with wrappers that implements the noted interfaces if applicable Call the original Ruby method with the modified arguments We should be able to do this using alias_method to copy the original subscribe for instance to subscribe_without_argument_wrapping and then redefine subscribe to modify the arguments and call subscribe_without_argument_wrapping with the updated arguments Under this scenario most of the hard dispatch logic remains in Java the only additional runtime things we re doing in Ruby are a a check to see if the argument is a Proc b a Hash lookup to see whether we can replace the Proc with a wrapper and c instantiating the Java wrapper So I don t think it should significantly slow things down It s clear you ve thought about this quite a bit @iconara anything stick out to you as suspect here It isn t the cleanest thing in the world but https github com ragalie RxJava commit 957af11bb7e843e79e72a7559a7c0c8a24052e35 seems to be working correctly This code no longer causes an ambiguous method warning ruby require rxjava core build libs rxjava core 0 14 2 SNAPSHOT jar require language adaptors rxjava jruby build libs rxjava jruby 0 14 2 SNAPSHOT jar require language adaptors rxjava jruby src main ruby rx lang jruby interop o Java Rx Observable from 1 2 3 o map n n 2 subscribe n puts n I m going to clean it up as best as I can then open a PR I m pretty new to JRuby though and I m sure there are some ways to simplify what I ve done so hopefully someone can help me out with that In particular I d love to be able to leverage the built in JRuby proxying telling it which interface to proxy instead of the clunky ones in the commit I also don t know what to do with the Ruby code Should that stay in the JAR and just need to be required manually Or should it be pulled out to a gem I m not sure what s idiomatic Thanks @ragalie I m sure it can be done more elegantly but it would take a lot of time and I don t know very much more about the details of JRuby s Java integration to say for sure how to do it It s better to get something that works and improve it later than trying to find the optimal solution now There s a way to package a JAR that makes JRuby run code when it is require d from Ruby code You need to stick a special class at the root of the JAR here s an example https github com iconara msgpack jruby blob master ext java MsgpackJrubyService java It s used to load JRuby native extensions i e Java code that creates JRuby modules and classes but in this case it could be used to automatically run the interop code which can be loaded from within the JAR Another option would be to make the the interop code the main entrypoint for Ruby and for it to load rxjava core jar and rxjava jruby jar Come to think of it that would be the better solution The benefit of the former solution would be that you could ship it all as just the JAR but the latter is simpler to maintain and is how many JRuby wrappers for Java libraries work If it s ever going to get any kind of adoption in the Ruby world the library must be packaged as a gem I implemented JRuby support in #422 Let me know what you all think and if there s anything that doesn t seem to be working correctly Thanks Awesome @ragalie I m taking a look now and will merge it into master or iterate with you on it if there are changes needed',RxJava,false,false,false
18501263,'AtomicObservableSubscription to SafeObservableSubscription','','RxJava pull requests #203 https netflixoss ci cloudbees com job RxJava pull requests 203 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
18508937,'Update Android README md','Added sample usage of Android Handler schedulers','RxJava pull requests #204 https netflixoss ci cloudbees com job RxJava pull requests 204 FAILURE Looks like there s a problem with this pull request Thank you',RxJava,true,false,false
18747412,'Static core','Another take on Issues #204 #208 typesafe rxjava core modular jars Scala support via implicits Groovy support via extension methods No Clojure support in this PR eventually via macros Eliminated JRuby support for now','RxJava pull requests #205 https netflixoss ci cloudbees com job RxJava pull requests 205 FAILURE Looks like there s a problem with this pull request @jmhofer @mttkay If either of you use Scala and of course anyone else using Scala can you build the rxjava scala module and try this out I would appreciate your feedback as this is a pretty major refactoring and key step towards getting to version 1 0 Sure I ll try this out asap Updating my rxjava samples https github com jmhofer rxjava samples project to this worked fine Thank you @jmhofer for confirming Scala functionality RxJava pull requests #206 https netflixoss ci cloudbees com job RxJava pull requests 206 FAILURE Looks like there s a problem with this pull request If anyone watching this project uses RxJava with Groovy please build from this branch and test Current status of this pull request is Java core is fully type safe removed object overloads Java core has a reduced API surface area removed duplicative and deprecated methods Scala is functional using implicits Groovy is functional using an extension module Clojure is awaiting a new macro that will allow rx fn syntax for passing closures JRuby support is dropped for now apparently it hasn t been working If anyone from the JRuby community can get involved to help we d gladly accept the assistance to get it fully supported again RxJava pull requests #207 https netflixoss ci cloudbees com job RxJava pull requests 207 FAILURE Looks like there s a problem with this pull request We use some Scala on the server side where we use Finagle and Twitter Futures not RxJava but I could test in a sandbox project if that helps I will be travelling for 2 weeks starting Monday but I ll try to find some time over the weekend Thanks @mttkay Don t stress if you don t have time over the weekend we ve had enough confirmation of Scala functionality to move forward Enjoy your trip Thank you @daveray for the Clojure adaptor I think we are getting close to this pull request being ready to merge into master just some final testing If anyone has final feedback before we move forward now is the time Merging to master for final testing and release',RxJava,true,false,false
18803626,'0 11 Cleanup','','RxJava pull requests #208 https netflixoss ci cloudbees com job RxJava pull requests 208 FAILURE Looks like there s a problem with this pull request RxJava pull requests #209 https netflixoss ci cloudbees com job RxJava pull requests 209 FAILURE Looks like there s a problem with this pull request RxJava pull requests #210 https netflixoss ci cloudbees com job RxJava pull requests 210 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
18818625,'Preserve metadata on fn and action macros','Because they re macros rx fn and rx action would lose metadata attached to them in particular type hints which are slightly important to disambiguate overloaded Observable methods Fixed','RxJava pull requests #211 https netflixoss ci cloudbees com job RxJava pull requests 211 FAILURE Looks like there s a problem with this pull request What normal use cases with Observable need type hints @benjchristensen only to disambiguate an overloaded method So for 0 11 0 almost never as far as I can tell This is the result of further backporting the interop stuff into a 0 10 system where the Object version of methods was always chosen leading to strange failures I hope we can avoid ambiguous method signatures as it would cause problems for other languages as well such as Groovy I just released 0 11 1 to pick up this change Me too Aren t you worried about running out of version numbers if you keep releasing so often',RxJava,true,false,false
18819289,'Make Observable covariant and Observer contravariant etc','Now that RxJava is typesafe there s one thing I m still dearly missing a covariant Observable or generally making everything in the library properly co contra and invariant which especially means functions and observers too Rx NET has this for example see http msdn microsoft com en us library dd990377 aspx and notice the out in public interface IObservable out T Unfortunately variance can not be as easily defined in Java as in C# or Scala Instead this will lead to an aweful lot of super extends generics in method signatures This means that the longer we wait with this the more it will hurt to introduce it everywhere So I d like to try my hand at this if you agree that it s worthwhile at all','I agree it is worth pursuing and would appreciate you tackling it Like On Aug 31 2013 at 1 05 AM Ben Christensen notifications@github com wrote I agree it is worth pursuing and would appreciate you tackling it Reply to this email directly or view it on GitHub Started with Func0 and Func1 see https github com jmhofer RxJava tree super extends I don t think it s worthy of a pull request yet will work towards that',RxJava,false,false,false
18821885,'Clojure doesn t build for me','For 0 11 1 gradlew clean build leads to language adaptors rxjava clojure clojureTest Exception in thread main java lang ClassNotFoundException rx lang clojure interop DummyObservable The class is there however the build doesn t seem to pick it up','That is odd considering it made it through our build and release cycle @daveray any ideas I was able to reproduce this but not consistently I also found non deterministic unit test failures during build See #329 for the full report link to a gist with transcripts I wrestled with DummyObservable a bit but thought I had beaten it Clearly not I ll take a look Sorry about that @jmhofer Does it work for you now that https github com Netflix RxJava pull 330 is merged Yes works for me now thanks Great Thanks for confirming',RxJava,false,false,false
18825017,'Jenkins build failing due to use of system gradle','Since 2013 08 22 https netflixoss ci cloudbees com job RxJava master 138 the Jenkins build has been failing The build fails https netflixoss ci cloudbees com job RxJava master 138 console with the error What went wrong A problem occurred evaluating project language adaptors rxjava scala Could not find property ideaProject on task set I can reproduce this locally by building with gradle 1 7 Building with the gradle wrapper gradlew pins to gradle 1 6 which does not exhibit this error Aside Building with gradle 1 6 reveals a unit test failure in rx plugins RxJavaPlugins UnitTest This failure has been masked by the missing property error that occurs earlier in the build process It appears to fail because the build command is gradle clean build which uses the system install of gradle I believe that the system gradle was upgraded to version 1 7 between 2013 08 01 and 2013 08 22 The solution is to change the Jenkins build command to gradlew clean build','I have alerted our build team to update the CloudBees config @garethbowles or @quidryan Can you please adjust the CloudBees config to use the gradlew wrapper instead of the system gradle version You should have permission to update your CloudBees jobs I can take a loom later otherwise Sent from Mailbox for iPhone On Sat Aug 31 2013 at 1 32 PM Ben Christensen notifications@github com wrote @garethbowles or @quidryan Can you please adjust the CloudBees config to use the gradlew wrapper instead of the system gradle version Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 328#issuecomment 23613406 Oh I do have access I had tried about a week ago and didn t see what I needed for some reason but now I do I m changing the config and running will report back on if I run into other issues Thanks @garethbowles and sorry for harassing you needlessly No prob sorry it took us a while to get back to you on this it may be something we need to do for other OSS projects so it s good to know The CloudBees builds both master and pull request are succeeding again so closing out this issue screen shot 2013 08 31 at 2 34 13 pm https f cloud github com assets 813492 1063046 1acdd3ae 1285 11e3 8041 c2e4ea507623 png I upgraded gradle from 1 6 to 1 10 and the same issue appeared in my machine Is anyone using gradle 1 10',RxJava,false,false,false
18825191,'Build is non deterministic failed 4 times in different places','Reported as of commit 6a7ee812c7 https github com Netflix RxJava commit 6a7ee812c75234ed01350b2fa168223f2d79c62e I ve pasted a transcript as this gist https gist github com mtnygard 6399361 All of the builds were executed in a single shell with the same build command gradlew clean build The builds all failed for different reasons suggesting timing dependencies in the unit tests','Note that the build failure reported in #327 is one of the errors I encountered More detail this seems to be a Java 8 issue It builds clean with 1 6 I have committed fixes for these that should behave better There were legit issues in them that depended on specific machine and scheduler timing I won t be surprised if there are other tests with similar issues in the codebase Considering this closed reopen if you re still seeing these issues',RxJava,false,false,false
18827522,'Make DummyObservable visible to clojureTest classpath','RxJava issue #327 Moved DummyObservable into main so that it s compiled and available when the clojureTest task executes Perhaps someone with stronger Gradle skills can figure out how to put this Java class in src test and get things to work out Correctly For the time being several clean build cycles worked fine for me','RxJava pull requests #212 https netflixoss ci cloudbees com job RxJava pull requests 212 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
18827812,'Adding super extends so that Observable is covariant','Ok so this pull request changes a lot of lines It s mostly generalizing all the FuncX s to be used like FuncX T1 T2 TX R contravariant parameters covariant return type and all the Observer s to be used in a contravariant way A few of the Observable uses are covariant now too mostly zip This is the pull request for #326 This doesn t look very good in the code thanks Java Also it doesn t seem to make Scala interop easier at all at least not yet Please take a look I m not exactly happy with the result Maybe I m doing something wrong here I ve still got hope that there s an easier way The pull request compiles and tests ok for me except for the Clojure module but that s another story and not due to my changes','RxJava pull requests #213 https netflixoss ci cloudbees com job RxJava pull requests 213 FAILURE Looks like there s a problem with this pull request I ll have to spend some time later playing with this Anyone else able to try this out and comment on the changes @jmhofer Can you provide examples or use cases of using the updated code that demonstrates covariant contravariant usage that couldn t be achieved before Ok here s an example of what you can do now with the improved zip java import rx Observable import rx util functions Func2 class Media class Movie extends Media class HorrorMovie extends Movie class Rating class CoolRating extends Rating class Result class ExtendedResult extends Result public class Covariance public static void main String args Observable HorrorMovie horrors Observable from new HorrorMovie Observable CoolRating ratings Observable from new CoolRating Func2 Media Rating ExtendedResult combine new Func2 Media Rating ExtendedResult @Override public ExtendedResult call Media m Rating r return null Observable zip horrors ratings combine 0 11 The method zip Observable T0 Observable T1 Func2 T0 T1 R in the type Observable is not applicable for the arguments Observable HorrorMovie Observable CoolRating Func2 Media Rating ExtendedResult but works in super extends branch Lots more Observable usages to go however the Observer s are probably mostly done RxJava pull requests #216 https netflixoss ci cloudbees com job RxJava pull requests 216 FAILURE Looks like there s a problem with this pull request Let me know when you re ready for this to be merged and released I plan on releasing this as 0 12 0 as it does have some breaking changes That CloudBees build failure is legit I also can t build rxjava scala on my machine with this branch The core library is fine What went wrong Execution failed for task language adaptors rxjava scala compileScala Compilation failed because of an internal compiler error see the error output for details In this line java Observable String observable Observable create new Func1 Observer super String Subscription is it the case that Java programmers creating an Observable this way would always have to include the super bit Or is this just for completeness Is this what you mean by I m not exactly happy with the result I haven t thought through it but this doesn t seem like it should be necessary if it s done right @benjchristensen I just noticed that too and adapted the RxImplicits @daveray Looks like it yes I couldn t make the compiler happy without it but maybe I m missing something If you find something that avoids this then please let me know RxJava pull requests #217 https netflixoss ci cloudbees com job RxJava pull requests 217 SUCCESS This pull request looks good Still to do Future is covariant and Timestamped and Notification are probably too Also Lots of operators can be used standalone and therefore should be generalized too RxJava pull requests #218 https netflixoss ci cloudbees com job RxJava pull requests 218 SUCCESS This pull request looks good RxJava pull requests #219 https netflixoss ci cloudbees com job RxJava pull requests 219 FAILURE Looks like there s a problem with this pull request Huh Very interesting compiles for me RxJava pull requests #220 https netflixoss ci cloudbees com job RxJava pull requests 220 SUCCESS This pull request looks good RxJava pull requests #221 https netflixoss ci cloudbees com job RxJava pull requests 221 SUCCESS This pull request looks good RxJava pull requests #222 https netflixoss ci cloudbees com job RxJava pull requests 222 SUCCESS This pull request looks good RxJava pull requests #223 https netflixoss ci cloudbees com job RxJava pull requests 223 SUCCESS This pull request looks good I would call this ready to merge now I looked through all the code and adapted everything I found I can t guarantee that I haven t overlooked something but I guess a few places here and there can still be adapted later on without too much harm The one caveat is @daveray s comment Maybe the observers are overgeneralized somewhere and we can really avoid people having to write super X when creating their own observers I haven t found a solution for this but I m probably blind to it by now Of course one could still add a lot of tests or use cases in CovarianceTest to show that everything compiles as it should In that respect I m rather optimistic though Maybe we can also get rid of more rawtype unchecked annotations now I ll check this later on Now I need some time to recover from all that toiling through Java boilerplatery I need to spend some more time on this In my playing around I wasn t thrilled by how it forces this type of user code that has super in it java public static Observable String o Observable create new Func1 Observer super String Subscription @Override public Subscription call Observer super String t1 return null I have the same concern Guava seems to takes the same approach but I don t recall ever having to use type constraints like that when using it Briefly looking through the Guava code nothing stood out to me though that would make it behave differently though Re reading Effective Java Josh Bloch says this on page 137 Properly used wildcard types are nearly invisible to users of a class They cause methods to accept the parameters they should accept and reject those they should reject If the user of a class has to think about wildcard types there is probably something wrong with the class s API However all of his examples are about methods they aren t about instantiating classes like Func1 T R where T R ends up as super Observer super T extends Subscription Perhaps if this is what covariant generics truly requires we create a new function type specifically for this extremely common case of creating an Observable and have it be something like this java public interface ObservableFunction T extends Func1 Observer super T Subscription public Subscription call Observer super T t1 It can then be used like this java public static Observable Movie o2 Observable create new ObservableFunction Movie @Override public Subscription call Observer super Movie t1 return null public static class MyObserver implements Observer Media @Override public void onCompleted TODO Auto generated method stub @Override public void onError Throwable e TODO Auto generated method stub @Override public void onNext Media args TODO Auto generated method stub public static void testThis o2 subscribe new MyObserver This still requires public Subscription call Observer super Movie t1 but that is auto generated by an IDE and let s face it anyone writing Java is using an IDE whereas the function definition is far easier new ObservableFunction Movie Probably need a better name than ObservableFunction but thus far it feels better to use Unfortunately it can t be an overload of the existing create method as type erasure and dynamic languages see it as the same thing java public static T Observable T create Func1 super Observer super T extends Subscription func Using the ObservableFunction works against that but then people would have to discover that new type in some other way To be truly user friendly the method signature would need to change to java public static T Observable T create ObservableFunction T func This way people would get prompted by their IDEs and Javadoc to use the easiest approach This whole thing with or without a new type is a wide impact breaking change all places someone does Observable create I tried again to do without Observer super T in several relevant places but I failed yet again It seems to be just necessary It stands to reason though if you think about it because Observer is a contravariant type and Java can t deal with that in any other way And in the case of observers API users are not just using them they re creating them I like Ben s ObservableFunction idea above I think it would probably even be possible to get around the overloading problem by not inheriting from Func1 delegating to it instead However it s still a wide impact breaking change due to the super that has to be added within every call method signature concerning observers Still if the create method is the biggest problem maybe it s not so big after all or is create really so widely used I d think that mostly API users will be using already created observables combining them and subscribing to them Here is a trivial example using Java 8 demonstrating how super needs to exist even here if retaining type safety java Observable String oMovie Observable create Observer super Movie o o onNext new Movie o onNext new Movie return Subscriptions empty map movie return movie transformed movie Observable String oMedia Observable create Observer super Media o o onNext new Media o onNext new HorrorMovie return Subscriptions empty map movie return media transformed movie Observable zip oMovie oMedia a b return a b subscribe movie System out println Media Movie movie Or type safety can be thrown away java Observable String oMovie Observable create Observer o o onNext new Movie o onNext new Movie return Subscriptions empty map movie return movie transformed movie But now that allows this to compile java Observable String oMovie Observable create Observer o o onNext new Movie o onNext hello this is not a Movie object return Subscriptions empty map movie return movie transformed movie @jmhofer The create method is how Observable s are created so this affects all producers This should not affect consumers other than making the prompts docs verbose screen shot 2013 09 03 at 4 41 21 pm https f cloud github com assets 813492 1077109 6a7a584a 14f2 11e3 9886 bdddd24de290 png @mttkay and @mustafasezgin Do you have any input on this discussion since you are using RxJava from plain Java Groovy is similar but the generics don t actually do much for it as they are more or less ignored at compile time as best I can tell groovy Observable String oMovie Observable create Observer o o onNext new Movie o onNext new Movie return Subscriptions empty map movie return movie transformed movie Observable String oMedia Observable create Observer super Media o o onNext new Media o onNext new HorrorMovie return Subscriptions empty map movie return media transformed movie Observable zip oMovie oMedia a b return a b subscribe movie System out println Media Movie movie This Groovy code works against current master as well as the new code with super groovy Observable Movie oMovie Observable create Observer super Movie o o onNext new Movie o onNext new Movie o onCompleted return Subscriptions empty Observable Media oMedia Observable create Observer super Media o o onNext new Media o onNext new HorrorMovie o onCompleted return Subscriptions empty Observable zip oMovie oMedia Movie a Media b return String valueOf a String valueOf b subscribe media System out println Media Movie media And here it is again in plain Java java Observable Movie oMovie Observable create new Func1 Observer super Movie Subscription @Override public Subscription call Observer super Movie o o onNext new Movie o onNext new Movie o onCompleted return Subscriptions empty Observable Media oMedia Observable create new Func1 Observer super Media Subscription @Override public Subscription call Observer super Media o o onNext new Media o onNext new HorrorMovie o onCompleted return Subscriptions empty Observable zip oMovie oMedia new Func2 Movie Media String @Override public String call Movie a Media b return String valueOf a String valueOf b subscribe new Action1 String @Override public void call String media System out println Media Movie media It seems that super is fine on the outer generics and doesn t need to be typed everywhere it s just when it s a generic inside a generic the type of the Observer that it becomes annoying It seems the only option while supporting covariance for reducing code verbosity is to create a new type that hides the Func1 super Observer super T extends Subscription complexity So my question now is should we change the API to make all uses of create use the new type or should it remain as Func1 and the other type is just a nice utility that can be used to fulfill the signature In other words do we leave it as this java public static T Observable T create Func1 super Observer super T extends Subscription func or change it to java public static T Observable T create ObservableFunction T func And what do we call the new type if we go that route Options I ve considered are ObservableFunction ObservableFunc OnSubscribeFunction OnSubscribeFunc FuncOnSubscribe And should that live in rx util functions or rx alongside rx Observable It feels that this is not generic and should therefore live inside rx Unfortunately we can not overload this method and support both as type erasure makes them the same and it will confuse dynamic languages implicits etc if we had two methods with similar single function signatures Normally I d rather leave the lower level Func1 method signature and just have a helper class but code completion and javadocs will be far less obvious and not very discoverable Thus for discoverability I think it makes more sense to use create ObservableFunction T func I can t yet think of any forward compatibility reason why this would be a bad thing This pull request is breaking either direction we pursue One last spam to everyone please weigh in if you have an opinion as I intend on making a decision and releasing this week This will be a breaking change and affect usage for everyone Here is what the ObservableFunction interface looks like java Function interface for work to be performed when an @link Observable is subscribed to via @link Observable#subscribe Observer @param T public interface ObservableFunction T extends Func1 Observer super T Subscription public Subscription call Observer super T t1 And the updated create method java public static T Observable T create ObservableFunction T func And sample code using this java Observable Movie oMovie Observable create new ObservableFunction Movie @Override public Subscription call Observer super Movie o o onNext new Movie o onNext new Movie o onCompleted return Subscriptions empty Here is a fork including these changes so we can review and discuss https github com benjchristensen RxJava commit de0358f48518225cea6aaf1fbb56ee529eec8191 I m still not thrilled by any of the directions we can take here I can t argue against making RxJava support covariant types Josh Bloch certainly supports it in Effective Java when he says If you write a library that will be widely used the proper use of wildcard types should be considered mandatory On the flip side it forces the use of super extends everywhere even when covariant requirements are rare I think the only decision at this point to make is whether we should use something like ObservableFunction T to minimize the verbosity or just leave Func1 super Observer super T extends Subscription And if we do use ObservableFunction do we provide similar solutions elsewhere That feels wrong to have special function interfaces for so many things even though it likely will improve readability and usability Other operators that are awkward include defer Func0 extends Observable extends T observableFactory aggregate Func2 super T super T extends T accumulator buffer Func0 extends Observable extends BufferClosing bufferClosingSelector flatMap Func1 super T extends Observable extends R func FlatMap is very common and ends up like this java oMedia flatMap new Func1 Media Observable extends String @Override public Observable extends String call Media s Compare this with current java oMedia flatMap new Func1 Media Observable String @Override public Observable String call Media s However lambdas do make a big different on instance methods not as much on statics as they can infer the types For example in Java 8 the above can become this java oMedia flatMap value return null So without ObservableFunction T in Java 8 we have java Observable create Observer super Media o o onNext new Media o onNext new HorrorMovie return Subscriptions empty flatMap movie return Observable from media transformed movie getName With ObservableFunction T in Java 8 we get this java Observable create Observer Media o o onNext new Media o onNext new HorrorMovie return Subscriptions empty flatMap movie return Observable from media transformed movie getName It seems that type inference will handle the instance methods For example aggregate reduce becomes this java Observable create Observer Integer o o onNext 1 o onNext 2 return Subscriptions empty aggregate previous current return previous current So it s only the static methods of concern create being the most significant Java 6 7 and Android are going to be ugly no matter what but we already knew that and they already are This makes it worse Experiencing some of the pain with generic method signatures and nesting first hand I prefer the type alias in form of an interface I would argue that the subscription function is so widely used that the interface cloaking it will be understood quickly enough by developers so the loss in direct clarity should be negligible RxJava pull requests #229 https netflixoss ci cloudbees com job RxJava pull requests 229 FAILURE Looks like there s a problem with this pull request 1 ObservableFunction interface but call it something else maybe with subscription subscribe in the name @benjchristensen We could overload create etc For this we d have to make ObservableFunction delegate to Func1 then instead of inheriting from it I m not sure if that s a good idea though It would probably be even more confusing I m not sure about the naming Although it is kind of the internal Observable function I think I d prefer SubscriptionFunction or SubscriberFunction or something like that RxJava pull requests #230 https netflixoss ci cloudbees com job RxJava pull requests 230 SUCCESS This pull request looks good How about these names OnSubscribeFunction OnSubscribeFunc FuncOnSubscribe Based on my highly scientific poll of people around me at my office and the few who have commented above I m going with OnSubscribeFunc @benjchristensen works for me Will it extend Func1 or be an independent type as @jmhofer suggests above I think I d prefer the latter I haven t played with it not extending Func1 It will need to at least extend Function so it fits with all other functions in the codebase In what way will it improve things if it doesn t extend Since this function is only intended for us by the Observable create does anyone have issues with it being namespaced as rx Observable OnSubscribeFunc as a static inner class of Observable rather than a first class citizen rx OnSubscribeFunc This works great in Java are there any issues from Clojure or Scala doing it this way Create looks like this java public static T Observable T create OnSubscribeFunc T func Use of it looks like this java import rx Observable import rx Observable OnSubscribeFunc Observable String observable Observable create new OnSubscribeFunc String @Override public Subscription call Observer super String Observer Observer onNext one Observer onNext two Observer onNext three Observer onCompleted return Subscriptions empty The function definition looks like java Function interface for work to be performed when an @link Observable is subscribed to via @link Observable#subscribe Observer @param T public static interface OnSubscribeFunc T extends Function T public Subscription call Observer super T t1 Good idea and shouldn t be a problem for Scala Great I ll proceed with this change then Thanks for the feedback Final interface looks like this java Function interface for work to be performed when an @link Observable is subscribed to via @link Observable#subscribe Observer @param T public static interface OnSubscribeFunc T extends Function public Subscription onSubscribe Observer super T t1 This is being merged in https github com Netflix RxJava pull 343',RxJava,true,false,false
18828564,'Issue 329 Fix non deterministic unit tests','I m sure there are others but I ve tried to fix the ones reported in https github com Netflix RxJava issues 329','RxJava pull requests #214 https netflixoss ci cloudbees com job RxJava pull requests 214 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
18829307,'Order of Generics on Zip Operator','I just noticed that the zip operator has generics ordered as R T0 T1 T2 T3 This differs from Rx Net and Func classes which are like Func4 T1 T2 T3 T4 R This would be a breaking change but should we do it to get consistency of ordering the return type always as the last generic','Maybe we get 0 12 0 out the door with https github com Netflix RxJava pull 331 right away so it comes along with most people picking up the breaking changes in 0 11 0 as well I agree these generics should be reordered for consistency I ll hurry with #331 as it will get difficult to merge as soon as more changes happen There s probably still a lot more Observable usages that can be generalized though Definitely I was thinking that any incompatibilities rx JavaScript and Java implementations might be a deal breaker for kotlin On Saturday August 31 2013 Joachim Hofer wrote I agree these generics should be reordered for consistency I ll hurry with #331 https github com Netflix RxJava issues 331 as it will get difficult to merge as soon as more changes happen There s probably still a lot more Observable usages that can be generalized though Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 333#issuecomment 23615247 I have submitted these changes to https github com jmhofer RxJava pull 1 for inclusion in https github com Netflix RxJava pull 331',RxJava,false,false,false
18833242,'Idiomatic Clojure interface','As of RxJava 0 11 the automagic conversion of IFn has been removed and in it s place there s now a set of functions and macros rx lang clojure interop to ease interop It s slightly more tedious but the API surface area of RxJava has been reduced and it s clearer exactly what s going on now That said using RxJava directly from Clojure still doesn t feel that Clojure y Some issues Remembering to use rx fn now instead of just fn RxJava predicates like those passed to filter must return a boolean Failure to do so results in a ClassCastException Argument order isn t consistent with Clojure conventions even though many names are the same etc This issue is meant to track the addition of a Clojure interface to RxJava that addresses these issues and more The basic idea is to provide an rx core namespace I m open to other suggestions but I like this since the single segment rx namespace is usually frowned upon in Clojure that provides observable implementations for all the functions in clojure core at least where it makes sense So for example rx core map unlike Observable map would support multiple sequences and take a plain IFn to apply to them Similarly rather than operators like Observable toList rx core into would provide the same but more powerful semantics Similar namespaces for blocking ops futures and other useful stuff would also be included Also a raw namespace will exist that provides wrappers around useful Obesrvable methods that don t have a clojure core counterpart For example Observable merge would live here A very old sketch of this approach can be seen here https github com daveray rx clj Since then we ve internally extended these ideas and used them in production So the next steps will be for me @daveray to get that stuff all updated and tested with 0 11 and submit an initial pull request for review Please use this space to offer suggestions ideas etc I ve pursued the above approach but I m totally open to hearing other ideas for making RxJava easier to use from Clojure','Is there any way in Clojure to support implicit closure function coercion against function interfaces like Java 8 or Groovy 2 2 http docs codehaus org display GROOVY 2013 07 09 First beta of Groovy 2 2 available However this goes I would like to see a solution that doesn t require adding new Clojure wrapper code every time a new method operator is added to the core library Don t know why I didn t think of this especially since I did a proof of concept of it back before RxJava was called RxJava At compile time generate wrapper functions from class method info It won t be perfect and will have some of the same problems as Matt s approach but it will be automated and a nice intermediate step between raw java interop and the more curated approach I suggested above I ll give it a try and report back I like the idea of a more idiomatic clojure interface for RxJava I m integrating RxJava into some small clojure projects at Rally and would like to help In PR #338 I wrote some kinda messy code to try auto generating Clojure wrapper functions for RxJava The basic goal is as Ben alluded to something that takes care of fn rx util functions Func conversion and is auto generated from RxJava with minimal human intervention Newly added methods should magically appear in the Clojure wrapper If you look at observable clj you can see the invocation which causes the code generation In observable_test clj is basic usage showing that it actually works The problems @mattrjacobs encountered when doing basically the same thing from Java still remain Figuring out exactly what to do for overloads with the same arity may be tricky I can write a little solver that should be able to insert the right instanceof checks to dispatch correctly at least in most cases Pathological cases like Observable switchDo where the static and non static forms are basically indistinguishable when written as normal function application probably can t be solved automatically So Feedback on this approach is encouraged and welcome I think this would make using rxjava from Clojure mostly idiomatic although I m still partial to the curated approach outlined above I like only needing to know one set of sequence manipulation primitives rather than two Pathological cases like Observable switchDo where the static and non static forms are basically indistinguishable when written as normal function application probably can t be solved automatically Is this the case even when switchDo as an instance has no args I would think it wouldn t apply to this issue in that case Note the comment I left in the source code for switchDo as one I couldn t decide should be left as a static or removed https github com Netflix RxJava blob master rxjava core src main java rx Observable java#L776 Are there any others you ve come across One of the reasons to remove most of the static methods was to remove duplicate signatures that would confuse dynamic languages and also reduce API surface area confusion etc Well the instance switchDo has no args and the static version has one Observable arg In clojure the this parameter from the instance method moves to the arg list so they re effectively exactly the same Unless the instance version can somehow express the constraint that it only applies to Observable Observable T I d stick with just the static version The switchDo issue has been fixed by deleting the instance method in version 0 12 It has also been renamed to switchOnNext Start of wrapper for discussion https github com Netflix RxJava pull 338 Anyone want to continue this discussion @daveray I know you have for more mature Clojure bindings internally do you want to close this and re open a new discussion when you have a pull request ready Closing out if and when there is something concrete regarding Clojure improvements please open a new issue or contribute a PR',RxJava,false,false,false
18840699,'Support for Android events','Hello TL DR I want to contribute on Android support In the past few weeks I m become very interested in FRP in general and how it applies to better wire code in GUI applications my main interest is to build more elegant Android code So I found that here on RxJava there is an initial code to support run RxJava on Android which is really awesome So I ve started to work on some code to try to grasp how to work with Rx After that I want to have some helper methods to transform Android event listeners into RxJava s Subject s so we can really start to make it useful to cleanup our Activity Fragment code There is something like that waiting to be published Can I start to draft some implementation Someone is taking this task and want some help @mttkay I saw that you commited on this area of the project are you the person to ask about this stuff Thank you all for the attention and sorry about the large message smile','Hi Andrew at SoundCloud we re using RxJava on the service layer With the exception of adapters which can be hooked up nicely to an Observable exposed by a service object we haven t given other UI components much thought The main reason I guess being that there is less to be gained out of it I see RxJava s main benefits in the reliability and ease gained where asynchronous event composition is required However neither seem very likely to me to occur in say a TextView or other widgets UI components When I say that I suppose I mean RxJava specifically not FRP in general ReactiveCocoa for instances takes Rx into the view layer but it supports heterogeneous signals that can be mapped to view properties which is very powerful since it allows a view to directly react to state change emitted by an observable sequence With Rx Java one would have to jump through a few hoops to accomplish that That s not to say I m not interested in investigating in that direction If you have ideas or even some working components already I d be curious how such a solution could look like I ll be on vacation for 2 weeks starting Tuesday so apologies if I reply infrequently That reminds me Another area where I think RxJava adds benefits and convenience on Android is when used as a simple event bus Due to its nature it s extremely simple to build application global pub sub style interaction with Rx The Subject class lends itself well for that since every system event can be described using a Subject to which observers subscribe I wrote a tiny event bus using a Java enum in which every enum constant was a Subject The enum had a fire method to signal each event so that observers would receive it The data transmitted through the subject could then be an event object That way you can e g fan out a state change to multiple views at once I can see also benefits in this in replacing many occasions where Intents or Handler messages are cumbersome to use @mttkay Thank you for the response and the nice share of experiences smile My idea with the event support is to remove the logic from Activity by creating new objects in a similar way to ViewModel Passive Presenter So we can write our business logic and test in separation from Android code Even without any separation our code becomes much more declarative and I think that we could have some benefit from this approach I will try to put some experimental project online and link here so you can see what I m talking about Thank you again for your attention Hello Here is a short example https github com andrewhr rxjava android example of what I m thinking about with extending RxJava The implementation of the Events and Properties is quite naive but served as a sort of API exploration There is anyone who also thinks that this extensions are useful I definitely find this useful Especially as it can be combined with Scala even for Android development Thanks @jmhofer for the feedback I will continue to explore in a separate project before making any PR to official project Andrew this looks very interesting and in fact I sat down the other day to think about how this could look like and came up with something very similar I was wondering if you guys already use this in production I would not like the idea of adding features to the library prematurely not unless the code has proven to work in a number of production scenarios I will also start to dabble with it when I m back from vacation I m still traveling for the next 10 days Thanks for working on this It could go a long way in getting rxjava android closer to the feature set of ReactiveCocoa On Sep 7 2013 3 02 AM Andrew Rosa notifications@github com wrote Thanks @jmhofer https github com jmhofer for the feedback I will continue to explore in a separate project before making any PR to official project Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 335#issuecomment 23978488 Hello @mttkay Honestly we don t have any code in production yet I m still trying to get around the concepts But I agree with you that we need something more solid to put into RxJava itself What I ve started to do was converting some code from our apps to Rx model and in the past days I ve done for a meaningful amount of the codebase This is helping me to evaluate and extend the helpers I ve published before As soon I ship this application I can give more concrete feedback about the experience Thank you again for the attention spent here I really appreciate Sounds good Looking forward to it Hi @andrewhr I also think this is very helpful However I have one problem about Android events Most of Android listeners are set via set Listeners If some view has already been set a listener how do you handle it Override it directly Or wrap the old listener in a new listener Hi @zsxwing Actually I have only one project in production which was ported to use the helpers similar to those on the sample project that I shared In the current implementation I found the exact problem that you described I opted for just override the listeners The few cases where I need to reuse an observable I just create a temporary reference for reusing I though that it s fine because my in this first attempt I only want to experiment with some sort of API and also want to gain some experience with the tools this is my first real project with FRP style I ve never tough about listener overriding before but I ve imagined some kind of Context like object to create the observers instead of just using static helpers so it can keep all references and memoize if necessary But I m afraid that it would to some over complication worried Is work still happening on this issue Closing out as this thread has gone quiet please re open or start something new if applicable The RxJava Google Groups is a good place for discussion as well https groups google com forum # forum rxjava',RxJava,false,false,false
18845513,'Idiomatic Scala Support','As of version 0 11 0 Scala support is provided through the use of implicits Conversations on Twitter are bringing up other possible improvements Let s use this issue to discuss','A few comments from my point of view since I first looked at this project I always wanted to use it from Scala Now that the core is typesafe imho we have the first workable Scala integration via implicits From here on everthing depends on how much effort we want to put into this vs how convenient it will be for the users What we already have is that the most important method names match map flatMap filter Matt also made Scala for comprehensions work with observables There s a lot of room for improvements though It seems that due to Scala Java interop there are problems with type inference I even ran into a Scala compiler crash somewhere and sometimes asJava collection conversions are necessary Also Scala Akka futures are not yet addressed at all An Akka specific scheduler would probably be awesome to have too For full Scala user convenience we d probably have to completely wrap rx Observable into its own rx scala Observable This would mean a lot more maintenance effort for the Scala integration of course I don t think we can do this automatically via code generation or macros but I m no expert of all that But still I think it s well worth it to create a dedicated Scala API 1 Implicit based integration with Java based observables has a serious flaw as it doesn t support parameter type inference for lambdas The situation isn t going to change until https issues scala lang org browse SI 6221 is fixed It s definitely fixed in 2 11 and at EPFL we have a compiler plugin that backports the fix to 2 10 Probably Typesafe folks can be convinced to do the backport in one of 2 10 x releases cc @adriaanm @gkossakowski @retronym @JamesIry 2 Some features that might be desirable in rx scala Observable a native function types b native collections c method names familiar to folks that use native collections d making parameter of defer by name e creation of Observables via apply rather than via from 3 I also don t think that macros can help with rx scala Observable because what you re probably after isn t just a copy paste of a Java API but rather a redesign that takes Scala features into account But if there are some things that can be autogenerated I ll be happy to answer questions about how macros work and how they can be used IMHO after looking at the code using implicits convertions is not a good idea I think you have better to start with a complete wrapper of the API then you ll be able to apply scala idiom basically writing a DSL instead of having a Java API with some facilities for converting type And that way you don t have to wait for https issues scala lang org browse SI 6221 which sounds anyway like a clumsy integration of Java API to me Here is some background https github com Netflix RxJava issues 204#issuecomment 15249648 on why the current design was chosen rather than having each language with a separate version of Observable The approach of having language specific packages classes was pursued but did not work well because Rx is a composable library It means that every time an Observable is used it needs to be re wrapped or un wrapped by whichever language is using it For example From Java a library is exposed that has a method like this java rx Observable getData From Groovy a library is exposed with a method like java rx groovy GroovyObservable getOtherData Then from Scala you need to wrap them again java rx scala ScalaObservable from getOtherData This means we have an rx Observable wrapped as rx groovy GroovyObservable wrapped as rx scala ScalaObservable To compose the two we would have java rx scala ScalaObservable zip rx scala ScalaObservable from getOtherData rx scala ScalaObservable from getData scala closure here Now what does ScalaObservable return from its operators ScalaObservable or Observable Should the above zip operator return rx scala ScalaObservable or rx Observable What happens if this library is consumed from another language If Observable each step along the way it must be wrapped yet again If ScalaObservable it has now changed all of the return types of rx Observable to a subtype In short for interop between languages it very quickly becomes a mess and our primary polyglot goal was that rx Observable was usable across all libraries as the single type and because the whole point of Rx is chained composition it s not as simple as just a single decoration at the beginning It affects every single method in an API and step of the chaining For this reason we chose the current language adaptor model so rx Observable can remain the sole public interface across languages Thanks for providing the design notes I wonder though how often people tend to mix languages in their projects Usability improvements in switching from a Java based least common denominator to an idiomatic API might be significant Does being polyglot overweigh these improvements I m not sure if wrapping Observable for Scala not in a subclass though would really hurt so much Imho it s worth a try to find out how it feels There will be a lot of wrapping and unwrapping behind the scene though I m afraid At Netflix we are using Clojure Groovy Java and Scala and I know of apps running code from at least 3 of those 4 in the same JVM instance I imagine it s not common in most environment for this type of diversity but it is something we have wanted to support as seamlessly as possible This is because we have wanted the rx Observable to act as the interface we can expose across module boundaries as it naturally ends up at the edge of the API in methods such as Observable T getDataFromService args This is part of what drove us to target the JVM with RxJava and not any specific language That said an idiomatic solution that works best for pure Scala apps is more important If we can find a solution that can retain the use of rx Observable without a completely separate wrapper then great otherwise let s have a ScalaObservable for pure Scala apps and a way of going back and forth across language boundaries when it s needed Perhaps the implicits that exist right now can solve the immediate interop needs for easy interaction from Scala to Java but the option to convert to ScalaObservable would also be there Another piece of information to guide this the Rx Net version in C# is defined by simple interfaces for Observer and Observable without any of the operator interfaces on them All of the operator methods static and instance level are added via extension methods It s quite clean and makes the interfaces more flexible anyone can easily implement them and the extension methods are just there without inheritance involved The reason RxJava has Observable as a concrete class is because extension methods don t exist in Java so we don t have a choice but to have them as concrete methods to enable the fluent chaining pattern In Scala however we do have extension methods implicits macros etc that theoretically can allow the rx Observable to be made into whatever it needs to be for idiomatic Scala usage similar to how C# implements Rx Net using extension methods I imagine a possible issue is if existing methods on rx Observable are in the way and cause problems in achieving idiomatic Scala functionality if that s the case I d like to understand what those issues are and if they can be resolved and if not if they really are deal breakers At this point I become not so helpful as I am not skilled enough in Scala to have a valid opinion or guide the conversation much further I do have some questions though for the Scala experts here 1 What would make rx Observable idiomatic for Scala I d like to see unit tests or sample code demonstrating expected behavior and usage so that we re all working towards the same goal and know when we ve achieved success 2 What about the current rx Observable Scala implicits is not working well 3 What requirements of 1 can not be achieved with implicits and macros and requires a separate concrete class as a wrapper Thank you everyone for your involvement I really do want us to find the ideal solution for Scala and then as a secondary priority make it work well across the JVM for polyglot applications Thank you for your swift feedback It s a pleasure to help 1 I m not an Rx expert and in fact this is the first time I see any Rx code apart from random snippets in web articles so please don t treat this list as definitive Comprehensive analysis would require quite some time and I m not sure I have it right now a Observable from could be replaced by Observable apply so that one can write Observable 1 2 3 instead of Observable from 1 2 3 b It shouldn t be necessary to write asJava e g as in https github com Netflix RxJava blob master language adaptors rxjava scala src main scala rx lang scala RxImplicits scala#L349 and asScala not sure whether it s necessary now c Use of mutable collections in situations like https github com Netflix RxJava blob master language adaptors rxjava scala src main scala rx lang scala RxImplicits scala#L350 is really inconsistent with Scala s pursuit of immutability I wonder whether it d be possible to write such code in a functional way d Instead of taking a no arg function Observable defer could take a by name parameter which would obviate the need of creating an explicit closure https github com Netflix RxJava blob master language adaptors rxjava scala src main scala rx lang scala RxImplicits scala#L232 e For a former C# developer like me method names like lastOrDefault sound familiar but for the Scala croud out there not so much How about changing the names and maybe even signatures so that they mirror method names of native collections E g lastOrDefault could become lastOption also note the change from default values to options f I m also not sure whether extension methods are even necessary From what I would guess in C# they are forced to use them because interfaces can t define methods with implementations at least that was the story with IEnumerable and Enumerable In Scala we can do that so why not just put all the combinators in Observable g mapMany in https github com Netflix RxJava blob master language adaptors rxjava scala src main scala rx lang scala RxImplicits scala#L351 is essentially flatMap right h No idea how this name could be stated more succinctly but toBlockingObservable feels a bit verbose When I moved from C# to Scala in people s code I felt an overall tendency to compress everything including names This is kind of a vague observation so feel free to ignore it 2 Function literals don t support inference for parameter types unless they are used in a context that requires a Scala native function type In particular inference won t work if function literals are supposed to be converted to something implicitly E g in https github com Netflix RxJava blob master language adaptors rxjava scala src main scala rx lang scala RxImplicits scala#L341 one can t drop type annotations for lambda parameters I tried removing them and got a compilation error Btw why are you using 2 10 1 when 2 10 2 is already available for quite long Did you have any problems with it That s an instance of https issues scala lang org browse SI 6221 which has been fixed in 2 11 and probably could be backported to 2 10 If you re in need of an immediate solution we at EPFL have a compiler plugin for 2 10 that provides a backport Excellent observations about the API @xeno by Currently we are preparing exercises for the Coursera class Principles of Reactive Programming https www coursera org course reactive For this course we would like to make an idiomatic Scala API @samuelgruetter is working on that The cross language compatibility pointed out by @benjchristensen is a reasonable concern However I think there is a lot of monolingual projects out there that would greatly benefit from the idiomatic Scala library It seems to me that adding a Scala wrapper can be only a plus in those cases For polyglot projects we could also take the Java rx Observable as a common ground being a return type of each operation and in API signatures Then all of the Scala support can be added by an implicit conversion rx Observable rx ScalaObservable As a long shot maybe the interface for multi and mono lingual projects can be unified so that we do not repeat our selves IMHO it is worth a try Thanks for all the observations I ll try to address some of the ones from @xeno by 1a 1e and 1g are just aliasing problems imho We already have flatMap as alias for mapMany and the other aliases could easily be added either directly in rx Observable or in a Scala wrapper if the namespace gets too big otherwise not my preferred solution Methods returning options will have to live in a Scala wrapper however I didn t take a look at 1b and collection conversions yet This really shouldn t be necessary often if at all 1c You re looking at test code here which tests the callback at the end of the world This is not really normal usage of the API The whole RxJava codebase is refreshingly though not completely free of mutability if you ask me Also the Rx API is actually there to allow you to handle all your events in a functional immutable way In short I don t see a problem here 1d is Scala specific By name parameters are a great feature for methods like defer I agree We should make use of them in the Scala wrapper I m not worried about 1f either 1h I like the verbose name in this specific case Imho it s the same as asInstanceOf in Scala Maybe I m evil but I like to punish people who do things they probably shouldn t do Ok there will of course be valid use cases for blocking observables but there shouldn t be too many of them hopefully 2 is quite a big problem if you ask me A backport of the fix to Scala 2 10 would be great We can probably get around this with a dedicated Scala wrapper though And the reason for 2 10 1 instead of 2 10 2 is currently just a technical problem with the build system I too hope that this will be fixed soon 1c Even that can be made functional if you replace the subscribe with toList toBlockingObservable single @abersnaze You re right good point I started a little experiment with a more idiomatic Scala wrapper It s just humble beginnings currently though You can find it here https github com jmhofer RxJava blob scala wrapper language adaptors rxjava scala src main scala rx lang scala Observable scala Comments and forks are welcome of course I started from the super extends pull request in order to check how this whole thing feels in Scala Scala 2 10 2 support was added in version 0 11 2 https github com Netflix RxJava releases tag 0 11 2 1 Implicit based integration with Java based observables has a serious flaw as it doesn t support parameter type inference for lambdas The situation isn t going to change until https issues scala lang org browse SI 6221 is fixed It s definitely fixed in 2 11 and at EPFL we have a compiler plugin that backports the fix to 2 10 Probably Typesafe folks can be convinced to do the backport in one of 2 10 x releases cc @adriaanm @gkossakowski @retronym @JamesIry Sorry we don t change type inference in minor versions unless there s a critical bug The risk of regression in source compatibility is too high The cross language compatibility pointed out by @benjchristensen is a reasonable concern However I think there is a lot of monolingual projects out there that would greatly benefit from the idiomatic Scala library It seems to me that adding a Scala wrapper can be only a plus in those cases I completely agree if a wrapper is the only way to achieve idiomatic support Monolingual projects should take first priority as that is the common case We believe that the following solution would be best Implicit value class let s call it ScalaObservable for the moment wrapping an rx Observable all return types are rx Observable Since ScalaObservable is a value class there is no runtime overhead for the wrapping some explanations can be found in the second half of this blog post http www blog project13 pl index php coding 1769 scala 2 10 and why you will love implicit value classes This is new in Scala 2 10 and actually allows us to have extension methods similar to C# An object FunctionConversions containing all implicit conversions from Scala functions to Rx functions the same as in the present Scala adaptor https github com Netflix RxJava blob rxjava 0 11 1 language adaptors rxjava scala src main scala rx lang scala RxImplicits scala#L29 These conversions are only used by the adapter users of Scala Rx won t use them All instance methods of rx Observable which take a Func or an Action have a wrapper method in ScalaObservable whose signature has Scala functions and whose body uses the conversions from FunctionConversions ScalaObservable has map flatMap filter like in the present adaptor https github com Netflix RxJava blob rxjava 0 11 1 language adaptors rxjava scala src main scala rx lang scala RxImplicits scala#L108 to enable for comprehensions ScalaObservable has lastOption method instead of lastOrDefault etc functions passed by Rx Scala users to Observable needn t be implicitly converted so we re not affected by the bug https issues scala lang org browse SI 6221 that parameter type inference of implicitly converted functions does not work in Scala 2 10 An object Observable with apply methods instead of from and create polyglot projects can also use this approach I ve started to implement such an adapter and will post some code soon Note that I ve not yet addressed the following points compatibility with Scala Akka futures how to integrate ScalaObservable with Scala collections to get all methods of Scala s Traversable http www scala lang org api current index html#scala collection Traversable @samuelgruetter Sounds awesome Very much looking forward to your sharing the code You can see what I m doing here https github com samuelgruetter rx playground blob master RxScalaAdapter src main scala ScalaAdapter scala Note that it s still very incomplete and not yet tested but work is in progress Great thanks I ll play around with it too @samuelgruetter All of that sounds great I ll take a look next week and offer feedback There s an interesting problem with map If I add an explicit conversion like ScalaObservable numbers map it works but without i e numbers map gives an error I ll investigate on this You can see the corresponding test here https github com samuelgruetter rx playground blob 365a7ba8afa4feda1f5961a3a21c524092caf8f4 RxScalaAdapter src main scala rx lang scala Adaptor scala#L497 Maybe there s a 2nd implicit somewhere adding map @samuelgruetter what is the error if @jmhofer is right you should have an amibgous implicit resolution error If anything about the core Java library is causing issues let me know There s no 2nd implicit but there s a second map The map in rx Observable And scalac wants to use this one and does not convert to ScalaObservable However with reduce it works Just another guess but then it s maybe due to the type parameter of map your reduce doesn t have one you renamed the one with type parameter to fold which luckily avoids the problem Covariant support has been merged into master This also changes the type used with Observable create I believe all of the structural changes are now merged to master Are there any other changes that should be made before we release 0 12 so as to better support Scala integration I ve isolated the implicit conversion problem here https github com samuelgruetter rx playground blob master ScalaImplicitsProblem src main scala ScalaImplicitsProblem scala It s a problem with the Scala compiler @benjchristensen looking forward to a jar with covariant observables @samuelgruetter I m pretty sure no one could make the scala compiler be able to solve an ambiguity like that one If you where the compiler which method you think should be choosed You guys should seriously consider implementing a full wrapped scala version first and keep multi lang support as a cherry on cake IMHO it s a mistake to do the opposite maybe I m wrong but I think most scala user will want to use it in a full scala project And for the course it would be good to have an idiomatic API scalac is indeed inconsistent it goes the extra mile to try an implicit view when the originally tried method is monomorphic but doesn t do the same if it is polymorphic That s unlikely to change soon even in 2 11 But one change that is likely in the 2 11 timeframe is first class support of SAM types which would let you write an anonymous function that would be translated to rx Func1 BTW it s really great to see this discussion and cooperation happening So to make polymorphic methods like map work we d have to return ScalaObservables not Java Observables everywhere I guess which doesn t pose a problem anyway as far as I can see @aloiscochard Is that what you mean by a full wrapped scala version Because I thought that @samuelgruetter s goal was already to create a full wrapped scala version @jmhofer yeah it s exactly what I meant By doing that you ll be able to provide the best possible syntax for RX API looking forward next enhancement @samuelgruetter is there something we can do in the short term to work around this issue Is there anything about the core library that if changed would simplify this effort @aloiscochard What about the approach being pursued if the compiler bugs didn t exist is a mistake @benjchristensen I don t see any problem with switching to the approach where we stay with intermediate ScalaObservables throughout the wrapper As ScalaObservable is a value class it shouldn t even impact performance at all I agree with @jmhofer I ve started such a Scala Observable which always returns Scala Observable see here https github com samuelgruetter rx playground blob master RxScalaAdapter src main scala rx lang scala Observable scala @benjchristensen I would say it s kind of bad design a form of overloading abuse I would go the type class way on a similar Wrapper than @jmhofer one to make a map function polymorphic Anyway the current approach took by @samuelgruetter looks good As @jmhofer said there should be no perf impact as long as you keep a value class and from what I ve seen there should be no reason to need more than one value in the wrapper I have some remarks but I l make them directly on @samuelgruetter commit as I did before @benjchristensen I m confused about the jar releases I thought they have contained @jmhofer s changes for proper covariance contravariance handling since 0 11 2 but apparently they don t In rxjava core 0 11 3 jar flatMap looks like this public R Observable R flatMap Func1 T Observable R func return mapMany func On github master flatMap looks like this that s what I would like to have in the jar public R Observable R flatMap Func1 super T extends Observable extends R func return mapMany func @samuelgruetter If I m not mistaken there was no release yet after the merge of the co contavariance branch 0 11 3 was right before that I m afraid that you ll have to wait for 0 11 4 or 0 12 more likely or you ll have to work directly on the repo build of RxJava Those changes will be in 0 12 which has not been released yet It was merged to master yesterday Before releasing I wanted to determine if this thread of discussion required any further changes to core and I want to get in https github com Netflix RxJava pull 349 as well since it generalizes some objects in rx util which hopefully gets confirmed today Is there anything else that if done in core for release 0 12 would improve Scala support I can t currently think of anything that if done in core for release 0 12 would improve Scala support But probably I ll find such things just after 0 12 is released Then once I wrap up those other things hopefully today I will release 0 12 I fully expect we ll find more to change hence us not being at 1 0 yet Due to the 2 bugs are we unable to pursue the route where rx Observable is the return type at this time Also since I m unfortunately not yet very experienced with Scala in your examples would you mind demonstrating a use case where a ScalaObservable is exposed back to Java for interop I m interested in understanding how the solution being worked on would function in polyglot environments while understanding this is a secondary priority if you call wrapped on a ScalaObservable you get back the original Observable which can be used with the Java API Maybe we could find a better name that wrapped not easy though I d prefer calling wrapped asJava instead like the collection JavaConverters do Version 0 12 has been released I ve forked the RxJava repo and I m now working here https github com samuelgruetter RxJava blob idiomaticscala language adaptors rxjava scala src main scala rx lang scala Observable scala @samuelgruetter great stuff @samuelgruetter Good idea And Yay finally a covariant observable Awesome I ve been working towards this all the time Well now I have a Scala compiler bug It s here https github com samuelgruetter RxJava blob idiomaticscala language adaptors rxjava scala src main scala rx lang scala Observable scala#L168 I don t know yet what to do about that @samuelgruetter You can work around the bug by explicitly provide a type argument I ve isolated and reported this issue along with the workaround here https issues scala lang org browse SI 7818 Try it with an explicit type parameter for the Java method new Observable JObservable synchronize T asJava Works for me at least Thanks @retronym Is this going to be fixed in Scala 2 10 x I m asking because we want to use the Rx Scala Wrapper for a course in November and we don t want to confront students with compiler bugs So we consider temporarily removing extends AnyVal until the interplay between value classes and covariance can be considered stable @samuelgruetter The particular bug only affects you when you define the value class Clients of the class are safe ok so we ll keep using extends AnyVal unless it leads to more problems This Observable scala https github com samuelgruetter RxJava blob 955fbfcdfdd2ce12ac2ee578d63c8edd734f8444 language adaptors rxjava scala src main scala rx lang scala Observable scala now contains all methods present in the Java Observable but for many of them there is only a comment containing their signature and a note on the problem I faced You can find all these interesting problems by searching for TODO Code Bounty https app codebounty co reward image 6b82995d8cf0ea7678754a98 https app codebounty co reward link 6b82995d8cf0ea7678754a98 I m planning to continue as follows Add some tests to Observable java Their goal is not to test the correct behavior of the methods that s already done in the unit tests of the operations but to test if the method signatures of Observable are good and to provide small usage examples I expect these tests to reveal some issues related to covariance Fix these Continue with the Scala adaptor @samuelgruetter I just took a quick look nice progress Looks like most of your issues are related to covariance I haven t look in depth but there is some trick to workaround this kind of thing in scala not sure if possible to apply them here I ll try to take a look during the week and give you feedback not sure when unfortunately I ve seen some comments where you hesitate returning the scala wrapped version or the java one I would say that for a first version just return the scala one You can refine that later trying to find where you can return the native type IMO it s a nice to have but clearly not absolutely needed when using the API in pure scala About Future I think it should be quite easy to create a wrapper to expose scala future as java one have you tried implementing the java future interface backed by a scala one @samuelgruetter Could you explain the problem with the reduce signature please Do you mean by your TODO that this needs a second type parameter U with U extends T etc instead of simple wildcards in Java too I think that reduce needs a type parameter U with U super T in the Java Observable And similar changes will be needed for other methods as well in order to make sure that the T of Observable T never occurs in a contravariant position I ll post corresponding code soon I added tests to CovarianceTest java https github com samuelgruetter RxJava blob b59b68d7361bbb01604e2feaeba904a6b4cbd85c rxjava core src test java rx CovarianceTest java which I would like to compile but they don t and I think that the signatures in Observable java need to be tweaked The tests which do not compile are marked with might not compile I will now try to tweak Observable java as needed The signature of reduce in Observable java currently looks like this public Observable T reduce Func2 super T super T extends T accumulator The problem with this is that the underlined T appears in a contravariant position This means that we cannot say anymore that Observable T is covariant in T and we cannot use Observable as we would like to public void libraryFunctionActingOnMovieObservables Observable extends Movie obs Func2 Movie Movie Movie chooseSecondMovie new Func2 Movie Movie Movie public Movie call Movie t1 Movie t2 return t2 Observable Movie reduceResult obs reduce chooseSecondMovie weird error do something with reduceResult public void codeUsingTheFunction Observable HorrorMovie horrorMovies Observable from new HorrorMovie do something with horrorMovies relying on the fact that all are HorrorMovies and not just any Movies pass it to library works because it takes Observable extends Movie libraryFunctionActingOnMovieObservables horrorMovies The above code should compile but instead produces a weird compilation error Now let s see how Scala solves this The signature of reduceLeft in the Scala immutable collections which are covariant in their type parameter A looks like this def reduceLeft B A f B A B B The trick is to add a type parameter B to the method whose lower bound is A Now A only appears in covariant positions and we re fine So I thought we could just do the same in Java public U super T Observable U reduce Func2 super U super T extends U accumulator But unfortunately Java does not support lower bounds for type parameters So this makes me think that Java s type system is not powerful enough to properly support covariant Observables Because of this I will now return to the Scala adaptor and try to implement a covariant Scala Observable which uses casts where necessary If we later find a way to get rid of the casts all the better I think it would be possible to work around that by making reduce static and giving it two type parameters U T extends U With this we could probably simplify the type parameters of the instance method dropping covariance in that place and instead get the full covariance via the static method Scala could just use the static method I m not sure whether we want that Or maybe there s a more direct workaround via casting yuck Haven t tried anything like that out yet It could go direct against the internal static operators instead of us putting an unnecessary static reduce on Observable java Observable create OperationScan scan observable accumulator takeLast 1 Varargs have been removed from Observable https github com Netflix RxJava pull 361 Investigating issues with reduce covariance at https github com Netflix RxJava issues 360#issuecomment 24128500 It works when done statically instead of via an instance method https github com Netflix RxJava blob master rxjava core src test java rx ReduceTests java#L39 I can now confirm that the solution with value classes is indeed as awesome as we expected D I wrote a very small example showing how Java code can use Scala code There s a MovieLib scala https github com samuelgruetter RxJava blob 0603e395b680655a923e138582d779c65d001651 language adaptors rxjava scala src main scala rx lang scalatests MovieLib scala which uses Scala Observables everywhere In a second project there is MovieLibUsage java https github com samuelgruetter RxJava blob 0603e395b680655a923e138582d779c65d001651 language adaptors rxjava scala java src main java rx lang scalaexamples MovieLibUsage java which uses MovieLib as a class which uses Java Observables everywhere because Scala value classes are such that the Scala Observables appear as Java Observables for the Java compiler The only challenge here is to set up the build process correctly In this scenario the Scala sources have to be built first and then the Java sources I achieved this by making a seperate project for MovieLibUsage which depends on the project containing MovieLib Value classes are awesome This means we don t even need to convert back to Java Observables anywhere Thanks for the example Sounds great @samuelgruetter I m happy to hear that we can achieve idiomatic Scala and Java interop cleanly without converting back and forth Do the compiler bugs prevent us from moving forward or are their sufficient workarounds for now I am planning on releasing 0 13 with the changes merged to master shortly Is there anything else you need to core to support rx lang scala Observable We have sufficient workarounds for the compiler bug There s nothing fundamental that we need for the Scala adapter right now but I m currently trying to translate the dictionary autocomplete example written in C# from this Rx Hands On Lab http blogs msdn com b rxteam archive 2010 07 15 rx hands on labs published aspx to Scala to see what we can already do For this I miss the distinctUntilChanged and the throttle operator so these are currently on top of my whishlist The throttle operator was just merged to master as debounce throttleWithTimeout See https github com Netflix RxJava pull 368 for an explanation of the 3 variants of throttle that were committed We do not yet have distinctUntilChanged but that shouldn t be hard to get added That s great that workarounds exist so we can move forward I look forward to hearing how the autocomplete example works If you can get that functioning is that strong enough evidence to move forward with it or are there still pieces of functionality lacking How do you envision ongoing maintenance of this class Do all new operators added to rx Observable java required wrapping methods or does it pass thru if a wrapper isn t there If I can get the autocomplete example functioning then I think that s strong enough evidence to move forward with it We still lack operations in the wrapper but it should be possible to add them all This adapter will require some maintenance New operators added to the Java observable will have to be added to the adapter as well and updates of the documentation too because the signatures are too different to automate this However if really needed one can always call asJava on a Scala observable and use the Java methods directly and if the implicit function conversions from Scala functions to Java Func Action are imported one could even use Scala functions But that s not the intended way of using it and should only be used in quick hacks Good to know regarding maintenance we ll need to figure out a reasonable way of handling that as operators get added Do you have an idea of when I should expect a pull request with this new Scala Observable Is this a breaking change to how the implicits support currently works for Scala or does this wrapper only take effect when someone imports rx lang scala Observable instead of rx Observable Can the existing implicits continue existing alongside It s not a breaking change The old RxImplicits are still there and usable but marked as deprecated So does it make sense to mark them deprecated since they re still usable and possibly useful for someone accessing operations that haven t made their way to this curated wrapper Just checking If an operation from rx Observable has not yet made it to rx lang scala Observable there are the following solutions ordered by my preference report an issue to get the operation into rx lang scala Observable call asJava on the Scala observable and use the implicit conversions from rx lang scala internal ImplicitFunctionConversions use the old RxImplicits Btw RxImplicits and ImplicitFunctionConversions are almost the same except that ImplicitFunctionConversions does not contain an implicit class ScalaObservable Pull https github com Netflix RxJava pull 376 has been released in 0 13 1 https github com Netflix RxJava releases tag 0 13 1 Thank you @samuelgruetter Btw RxImplicits and ImplicitFunctionConversions are almost the same except that ImplicitFunctionConversions does not contain an implicit class ScalaObservable With that one difference does it still require the two existing or can ImplicitFunctionConversions perform the same functionality as RxImplicits and negate it s need Or does having RxImplicits around still help for any use cases If there is already code out there depending on RxImplicits we need to keep it to remain compatible with that code If not we can remove RxImplicits without any loss of functionality Given that there s no loss of functionality I think it makes the most sense to remove RxImplicits and not introduce the chance of newcomers to RxJava depending on unsupported functionality I ll generate a pull request to this effect Removing duplication makes sense Since rx lang scala internal ImplicitFunctionConversions is escape hatch besides manually using Func1 and friends for stuff not covered by the Scala wrapper would it make sense for it not to be in an internal package @mattrjacobs Good idea @daveray Well the goal should be that there is no such thing as stuff not covered by the Scala wrapper Having ImplicitFunctionConversions in an internal package would increase the pressure to keep the Scala Observable in sync which is a desired effect And if we add a unit test as I outlined at the bottom of this comment https github com Netflix RxJava pull 376#issuecomment 24439163 keeping the Scala Observable up to date would become easier Removing RxImplicits will be breaking for people until they change their import from rx Observable to rx lang scala Observable correct If so I will bump the version to 0 14 when I merge this change Can someone also please update the README https github com Netflix RxJava blob master language adaptors rxjava scala README md to show usage information to help someone get started @samuelgruetter It s up to you guys I ll just leave with this open source projects live a lot longer than the enthusiasm of their contributors so I m skeptical of a wrapper that assumes it will always be kept completely up to date with complete coverage forever If some third party decided to create a project of custom observables beyond what s in RxJava those would be more difficult to use assuming users respect the implication of internal in the package name I ll go back to Clojure land now @daveray ScalaObservable has a method to get the wrapped Java Observable so you should be able to use any method from its API And since the project is Open Source you can always send a Pull Request and improve it @martin g Right And if for whatever reason some poor Scala programmer finds herself in yucky Java land calling these mehods at least throw her a bone and make the Func implicits available in a non internal package @martin g Correct me if I m wrong but dropping down to using rx Observable still mandates passing in Func1 Func2 etc Being able to use native Scala functions and the implicits in this case seems far better than forcing user code to new up these function types and pass them in After thinking about it 1 to @daveray s idea of making both the value class and implicits available with the value class preferred This will allow any temporary mismatch between rx Observable and rx lang scala Observable to be addressed by implicits while not impeding non Scala developers from moving core along 1 on this There are other places where Func are used such as BlockingObservable not yet wrapped and as new things are added if they don t yet have a full wrapper there should still be a way to use them with the implicits it might be cool to have a unit test in which we encode the information which Java method corresponds to which Scala method and using reflection we check if there is a Scala method for each Java method So if a method is added to the Java Observable but not to the Scala Observable this test would fail And if we add a unit test as I outlined at the bottom of this comment keeping the Scala Observable up to date would become easier We can t make the build fail if rx lang scala Observable is out of sync We can t block the project from building and releasing just because a new operator is added and the developer adding it isn t comfortable deciding what the idiomatic Scala method signature should look like It needs to be an async process for Scala developers to add wrapper methods classes Since this is open source we can t control people s schedule and require quick turnaround on adding the wrappers Ideally that will happen when new functionality is added but we can t make building and releasing dependent on that Thus I think we need to account for the fact that most things will have wrappers but very newly added functionality or fringe functionality may not and should still have a mechanism for being used If you want rxjava core to evolve independently then perhaps rxjava scala and other language adapters should each be a separate top level project with its own release cycle On Mon Sep 16 2013 at 2 55 PM Ben Christensen notifications@github com wrote it might be cool to have a unit test in which we encode the information which Java method corresponds to which Scala method and using reflection we check if there is a Scala method for each Java method So if a method is added to the Java Observable but not to the Scala Observable this test would fail And if we add a unit test as I outlined at the bottom of this comment keeping the Scala Observable up to date would become easier We can t make the build fail if rx lang scala Observable is out of sync We can t block the project from building and releasing just because a new operator is added and the developer adding it isn t comfortable deciding what the idiomatic Scala method signature should look like It needs to be an async process for Scala developers to add wrapper methods classes Since this is open source we can t control people s schedule and require quick turnaround on adding the wrappers Ideally that will happen when new functionality is added but we can t make building and releasing dependent on that Thus I think we need to account for the fact that most things will have wrappers but very newly added functionality or fringe functionality may not and should still have a mechanism for being used Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 336#issuecomment 24548044 Erik Meijer and I have discussed this but it doesn t feel like the right thing to do as it would hurt the JVM ecosystem more than benefit it if the different languages forked from each other There is no harm in a new version of RxJava being released without the Scala adaptor adding the new functionality as that is no different than a separate RxScala project not yet supporting it on top of the RxJava core dependency As we approach 1 0 the rapid iteration will slow and this will become less of an issue Around that time as well the project may migrate into a different home than here On September 16 2013 at 3 20 07 PM Chris Richardson notifications@github com wrote If you want rxjava core to evolve independently then perhaps rxjava scala and other language adapters should each be a separate top level project with its own release cycle I like @daveray s point If some third party decided to create a Java project of custom observables beyond what s in RxJava and we want to use this project from Scala then we need the ImplicitFunctionConversions So I will make this non internal @benjchristensen I agree that it would be kind of crazy to make the build fail just because rx lang scala Observable is out of sync Closing this out as completed further progress bugs can use new issues Great work and thank you everyone involved on this',RxJava,false,false,false
18848307,'Added the window operation','window returns an Observable Observable T that will chunk the source observable based on several criteria counts time etc This differs from buffer in that the underlying observables will all onComplete independently from their upstream Observable','RxJava pull requests #224 https netflixoss ci cloudbees com job RxJava pull requests 224 SUCCESS This pull request looks good For consistency with buffer it seems like all the Observable window methods should be instance methods rather than static ok Missed it when porting into 0 11 1 I ve forced pushed my amended commit RxJava pull requests #225 https netflixoss ci cloudbees com job RxJava pull requests 225 SUCCESS This pull request looks good Now documented on the wiki marble diagrams TBD https github com Netflix RxJava wiki Transforming Observables#window Let s switch over to https github com Netflix RxJava pull 349 for review as this pull request is out of date with master',RxJava,true,false,false
18888638,'Extremely rudimentary auto generated Clojure wrapper DO NOT MERGE','Proof of concept for rxjava issue #334 Please do not merge','RxJava pull requests #226 https netflixoss ci cloudbees com job RxJava pull requests 226 FAILURE Looks like there s a problem with this pull request No feedback in a long time Closing',RxJava,true,false,false
18910804,'Garbage Creation','Hi Do you use object pooling to prevent garbage being produced Can this run without GC activity for a few weeks at least Suminda','No it does not use pooling By definition Rx uses composition and if object allocation is a concern to you then it should not be used We use Rx extensively in the Netflix API without full stop the world GCs but the young gen is constantly cleaning garbage Our JVMs are tuned to handle the garbage throughput of Rx Hystrix JSON XML Thrift etc serialization deserialization and all other object allocations of the JVM We nor this library do not attempt to fit the constraints of something like a financial trading application which pursues no object allocation at all',RxJava,false,false,false
18910985,'Messages a Second in Commodity Hardware','How much message throughput have you got on commodity hardware What is the latency distribution like','The answer completely depends on what operators and schedulers you are using but RxJava operations will have more overhead than using an imperative approach With the simplest use of RxJava it is doing nothing more than a method invocation from a single Observable to a single Observer in which case there is little more overhead than you having 2 objects doing the same thing Here are some simple tests I ve used in the past to test performance that you can play with to get a feel for yourself https github com Netflix RxJava tree master rxjava core src test java rx performance',RxJava,false,false,false
18921298,'Update gradle wrapper to latest','','RxJava pull requests #227 https netflixoss ci cloudbees com job RxJava pull requests 227 SUCCESS This pull request looks good RxJava pull requests #228 https netflixoss ci cloudbees com job RxJava pull requests 228 SUCCESS This pull request looks good Thanks @quidryan for the updates and fix for Scala 2 10 2',RxJava,true,false,false
18988276,'Rename switchDo to switchOnNext','I really don t like the switchDo name and am considering renaming to switchOnNext since that s what it does Ofcourse this is all because we can t use switch as it is a reserved word Agreement Disagreement','Just submitted pull request for this does anyone have an opinion People I ve asked agree with changing from switchDo to switchOnNext switchOnNext is a better name Works for me I agree switchOnNext is a lot better Proceeding then that s enough votes for me Yeah switchOnNext is a lot better Since the PR is merged can t we close this',RxJava,false,false,false
18993600,'Covariant Support with super extends and OnSubscribeFunc','Merging and adding to work by @jmhofer in https github com Netflix RxJava pull 331 In particular this adds the following change to the previous pull request java public static T Observable T create Func1 super Observer super T extends Subscription func to java public static T Observable T create OnSubscribeFunc T func','RxJava pull requests #233 https netflixoss ci cloudbees com job RxJava pull requests 233 SUCCESS This pull request looks good RxJava pull requests #234 https netflixoss ci cloudbees com job RxJava pull requests 234 SUCCESS This pull request looks good',RxJava,true,false,false
19009281,'Update Clojure interop to support new OnSubscribeFunc with rx fn','','RxJava pull requests #235 https netflixoss ci cloudbees com job RxJava pull requests 235 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
19009288,'Remove unnecessary Observable constructor','fixed unit tests that relied on it','',RxJava,true,false,false
19013311,'BlockingObservable Refactor','No longer extends from Observable If someone chooses to use BlockingObservable the intent is to leave the Observable so it shouldn t show the non blocking operators Remove duplicate static methods similar to how done on Observable in earlier commit','RxJava pull requests #236 https netflixoss ci cloudbees com job RxJava pull requests 236 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
19013785,'Fixing Scala unit tests after previous commits accidentally broke them','','RxJava pull requests #237 https netflixoss ci cloudbees com job RxJava pull requests 237 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
19014036,'switchDo to switchOnNext','See https github com Netflix RxJava issues 342 for original question Does anyone have an opinion on this','RxJava pull requests #238 https netflixoss ci cloudbees com job RxJava pull requests 238 SUCCESS This pull request looks good',RxJava,true,false,false
19024989,'Window Operator','Manual merge of https github com Netflix RxJava pull 337 Since this pull request was submitted there were significant changes to the create operator and generics so I manually merged into master I have not actually reviewed for behavior but unit tests are passing and code structure looked good This is for issue https github com Netflix RxJava issues 102 source c','@bcotton Great pull request I like how you also worked on buffer Now that I ve merged this with master I ll add some inline comments on the code with questions If another pull request is needed so you can take back control of the branch go right ahead and just cherry pick these 2 commits on to a new branch of your own RxJava pull requests #239 https netflixoss ci cloudbees com job RxJava pull requests 239 SUCCESS This pull request looks good This looks like a great addition of code and not a trival one so thank you @bcotton I do not have the time to review it for thread safety but nothing jumps out as obviously wrong The unit tests appear to cover the use cases well and based on them the behavior looks correct I have not done a comparison with Rx Net to determine if we have covered all cases If anyone else could do that I d appreciate it Once we ve got resolutions to the 1 generics and 2 Func0 questions I posted above this appears good to merge unless anyone else can find issues If possible I d like to get the above items resolved today so I can merge this and release 0 12 by end of today US time I know that I m being kind of a pain in the butt here but there s also the question whether the various Chunk and Window classes are co contra or invariant in their type parameters I ll go examine the code more closely now I made the wi n dow maker typesafe There are also some more raw types in ChunkedOperation though Now I think I m done with the important things The chunks look invariant to me at first sight I tried to get everything typesafe that wasn t already and again added a lot of wildcards it s all here https github com jmhofer RxJava tree window operator @benjchristensen Should I put up a pull request against your window merge branch I just pulled them off your branch to this pull request Looks like both of my questions concerns are now addressed Any last thoughts on placement of util classes Otherwise this looks ready to merge if the build passes RxJava pull requests #240 https netflixoss ci cloudbees com job RxJava pull requests 240 SUCCESS This pull request looks good Thanks for the reviews @jmhofer @bcotton It looks like this pull request only has you as the author but not commiter due to the crazy merge I had to do If you want to take these commits and reapply them so you get the credit please do so I ll wait a few hours if you can do it otherwise I ll proceed with this pull request Go ahead No need for glory Happy to help Thanks @bcotton I ll merge now and release 0 12 fairly soon I m confused These methods all are instance methods but they do not depend in any way on this so they could be made static However the better way would probably be to remove the argument called source and replace all occurences of source by this Am I missing something No you re not missing anything we all did who reviewed this So funny an earlier review had the methods change from static to instance but apparently only the static keyword got removed I ll go submit a fix and release 0 12 1 too funny and embarrassing we all missed this Thanks for reporting it Oops embarrassing Completely missed this too Just release 0 12 1 making its way through Sonatype now',RxJava,true,false,false
19105235,'A little Swing wrap up','These are some old changes in the Swing contrib library that wrap up a few loose endings javadoc warnings slightly inconsistent behavior for KEY_TYPED events an additional helper for computing relative mouse motion I updated this to work with the current master and fixed a few warnings concerning unused imports and double semicolons I also checked whether this needs some variance generalizations but it seems that it doesn t','RxJava pull requests #241 https netflixoss ci cloudbees com job RxJava pull requests 241 SUCCESS This pull request looks good Looks good to me and additive or cleanup not breaking or changing anything as far as I can tell so this can be in a point release',RxJava,true,false,false
19115069,'Fix Observable window static instance bug','reported at https github com Netflix RxJava pull 349#issuecomment 23946707','RxJava pull requests #242 https netflixoss ci cloudbees com job RxJava pull requests 242 SUCCESS This pull request looks good',RxJava,true,false,false
19121934,'Adding Func5 9 and N to the wrapper','the zip Collection FuncN isn t working in groovy because the function wrapper doesn t implement FuncN','RxJava pull requests #243 https netflixoss ci cloudbees com job RxJava pull requests 243 SUCCESS This pull request looks good',RxJava,true,false,false
19139391,'Take Operator Error Handling','Unit test for https github com Netflix RxJava issues 217','RxJava pull requests #244 https netflixoss ci cloudbees com job RxJava pull requests 244 SUCCESS This pull request looks good',RxJava,true,false,false
19150184,'Count Sum Average implementations','I implemented three easy operations here simply using reduce Two things were tricky however 1 How to name the various overloads have to use different names due to identical erasure I propose sum sumLongs sumFloats sumDoubles here and the same for the averages 1 How to handle empty source observables when averaging I propose throwing an ArithmeticException here Any other opinions','RxJava pull requests #245 https netflixoss ci cloudbees com job RxJava pull requests 245 SUCCESS This pull request looks good Looks good to me',RxJava,true,false,false
19150998,'implemented skipWhile and skipWhileWithIndex #80','The title says it all already','RxJava pull requests #246 https netflixoss ci cloudbees com job RxJava pull requests 246 SUCCESS This pull request looks good',RxJava,true,false,false
19159508,'Added interval methods to Observable where they were still missing','This was simply missing and forgotten in #55','RxJava pull requests #247 https netflixoss ci cloudbees com job RxJava pull requests 247 SUCCESS This pull request looks good',RxJava,true,false,false
19160751,'Implemented First and FirstOrDefault operations','This PR builds upon the skipWhile PR #355 which makes implementing the two first variants extremely easy I changed firstOrDefault slightly from what Rx NET does by explicitly requiring a default value as parameter of the function call I don t know what default value I should return otherwise except null and imho this would be pretty useless This PR addresses issue #44','RxJava pull requests #248 https netflixoss ci cloudbees com job RxJava pull requests 248 SUCCESS This pull request looks good In Scala first would be called head do we have some kind of skipFirst aka tail too I m okay with both naming schemes with a slight preference for leaving the take s away I was also playing around with firstOrElse instead of firstOrDefault btw The orElse naming scheme is quite common in Scala and the default is not really much of a default anyway when you have to explicitly specify it in a parameter I left it as is because of the NET naming scheme though I need to look at what Java 8 is calling these things as that is the more important naming convention for the core lib to match Java 8 uses findFirst which doesn t seem all that helpful http download java net jdk8 docs api java util stream Stream html#findFirst',RxJava,true,false,false
19176386,'Problems using rxjava scala 0 12 3 SNAPSHOT','I tried recompiling my code that worked fine with 0 11 3 with 0 12 3 SNAPSHOT and got quite a few errors The problems seem related to the covariant changes I added a couple of tests to RxImplicitsTests scala that reproduce the similar problems @Test def testWithChainedMap val observable Observable from 1 2 3 val o2 observable map s String s s map s String s s assertSubscribeReceives o2 1111 2222 @Test def testWithBuffer val observable Observable from 1 2 3 val o2 observable buffer 2 o2 map s java util List String s size These are the compilation errors ant scalac Users cer 3rdPartySrc RxJava language adaptors rxjava scala src test scala rx lang scala RxImplicitsTests scala 122 error type mismatch ant scalac found String String ant scalac required rx util functions Func1 _ 0 in value x 1 in value x 1 in value x 1 in value x 1 _ ant scalac val o2 observable map s String s s map s String s s ant scalac ant scalac Users cer 3rdPartySrc RxJava language adaptors rxjava scala src test scala rx lang scala RxImplicitsTests scala 129 error no type parameters for method map x 1 rx util functions Func1 _ java util List String _ R rx Observable R exist so that it can be applied to arguments rx util functions Func1 java util List String Int ant scalac because ant scalac argument expression s type is not compatible with formal parameter type ant scalac found rx util functions Func1 java util List String Int ant scalac required rx util functions Func1 _ java util List String _ R ant scalac Note java util List String Any but Java defined trait Func1 is invariant in type T1 ant scalac You may wish to investigate a wildcard type such as _ Any SLS 3 2 10 ant scalac o2 map s java util List String s size ant scalac ant scalac Users cer 3rdPartySrc RxJava language adaptors rxjava scala src test scala rx lang scala RxImplicitsTests scala 129 error type mismatch ant scalac found rx util functions Func1 java util List String Int ant scalac required rx util functions Func1 _ java util List String _ R ant scalac o2 map s java util List String s size','Yes we re still working on that Scala Adapter I m writing a new one you can see what I m doing here https github com samuelgruetter RxJava tree idiomaticscala language adaptors rxjava scala src main scala rx lang scala Covariance I also believe that covariance is not yet fully ok and I ll work on this today Thanks anyway for reporting Thanks for your reply What s the state of your Scala adapter When should I try it out On Mon Sep 9 2013 at 12 11 AM samuelgruetter notifications@github com wrote Yes we re still working on that Scala Adapter I m writing a new one you can see what I m doing here https github com samuelgruetter RxJava tree idiomaticscala language adaptors rxjava scala src main scala rx lang scala Covariance I also believe that covariance is not yet fully ok and I ll work on this today Thanks anyway for reporting Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 358#issuecomment 24048659 I hope that it will be ready in a few days There have been some interesting problems to solve and maybe there will be more You can see the progress here https github com Netflix RxJava issues 336 Version 0 13 1 https github com Netflix RxJava releases tag 0 13 1 now contains the new Scala adaptor Your examples should work with it but make sure you import rx lang scala Observable instead of rx Observable And Observable from 1 2 3 now looks more Scala idiomatic Observable 1 2 3 Any feedback is welcome Looks pretty good However it looks like groupBy is not yet implemented which my code needs On Thu Sep 12 2013 at 11 05 PM samuelgruetter notifications@github com wrote Version 0 13 1 https github com Netflix RxJava releases tag 0 13 1 now contains the new Scala adaptor Your examples should work with it but make sure you import rx lang scala Observable instead of rx Observable And Observable from 1 2 3 now looks more Scala idiomatic Observable 1 2 3 Any feedback is welcome Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 358#issuecomment 24375001 groupBy was merged into master just now Thanks I just tried it out New core functionality Scala adaptor awesome On Tue Sep 17 2013 at 10 38 PM samuelgruetter notifications@github com wrote groupBy was merged into master just now Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 358#issuecomment 24642093 Glad it s working well for you is this resolved enough to close On question what s the Scala adaptor s equivalent of Java s public static T Observable T merge Observable extends Observable extends T source I saw a merge method that takes another observable but no flatten There s nothing yet in master but in my fork there s merge as an instance method https github com samuelgruetter RxJava blob 9fc14a1334ffa5b9bd27580a1850967698eed65f language adaptors rxjava scala src main scala rx lang scala Observable scala#L1271 which I will probably rename to flatten That s great I saw the pull request',RxJava,false,false,false
19182627,'Varargs cause compiler warnings','I m trying to use the concat operator but I can t use it without getting a compiler warning Here s my code Observable HorrorMovie horrorMoviesWithException Observable HorrorMovie movies Observable from new HorrorMovie Observable HorrorMovie ex Observable error new Exception test return Observable concat movies ex WARNING I get the warning Type safety A generic array of Observable CovarianceTest HorrorMovie is created for a varargs parameter This problem was discussed on stackoverflow http stackoverflow com questions 1445233 is it possible to solve the a generic array of t is created for a varargs param and this bug report http bugs sun com bugdatabase view_bug do bug_id 6227971 explains why it s not going to be fixed','The same problem also occurs with merge mergeDelayError and if arguments with generic type are passed to from and startWith they are also affected Unless someone shows me how to get rid of this warning without using @SuppressWarnings unchecked I would suggest that we remove the varargs methods and add instead an overloaded method for each arity a method taking an Iterable will be used by the Scala adaptor Like the zip operator Sent from my iPhone On Sep 9 2013 at 1 50 AM samuelgruetter notifications@github com wrote Unless someone shows me how to get rid of this warning without using @SuppressWarnings unchecked I would suggest that we remove the varargs methods and add instead an overloaded method for each arity a method taking an Iterable will be used by the Scala adaptor Reply to this email directly or view it on GitHub yes That issue with varargs is definitely one of the weaknesses of generics How about if we had overloads for up to 9 arities and then on that one have a 10th vararg for scenarios were people truly do want need more That way it would only affect someone using beyond 9 args I don t quite get what you mean by a 10th vararg for scenarios but I d also be fine with overloads for up to 9 arguments plus another overload which takes only 1 argument of type Collection Observable T or Iterable Observable T so if people want more than 9 arguments they have to construct a list containing the arguments and pass this list to concat I meant something like this java concat T t1 T t2 etc concat T t1 T t2 T t3 T t4 T t5 T t6 T t7 T t8 concat T t1 T t2 T t3 T t4 T t5 T t6 T t7 T t8 T t9 concat T t1 T t2 T t3 T t4 T t5 T t6 T t7 T t8 T t9 T rest I will start refactoring vararg method signature later today or tonight US Pacific time unless someone else is already doing it If one of you already are tackling this please let me know here so we don t replicate effort Closing as I have removed all varargs from Observable The @SafeVarargs annotation allows us to solve this Trying to figure out if we can leverage this Java 7 feature without breaking Android support which is obviously more important',RxJava,false,false,false
19227381,'Covariant Generics Issues','After the recent super extends additions there are some areas where it doesn t quite feel right in how it s working This issue has come up at https github com Netflix RxJava issues 336#issuecomment 24076177 as well as work I m doing related to https github com Netflix RxJava issues 359 I want to use this issue to track issues and discuss solutions','One issue is with concat java public static T Observable T concat Observable Observable extends T observables That works with this java public void testConcatCovariance Observable Media o1 Observable from new HorrorMovie new Movie Observable Media o2 Observable from new Media new HorrorMovie Observable Observable Media os Observable from o1 o2 List Media values Observable concat os toList toBlockingObservable single but it doesn t work with this java public void testConcatCovariance2 Observable Media o1 Observable from new HorrorMovie new Movie new Media Observable Media o2 Observable from new Media new HorrorMovie Observable Observable Media os Observable from o1 o2 List Media values Observable concat os toList toBlockingObservable single When both types are Media the Observable ends up being Observable Observable Media instead of Observable Observable super Media and then concat fails This is not at all ideal especially since it s more common to be concatenating multiple Observables of the same type If I change concat to this and remove the extends java public static T Observable T concat Observable Observable T observables the testConcatCovariance2 example works and testConcatCovariance1 fails unless I change this line java Observable Media o1 Observable Media from new HorrorMovie new Movie Personally I prefer doing that when dealing with super types than making concat be forced to deal with it all the time If you skip to Observable from o1 o2 step which confuses the generics and go directly to concat then it s even cleaner This uses java public static T Observable T concat Observable extends T t1 Observable extends T t2 Both of these work java @Test public void testConcatCovariance3 Observable Movie o1 Observable from new HorrorMovie new Movie Observable Media o2 Observable from new Media new HorrorMovie List Media values Observable concat o1 o2 toList toBlockingObservable single @Test public void testConcatCovariance4 Observable Movie o1 Observable create new OnSubscribeFunc Movie @Override public Subscription onSubscribe Observer super Movie o o onNext new HorrorMovie o onNext new Movie o onNext new Media correctly doesn t compile o onCompleted return Subscriptions empty Observable Media o2 Observable from new Media new HorrorMovie List Media values Observable concat o1 o2 toList toBlockingObservable single In short it seems the Observable Observable extends T does not work well See https github com benjchristensen RxJava commit 1a0fcdc976d78aea4ec59c6ab73e0856f98e6dfc for the changes made to Observable concat due to the above finding in relation to https github com Netflix RxJava issues 359 If someone can provide a better solution I d appreciate it Looks like this makes it work java public static T Observable T concat Observable extends Observable extends T observables See https github com benjchristensen RxJava commit 97b51eb2a9eaebfcf5064306736514ff39c85a8b for this change I think concat is fine as of https github com Netflix RxJava pull 361 Need to look at reduce as reported at https github com Netflix RxJava issues 336#issuecomment 24094254 The issues with reduce are shown at https github com Netflix RxJava blob master rxjava core src test java rx ReduceTests java#L58 and https github com Netflix RxJava blob master rxjava core src test java rx ReduceTests java#L83 I have not yet figured out a solution to reduce that retains super on the instance method version I would appreciate someone else taking a look @jmhofer can you give an example where the instance reduce method actually benefits from the wildcards java public Observable T reduce Func2 super T super T extends T accumulator vs public Observable T reduce Func2 T T T accumulator I can get covariance to work on it as a static method but not as an instance method Here is example code separate from Rx java import java util ArrayList import java util Arrays import java util List import rx util functions Func1 public class CovariancePlayground public static class TestContainer T private final List T items public TestContainer T items this Arrays asList items public TestContainer List T items this items items public TestContainer T doSomethingToIt Func1 super T extends T function ArrayList T newItems new ArrayList T for T t items newItems add function call t return new TestContainer T newItems public R TestContainer R transformIt Func1 super T extends R function ArrayList R newItems new ArrayList R for T t items newItems add function call t return new TestContainer R newItems public static class UnitTest public void test TestContainer Movie movies new TestContainer Movie new ActionMovie new HorrorMovie TestContainer Media media new TestContainer Media new Album new Movie new TVSeason movies doSomethingToIt movieFunction movies doSomethingToIt mediaFunction doesn t compile media doSomethingToIt movieFunction shouldn t be possible media doSomethingToIt mediaFunction movies transformIt mediaToString media transformIt mediaToString Func1 Movie Movie movieFunction new Func1 Movie Movie @Override public Movie call Movie t1 return t1 Func1 Media Media mediaFunction new Func1 Media Media @Override public Media call Media t1 return t1 Func1 Media String mediaToString new Func1 Media String @Override public String call Media t1 return t1 getClass getName static class Media static class Movie extends Media static class ActionMovie extends Movie static class HorrorMovie extends Movie static class Album extends Media static class TVSeason extends Media I remember reading in effective java that the only type that can satisfy the super T and extends T is just T I think the reduce instance method fits this quote from Effective Java 2nd Edition page 136 If an input parameter is both a producer and a consumer then wildcard types will do you no good you need an exact type match which is what you get without any wildcards I don t think we can get it to work since the publisher and consumer are the same type Thus I think we should change it to just be the following java public Observable T reduce Func2 T T T accumulator Yes George I think I just read that very quote and pasted it Funny we both got to the same thing Thanks for confirming my thoughts on this Can someone else take a look at https github com Netflix RxJava pull 369 and let me know if my understanding of generics are correct here I have changed reduce aggregate and scan back to Func2 T T T without super and extends because these functions produce and consume the same type thus they must match and the wildcards serve no value I don t see a problem with the reduce variant that takes and produces the same type However there s also R Observable R reduce R initialValue Func2 super R super T extends R accumulator I still have to examine that in more detail As illustrated by this example https github com samuelgruetter rx playground blob 294a8e835502c7fe53ab3f455b3b0442df8efa51 CovarianceTests src main java CovariancePlayground java#L92 Func2 T T T is a subtype of Func2 super T super T extends T so if we replace Func2 super T super T extends T by Func2 T T T then We loose some flexibility for instance this example https github com samuelgruetter rx playground blob 294a8e835502c7fe53ab3f455b3b0442df8efa51 CovarianceTests src main java CovariancePlayground java#L111 won t work any more But I think such examples are not very common We gain easier to read method signatures For the Scala adapter it doesn t matter whether we have these wildcards or not in the Java core because we have to do typecasting anyways @samuelgruetter I see how that example could work but playing with it I think the example method I created having only 2 arguments is too contrived When I try and stretch that to reduce with T T T it doesn t work as the output must be injected back as the input George and I discussed in https github com Netflix RxJava pull 369#issuecomment 24255958 and looked at JDK 8 to confirm how it uses wildcards and I think it confirms that wildcards don t help Beyond reduce and scan are there any others either not working or where wildcards are useless The problematic operations are those where the type parameter T intended to be covariant appears in a contravariant position These operations are listed in this section https github com samuelgruetter RxJava blob def97312d2f242494cfc35f59034dc2a089b424f rxjava core src test java rx CovarianceTest java#L263 of my version of CovarianceTest java I don t know how to solve those examples when the Observable is defined as Observable extends Movie with onErrorResumeNext onErrorReturn etc I can get this to work and it makes sense to me java Observable Movie o Observable from new Movie new HorrorMovie Observable HorrorMovie n Observable from new HorrorMovie o onErrorResumeNext n In that example T becomes Movie and can then accept T extends Movie which allows n which is HorrorMovie If it was instead Observable extends Movie that means T is extends Movie which means n would be extends extends Movie which can t work Here is a screenshot from the IDE showing it confused and combining the types like that screen shot 2013 09 11 at 10 32 20 am https f cloud github com assets 813492 1124947 4ba61212 1b08 11e3 957f 0c3938dd7759 png In short I don t know how to make it work when the generic itself is extends SomeType I don t have a solution either but we just have to be aware that certain methods become unusable if we want to call them on an Observable extends SomeType In Scala btw we have declaration site variance and lower bounds on type parameters which make all these examples work I m not surprised Scala has a solution I m going to consider this issue closed then unless someone can provide a concrete example of something that can be improved or fixed similar to what we did on reduce scan Thank you @samuelgruetter for your help on this',RxJava,false,false,false
19228047,'Fix vararg issues reported in https github com Netflix RxJava issues 359','Branch working on https github com Netflix RxJava issues 359 I ll continue committing to this until all the varargs are replaced','RxJava pull requests #253 https netflixoss ci cloudbees com job RxJava pull requests 253 SUCCESS This pull request looks good This seems to be working well so am merging it This removes all vararg usage It does increase surface area with multiple arity overloads but it s clean and displays well in an IDE I have chosen to use Observable Observable T on all of the overloads instead of Iterable Observable T since Observable is more generic and fits the Rx model An Observable Observable T can easily be created from Iterable Observable T using Observable from If this is not liked we can add the Iterable overloads as well screen shot 2013 09 09 at 5 49 25 pm https f cloud github com assets 813492 1111603 e5c8fa78 19b2 11e3 9737 30d973ff4c43 png RxJava pull requests #254 https netflixoss ci cloudbees com job RxJava pull requests 254 SUCCESS This pull request looks good',RxJava,true,false,false
19232568,'Merge first Operator','Merge pull request https github com Netflix RxJava pull 357 with first and firstOrDefault operators','RxJava pull requests #255 https netflixoss ci cloudbees com job RxJava pull requests 255 SUCCESS This pull request looks good',RxJava,true,false,false
19233643,'unit tests for covariance','refactoring so not everything for the entire Observable ends up in a single class','RxJava pull requests #256 https netflixoss ci cloudbees com job RxJava pull requests 256 SUCCESS This pull request looks good',RxJava,true,false,false
19234932,'additions to tests','','RxJava pull requests #257 https netflixoss ci cloudbees com job RxJava pull requests 257 SUCCESS This pull request looks good',RxJava,true,false,false
19239552,'Operation throttleLast','Merge of https github com Netflix RxJava pull 258','RxJava pull requests #258 https netflixoss ci cloudbees com job RxJava pull requests 258 SUCCESS This pull request looks good NOTE This implementation is modified to use window which differs from the original It feels simpler but is not exactly the same as was contributed nor do I think it s an exact match to Rx Net As currently implemented this returns the last value of each window as opposed to restarting the time at each onNext I m playing with that implementation next I m curious about when the different types of implementations may be more valuable than others Great Looking forward to having this operator This will return the last value in each time window It will always emit at least 1 value in each window java PublishSubject Integer o PublishSubject create o throttleLast 500 TimeUnit MILLISECONDS s subscribe observer send events with simulated time increments s advanceTimeTo 0 TimeUnit MILLISECONDS o onNext 1 skip o onNext 2 deliver s advanceTimeTo 501 TimeUnit MILLISECONDS o onNext 3 skip s advanceTimeTo 600 TimeUnit MILLISECONDS o onNext 4 skip s advanceTimeTo 700 TimeUnit MILLISECONDS o onNext 5 skip o onNext 6 deliver s advanceTimeTo 1001 TimeUnit MILLISECONDS o onNext 7 deliver s advanceTimeTo 1501 TimeUnit MILLISECONDS o onCompleted Compare this with https github com Netflix RxJava pull 366 Please review this behavior and let me know if it is accurate and if the name is explanatory Javadoc Throttles to last value in each window I have submitted 3 separate pull requests with different variants of throttle I would appreciate feedback on them is the name and javadoc descriptive does the throttling strategy make sense Variants are throttleWithTimeout https github com Netflix RxJava pull 366 throttleLast https github com Netflix RxJava pull 365 throttleFirst https github com Netflix RxJava pull 367 Would you summarize for me how this differs from sample On Tue Sep 10 2013 at 12 17 AM Ben Christensen notifications@github com wrote I have submitted 3 separate pull requests with different variants of throttle I would appreciate feedback on them is the name and javadoc descriptive does the throttling strategy make sense Variants are throttleWithTimeout #366 https github com Netflix RxJava pull 366 throttleLast #365 https github com Netflix RxJava pull 365 throttleFirst #367 https github com Netflix RxJava pull 367 Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 365#issuecomment 24138547 The throttleLast is absolutely the same as sample it appears so I ll remove throttleLast',RxJava,true,false,false
19240806,'Operator throttleWithTimeout','Another take on throttle I believe this matches Rx Net behavior This will wait until timeout value has passed without any further values before emitting the received value','This example will throttle by waiting until timeout value has passed without any other onNext calls before emitting If anything else is emitted it will throw away the previous value and restart the timer This will not emit anything if events keep firing shorter than the timeout java PublishSubject Integer o PublishSubject create o throttleWithTimeout 500 TimeUnit MILLISECONDS s subscribe observer send events with simulated time increments s advanceTimeTo 0 TimeUnit MILLISECONDS o onNext 1 skip o onNext 2 deliver s advanceTimeTo 501 TimeUnit MILLISECONDS o onNext 3 skip s advanceTimeTo 600 TimeUnit MILLISECONDS o onNext 4 skip s advanceTimeTo 700 TimeUnit MILLISECONDS o onNext 5 skip o onNext 6 deliver at 1300 after 500ms has passed since onNext 5 s advanceTimeTo 1300 TimeUnit MILLISECONDS o onNext 7 deliver s advanceTimeTo 1800 TimeUnit MILLISECONDS o onCompleted Compare with https github com Netflix RxJava pull 365 Please review this behavior and let me know if it is accurate and if the name is explanatory RxJava pull requests #259 https netflixoss ci cloudbees com job RxJava pull requests 259 SUCCESS This pull request looks good throttleLast and throttleWithTimeout both have the same javadoc that s confusing that was fast D Javadoc Throttles by dropping all values that are followed by newer values before the timeout value expires The timer reset on each onNext call NOTE If the timeout is set higher than the rate of traffic then this will drop all data I have submitted 3 separate pull requests with different variants of throttle I would appreciate feedback on them is the name and javadoc descriptive does the throttling strategy make sense Variants are throttleWithTimeout https github com Netflix RxJava pull 366 throttleLast https github com Netflix RxJava pull 365 throttleFirst https github com Netflix RxJava pull 367 throttleWithTimeout the really interesting one not easily implemented using other operators corresponds to the C# version throttleLast easily obtained combining window flatMap and takeLast throttleFirst easily obtained combining window flatMap and takeFirst Is this correct Yes',RxJava,true,false,false
19241224,'Operator throttleFirst','Another take on throttle this delivers the first value in each window','This will throttle to the first value received in each window java PublishSubject Integer o PublishSubject create o throttleFirst 500 TimeUnit MILLISECONDS s subscribe observer send events with simulated time increments s advanceTimeTo 0 TimeUnit MILLISECONDS o onNext 1 deliver o onNext 2 skip s advanceTimeTo 501 TimeUnit MILLISECONDS o onNext 3 deliver s advanceTimeTo 600 TimeUnit MILLISECONDS o onNext 4 skip s advanceTimeTo 700 TimeUnit MILLISECONDS o onNext 5 skip o onNext 6 skip s advanceTimeTo 1001 TimeUnit MILLISECONDS o onNext 7 deliver s advanceTimeTo 1501 TimeUnit MILLISECONDS o onCompleted Compare with https github com Netflix RxJava pull 366 and https github com Netflix RxJava pull 365 RxJava pull requests #260 https netflixoss ci cloudbees com job RxJava pull requests 260 SUCCESS This pull request looks good Javadoc Throttles to first value in each window I have submitted 3 separate pull requests with different variants of throttle I would appreciate feedback on them is the name and javadoc descriptive does the throttling strategy make sense Variants are throttleWithTimeout https github com Netflix RxJava pull 366 throttleLast https github com Netflix RxJava pull 365 throttleFirst https github com Netflix RxJava pull 367 RxJava pull requests #261 https netflixoss ci cloudbees com job RxJava pull requests 261 SUCCESS This pull request looks good',RxJava,true,false,false
19281480,'Operators Throttle and Debounce','This adds throttleFirst throttleLast alias of sample and debounce aliased with throttleWithTimeout This merges pull request https github com Netflix RxJava pull 258 Unfortunately the Rx throttle operator behavior is actually debounce not throttle This pull request tries to address that Here is a good place to get a description of throttle versus debounce http drupalmotion com article debounce and throttle visual explanation Debounce Think of it as grouping multiple events in one Imagine that you go home enter in the elevator doors are closing and suddenly your neighbor appears in the hall and tries to jump on the elevator Be polite and open the doors for him you are debouncing the elevator departure Consider that the same situation can happen again with a third person and so on probably delaying the departure several minutes Throttle Think of it as a valve it regulates the flow of the executions We can determine the maximum number of times a function can be called in certain time So in the elevator analogy you are polite enough to let people in for 10 secs but once that delay passes you must go Other links includes http unscriptable com 2009 03 20 debouncing javascript methods http www illyriad co uk blog index php 2011 09 javascript dont spam your server debounce and throttle I feel we need some kind of throttle operator name as an alias to debounce to help people discover it especially those coming from Rx Net or RxJS I m not fond of throttleWithTimeout which is what I have it as right now Perhaps throttleViaDebounce even though that doesn t actually make sense I do not want to use throttle because it s not actually the definition of throttle To confirm this I have asked over a dozen server side engineers what their definition of throttle is and their expectations of an operator is It never matches the Rx definition and they are always surprised by the debounce behavior I have included throttleLast as an alias to sample so that as people start typing throttle it prompts them for the different options and discoverability will be improved instead of knowing to go look for sample The throttleFirst operator is included as an efficient approach to throttling tht does not involve ticking time intervals or buffering in any way It simply allows an onNext value through if the last onNext event was greater than X time units ago All others are discarded This matches server side throttling expectations and is limited overhead Questions 1 Is there a better name for throttleWithTimeout as an alias to debounce 2 Does the documentation sufficiently explain the different strategies 3 If ambitious in your review does anyone see concurrency bugs','RxJava pull requests #262 https netflixoss ci cloudbees com job RxJava pull requests 262 SUCCESS This pull request looks good I would appreciate feedback on this today so I can merge or fix with feedback tomorrow Wednesday US time and get ready to release version 0 13 I ve created marble diagrams for these new methods If you want to include them in the javadocs you can use a similar URL pattern to those that are already found there The diagrams are called throttleLast png throttleFirst png throttleWithTimeout png debounce png On Tue Sep 10 2013 at 3 21 PM Ben Christensen notifications@github com wrote I would appreciate feedback on this today so I can merge or fix with feedback tomorrow Wednesday US time and get ready to release version 0 13 Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 368#issuecomment 24199540 Thank you @DavidMGross One change to make on throttleFirst there would not be a delay in delivering thus it would emit red yellow turquoise immediately not after a delay That s the big difference with throttleFirst there is no scheduling or delaying thus no threading overhead It only skips until skipDuration has passed since the last onNext was emitted then emits the next onNext it receives RxJava pull requests #264 https netflixoss ci cloudbees com job RxJava pull requests 264 SUCCESS This pull request looks good No feedback so I m moving forward with this',RxJava,true,false,false
19299248,'Remove covariance of scan reduce','Remove covariance of scan reduce since consumer producer are the same T T T See https github com Netflix RxJava issues 360#issuecomment 24203016','RxJava pull requests #263 https netflixoss ci cloudbees com job RxJava pull requests 263 SUCCESS This pull request looks good This method and friends public lt R gt Observable lt R gt reduce R initialValue Func2 lt super R super T extends R gt accumulator also needs to changed to public lt R gt Observable lt R gt reduce R initialValue Func2 lt R super T R gt accumulator T2 should remain super T because it is only consumed I didn t change those yet as I wasn t sure if they behave differently because they consume and produce different types I wasn t able to get an example that proved or disproved anything so left it until I can Do you have example code that shows that method doesn t benefit from super T And what T2 are you referring to There isn t anything with a type T2 in reduce Func2 lt T1 T2 R gt George and I chatted in person We looked at JDK 8 to try and get a final representation of others doing this and it does it like this java U U reduce U identity BiFunction U super T U accumulator BinaryOperator U combiner This is at http download java net jdk8 docs api java util stream Stream html#reduce U 20java util function BiFunction 20java util function BinaryOperator java Optional T reduce BinaryOperator T accumulator The BinaryOperator is this java public interface BinaryOperator T extends BiFunction T T T Thus this seems to confirm the decision to remove super in reduce without a seed and in the one with a seed value do what George recommended java reduce R initialValue Func2 R super T R accumulator RxJava pull requests #267 https netflixoss ci cloudbees com job RxJava pull requests 267 SUCCESS This pull request looks good',RxJava,true,false,false
19299555,'Change zip method signature from Collection to Iterable','Fix javadoc typos','RxJava pull requests #265 https netflixoss ci cloudbees com job RxJava pull requests 265 SUCCESS This pull request looks good',RxJava,true,false,false
19301218,'Operator Retry','https github com Netflix RxJava issues 72','This completes https github com Netflix RxJava issues 72 RxJava pull requests #266 https netflixoss ci cloudbees com job RxJava pull requests 266 SUCCESS This pull request looks good',RxJava,true,false,false
19318247,'Zip Map Select with index','I m looking for a function corresponding to this Rx C# function http msdn microsoft com en us library hh244311 v vs 103 aspx Do we already have this in RxJava I m asking this because I want to implement the zipWithIndex function in the Scala adaptor','No we do not have that yet Your naming convention will be what we need to use so we don t overload methods with functions of different arities as that causes issues So mapWithIndex and zipWithIndex make sense I d be happy with mapWithIndex and zipWithIndex I don t think we have the arity problem with map mapWithIndex or do we I think it should be specific to zip So we could name it map instead of mapWithIndex if we wanted to But probably we should be consistent and still call it mapWithIndex I take that back I just experimented with this and noticed that at least Clojure does indeed have a problem with that So mapWithIndex it is',RxJava,false,false,false
19366509,'a few warnings javadoc and one missing scheduler parameter','This is just a quick fix for #368 according to @samuelgruetter s comments I also removed a few unnecessary @SuppressWarnings unchecked and one unnecessary semicolon','RxJava pull requests #268 https netflixoss ci cloudbees com job RxJava pull requests 268 SUCCESS This pull request looks good RxJava pull requests #270 https netflixoss ci cloudbees com job RxJava pull requests 270 SUCCESS This pull request looks good Thank you',RxJava,true,false,false
19374620,'Implemented distinctUntilChanged operation','This is the implementation for distinctUntilChanged as described in #39 I haven t implemented the two methods from NET that are using an IEqualityComparator because I don t think it would be idiomatic Java to define an interface like this and use that here Or does somebody want that','RxJava pull requests #269 https netflixoss ci cloudbees com job RxJava pull requests 269 SUCCESS This pull request looks good RxJava pull requests #271 https netflixoss ci cloudbees com job RxJava pull requests 271 SUCCESS This pull request looks good What about a method that takes a java util Comparator @abersnaze I don t know It s possible and easy of course I just don t see much of a use case But maybe that s just me If there was an Observable of some object and they either didn t implement equals correctly or a different criteria for equality was needed then in Java this operator couldn t be used as is I work around be to use map before to wrap the object that implements a different equals then a map after it to unwrap it You could also use the distinctUntilChanged version with the keySelector to work around that Then there s not even the need for unwrapping anymore The point I was trying to make was that I think it would be inconvenient and not in line with most of the other java APIs that involve comparing values This brings up another concern that I have is how to deal with instance operators that require some additional constraints on the values emitted In this case it only works if equals is implemented correctly Then there is the no arg version toSortedList that casts the values to Comparable Some of the other method only operate on Observable Observable T The only way to ensure that is to have them as static where the generics can be specific to that method I thought about making a toComparableObservable Comparator where the sorting APIs could live or a toObservableOfObservable where zip and merge could be instance methods There are many problems with this idea discoverability of operators inability to mix sorted observable of observables it still isn t type safe I tend to agree that we should have the Comparator overloads but those can be added later Merging',RxJava,true,false,false
19380736,'Implemented distinct operator','This PR implements distinct as speficied by #38 Again I haven t implemented the NET methods taking an IEqualityComparator see #374','RxJava pull requests #272 https netflixoss ci cloudbees com job RxJava pull requests 272 SUCCESS This pull request looks good',RxJava,true,false,false
19410697,'Idiomatic Scala Adaptor','This is a first pull request for https github com Netflix RxJava issues 336 The Scala Adaptor is still far from being finished see TODOs in language adaptors rxjava scala TODO md but I think it s in a state where it can be merged in so that people can try it out and give feedback','RxJava pull requests #273 https netflixoss ci cloudbees com job RxJava pull requests 273 SUCCESS This pull request looks good As far as testing is concerned I mainly tested usability in the file language adaptors rxjava scala src main scala rx lang scala examples RxScalaDemo scala and not whether the operators behave correctly because that s already covered by the tests in RxJava Nevertheless I also plan to add such tests in Scala Does this break any existing usability with the implicits that have been in place How does this new approach and those implicits interact or this is a complete replacement forgot to say awesome work Thanks so much for your effort and submitting this It s not a breaking change The old RxImplicits are still there and usable It s even imaginable to use both approaches in the same project by importing one or the other In Scala code if you have an rx lang scala Observable you can always call asJava to get the underlying rx Observable And to code in languages other than Scala rx lang scala Observable appears as rx Observable thanks to Scala s value classes Ditto Since this is not breaking I will merge this and release 0 13 1 so people can start trying it out @samuelgruetter Really nice work the value class approach lends itself very well to the JVM centric approach and allows for easy consumption by all other JVM languages I share your concern on the maintenance burden of keeping rx Observable and rx lang scala Observable in sync It seems like some sort of codegen approach may ease the burden do have a sense if that would be a worthwhile endeavor @mattrjacobs the whole point of this Scala adaptor is that someone manually looks at each method in the Java Observable and asks how should this be done in Scala There are more differences between Java and Scala than one might think and the goal of the adapter is to expose an API which looks as Scala idiomatic as possible Some examples for these differences scala def U T that Observable U Observable U instead of concat def zip U that Observable U Observable T U instance method instead of static def dematerialize U implicit evidence T Notification U Observable U ensures that it can only be called on Observables of Notifications def onErrorResumeNext U T resumeFunction Throwable Observable U Observable U requires type parameter with lower bound to get covariance right def fold R initialValue R accumulator R T R Observable R curried in Scala collections so curry if also here def sample duration Duration Observable T using Duration instead of long timepan TimeUnit duration def drop n Int Observable T called skip in Java but drop in Scala def zipWithIndex Observable T Int there s only mapWithIndex in Java because Java doesn t have tuples def toSeq Observable Seq T corresponds to Java s toList def switch U implicit evidence Observable T Observable Observable U Observable U ensures that it can only be called on Observables of Observables def apply range Range Observable Int static from becomes apply use Scala Range def never Observable Nothing use Bottom type So I would definitely not go for a codegen approach However it might be cool to have a unit test in which we encode the information which Java method corresponds to which Scala method and using reflection we check if there is a Scala method for each Java method So if a method is added to the Java Observable but not to the Scala Observable this test would fail',RxJava,true,false,false
19428771,'Distinct operator','Merging https github com Netflix RxJava pull 375','RxJava pull requests #274 https netflixoss ci cloudbees com job RxJava pull requests 274 SUCCESS This pull request looks good',RxJava,true,false,false
19428910,'UnitTests while working on EventStream use cases','','RxJava pull requests #275 https netflixoss ci cloudbees com job RxJava pull requests 275 SUCCESS This pull request looks good',RxJava,true,false,false
19435212,'Make interval work with multiple subscribers','As per @samuelgruetter s comments in #55 I added some tests against interval together with multiple subscribers and then proceeded to fix the behavior by wrapping it in another subscription function I hope it s ok now','RxJava pull requests #276 https netflixoss ci cloudbees com job RxJava pull requests 276 FAILURE Looks like there s a problem with this pull request I feel innocent about that test failure Looks like a sporadic timing problem of the CurrentThreadScheduler test to me',RxJava,true,false,false
19440951,'Implemented distinct and distinctUntilChanged variants using a comparator','As @abersnaze and @benjchristensen both agreed see the #374 discussion that they d like the comparator versions of these two operations too I implemented them here','RxJava pull requests #277 https netflixoss ci cloudbees com job RxJava pull requests 277 FAILURE Looks like there s a problem with this pull request Hmm today is the day of sporadic concurrency test failures it seems This doesn t look like a problem caused by this PR RxJava pull requests #279 https netflixoss ci cloudbees com job RxJava pull requests 279 SUCCESS This pull request looks good',RxJava,true,false,false
19443938,'Implemented mapWithIndex','As requested by @samuelgruetter in #372','RxJava pull requests #278 https netflixoss ci cloudbees com job RxJava pull requests 278 FAILURE Looks like there s a problem with this pull request Test failure again due to sporadic timing problems I just submitted an issue https github com Netflix RxJava issues 383 for this Looks good',RxJava,true,false,false
19480822,'Removing deprecated RxImplicits from rxjava scala','Now that @samuelgruetter s work on a value class implementation of Scala Observable has been merged no need for the standalone RxImplicits','RxJava pull requests #280 https netflixoss ci cloudbees com job RxJava pull requests 280 SUCCESS This pull request looks good Now that https github com Netflix RxJava blob master language adaptors rxjava scala src main scala rx lang scala ImplicitFunctionConversions scala is made public it looks like this can still be deleted RxJava pull requests #289 https netflixoss ci cloudbees com job RxJava pull requests 289 SUCCESS This pull request looks good',RxJava,true,false,false
19494210,'Flaky unit tests','It looks like there are some flaky unit tests On my machine this test failed today but only once rx operators OperationNext UnitTest testOnErrorViaHasNext On cloudbees these tests seem to be flaky Build #278 rx concurrency CurrentThreadScheduler UnitTest testSequenceOfDelayedActions Build #276 rx concurrency CurrentThreadScheduler UnitTest testSequenceOfDelayedActions Build #237 rx concurrency CurrentThreadScheduler UnitTest testSequenceOfDelayedActions Build #185 rx concurrency CurrentThreadScheduler UnitTest testSequenceOfDelayedActions Build #251 rx concurrency TestSchedulers testSchedulingWithDueTime Build #277 rx operators OperationConcat UnitTest testConcatConcurrentWithInfinity','Output of failed rx operators OperationNext UnitTest testOnErrorViaHasNext java lang AssertionError should not have received exception at org junit Assert fail Assert java 93 at rx operators OperationNext UnitTest testOnErrorViaHasNext OperationNext java 252 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 57 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at java lang reflect Method invoke Method java 606 at org junit runners model FrameworkMethod 1 runReflectiveCall FrameworkMethod java 45 at org junit internal runners model ReflectiveCallable run ReflectiveCallable java 15 at org junit runners model FrameworkMethod invokeExplosively FrameworkMethod java 42 at org junit internal runners statements InvokeMethod evaluate InvokeMethod java 20 at org junit runners ParentRunner runLeaf ParentRunner java 263 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 68 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 47 at org junit runners ParentRunner 3 run ParentRunner java 231 at org junit runners ParentRunner 1 schedule ParentRunner java 60 at org junit runners ParentRunner runChildren ParentRunner java 229 at org junit runners ParentRunner access 000 ParentRunner java 50 at org junit runners ParentRunner 2 evaluate ParentRunner java 222 at org junit runners ParentRunner run ParentRunner java 300 at org gradle api internal tasks testing junit JUnitTestClassExecuter runTestClass JUnitTestClassExecuter java 80 at org gradle api internal tasks testing junit JUnitTestClassExecuter execute JUnitTestClassExecuter java 47 at org gradle api internal tasks testing junit JUnitTestClassProcessor processTestClass JUnitTestClassProcessor java 69 at org gradle api internal tasks testing SuiteTestClassProcessor processTestClass SuiteTestClassProcessor java 49 at sun reflect GeneratedMethodAccessor7 invoke Unknown Source at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at java lang reflect Method invoke Method java 606 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 35 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 24 at org gradle messaging dispatch ContextClassLoaderDispatch dispatch ContextClassLoaderDispatch java 32 at org gradle messaging dispatch ProxyDispatchAdapter DispatchingInvocationHandler invoke ProxyDispatchAdapter java 93 at com sun proxy Proxy2 processTestClass Unknown Source at org gradle api internal tasks testing worker TestWorker processTestClass TestWorker java 103 at sun reflect GeneratedMethodAccessor6 invoke Unknown Source at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at java lang reflect Method invoke Method java 606 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 35 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 24 at org gradle messaging remote internal hub MessageHub Handler run MessageHub java 355 at org gradle internal concurrent DefaultExecutorFactory StoppableExecutorImpl 1 run DefaultExecutorFactory java 66 at java util concurrent ThreadPoolExecutor runWorker ThreadPoolExecutor java 1145 at java util concurrent ThreadPoolExecutor Worker run ThreadPoolExecutor java 615 at java lang Thread run Thread java 724 Build 278 rx concurrency CurrentThreadScheduler UnitTest testSequenceOfDelayedActions Build 276 rx concurrency CurrentThreadScheduler UnitTest testSequenceOfDelayedActions Build 237 rx concurrency CurrentThreadScheduler UnitTest testSequenceOfDelayedActions Build 185 rx concurrency CurrentThreadScheduler UnitTest testSequenceOfDelayedActions The CurrentThreadScheduler tests that are testing delay functionality are very non deterministic The assertions either need to change to allow for that or we need to change to using artificial time though these particular tests are purposefully testing the real implementation so using artificial time would someone defeat the purpose Build 251 rx concurrency TestSchedulers testSchedulingWithDueTime This is similar it s asserting something scheduled on a background thread I haven t dug into what needs to change Build 277 rx operators OperationConcat UnitTest testConcatConcurrentWithInfinity Not sure at a quick glance what the issue here is I don t have time this morning to fix these but will do so at some point their intermittent failures annoy me too Another here https netflixoss ci cloudbees com job RxJava pull requests 293 another local failure rx operators OperationNext UnitTest testOnErrorViaHasNext FAILED java lang AssertionError at OperationNext java 252 and yet another in rx operators SynchronizedObserver UnitTest java lang AssertionError expected 1 but was 0 at org junit Assert fail Assert java 93 at org junit Assert failNotEquals Assert java 647 at org junit Assert assertEquals Assert java 128 at org junit Assert assertEquals Assert java 472 at org junit Assert assertEquals Assert java 456 at rx operators SynchronizedObserver UnitTest testMultiThreadedWithNPEinMiddle SynchronizedObserver java 250 rx concurrency CurrentThreadScheduler UnitTest failed several times in my machine today pre org mockito exceptions verification VerificationInOrderFailure Verification in order failure Wanted but not invoked action0 call at rx concurrency CurrentThreadScheduler UnitTest testSequenceOfDelayedActions CurrentThreadScheduler java 191 Wanted anywhere AFTER following interaction action0 call at rx Scheduler 4 call Scheduler java 184 at rx concurrency CurrentThreadScheduler UnitTest testSequenceOfDelayedActions CurrentThreadScheduler java 191 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 39 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 25 at java lang reflect Method invoke Method java 597 at org junit runners model FrameworkMethod 1 runReflectiveCall FrameworkMethod java 45 at org junit internal runners model ReflectiveCallable run ReflectiveCallable java 15 at org junit runners model FrameworkMethod invokeExplosively FrameworkMethod java 42 at org junit internal runners statements InvokeMethod evaluate InvokeMethod java 20 at org junit runners ParentRunner runLeaf ParentRunner java 263 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 68 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 47 at org junit runners ParentRunner 3 run ParentRunner java 231 at org junit runners ParentRunner 1 schedule ParentRunner java 60 at org junit runners ParentRunner runChildren ParentRunner java 229 at org junit runners ParentRunner access 000 ParentRunner java 50 at org junit runners ParentRunner 2 evaluate ParentRunner java 222 at org junit runners ParentRunner run ParentRunner java 300 at org gradle api internal tasks testing junit JUnitTestClassExecuter runTestClass JUnitTestClassExecuter java 80 at org gradle api internal tasks testing junit JUnitTestClassExecuter execute JUnitTestClassExecuter java 47 at org gradle api internal tasks testing junit JUnitTestClassProcessor processTestClass JUnitTestClassProcessor java 69 at org gradle api internal tasks testing SuiteTestClassProcessor processTestClass SuiteTestClassProcessor java 49 at sun reflect GeneratedMethodAccessor7 invoke Unknown Source at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 25 at java lang reflect Method invoke Method java 597 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 35 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 24 at org gradle messaging dispatch ContextClassLoaderDispatch dispatch ContextClassLoaderDispatch java 32 at org gradle messaging dispatch ProxyDispatchAdapter DispatchingInvocationHandler invoke ProxyDispatchAdapter java 93 at Proxy2 processTestClass Unknown Source at org gradle api internal tasks testing worker TestWorker processTestClass TestWorker java 103 at sun reflect GeneratedMethodAccessor6 invoke Unknown Source at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 25 at java lang reflect Method invoke Method java 597 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 35 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 24 at org gradle messaging remote internal hub MessageHub Handler run MessageHub java 355 at org gradle internal concurrent DefaultExecutorFactory StoppableExecutorImpl 1 run DefaultExecutorFactory java 66 at java util concurrent ThreadPoolExecutor Worker runTask ThreadPoolExecutor java 886 at java util concurrent ThreadPoolExecutor Worker run ThreadPoolExecutor java 908 at java lang Thread run Thread java 662 pre again rx operators OperationNext UnitTest testOnErrorViaHasNext wrt rx operators OperationNext UnitTest testOnErrorViaHasNext I don t think the test is necessarily flaky rather that the Iterable returned by next is inconsistent if you trigger an exception during Iterable next then the Iterable hasNext will revert to returning true This can fail the test if the assertFalse it hasNext runs after the it next on the async thread so you can t really fix the test you can either make the test thread delay a little longer and definitely fail or remove the assert and accept that the behavior of hasNext is unreliable after next completes either with a value or exception since its unusual that you d be checking the Iterable from a different thread also might be worth noting that the wiki suggests the Iterable should return a single null value if the Observable completes without any value https github com Netflix RxJava wiki Blocking Observable Operators#next but I can t see any test or implementation for this case am I misunderstanding this Then the hasNext should block until either the onNext or onComplete has been called not sure in which case you mean the hasNext in the failing test is called after the onNext onComplete has occurred the async thread has called next and it has thrown an exception or do you mean in the case where the Observable completes without an onNext The following error happened in my machine today pre java lang AssertionError expected 39 0 but was 100 0 at org junit Assert fail Assert java 93 at org junit Assert failNotEquals Assert java 647 at org junit Assert assertEquals Assert java 443 at org junit Assert assertEquals Assert java 512 at rx operators OperationGroupBy UnitTest testUnsubscribe OperationGroupBy java 546 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 39 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 25 at java lang reflect Method invoke Method java 597 at org junit runners model FrameworkMethod 1 runReflectiveCall FrameworkMethod java 45 at org junit internal runners model ReflectiveCallable run ReflectiveCallable java 15 at org junit runners model FrameworkMethod invokeExplosively FrameworkMethod java 42 at org junit internal runners statements InvokeMethod evaluate InvokeMethod java 20 at org junit runners ParentRunner runLeaf ParentRunner java 263 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 68 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 47 at org junit runners ParentRunner 3 run ParentRunner java 231 at org junit runners ParentRunner 1 schedule ParentRunner java 60 at org junit runners ParentRunner runChildren ParentRunner java 229 at org junit runners ParentRunner access 000 ParentRunner java 50 at org junit runners ParentRunner 2 evaluate ParentRunner java 222 at org junit runners ParentRunner run ParentRunner java 300 at org gradle api internal tasks testing junit JUnitTestClassExecuter runTestClass JUnitTestClassExecuter java 80 at org gradle api internal tasks testing junit JUnitTestClassExecuter execute JUnitTestClassExecuter java 47 at org gradle api internal tasks testing junit JUnitTestClassProcessor processTestClass JUnitTestClassProcessor java 69 at org gradle api internal tasks testing SuiteTestClassProcessor processTestClass SuiteTestClassProcessor java 49 at sun reflect GeneratedMethodAccessor7 invoke Unknown Source at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 25 at java lang reflect Method invoke Method java 597 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 35 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 24 at org gradle messaging dispatch ContextClassLoaderDispatch dispatch ContextClassLoaderDispatch java 32 at org gradle messaging dispatch ProxyDispatchAdapter DispatchingInvocationHandler invoke ProxyDispatchAdapter java 93 at com sun proxy Proxy2 processTestClass Unknown Source at org gradle api internal tasks testing worker TestWorker processTestClass TestWorker java 103 at sun reflect GeneratedMethodAccessor6 invoke Unknown Source at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 25 at java lang reflect Method invoke Method java 597 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 35 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 24 at org gradle messaging remote internal hub MessageHub Handler run MessageHub java 355 at org gradle internal concurrent DefaultExecutorFactory StoppableExecutorImpl 1 run DefaultExecutorFactory java 66 at java util concurrent ThreadPoolExecutor Worker runTask ThreadPoolExecutor java 895 at java util concurrent ThreadPoolExecutor Worker run ThreadPoolExecutor java 918 at java lang Thread run Thread java 695 pre I reviewed rx operators OperationGroupBy UnitTest testUnsubscribe and found the following assumption was wrong java sentEvents will go until eventCounter hits 20 and then unsubscribes which means it will also send but ignore the 19 20 events for the other group It will not however send all 100 events assertEquals 39 sentEventCounter get 10 gave it a delta of 10 to account for the threading unsubscription race condition which can vary depending on a machines performance thread scheduler etc Actually since we can not control when to run a thread sentEventCounter can be 100 in some scenario I fixed one flaky test by moving the decrement of the latch in to the observer java map new Func1 String String public String call String arg0 throw new IllegalArgumentException any error try throw new IllegalArgumentException any error finally latch countDown wait for the call to get to the observer before decrementing the latch doAnswer new Answer @Override public Object answer InvocationOnMock invocation throws Throwable latch countDown return null when stringObserver onError any Throwable class m subscribe stringObserver latch await @abersnaze Thanks I added your patch to PR #461 Is it OK Could you take a look Just had another instance of this java lang NullPointerException at rx operators OperationConcatTest testConcatConcurrentWithInfinity OperationConcatTest java 324 at sun reflect NativeMethodAccessorImpl invoke0 Native Method Another test which also seems to be flaky rx schedulers NewThreadSchedulerTest testMixOfDelayedAndNonDelayedActions org mockito exceptions verification VerificationInOrderFailure Verification in order failure Wanted but not invoked action0 call at rx schedulers AbstractSchedulerTests testMixOfDelayedAndNonDelayedActions AbstractSchedulerTests java 317 Wanted anywhere AFTER following interaction action0 call at rx Scheduler 4 call Scheduler java 194 at rx schedulers AbstractSchedulerTests testMixOfDelayedAndNonDelayedActions AbstractSchedulerTests java 317 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 57 This was with version 0 16 0 For the rx schedulers NewThreadSchedulerTest testMixOfDelayedAndNonDelayedActions as AbstractSchedulerTests testMixOfDelayedAndNonDelayedActions uses the real time to schedule the actions it s non deterministic When the CPUs are busy the test may fail Can we enlarge the time java scheduler schedule first scheduler schedule second 300 TimeUnit MILLISECONDS scheduler schedule third 100 TimeUnit MILLISECONDS scheduler schedule fourth scheduler schedule new Action0 @Override public void call latch countDown 400 TimeUnit MILLISECONDS Closing as this has become an epic dumping ground most issues have been solved The only one I m still aware of is a new one the pivot operator',RxJava,false,false,false
19496577,'Implemented the delay operator','This implements the operator from #36 in all four variants The tests also found a bug in interval that I fixed Maybe this is a bug of map though map throws exceptions in onNext not sure if it should be allowed to do that the SafeObserver that it relies on comes too late for scheduled actions However this can be discussed and fixed independently','RxJava pull requests #281 https netflixoss ci cloudbees com job RxJava pull requests 281 SUCCESS This pull request looks good Maybe this is a bug of map though map throws exceptions in onNext not sure if it should be allowed to do that the SafeObserver that it relies on comes too late for scheduled actions However this can be discussed and fixed independently The idea is that Func implementations from internal code functions correctly and does not break the Rx contract that onNext should not throw Thus we shouldn t need the SafeObserver around anything internal that complies with the Rx contract The SafeObserver only wraps functions and observers that are passed in from outside the RxJava codebase as those are untrusted This was discussed further at https github com Netflix RxJava issues 216 and then more recently changes to map were made for error handling https github com Netflix RxJava pull 314 RxJava pull requests #282 https netflixoss ci cloudbees com job RxJava pull requests 282 SUCCESS This pull request looks good RxJava pull requests #283 https netflixoss ci cloudbees com job RxJava pull requests 283 SUCCESS This pull request looks good Only errors emitted by the source Observable are not delayed Why was this decision made Is that how Rx Net works the MSDN docs don t say This means we d ignore onNext events scheduled to be delivered since we d push onError before them That breaks the Rx contract so don t know why we d want to do this It seems that onError and onCompleted should be delayed just like onNext all notifications scheduled for future delivery Concerning the question whether Rx NET emits errors without delay Here http www introtorx com content v1 0 10621 0 13_TimeShiftedSequences html it says that they get emitted without delay MSDN doesn t say anything about it So I tried it out in F# and it actually doesn t get delayed fsharp #light open Core Printf open System open System Reactive Linq module Program exception ObsvError EntryPoint let Main args let mapToError fun x int64 if x 4L then raise ObsvError else x let obsv Observable Interval TimeSpan FromSeconds 1 0 Select mapToError Delay TimeSpan FromSeconds 4 5 let sub obsv Subscribe onNext fun x printfn d x onError fun exn Console WriteLine Error Console ReadLine ignore sub Dispose 0 Will output 0 1 Error If the error weren t delayed at all however it should happen before 1 If it were delayed fully it should happen after 4 So that s a bit strange I guess all that means that we ll have to introduce a specific timestamped queue here @headinthebox Erik can you provide guidance on what we should do here It seems that onError should be delayed if any onNext are still outstanding but that isn t what happens in Net and that seems to break the Rx contract Erik has confirmed that onError should emit immediately and that if the onNext events should not be lost then onErrorResumeNext or something similar should be used before delay or materialize can be used before passing into delay to treat onError as an event rather than exception @jmhofer Based on Erik s confirmation is this good to merge Unfortunately I didn t get around to another close look here yet I m afraid that this might still need a queue and some synchronization in order to be clean concurrency wise Imho the current implementation should work for sane use cases though I must say that I am surprised that in NET xs Delay t does not behave the same as xs Select x Observable Timer t Select _ x Concat Erik On Oct 22 2013 at 10 05 PM Joachim Hofer notifications@github com wrote Unfortunately I didn t get around to another close look here yet I m afraid that this might still need a queue and some synchronization in order to be clean concurrency wise Imho the current implementation should work for sane use cases though Reply to this email directly or view it on GitHub Could we implement delay with something like xs map x Observable timer t map _ x cache concat That s what I effectively do below except I am not sure why you add the extra call to cache I am digging into the NET implementation as we speak since I am not sure that implementation is correct On Oct 23 2013 at 11 44 AM samuelgruetter notifications@github com wrote Could we implement delay with something like xs map x Observable timer t map _ x cache concat Reply to this email directly or view it on GitHub concat Observable Observable T has never more than two subscriptions at the same time one to the outer Observable Observable T and one to the current inner Observable T For delay however if the time distance between two elements is smaller than the delay both TimerObservables created for delaying these two elements must have a subscriber as soon as they re created to make sure that they start counting time Comcat doesn t do these necessary subscriptions and that s why I added cache Note that I m making these claims without having access to a computer where I can do tests so this risks being complete nonsense The NET implementation has a bug The version using the Delay operator delivers one value after the input has experienced an OnError and waits for 10 seconds to deliver the answer and fail The values in X Y don t matter 0 31 44 Exception of type System Exception was thrown If you draw the marble diagram the correct answer is to call onError after 4 seconds Exception of type System Exception was thrown Erik var xs Observable Interval TimeSpan FromSeconds 1 Select x if x 4 throw new Exception return x System DateTime Now Millisecond Delay TimeSpan FromSeconds 10 Select x x System DateTime Now Millisecond xs Subscribe x Console WriteLine x e Console WriteLine e Message Console WriteLine var zs Observable Interval TimeSpan FromSeconds 1 Select x if x 4 throw new Exception return x System DateTime Now Millisecond Select x Observable Timer TimeSpan FromSeconds 10 Select _ x Concat Select x x System DateTime Now Millisecond zs Subscribe x Console WriteLine x e Console WriteLine e Message Console WriteLine From erik meijer mailto erik meijer@meijcrosoft com Sent Wednesday October 23 2013 2 52 AM To Netflix RxJava Cc Netflix RxJava Erik Meijer Subject Re RxJava Implemented the delay operator #384 That s what I effectively do below except I am not sure why you add the extra call to cache I am digging into the NET implementation as we speak since I am not sure that implementation is correct On Oct 23 2013 at 11 44 AM samuelgruetter notifications@github com wrote Could we implement delay with something like xs map x Observable timer t map _ x cache concat Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 384#issuecomment 26892143 https github com notifications beacon f5Np9 JVjG56Yyi3j3ToPDeurdEmqyCr9bz IdcgJ4T5obnlPCkNxbsmS18XcQofG gif @jmhofer Can you rebase this with master so it can be merged and ensure it matches the final answers we got from @headinthebox this is a 1 on this PR I have rebased this onto netflix rxjava master and issued a PR to @jmhofer here is my fork https github com jonnolen RxJava tree delay Completed in #576',RxJava,true,false,false
19542346,'Implemented the any operator','This implements the operator Any from #24 in all two variants However I encountered two problems Updated the online document http msdn microsoft com en us library hh211993 v vs 103 aspx is wrong See my later discussion Another question is if I add the any method to rx Observable T some unit tests will fail as the method any in rx Observable T overrides the method org mockito Matchers any java lang Class T in some unit tests e g rx subjects ReplaySubject T Do I need to use another method name or just modify the unit tests Now the any methods in rx Observable T are commented out Thanks','RxJava pull requests #284 https netflixoss ci cloudbees com job RxJava pull requests 284 SUCCESS This pull request looks good I haven t looked at the first question yet but on the second one we ll likely need to stop importing org mockito Matchers and call it directly org mockito Matchers any Sorry that I missed the keyword empty in my description The first question is I m not sure how to handle an empty observable sequence RxJava pull requests #285 https netflixoss ci cloudbees com job RxJava pull requests 285 ABORTED I tested the C# Any today The environment is VS2010 Net 4 0 I found the description in my VS is Determines whether any element of an observable sequence satisfies a condition This is totally different from the online document http msdn microsoft com en us library hh211993 v vs 103 aspx I always did some tests for Any Here is the code pre using System using System Collections Generic using System Linq using System Text using System Reactive Linq namespace ConsoleApplication1 class Program static void Main string args var any Observable Empty int Any any Subscribe x Console WriteLine subscriber got x subscriber got False any Observable Range 1 5 Any any Subscribe x Console WriteLine subscriber got x subscriber got True any Observable Empty int Any x true any Subscribe x Console WriteLine subscriber got x subscriber got False any Observable Range 1 5 Any x x 3 any Subscribe x Console WriteLine subscriber got x subscriber got True any Observable Range 1 5 Any x x 5 any Subscribe x Console WriteLine subscriber got x subscriber got False Console ReadLine pre Here is the output pre subscriber got False subscriber got True subscriber got False subscriber got True subscriber got False pre In summary If an observable sequence is empty any emits false If one element of an observable sequence satisfies the condition any emits true If all elements of an observable sequence do not satisfy the condition any emits false I have implemented the correct any operator Please take a look Thanks RxJava pull requests #286 https netflixoss ci cloudbees com job RxJava pull requests 286 ABORTED In Scala we will probably use isEmpty instead of any negated and exists somePredicate instead of any somePredicate You could use these names also in Java to avoid confusion and name conflicts @zsxwing I don t have time tonight but will definitely get to this in the near future thank you for getting involved',RxJava,true,false,false
19597343,'Android how to manage screen rotation with observer','Hi Since I have discovered Rx java I have replaced all my async loaders by observers and observables That s very cool to easily get an error to the UI thread I have still a question As you know when the screen rotate the activity is killed and recreated I am wondering how should I do to resubscribe to the same observable launched before the rotation Is there a pattern I have not think of Or is it a feature to come I am very new to reactive programming and I perfectly realize I am using 1 of the power of Rx java but can you help me to reach the 2 Thank you','Something else but related is there a way to stop an observable during its work I noticed that when onError is called the process is stopped is there a way to call the stop method from the main thread I don t have experience with Android so can t help on this Perhaps the RxJava Google Group would be a better place to ask https groups google com forum # forum rxjava Hi @benjchristensen Indeed it s not really an Android issue It s a more general issue which may happen more often on Android The point is that I am getting many java lang RuntimeException Error occurred when trying to propagate error to Observer onError The reason is easy to understand the activity which is also the subscriber has been closed because the screen rotate but we don t really care before the observable catch an error and try to send it back to the subscriber Because of the way SafeObserver works it crash all the application java @Override public void onError Throwable e if isFinished compareAndSet false true try actual onError e catch Throwable e2 if e2 instanceof OnErrorNotImplementedException onError isn t implemented so throw https github com Netflix RxJava issues 198 Rx Design Guidelines 5 2 when calling the Subscribe method that only has an onNext argument the OnError behavior will be to rethrow the exception on the thread that the message comes out from the observable sequence The OnCompleted behavior in this case is to do nothing throw OnErrorNotImplementedException e2 else if the onError itself fails then pass to the plugin see https github com Netflix RxJava issues 216 for further discussion RxJavaPlugins getInstance getErrorHandler handleError e RxJavaPlugins getInstance getErrorHandler handleError e2 and throw exception despite that not being proper for Rx https github com Netflix RxJava issues 198 throw new RuntimeException Error occurred when trying to propagate error to Observer onError new CompositeException Arrays asList e e2 auto unsubscribe subscription unsubscribe So in a general is there a way to deal with an error reported AFTER the subscriber unsubscribe and even disappears So in a general is there a way to deal with an error reported AFTER the subscriber unsubscribe and even disappears The event is not relevant to the subscription at that point since the subscriber is gone Because of the way SafeObserver works it crash all the application What about SafeObserver would crash the application java lang RuntimeException Error occurred when trying to propagate error to Observer onError That error does not mean the Observer is unsubscribed that means the Observer is failing to handle the onError event and thus there is no choice but to throw So why is the Observer onError failing when an exception is passed to it I think this happens because we can not disable HandlerThreadScheduler when the activity stops Is the activity you re referring to an Observable or an Observer If it is an Observable then it should emit an onCompleted and be done If is is an Observer then it should unsubscribe from the Subscription it received when it called Observable subscribe and it will give the Observable a chance to shutdown and clean up The Scheduler does not have a cancel on it because what would that mean Scheduling is per task the schedule methods and when something is scheduled it returns a Subscription Thus the Subscription is cancelled Subscription unsubscribe not the entire Scheduler If you can post a unit test demonstrating the issue that would help Sorry that I misunderstood this issue I deleted my comments @benjchristensen Thank you for your answer questions It made me search in the right direction I think I know understand what was happening On Android UI stuff is realized in an Activity If a user rotates the phone say from Portrait to Landscape the Activity is killed A new one is then recreated Of course in the rotation you loose everything There are some techniques to keep variable values however But in general it has to be stored in a bundle object Android boring stuff Anyway in my first implementation I followed the blog post from @mttkay without really understanding how Rx works inside So the Activity class was implementing the Observer interface It means that if the user rotate its phone you better have to call unsubscribe method or you will use a zombie Activity Observer Unfortunately I look at the source code of Rx and I understood that Observable built outside Rx are wrapped inside a SafeObservable and that SafeObservable will keep a hard reference to the Observer preventing it to be nullified garbage collected In normal case it should not be an issue because unsubscribe should have been called right but unfortunately in some cases I have still not found why unsubscribe method is not called lots of corner case in my app At the end of the story I get a call to onError because an exception has been released in the working thread inside the Observable this method is the one from an Observer which is also an Activity and this Observer Activity should have been destroyed doing stuff in a dead but not destroyed activity crash the application Based on the comment from @mttkay I have written a simple Proxy Observer to avoid this situation miss the unsubscribe Observer has disappeared java import java lang ref WeakReference import rx Observer public class AndroidProxyObserver public static T Observer T secure Observer T obs return new ProxyObserver T obs private static class ProxyObserver T implements Observer T final private WeakReference Observer T mCallBack private ProxyObserver Observer T obs mCallBack new WeakReference Observer T obs @Override public void onCompleted if mCallBack get null mCallBack get onCompleted @Override public void onError Throwable throwable if mCallBack get null mCallBack get onError throwable @Override public void onNext T object if mCallBack get null mCallBack get onNext object Nothing complex just a weak reference so if the Activity is destroyed there is no more hard reference to it to avoid cleaning garbage collection The Observer Activity will be killed at the device rotation and no more call to onError method is then possible because the WeakReference wrapper will be empty May be this code should be added to the Android contrib folder I will wait comments from you or @mttkay or whoever would see anything interesting in this simple snippet may be I am missing something else Moreover I am trying to build a class to manage easily the device rotation or any Activity Observer destruction in this Gist https gist github com pommedeterresautee 6752846 I am waiting opinion from advanced RxJava user to see if it s useful correct has to be committed Again thank you for having help to build such tool I am very happy when using it Regards I think you need to call mSubscription unsubscribe before the Activity is destroyed e g call in Activity onStop or Activity onDestroy After that the new events in the Scheduler will be dropped @pommedeterresautee We use a similar approach i e using a WeakReference However the class we use does some additional things to make it more sound when being used to update the UI We use an observer implementation which binds a fragment to a weak reference In every callback it first checks if a the reference is still set that s what you re doing too b if the fragment is still attached that s what you re not doing if you don t do b your app might still crash since getActivity returns null when the fragment is not attached If you don t use fragments I hope you do then you should probably check for isFinishing and drop the message if that s true That class I wanted to contribute back since it is production proven for a few months now and has proper unit tests and everything However I actually like the idea of decoupling the two concerns i e I see it could be beneficial although slightly more complex to use to have a WeakObserver I think AndroidProxyObserver is probably not a good name since it doesn t convey any meaning which could wrap a FragmentObserver or ActivityObserver which then do the above mentioned extra checks necessary when one wants to update the UI in onCompleted @benjchristensen Do you think a WeakObserver is something that should be part of the core module It sounds more universally applicable than to just Android It s simply an observer which doesn t guarantee to deliver any of the messages That might or might not be in violation with the design guidelines but we actually do require this behaviour on Android to not leak resources @zsxwing of course I have such call in onDestroy method However I can t reproduce exactly what happens when the application crashes but in my observable the one having issues I am executing some shell commands and in some cases for some reasons unsubscribe doesn t kill immediately the working thread Most of the time it does but not always I have not studied how unsubscribe works inside and why how it happens but the weak reference security avoid the effects of this behavior Regards @mttkay and @benjchristensen This post looks applicable http social msdn microsoft com Forums en US c8112371 e18a 4610 a840 53d1f81761ee weak subscribe Interesting thanks This paragraph applies to Android in the same way it applied to the author There are some rare scenarios in GUI and some other programming when the unsubscription moment is non determined and using the strong subscription will cause memory and resources leaks So it s not possible to explicitly control the unsubscription sometimes Android may decide non deterministically that it s time to destroy a sleeping Activity e g because the system runs out of memory I think weak references are an easy and straight forward way to deal with this The activity is either there or it s not If it s not drop the message as consuming it would crash the app It s an interesting thought however to implement this on the Observable level rather than in a decorating observer This for me falls into the general question that keeps bugging me which parts of Rx should be implemented as operators and which parts in observers In this case I found the observer to be the more natural place since the requested behaviour is purely specific to the subscriber side I don t really see how an operator that turns an observable sequence into a less reliable sequence is very useful outside this case which seems to be specific to GUIs I also noticed that his implementation of a WeakObserver auto unsubscribes from the observable http pastie org 901863 That could be useful on Android too Actually just talked to a co worker about this and it might end up being quite powerful after all to implement these things as an operator e g OperationToUserInterfaceEvents This would reduce client side boiler plate even further by doing the following things 1 Wrap both the subscription and the target observer in an inner observer that keeps weak references 2 Automatically schedule the observer on the Android UI thread since this is just boilerplate right now 3 Automatically unsubscribe if the reference to the target observer is gone This still doesn t encompass checking for isAttached or isFinishing but perhaps that bit could remain in the observer Thoughts @pommedeterresautee Which Scheduler do you use Does your onNext method run in the UI main thread or a non UI thread If it runs in a non UI thread onNext has a change to run after unsubscribe For example this is a snippet of codes in rx operators ScheduledObserver EventLoop which try to invoke your onNext method Java do Notification extends T notification queue poll if we got a notification send it if notification null if unsubscribed stop working if parentSubscription isUnsubscribed return parentSubscription process notification switch notification getKind case OnNext underlying onNext notification getValue break case OnError underlying onError notification getThrowable break case OnCompleted underlying onCompleted break default throw new IllegalStateException Unknown kind of notification notification while counter decrementAndGet 0 If this part of codes run in a non UI thread it may be suspended at switch statement Then the UI thread runs and invokes the Activity onDestroy method Even if unsubscribe is called in the Activity onDestroy method when the non UI thread is back it still will call the onNext method I m not sure if this is the cause of your issue Could you check it @mttkay Which parts of Rx should be implemented as operators and which parts in observers All operators are implemented as observers with sprecial behavior By having them as operators it allows for composition When I use Rx I generally try to have the final observer be as simple as possible Often there the body the onNext empty Thanks @abersnaze that sounds sensible I will set some time aside this or next week to move this behaviour to an operator @zsxwing In my application the Observer is an Activity and so the onNext method is called on UI thread My issue may be related to the fact that I was not checking isFinishing method as reminded by @mttkay May be in some cases the Activity is being destroyed when onError is called before the unsubscribe inside the onDestroy callback is called making the application crash @mttkay I try use as few as possible Fragment it introduces complexity in Android application I use them when I need to have different UI regarding the size orientation of the screen but I try to wrap separated task inside dedicated Activities if possible to limit the lots of complex bugs affecting Fragments However that s Android stuff not related to Rx may be not the place to discuss about that Regarding the question where to put stuff I like the idea to wrap as much as possible things inside a class hiding checks auto unsubscribing code to the user of the library In particular on Android most people will have the same needs regarding executing some Async work no need to bother them more than the strict minimum However I don t get why isFinishing isAttached should be check in the Observer by the lib user If you have a weak ref to your Observer in your OperationToUserInterfaceEvents class why not do the job there Regards @pommedeterresautee as to your last question Because the Observer isn t necessarily a fragment or activity it could be an inner class of either So you cannot invoke these methods on the observer directly @mttkay I think 90 of users will implement the Observer interface in their Activity Fragment directly as they do for LoaderManager LoaderCallbacks when implementing AsyncTaskLoader So it may be a good thing to manage both cases if Observer is an instance of Activity make all the boring work otherwise it s up to the lib user to implement these checks in the Observer Could you guys weigh in on this https github com Netflix RxJava pull 427 Thanks Is work still happening on this issue or shall we close it out IMO It can be closed',RxJava,false,true,false
19598851,'Zip calls onNext later than C# s Zip does','In the C# example below the zipped Observable completes as soon as o3 has completed because all of o3 s elements have been paired with an element from o6 cs static void Main var o3 Observable Interval TimeSpan FromMilliseconds 1000 Take 3 var o6 Observable Interval TimeSpan FromMilliseconds 1000 Take 10 var watch new Stopwatch watch Start Observable Zip o3 o6 Subscribe list Console WriteLine list 0 list 1 at t watch ElapsedMilliseconds e Console WriteLine e StackTrace Console WriteLine complete at t watch ElapsedMilliseconds Console ReadLine outputs 0 0 at t 1055 1 1 at t 2045 2 2 at t 3047 complete at t 4058 In the corresponding Java code however the zipped Observable only completes once both o3 and o6 have completed java static Func2 Long Long Long zipFunc new Func2 Long Long Long public Long call Long n1 Long n2 if n1 equals n2 return n1 else throw new RuntimeException numbers not equal public static void main String args Observable Long o3 Observable interval 1000 TimeUnit MILLISECONDS take 3 Observable Long o6 Observable interval 1000 TimeUnit MILLISECONDS take 10 final long startTime System currentTimeMillis Observable zip o3 o6 zipFunc subscribe new Action1 Long public void call Long n System out println n at t System currentTimeMillis startTime new Action1 Throwable public void call Throwable t t printStackTrace new Action0 public void call System out println complete at t System currentTimeMillis startTime outputs 0 at t 1019 1 at t 2019 2 at t 3019 complete at t 10019 I d like RxJava to follow C# here unless there are very good reasons against doing so This difference becomes even more important if one of the observables never completes Then the zipped Observable never completes either which was very unexpected for me','This unit test demonstrates the issue java @Test public void testOnFirstCompletion PublishSubject String oA PublishSubject create PublishSubject String oB PublishSubject create @SuppressWarnings unchecked Observer String observer mock Observer class Observable String o Observable create zip oA oB getConcat2Strings o subscribe observer InOrder inOrder inOrder observer oA onNext a1 inOrder verify observer never onNext anyString oB onNext b1 inOrder verify observer times 1 onNext a1 b1 oB onNext b2 inOrder verify observer never onNext anyString oA onNext a2 inOrder verify observer times 1 onNext a2 b2 oA onNext a3 oA onNext a4 oA onNext a5 oA onCompleted assert we complete the zip stream here inOrder verify observer times 1 onCompleted oB onNext b3 oB onNext b4 oB onNext b5 oB onNext b6 oB onNext b7 never completes infinite stream for example we should receive nothing else despite oB continuing after oA completed inOrder verifyNoMoreInteractions I need to play more with the C# version before I finish the changes as fixing this unit test could be done in different ways and the most obvious one breaks other unit tests Branch with unit test at https github com benjchristensen RxJava commit 6921f729c76c9b6bc940e239d99181e93eba8406 Hello I ve ported my Zip implementation and it appears to be doing almost the expected behavior https github com akarnokd RxJava commit cd0a5e7ec27169816738f63547289102f2044639 0 at t 1016 1 at t 2016 2 at t 3017 complete at t 3017 The difference to Rx seems to be that it terminates right after the 3rd item whereas Rx NET after rejecting the 4th item of the second observable I believe this is fixed in https github com Netflix RxJava pull 510 thanks to @akarnokd Could merge have the same problem scala val o1 Observable interval 700 milliseconds o1 rx lang scala Observable Long rx lang scala Observable anon 9@5c6f6cb4 scala val o2 o1 merge Observable 1L 2L 3L o2 rx lang scala Observable Long rx lang scala Observable anon 9@3a4724b7 scala o2 subscribe t println s received t e println s exception e n println completed res0 rx lang scala Subscription rx lang scala Subscription anon 1@50c64d9 received 1 received 2 received 3 received 0 from this point on the messages appear slow received 1 received 2 received 3 received 4 received 5 received 6 received 7',RxJava,false,false,false
19606472,'Program using interval and take does not terminate','When I run the following snippet java static Action1 Long onNextFunc final String who return new Action1 Long public void call Long x System out println who got x static Action1 Throwable onErrorFunc final String who return new Action1 Throwable public void call Throwable t t printStackTrace static Action0 onCompleteFunc final String who return new Action0 public void call System out println who complete public static void main String args Observable Long oneNumberPerSecond Observable interval 1 TimeUnit SECONDS take 5 oneNumberPerSecond subscribe onNextFunc subscriber 1 onErrorFunc subscriber 1 onCompleteFunc subscriber 1 then I get as expected the following output subscriber 1 got 0 subscriber 1 got 1 subscriber 1 got 2 subscriber 1 got 3 subscriber 1 got 4 subscriber 1 complete However the program does not terminate and that s unexpected I ran this test using rxjava core 0 13 2 SNAPSHOT jar built from commit 00d7c3b009053e6d5472f8bcb438e268a3d3c70b Sat Sep 14 08 37 09 2013 0700 Due to this problem some tests in the RxScalaDemo https github com samuelgruetter RxJava blob idiomaticscala language adaptors rxjava scala src main scala rx lang scala examples RxScalaDemo scala that I m working on do not terminate which is annoying','Just replicated it taking a look to see if I can find the cause The OperationInterval class was creating a new ExecutorService on every invocation and that is never shut down and launches non daemon threads java Schedulers executor Executors newSingleThreadScheduledExecutor Changing that the demo code now doesn t even run as the app quits immediately as it s all async as it should I revised the example to use BlockingObservable for the demo this and unit tests are where I generally use BlockingObservable and it runs then exits nicely java public static void main String args Observable Long oneNumberPerSecond Observable interval 1 TimeUnit SECONDS take 5 oneNumberPerSecond toBlockingObservable forEach onNextFunc subscriber 1 I ll submit a fix shortly Thanks now it behaves as I d expect but the example I d like to get to work still doesn t because of problems with groupBy https github com Netflix RxJava pull 289#issuecomment 24738668',RxJava,false,false,false
19619989,'Scala Adaptor Improvements','Includes groupBy scala README examples moving ImplicitFunctionConversions out of internal package multicast publish replay and methods for BlockingObservable Note that the commit https github com samuelgruetter RxJava commit ac26e42d1e85deac0b7bfa50c3ca3e5298493dd4 modifies core by making the Java Subject T R used as contravariant in T and covariant in R which allows me to write Scala s multicast without typecasting','RxJava pull requests #287 https netflixoss ci cloudbees com job RxJava pull requests 287 ABORTED Looks good to me unit test pass on my machine',RxJava,true,false,false
19662322,'Implemented the elementAt and elementAtOrDefault operators see #41','Hi This implements the ElementAt and ElementAtOrDefault operators from #41 For ElementAt if the index is less than 0 or greater than or equal to the number of elements in the source sequence an IndexOutOfBoundsException will be threw For ElementAtOrDefault if the index is less than 0 an IndexOutOfBoundsException will be threw What s more I added a defaultValue parameter I can not get the element type in the source observable due to type erasure So I can not determine the default value automatically That s why ElementAtOrDefault needs a defaultValue parameter','RxJava pull requests #288 https netflixoss ci cloudbees com job RxJava pull requests 288 SUCCESS This pull request looks good Thank you @zsxwing',RxJava,true,false,false
19666615,'remove scalatest packages from OSGI imports','','RxJava pull requests #290 https netflixoss ci cloudbees com job RxJava pull requests 290 FAILURE Looks like there s a problem with this pull request another instance of issue https github com Netflix RxJava issues 383 Thanks @brad uk',RxJava,true,false,false
19667778,'Add a way to stop an Observable executed in another thread','Function may take time to be executed This work can be realised on another thread as showed in this post from @mttkay blog http mttkay github io blog 2013 08 25 functional reactive programming on android with rxjava In particular this snipset let the work be done on a different thread that the main one java subscription downloadFileObservable subscribeOn Schedulers newThread observeOn AndroidSchedulers mainThread subscribe this However if we stop the activity and unsubscribe the observable before exiting the obsevable or the function mapped will finish try to send its work somewhere and notice there is no one to take care of it Then it will make the entire application crash If we had a way to stop a work before it finished we would be able to manage many more asynctask cases May be this is going to be released soon from the same blog entry For instance we use a custom Observer which makes guarantees that callbacks to fragments only happen whenever the fragment is attached and the Activity is alive thus making your own code more reliable If not it should Regards An idea of solution I think it may be possible to use the Subscription object returned by an observable to add the needed code to stop the work in the unsubscribe method But I don t have any idea how to reach the Thread Scheduler class has no method to stop the created thread or to reach it where the observable is executed','if we stop the activity and unsubscribe the observable before exiting the obsevable or the function mapped will finish try to send its work somewhere I would argue that if it tries to emit items even though you unsubscribed your subscription function is broken You as the developer need to ensure that the subscription s unsubscribe method acts appropriately in the context of your observable The safe observer we wrote mitigates this and removes some of the burden involved in littering your code with calls to isUnsubscribed by keeping a weak reference to the fragment and not firing the callback if it has been detached meanwhile Hi matthias Thank you for answering I am very new to Rx thing so may be I don t get obvious things When I call unsubscribe method on the subscriber object I stop my activity from listening but I don t stop the observable from working am I right The subscriber object returned from the observable is the one obtained with the factory Observers Empty I am writing from my phone so may be the names are not exacts To reach this purpose I need to have something to stop the work inside the unsubscribe method am I true I saw an example on the Rx wiki which call interrupt method on the thread where the work is done inside rhetoric observable But if I use the Android scheduler provided in the Android project then I can t reach the thread where the work is done I am wondering if I am doing something really wrong Another related question say I am working on a list so I create the observable using the factory method from list Then I map my functions on it Even if I insert a kind of system to stop the current work it will then jump to the next item of the observable And so another work will start The wiki is full of explanation about how the observable works and can be filtered transformed but there is not so many thing about basic things The wiki is full of explanation about how the observable works and can be filtered transformed but there is not so many thing about basic things What basic things are you referring to that you would like to see on the wiki @benjchristensen I am thinking to things related of how to create an Observable In the wiki methods are listed from create but the subscription part is missing In particular it took me time to realize that onCompleted is not call if you use Observable create method I ve found the reason on StackO http stackoverflow com questions 13561842 rx for net when calling observer oncompleted from within disposable create no I am still wondering what to put in Subscription object that I return in my Observable because it seems the method unsubscribe is never called too May be I need to only use Subscriptions empty method only I unsubscribe after the end of the process probably the reason why it s not called Moreover I find some part a bit misleading there are Scheduler to manage async call but on the Wiki https github com Netflix RxJava wiki How To Use#asynchronous observable one example use a thread to manage it Again I am still a newbee in the Rx technology In my first tries I really used Rx as a new way to manage thread Now I have a better understanding of how it works was not difficult compared to a 0 level but I have still many questions Listing all the methods to build a flow is cool but some words about how it works inside just to let the user put its code where he has to put it would be nice too However may be I am missing obvious documentation @mttkay Hi would it be possible for you to share a simple snipset write a short blog entry about your custom Observer just to give an idea of what you did Regarrds @benjchristensen regarding the Wiki I have spent lots of time on website dedicated to Rx for C# to learn about this technology I think in general one important thing is missing real examples I know each important method has its own example but some more general example are still missing showing simple cases using several method It has not to be super complex for the love of complexity but real cases showing what is possible to do I really enjoy to read and play with this technology I am still at a beginner level but I know enough to understand how powerful it is To get at this point I had to Google a lots of things I have some time right now so that s Ok for me But to reach a new audience of busy programmers knowing nothing about reactive programming putting all example in the same Wiki just to give an idea what kind of problem this technology solves would help And I am sure more people using RxJava means more improvements And by the way some Java code would be nice too I mean I can read C# Scala or whatever but Java is the language I use and most people too Thank you anyway for all the work you your company other companies have put in this work that s really awesome Long time I have not seen something interesting like that Regards I agree that there are not yet enough Rx examples in Java and for the other JVM languages but hey RxJava is still being created you re joining the adventure not consuming a finished product However for C# there are great resources to learn Rx such as introtorx http www introtorx com and the Rx Workshop Videos http channel9 msdn com Series Rx Workshop For RxJava this does not yet exist IMHO the only way to learn RxJava now is to start with C# and to try to translate C# examples to Java If you do so please publish your examples somewhere so that for other people it will be easier to learn RxJava than it was for you You can find my few little examples here https github com samuelgruetter rx playground blob master README md but they re mostly in Scala @pommedeterresautee Is this issue considered resolved Should there be any further actions other than more code examples out of this For me it s ik',RxJava,false,true,false
19731566,'Parallel Operator ObserveOn ScheduledObserver Fixes','#### Parallel Operator This operator came out of discussions and work with @headinthebox to allow explicit and composable declaration of blocks of work that can be scheduled for parallel execution An Observable event stream will be sharded using groupBy using a value from Scheduler degreeOfParallelism defaulting to number of CPU cores and perform the defined work in parallel Instead of having various parallel operators like parallelMap parallelFilter parallelScan etc this can work generically for any operators or sequence of operators #### Fix ObserveOn NewThreadScheduler and ScheduledObserver bugs @headinthebox and I were working on some code and found differences in behavior between Rx Net and RxJava with observeOn This commit should fix that','RxJava pull requests #291 https netflixoss ci cloudbees com job RxJava pull requests 291 SUCCESS This pull request looks good RxJava pull requests #292 https netflixoss ci cloudbees com job RxJava pull requests 292 SUCCESS This pull request looks good',RxJava,true,false,false
19731846,'Change Interval and Sample default Scheduler','Change to use built in thread pools rather than creating a new Executor on each invocation The built in ones are shared across all operators have threads ready are marked as daemon threads so don t prevent system shutdown and are named for clarity when looking at thread dumps and debuggers This fixes https github com Netflix RxJava issues 388','RxJava pull requests #293 https netflixoss ci cloudbees com job RxJava pull requests 293 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
19803340,'java util Comparator is not suitable for distinct and distinctUntilChanged','In C# distinct and distinctUntilChanged take an IEqualityComparer which provides Equals and GetHashCode That s not the same as java util Comparator which provides compare Or mathematically speaking There are two kinds of comparators Those which define a total ordering java util Comparator and C# s IComparer Those which define an equivalence relation C# s IEqualityComparer RxJava s Func2 T T Boolean and unfortunately no standard Java interface The problem is that for distinct and distinctUntilChanged we re not interested in an order on the elements but only in equality So it would be better to use Func2 super T super T Boolean equality just like sequenceEqual instead of Comparator U equalityComparator','The Func2 sounds fine unless getHashCode is necessary to make distinct fast In that case I think making our own EqualComparator T would be the way to go A Comparator returning 0 means the two items are equal thus it will work for this use case java int compare T o1 T o2 http docs oracle com javase 6 docs api java util Comparator html#compare T 20T returns a negative integer __zero__ or a positive integer as the first argument is less than __equal to__ or greater than the second Moving to EqualityComparator would limit the return type to boolean as opposed to 1 0 1 as possible return types but Comparator can represent equality as well and both approaches let the developer define equality using object reference equals hashCode deep comparison etc instead of automatically using just the equals method Supporting Comparator and Comparable object types makes it so people can just reuse the same logic as used for ordering Checking for equality is simpler than checking for ordering binary instead of trinary response but if the Comparator returns 0 it means the objects are equal So if we re not going to use Comparator it should be because we want a simpler return type not because it doesn t work That said I can t remember ever seeing something other than Comparator used for this type of behavior in a Java library because if not using Comparator then the library can just call equals on each Object Why would something else be needed For example the Set implementations in Java ensure uniqueness and they use the Object equals method on objects to determine equality Why would we need to do anything different than the Java collections libraries that use either equals or Comparator A Comparator per javadoc is a comparison function which imposes a total ordering on some collection of objects We don t actually need the total ordering for our purposes in distinct or distinctUntil only the fact that it incidentally defines equality as well But still if someone defines a Comparator for equality not making it define a total ordering he or she is basically misusing it As an aside Comparator s that are inconsistent with equals are dangerous beasts It s way too easy to use them for collections like TreeSet which simply won t work in that case Also at least for distinct there is indeed an efficiency problem when mis using Comparator as we do now There is no way to create an efficient set without either a total ordering or some kind of hash code All the Set implementations in Java always depend on at least one of these two concepts afaik Imho for doing this right we actually need a real Java equivalent to IEqualityComparer which defines both the concepts of equality and a hash code Or we could leave that whole thing out of the API and make people write their own wrapper classes for that use case which is not very convenient of course The compare method on a Comparator can use hashcode and equals just the same as a new interface would allow but I accept that having a trinary response is confusing when only a binary boolean is needed My vote is for Func2 super T super T Boolean not creating a new special type for this very limited use case The compare implementation can of course use whatever it likes internally However our code can t ever get a hashCode from a Comparator It could get one from a new interface and use it to make distinct efficient for example I agree though that it s probably a very limited use case So I m ok with Func2 too Or maybe distinctUntilChanged taking a Func2 super T super T Boolean and no custom comparison for distinct to keep it simple use it to make distinct efficient for example This is a valid concern iterating the entire list is not good though with a Comparator we could maintain a sorted list and do a binary search Another consideration for API design an interface with 2 methods like IEqualityComparer can not be implemented by lambdas as it is not a functional interface with a single method lambda body Is this use case and performance issue strong enough to have a non functional interface that requires an anonymous inner class to implement two methods Also implementing hashCode is far more obnoxious than implementing equals For performance reasons and avoiding hashCode implementations would Comparator having ordering in mind actually be the right choice so we can test for equality using a binary search algorithm How about this change to use TreeSet and Comparator and not require iterating the full list java final Subscription sourceSub source subscribe new Observer T use TreeSet instead of ArrayList private final TreeSet U emittedKeys new TreeSet U equalityComparator @Override public void onCompleted observer onCompleted @Override public void onError Throwable e observer onError e @Override public void onNext T next U nextKey keySelector call next if emittedKeys add nextKey observer onNext next Unit Test java @Test public void testDistinctOfObjectWithComparator Observer super RandomObject observer mock Observer class RandomObject r1 new RandomObject 1 one RandomObject r2 new RandomObject 2 two RandomObject r2b new RandomObject 2 twoB Observable RandomObject src from r1 r1 r2 r1 r2 r2b create distinct src new Comparator RandomObject @Override public int compare RandomObject o1 RandomObject o2 int i o1 i o2 i if i 0 return i return o1 v compareTo o2 v subscribe observer InOrder inOrder inOrder observer inOrder verify observer times 1 onNext r1 inOrder verify observer times 1 onNext r2 inOrder verify observer times 1 onNext r2b inOrder verify observer times 1 onCompleted verify observer never onError any Throwable class inOrder verifyNoMoreInteractions For TreeSet to work as expected the Comparator has to be consistent with equals and in that case we don t even need it in the first place It s not correct in Java to implement equals without implementing hashCode too This method java util Objects hash Object makes computing hash codes much easier @jmhofer Yes if it s not consistent with equals it won t work but if they have equals they don t need to use Comparator and why would they make them be different @abersnaze Yes it does but I d like to avoid an API that requires developers to do that and know about some obscure API if we don t need it Question about using IEqualityComparer would it need to calculate the hashCode every time the object is touched since it can t cache it as it doesn t know if mutation has occurred in an object If the observable objects already have an equals hashCode implementation then the distinct call without any additional parameters will do Afaik the additional distinct signature using an explicit IEqualityComparer in Rx NET is for cases where you want to use a different equals from the default one for distinguishing between the observable objects Java doesn t really support the concept of multiple equivalence relations per class It would need something like the IEqualityComparer in its standard library for that at least and probably support that interface in the collections library too This was the reason why I initially left away the implementation for that specific distinct signature I still don t think it s much of a use case My current implementation is a bit inconsistent It takes a Comparator but doesn t care for or use the total ordering that should be defined by that Comparator It just uses the equivalence relation defined by it and has to live without being able to compute hash codes The more I think about it the more I agree with @samuelgruetter that the Comparator is a bad choice for this distinct has no need to impose a total ordering It just needs an equivalence relation Given a total ordering we could make distinct efficient of course without using hash codes just not via the Java default set implementations But I don t see much value in that It s also something completely different from what Rx NET does here So basically I m for using a simple Func2 for distinctUntilChanged and maybe leaving that away from distinct due to efficiency If we created an interface like IEqualityComparer we d have to impose the same restrictions and contracts on its equals and hashCode methods as Object does Mutable fields used in hash code computations break the standard Java collection implementations based on hash codes Therefore I see no strong need to make distinct work with that special case either We ended up removing Comparator for these operators so closing',RxJava,false,false,false
19827313,'Add missing methods to Scala Adaptor','This pull request adds a method to the Scala Observable for each method in the Java Observable Some were renamed have a different signature or were left out intentionally A comparison can be found here https github com samuelgruetter rx playground wiki Comparison of Scala Observable and Java Observable The Scala Observable should now be complete but there are still some TODOs https github com samuelgruetter RxJava blob a2ab731ce1a867e1a2902c27062bcea2923ef303 language adaptors rxjava scala TODO md There should be no breaking changes but only additions There s also an automatic completeness test rx lang scala CompletenessTest If methods are missing it still succeeds but it prints the missing methods to stdout','RxJava pull requests #294 https netflixoss ci cloudbees com job RxJava pull requests 294 ABORTED So Jenkins needs all the 10 minutes to download scala compiler 2 10 3 RC2 jar D',RxJava,true,false,false
19852619,'Observable API for Apache HttpAsyncClient 4 0','This is still experimental I have not used it for any significant load or production traffic','RxJava pull requests #296 https netflixoss ci cloudbees com job RxJava pull requests 296 SUCCESS This pull request looks good',RxJava,true,false,false
19862501,'Merge any Pull Request','Merges pull https github com Netflix RxJava pull 385 I changed any to isEmpty and exists as I agree with @samuelgruetter comment at https github com Netflix RxJava pull 385#issuecomment 24568332 These names feel more idiomatic to Java languages','RxJava pull requests #297 https netflixoss ci cloudbees com job RxJava pull requests 297 ABORTED',RxJava,true,false,false
19862627,'Merge Pull #390 elementAt','Merge pull https github com Netflix RxJava pull 390','RxJava pull requests #298 https netflixoss ci cloudbees com job RxJava pull requests 298 ABORTED',RxJava,true,false,false
19863126,'Removing comparator overloads of distinct','Removing these fairly recently added overloads as they turn out to not be the best approach Discussion ongoing as to how to implement them at https github com Netflix RxJava issues 395','RxJava pull requests #299 https netflixoss ci cloudbees com job RxJava pull requests 299 ABORTED',RxJava,true,false,false
19866931,'Implemented the DefaultIfEmpty operator See #34','Hi This implements the DefaultIfEmpty operator from #34 There are two variants However I can not get the element type in the source observable due to type erasure So I only implemented the variant with a default value http msdn microsoft com en us library hh229624 v vs 103 aspx Please take a look Thanks','RxJava pull requests #300 https netflixoss ci cloudbees com job RxJava pull requests 300 ABORTED RxJava pull requests #302 https netflixoss ci cloudbees com job RxJava pull requests 302 ABORTED Thank you',RxJava,true,false,false
19867867,'Fixes to rxjava apache http','made Content Type inspection more reliable other small improvments','RxJava pull requests #301 https netflixoss ci cloudbees com job RxJava pull requests 301 ABORTED',RxJava,true,false,false
19889351,'Implemented the cast and ofType operators','Hi I used map to implement the cast operator #26 I also used cast to implement the ofType operator #67 Please take a look Thanks','Also this needs a unit test Thanks for contributing RxJava pull requests #303 https netflixoss ci cloudbees com job RxJava pull requests 303 ABORTED Thanks I added the klass parameter and unit tests RxJava pull requests #304 https netflixoss ci cloudbees com job RxJava pull requests 304 ABORTED RxJava pull requests #305 https netflixoss ci cloudbees com job RxJava pull requests 305 ABORTED RxJava pull requests #306 https netflixoss ci cloudbees com job RxJava pull requests 306 ABORTED RxJava pull requests #307 https netflixoss ci cloudbees com job RxJava pull requests 307 ABORTED RxJava pull requests #308 https netflixoss ci cloudbees com job RxJava pull requests 308 ABORTED Thank you @zsxwing for the contribution and @daveray for the review Looks good so merging',RxJava,true,false,false
19919644,'Add fromChangeEvents methods to SwingObservable','For swing components which fire ChangeEvent s I added a method SwingObservable fromChangeEvents similar to the other methods of SwingObservable Unfortunately there is no common base interface for all components which fire ChangeEvents s so I created one myself ChangeEventSource ChangeEventComponentWrapper Then each component which fires ChangeEvents s needs its own overload in SwingObservable An other approach would be to use reflection but then we loose typesafety','RxJava pull requests #309 https netflixoss ci cloudbees com job RxJava pull requests 309 ABORTED Before merging this we should also try a solution with reflection and then decide which one is better @jmhofer Can you comment on this as well since you were involved in the first submission of rxjava swing Looks good to me Will all these overloads work with dynamic languages though I wouldn t want to switch to reflection for this even if it s a bit ugly doing all this by hand I think we should at least try a solution with reflection because this would also work with custom components which have addChangeListener and removeChangeListener methods With reflection we lose typesafety but C# also uses reflection when I call something like cs Observable FromEventPattern EventArgs myTextFieldComponent TextChanged see http msdn microsoft com en us library hh229424 v vs 103 aspx I m always very sceptical when it comes to anything to do with reflection but I see your point If I understand you right you want to simulate a Scala structural type here correct This could very well be worth it RxJava pull requests #318 https netflixoss ci cloudbees com job RxJava pull requests 318 FAILURE Looks like there s a problem with this pull request For testing the negative maybe send a mock Observer and then verify obr times 1 onNext sentEvent This is a very long discussion is this ready for final review and merge @abersnaze Is this ready to merge I ve added some more commits just to avoid duplicate work but IMHO this is not yet ready for merge RxJava pull requests #340 https netflixoss ci cloudbees com job RxJava pull requests 340 SUCCESS This pull request looks good Is this waiting on people s time or is there something fundamental still to decide upon Last comment 20 days ago was that this is still not ready to merge so where is this going I think the current reflection based approach is good but the unit tests need to be rewritten from scratch and it might also need some polishing I don t have time now but if no one does it until December I will do it then Closing if any of you want to revive at some point please send another request Closing if any of you want to revive at some point please send another request',RxJava,true,false,false
19920058,combineWithMostRecent,'I m looking for an operation which does the following Whenever Observable o1 emits an item combine this item with the most recent item of Observable o2 Illustration A B C o1 0 1 2 3 4 o2 V V V A 0 B 2 C 4 I can t find a nice way of doing this Can anyone help me Or do we need to add a new operation to rx Observable','Actually combineLatest together with distinctUntilChanged with equality based on the tuple projection would work here I think Maybe there s an easier way but this is what first came to my mind But what if o1 emits two equal items in sequence If that is part of your problem we re discussing the distinct operator here https github com Netflix RxJava issues 395#issuecomment 24858966 Maybe this is a Join use case I found a description here http www introtorx com content v1 0 10621 0 17_SequencesOfCoincidence html Join is hardly ever used and the semantics are subtle and because of all the functions you need to pass pretty nasty if you don t have groupBy query comprehension syntax But implementing it would be a fun task for anyone that wants to dig down to the next level of detail Watch http channel9 msdn com Series Rx Workshop Rx Workshop 7 Reactive Coincidence first On Sep 24 2013 at 7 32 AM Joachim Hofer notifications@github com wrote Maybe this is a Join use case I found a description here Reply to this email directly or view it on GitHub This means that maybe it s a good idea to add combineWithMostRecent as described by @samuelgruetter as an operator To me it sounds like a relatively frequent use case I have similar problem came up with public static T U R Observable R enrich Observable T source Observable U data Func2 T U R f return Observable zip source data sample source f but noticed sample doesn t really sample input it doesn t emit last value multiple times when no change occured between timer causing zip operation to get out of sync Isn t that a bug or at least serious documentation problem with sample marcin I agree that s inconsistent sample long TimeUnit emits the last value multiple times if the source observable didn t emit a new value between two ticks but sample Observable U does not repeat it and this line https github com Netflix RxJava blob 019aa93a39db36019033d18f23a78b331f5cd445 rxjava core src main java rx operators OperationSample java#L182 suggests it was done on purpose But I think sample Observable U should be changed to match the behavior of sample long TimeUnit How about this groovy Observable combineLatest a b x y x y distinctUntilChanged tuple tuple 0 distinctUntilChanged tuple tuple 1 toBlockingObservable forEach v println v Regarding issue1 How to get combineWithMostRecent enrich behavior What if the source Observable a emits two equal values in succession We still want to see this in the resulting Observable so we can t use an approach with distinctUntilChanged Regarding issue2 Is the behavior of sample Observable U correct @benjchristensen what do you think The sample operator was fixed in v0 18 2',RxJava,false,false,false
19929461,'master fails to build due to a classworlds artifact not found','gradlew build Artifact classworlds classworlds 1 1 alpha 2@jar not found','That s an odd error and not one happening for the CI builds I have seen something similar before on my machine but with a different jar Could not resolve all dependencies for configuration rxjava contrib rxjava android provided Artifact commons codec commons codec 1 3@jar not found So there is indeed something weird going on but not deterministic and not affecting our build servers internal at Netflix nor CloudBees I ll post again if I learn more I had this too Clearing the Maven cache fixes it Sound like this http stackoverflow com questions 11001954 suddenly could not resolve all dependencies org apache jamesapache mime4j0 Some kind of Gradle Maven interop problem it seems I had the same problem too and clearing the maven cache fixed it for me thank you @jmhofer Yep clearing m2 repository away and building again solves this A On Sep 23 2013 at 7 58 PM Ben Christensen notifications@github com wrote That s an odd error and not one happening for the CI builds I have seen something similar before on my machine but with a different jar Could not resolve all dependencies for configuration rxjava contrib rxjava android provided Artifact commons codec commons codec 1 3@jar not found So there is indeed something weird going on but not deterministic and not affecting our build servers internal at Netflix nor CloudBees I ll post again if I learn more Reply to this email directly or view it on GitHub Yep I had this problem with a different dependency which was actually in my m2 repository Could not resolve all dependencies for configuration rxjava core provided Artifact org objenesis objenesis 1 0@jar not found Deleting the m2 repository org objenesis directory and rerunning gradlew clean build resolved it too',RxJava,false,false,false
19971087,'Implemented RefCount Operator','Please note that I placed the unit tests under the test root rather than inline with the implementation as has been done for other operators This is due to a bug in IDEA that prohibits running unit tests in folders designated as source rather than test I can see that a bunch of other operators follow this convention so hopefully that s okay','RxJava pull requests #310 https netflixoss ci cloudbees com job RxJava pull requests 310 ABORTED I notice this was aborted due to a timeout in the Scala language adaptors tests I didn t make any changes in this area so am guessing there s an intermittent bug somewhere RxJava pull requests #311 https netflixoss ci cloudbees com job RxJava pull requests 311 ABORTED The problem with the Scala tests should be fixed by https github com Netflix RxJava pull 408 but that only saves 48 seconds There must be also another problem with the cloudbees pull request builder Hopefully the builds should improve now I ve changed the CloudBees config to allow twice as much time Thank you for implementing refCount it s been one I ve wanted for a while but haven t had time to do Will review it and merge as soon as I can RxJava pull requests #314 https netflixoss ci cloudbees com job RxJava pull requests 314 ABORTED Thanks @johnhmarks for submitting this',RxJava,true,false,false
19996169,'Do not run RxScalaDemo on each build','On my last pull request I forgot to uncomment the line which ignores RxScalaDemo so currently it is executed on each build even though it does no automatic testing And since RxScalaDemo takes about 48 seconds this significantly increases build time Sorry for this After this change the complete build took 3 mins 33 932 secs on my 3 years old laptop so if cloudbees can t build it in 10 min there might be something else not properly working','RxJava pull requests #312 https netflixoss ci cloudbees com job RxJava pull requests 312 ABORTED So this time it was ABORTED because scala is too big and their internet connection is too slow Download http repo1 maven org maven2 org scala lang scala library 2 10 3 RC3 scala library 2 10 3 RC3 pom Download http repo1 maven org maven2 org scala lang scala library 2 10 3 RC3 scala library 2 10 3 RC3 jar Download http repo1 maven org maven2 org scala lang scala compiler 2 10 3 RC3 scala compiler 2 10 3 RC3 pom Download http repo1 maven org maven2 org scala lang scala reflect 2 10 3 RC3 scala reflect 2 10 3 RC3 pom Download http repo1 maven org maven2 org scala lang scala compiler 2 10 3 RC3 scala compiler 2 10 3 RC3 jar Download http repo1 maven org maven2 org scala lang scala reflect 2 10 3 RC3 scala reflect 2 10 3 RC3 jar I just increased the timeout on the build from 20 to 40 minutes to see if it helps things CloudBees is not fast',RxJava,true,false,false
20020823,'Implemented Synchronize with lock','Hi I implemented #84 to support that sending a lock to the synchronize operator I also found that there was a issue that testMultiThreadedWithNPE and testMultiThreadedWithNPEinMiddle might fail in some special situation When onError is invoked before any onNext the last statement assertEquals 1 busyObserver maxConcurrentThreads get in these methods will fail I also fixed this issue in the pull request','RxJava pull requests #313 https netflixoss ci cloudbees com job RxJava pull requests 313 ABORTED Looks good thank you',RxJava,true,false,false
20096283,'Implemented the Contains operator','Hi I implemented the Contains operator #31 I saw the discussion about the distinct operator #395 so I did not implement the comparator override Please take a look Thanks','RxJava pull requests #315 https netflixoss ci cloudbees com job RxJava pull requests 315 SUCCESS This pull request looks good RxJava pull requests #316 https netflixoss ci cloudbees com job RxJava pull requests 316 SUCCESS This pull request looks good @cloudbees pull request builder glad to see you work again @zsxwing Nice I also think that we don t need an overload with a comparator because one can simply use exists instead java o exists new Func1 T Boolean public Boolean call T a check if a is equal to the desired element using custom comparison strategy',RxJava,true,false,false
20110885,'update counter before triggering latch','as mentioned in #383 rx concurrency TestSchedulers testSchedulingWithDueTime is flaky because there is a race condition where the test can assert the counter value before it is updated fix is just to update the counter before releasing the latch','RxJava pull requests #317 https netflixoss ci cloudbees com job RxJava pull requests 317 SUCCESS This pull request looks good Thank you',RxJava,true,false,false
20172538,BufferingObserver,'We sometimes find that we want to hold on to items emitted by an observable before forwarding them to the final destination We therefore came up with a naive implementation of a BufferingObserver which acts as a decorator and can be thought of as a reactive array buffer It waits for onCompleted then flushes all items to a delegate observer One would then subclass BufferingObserver to provide extra behaviour before emitting the result This is different from OperationBuffer or OperationToList in that we do not consider this part of the event stream and it might even cause side effects on e g UI components so we did not want this to be executed as part of an observable sequence We use it purely to orchestrate UI callbacks like checking a result set before emitting it to a different observer that then updates the UI in some way shape or form We will probably have this in an upcoming PR for the android submodule but wanted to check if anyone thinks this might make sense to have in the core library Otherwise feel free to just close this','I m not sure I understand we did not want this to be executed as part of an observable sequence How is it executed then How does this compare to the ReplaySubject or toList mapMany list Observable from list By that I mean it s not supposed to be a transformation of the underlying observable but rather something that is specific to one of N observers on the listener side It s used as a means to decorate one of potentially many UI observers in our case and observers deriving from it actually manipulate view objects i e mutate state In other words I neither want the observable sequence to get collapsed into a list since other observers might still operate on individual elements nor do I want side effecting operations be executed as a transformation of the sequence Here s some dummy code showing how we use it ConnectableObservable observable serviceCall publish observable subscribe observer1 consumes an item directly observable subscribe new CustomBufferingObserver observer2 observable connect the custom buffering observer would cache the results perform some other UI related task then emit the results I can t transform the sequence itself since otherwise observer1 would have to be rewritten to take a list of T instead of T which is not what I want Let me know if that still doesn t make sense to you I might simply be missing something The toList mapMany combo can be localized to just one of the subscription calls ConnectableObservable observable serviceCall publish observable subscribe observer1 consumes an item directly observable toList mapMany list Observable from list subscribe observer2 observable connect I m confused Does line 3 actually do anything The observable is transformed into 2 different observables that are not connectable observables anymore So the call to subscribe on line 3 will fire immediately instead of connecting the observer to the published stream The toList mapMany combo is chained off the connected observable it can not bypass it The toList buffers all the items and the mapMany unwraps Observable List T again back to an Observable T so the following subscribe is in the wiser Interesting I shall try that instead thanks',RxJava,false,false,false
20222842,'Fixed the issues of takeLast items 0 and null values','Hi There are two issues about takeLast #85 #140 The essential cause is LinkedBlockingDeque 1 count 0 takeLast in RxJava will throw an exception when count 0 as LinkedBlockingDeque rejects count 0 However in c# TakeLast with 0 count is valid The following codes is OK in C# no exception and do nothing c# var source Observable Return 1 TakeLast 0 source Subscribe x Console WriteLine subscriber got x Console ReadLine 2 null values LinkedBlockingDeque requires the elements can not be null but an observable can emit a null value I used ReentrantLock and LinkedList to replace LinkedBlockingDeque Please take a look Thanks','RxJava pull requests #319 https netflixoss ci cloudbees com job RxJava pull requests 319 SUCCESS This pull request looks good RxJava pull requests #321 https netflixoss ci cloudbees com job RxJava pull requests 321 SUCCESS This pull request looks good Merging as this seems correct but I question whether we need any of this synchronization in here since this operator would never be multi threaded It can count on the Rx contract to have sequential onNext events Thus I wonder if the performance hit of all this synchronization is a concern or necessary I m favoring functionality and merging now but something to consider for the future',RxJava,true,false,false
20225287,'Implemented the SkipLast operator','Hi I implemented the skipLast operator #78 I used ReentrantLock and LinkedList to implement it rather than LinkedBlockingDeque like takeLast #85 #140 for two reasons LinkedBlockingDeque requires that count is greater than 0 but skipLast can accept 0 LinkedBlockingDeque requires the elements can not be null but an observable can emit a null value In summary LinkedBlockingDeque will cause issues like #413 Please take a look Thanks','RxJava pull requests #320 https netflixoss ci cloudbees com job RxJava pull requests 320 SUCCESS This pull request looks good RxJava pull requests #322 https netflixoss ci cloudbees com job RxJava pull requests 322 SUCCESS This pull request looks good RxJava pull requests #326 https netflixoss ci cloudbees com job RxJava pull requests 326 FAILURE Looks like there s a problem with this pull request another instance of https github com Netflix RxJava issues 383 In addition though ArrayDeque is more efficient than LinkedList it also rejects null values I prefer to an array implementation of Deque since it can avoid to create Entry objects But now I can not find any appropriate class Is there any better class I m not aware of anything better than LinkedList for what you re doing here The only consideration I have is whether we actually need all of the synchronization as this operator will not interact with multiple threads and should be able to assume thread safety due to the Rx contract Merging as it is functional but I d be interested in a followup exploration of performance benefits of removing the synchronization and confirming whether my thoughts on the matter are correct',RxJava,true,false,false
20241759,'Implemented the Empty operator with scheduler','Hi I implemented the Empty operator with scheduler #42 Please take a look Thanks','RxJava pull requests #323 https netflixoss ci cloudbees com job RxJava pull requests 323 SUCCESS This pull request looks good RxJava pull requests #325 https netflixoss ci cloudbees com job RxJava pull requests 325 SUCCESS This pull request looks good',RxJava,true,false,false
20244803,'Implemented the Throw operator with scheduler','Hi I implemented the Throw operator #89 with scheduler I found that RxJava had an error method So I just implemented the scheduler overload','RxJava pull requests #324 https netflixoss ci cloudbees com job RxJava pull requests 324 SUCCESS This pull request looks good @benjchristensen I agree with you I updated the codes and rebased it to master RxJava pull requests #338 https netflixoss ci cloudbees com job RxJava pull requests 338 SUCCESS This pull request looks good',RxJava,true,false,false
20294742,'Exception not properly propagated','Given java static Func1 Integer Integer f new Func1 Integer Integer public Integer call Integer arg0 throw new RuntimeException the error in f when I run this java public static void main String args System out println started System out println Observable from 1 map f toBlockingObservable single System out println done I get as expected this output started Exception in thread main java lang RuntimeException the error in f at RxJavaHelloWorld 2 call RxJavaHelloWorld java 226 at blah blah at RxJavaHelloWorld main RxJavaHelloWorld java 240 However when I observe it on a different thread java public static void main String args System out println started System out println Observable from 1 observeOn Schedulers threadPoolForComputation map f toBlockingObservable single System out println done then the output is this started and the application does not terminate But I would expect that no matter on what thread I observe errors are always propagated','Here the error occurs even without observeOn java System out println Observable from 1 2 3 take 1 map f toBlockingObservable single This snippet also makes the app never terminate This prevents me from implementing the head https github com samuelgruetter RxJava blob 2654f60e05a24fc910f73284e32290403d5bffcf language adaptors rxjava scala src main scala rx lang scala Observable scala#L1565 operation in the Scala adaptor and the original one with observeOn prevents me from implementing a nice constructor https github com samuelgruetter RxJava blob 2654f60e05a24fc910f73284e32290403d5bffcf language adaptors rxjava scala src main scala rx lang scala package scala#L141 Here the error occurs even without observeOn System out println Observable from 1 2 3 take 1 map f toBlockingObservable single This snippet also makes the app never terminate For take 1 after the observer receives a value any later value or error will be ignored even if onNext the first value throws an exception public static void main String args System out println started System out println Observable from 1 map f toBlockingObservable single System out println done This issue is because rx operators ScheduledObserver EventLoop does not handle the exception threw from the onNext method of a observer The related codes java switch notification getKind case OnNext underlying onNext notification getValue break case OnError underlying onError notification getThrowable break case OnCompleted underlying onCompleted break default throw new IllegalStateException Unknown kind of notification notification @benjchristensen I encountered one problem which I had never realized before when I tried to solve this issue From the Observable s perspective it can guarantee that it calls onCompleted of an Observer after all onNext calls However from the Observer s perspective if onNext and onCompleted run in different threads some weird thing may happen For example an Observable calls onNext in thread t1 After 5ms it calls onCompleted in thread t2 If t1 is suspended at once after it enters the onNext method At this moment none statement in onNext is executed So now the Observer does not know its onNext has been invoked Suppose t1 is suspended in 100ms and t2 is not be suspended So the Observer will find that onCompleted is invoked first and after 95ms the onNext method is called I really think such case is weird for the Observer Could you point out where I misunderstood I read the article about concurrency in Rx http www introtorx com Content v1 0 10621 0 15_SchedulingAndThreading html But I m still confused Here are my problems Should an Observable call all onNext onCompleted and onError in the same thread if no scheduler is involved What s the contract when an Observable encounters a thread pool scheduler @benjchristensen one more question If an Observer throws an exception in onNext does its onError have to be called If so there may be complicated to fix the issue in rx operators ScheduledObserver EventLoop For example in @samuelgruetter s example java public static void main String args System out println started System out println Observable from 1 observeOn Schedulers threadPoolForComputation map f toBlockingObservable single System out println done EventLoop will receive two notifications onNext 1 and onCompleted However as they are out of order onCompleted may arrive first So the observer will be notified onCompleted Then when onNext 1 is called the observer will need to be notified onError as onNext throws an exception In such situation the onCompleted and onError will be both called I m trapped in here Due to onCompleted and onError concurrency in RxJava is different from Rx Net Is there an wiki page about concurrency in RxJava You should read the Rx Design Guidelines http blogs msdn com b rxteam archive 2010 10 28 rx design guidelines aspx Should an Observable call all onNext onCompleted and onError in the same thread if no scheduler is involved There is nothing requiring it be the same thread necessarily but it is required that it being sequential and synchronized so the Observer doesn t need to worry about memory visibility interleaving calls etc See section 6 7 and 6 8 of the design guidelines What s the contract when an Observable encounters a thread pool scheduler It s the same a Scheduler is for moving location and time but does not change the contract A single Observable must still be serialized Anything in RxJava doing differently is a bug and needs to be fixed We iterated several times on ObserveOn to get it to hopefully behave correctly so that each event it receives is put on an event loop and processed sequentially on whatever Scheduler it is given EventLoop will receive two notifications onNext 1 and onCompleted However as they are out of order onCompleted may arrive first If they are out of order then we still don t have ObserveOn working correctly and it s a bug Thanks for your help Rx Design Guidelines is really helpful Now this issue should be fixed in PR #453 and #441 It can be closed',RxJava,false,false,false
20357520,'Observable merge List Observable T removed','This method got removed in commit 59578815c3d4c8336192baeed3dfe6b7119a9b73 in favor of Observable merge Observable Observable T Both signatures with covariance removed When looking at our use cases it s fairly common for scripts to get a handle of a number of Observables and then stuff them into a list Then get a handle on the overall Observable by calling Observable merge on that list Is there a compelling reason why this method got removed','Because List T is just a buffered version of Observable T and it is repetitive for methods that accept Observable Observable T to also have an overload of List Observable T In other words it was part of the cleanup to reduce the surface area of the API You can go from List Observable T to Observable Observable T with Observable from list and this pattern works anywhere an Observable Observable T is accepted Thus it was deemed the cleaner way of managing the API instead of having one off overloads for conversions and just letting the from methods be the conversion points Another related method signature is this java zip Iterable extends Observable ws FuncN extends R zipFunction I m not really a fan of that signature as I think it should be Observable Observable but it still exists I m open to adding it back if it s truly different and common enough to not just use the from approach This argument makes sense to me I didn t see this method noted in any of the related commits and wanted to be 100 sure it was an intentional removal We ve worked around this removal already and as you suggested it was a very straightforward change Closing',RxJava,false,false,false
20381195,'Marble diagram improvements','Many thanks @DavidMGross for all these nice marble diagrams they re awesome Here are some suggestions for improvements interval starts at 0 not at 1 flatMap mapMany make clear that there s an underlying merge currently it looks as if the items of observable i 1 were only emitted once observable i has completed where filter it might be nicer if the predicate was a shape scan also show that if frequency of source observable is lower than sampling frequency elements are repeated zip it looks like this operator can fetch elements from the future Make the diagrams open source','Thanks for the feedback I ll make the adjustments you suggest The diagrams are already open source https raw github com wiki Netflix RxJava images rx operators graffle though they re in a proprietary format http www omnigroup com omnigraffle On Wed Oct 2 2013 at 1 43 AM samuelgruetter notifications@github com wrote Many thanks @DavidMGross https github com DavidMGross for all these nice marble diagrams they re awesome Here are some suggestions for improvements interval starts at 0 not at 1 flatMap mapMany make clear that there s an underlying merge currently it looks as if the items of observable i 1 were only emitted once observable i has completed where filter it might be nicer if the predicate was a shape scan also show that if frequency of source observable is lower than sampling frequency elements are repeated zip it looks like this operator can fetch elements from the future Make the diagrams open source Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 419 Could you clarify what you meant about scan and its sampling frequency Did you mean sample or one of the throttle s On Fri Oct 4 2013 at 11 33 AM David Gross davgross@netflix com wrote Thanks for the feedback I ll make the adjustments you suggest The diagrams are already open source https raw github com wiki Netflix RxJava images rx operators graffle though they re in a proprietary format http www omnigroup com omnigraffle On Wed Oct 2 2013 at 1 43 AM samuelgruetter notifications@github com wrote Many thanks @DavidMGross https github com DavidMGross for all these nice marble diagrams they re awesome Here are some suggestions for improvements interval starts at 0 not at 1 flatMap mapMany make clear that there s an underlying merge currently it looks as if the items of observable i 1 were only emitted once observable i has completed where filter it might be nicer if the predicate was a shape scan also show that if frequency of source observable is lower than sampling frequency elements are repeated zip it looks like this operator can fetch elements from the future Make the diagrams open source Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 419 oh yes I meant sample not scan Thank you @DavidMGross for fixing these in https github com Netflix RxJava pull 527',RxJava,false,false,false
20394059,'Scala Adaptor','Here are more improvements to the Scala adaptor mostly changes in classes other than rx lang scala Observable itself as well as scaladoc for all classes And the MovieLib example is now part of the rxjava scala project instead of being a seperate project','RxJava pull requests #327 https netflixoss ci cloudbees com job RxJava pull requests 327 SUCCESS This pull request looks good RxJava pull requests #328 https netflixoss ci cloudbees com job RxJava pull requests 328 SUCCESS This pull request looks good I m just assuming this is all good from your side as I can t provide a useful review on this',RxJava,true,false,false
20548866,'Adding collect method to Scala Observable','I think it s a good idea to add a collect method analogous with the one in the Scala collection library It was simplest to implement it using a combination of filter map If you find any major disadvantages with this please chime in','RxJava pull requests #329 https netflixoss ci cloudbees com job RxJava pull requests 329 SUCCESS This pull request looks good @samuelgruetter can you review this and comment as it related to Scala @madnl thanks for getting involved Once review with Samuel can you please rebase this on top of the recent changes so it can merge without conflicts again Right now it conflicts as there was a large set of Scala changes that just got merged to master Yes adding methods which are in Scala collections but not in RxJava is one of the points which are still on the TODO list https github com Netflix RxJava blob df0436c9293f05de2f00f9ef50b6be0b053d99fc language adaptors rxjava scala TODO md @madnl your collect looks good but we would also like to have some unit tests We had the following unit test policy for Scala adaptor until now If a method just calls the corresponding RxJava method no need for a test but if new functionality is added also add a test This conflicts so can t be cleanly merged Can unit tests be added and a new pull request submitted after rebasing changes from master',RxJava,true,false,false
20589405,'JRuby function wrapping support','This PR fixes #320 by implementing JRuby wrappers for RxJava specific function interfaces Given a set of method signatures for a Java method JRuby will select the signature that best matches the Ruby arguments provided and wrap each argument in a proxy that implements the correct Java interface Occasionally JRuby will be unable to unambiguously select one method signature over another and will either a select the correct signature but report that there was ambiguity in the method signatures or b select the wrong signature and fail By explicitly wrapping Proc arguments into wrappers that implement the correct RxJava interface JRuby will always select the correct method signature and will not need to wrap the argument in a proxy increasing both correctness and performance','RxJava pull requests #330 https netflixoss ci cloudbees com job RxJava pull requests 330 FAILURE Looks like there s a problem with this pull request RxJava pull requests #331 https netflixoss ci cloudbees com job RxJava pull requests 331 SUCCESS This pull request looks good RxJava pull requests #332 https netflixoss ci cloudbees com job RxJava pull requests 332 SUCCESS This pull request looks good Structure of files build etc looks good Code looks good as far as I can tell I m not a Ruby expert Great contribution @ragalie I m merging for the next release Continue submitting fixes improvements as needed Curious is it this class require rx lang jruby interop that triggers all of the logic for converting from Proc to Action Function Is that idiomatic in JRuby to have an interop import like this or is something like rx lang jruby Observable also appropriate I have no idea so it s out of curiosity and want of understanding that I ask Hi @benjchristensen that is the line that triggers the wrapper logic I m not sure what s idiomatic in JRuby I m pretty new to it as well I considered rewriting the Ruby interop code in Java so that I could include it as a static block somewhere but it would ve taken much longer to get this out and I wasn t sure of the ultimate feasibility The best delivery method for rxjava jruby would probably be through a gem that depends on the relevant jars using jbundler for instance requires the jars and then does the interop require But again I m relatively new to the JRuby ecosystem and I don t know what exists for building gems via gradle maven or if you are even interested in maintaining a gem for RxJava specifically Once this gets released I will do the requisite require in porcupine https github com ragalie porcupine so that anyone using Porcupine for Hystrix in JRuby will benefit at least Is it worth reaching out to others in the JRuby community before releasing this to get some input on whether there is an expected approach to importing this if you are even interested in maintaining a gem for RxJava specifically I don t think so but honestly have no idea what that even entails Thanks again for the contribution I m waiting on confirming a few other things but likely will release in the next day or two @iconara what do you think Is it too much of an imposition to ask people to require an interop file in addition to the jar file The BasicLibraryService approach you suggested seemed promising but seemed potentially difficult in practice since it needs a particular filename and directory structure to work correctly As you say the BasicLibraryService approach depends on the JAR being named correctly which is difficult since you often want version numbers and that kind of thing in the name I think that the interop code should require the JARs you shouldn t have to require those first The interop code should know where they are and could just use a glob in place of the version so that it wouldn t have to be changed for each version e g require Dir path to jars rxjava core jar first In the end without a gem release I don t really see any adoption in the JRuby community Maybe releasing a JAR that automatically runs the interop code would work too with JBundler that would at least mean that dependency management could work If you released an official RxJava gem that bundled the core and JRuby JARs that would be much better I m not yet convinced by JBundler but releasing the interop code as a gem and depending on the RxJava JARs like Porcupine depends on Hystrix could work You d constantly get bug reports about the JARs missing or about making it work without JBundler but apart from that I think it would work The difficulty is that the interop code is currently _inside_ the rxjava jruby jar so it can t be required until the jar is required first To be honest my interest is primarily in Hystrix so to me having instructions in the README and doing the correct requires in porcupine seems like a good stopping point If there s independent interest in an RxJava gem then I would be happy to help get that going however You can probably require the interop code only even if it s in the JAR Try using path to jar path inside jar rb I think it should work On the other hand telling people to do that is probably even worse On Wed Oct 9 2013 at 9 19 PM Mike Ragalie notifications@github com wrote The difficulty is that the interop code is currently inside the rxjava jruby jar so it can t be required until the jar is required first To be honest my interest is primarily in Hystrix so to me having instructions in the README and doing the correct requires in porcupine seems like a good stopping point If there s independent interest in an RxJava gem then I would be happy to help get that going however Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 422#issuecomment 26000136',RxJava,true,false,false
20591971,'Reduce an empty observable','Hi In RxJava reduce Func2 T T T accumulator may be not implemented correctly Now reduce is implemented using scan When reducing on empty observable it will invoke onCompleted and do nothing This is against my expectation I suppose that reducing an empty observable should throw an exception Actually Scan and Aggregate I think this is reduce in C# have different behaviors in C# Scan an empty observable will do nothing but Aggregate will throw a System InvalidOperationException Here are my test codes in C# Scan c# Observable Empty int Scan x y x y Subscribe x Console WriteLine subscriber got x Aggregate c# Observable Empty int Aggregate x y x y Subscribe x Console WriteLine subscriber got x I also tried the reduce method in other languages List Int reduce _ _ will throw java lang UnsupportedOperationException empty reduceLeft in scala reduce lambda x y x y will throw reduce of empty sequence with no initial value in python If reducing an empty observable throws an exception we can implement min and max by reduce directly','@zsxwing Thanks for diving into this aside When you write snippets like this it is a good idea to also look at onCompleted and onError Aggregate does not throw an exception but sends out an onError with an exception And return the empty sequence by immediately calling onCompleted which is not the same as do nothing Subtle but important to be super precise as we look at the edge cases var xs new 1 2 3 ToObservable var ys new int ToObservable xs Aggregate accumulator x y x y Subscribe x Console WriteLine 1 2 3 Aggregate x y x 1 0 x e Console WriteLine Boom 0 e Console WriteLine Done 1 2 3 Aggregate x y x 1 6 Done ys Aggregate accumulator x y x y Subscribe x Console WriteLine Aggregate x y x 1 0 x e Console WriteLine Boom 0 e Console WriteLine Done Boom System InvalidOperationException Sequence contains no elements xs Aggregate seed 0 accumulator x y x y Subscribe x Console WriteLine 1 2 3 Aggregate x y x 1 0 x e Console WriteLine Boom 0 e Console WriteLine Done 1 2 3 Aggregate x y x 1 6 Done ys Aggregate seed 0 accumulator x y x y Subscribe x Console WriteLine Aggregate x y x 1 0 x e Console WriteLine Boom 0 e Console WriteLine Done Aggregate x y x 1 0 Done xs Aggregate seed 0 accumulator x y x y resultSelector x string Format 0 x Subscribe x Console WriteLine 1 2 3 Aggregate x y x 1 0 x e Console WriteLine Boom 0 e Console WriteLine Done 1 2 3 Aggregate x y x 1 6 Done ys Aggregate seed 0 accumulator x y x y resultSelector x string Format 0 x Subscribe x Console WriteLine Aggregate x y x 1 0 x e Console WriteLine Boom 0 e Console WriteLine Done Aggregate x y x 1 0 Done No looking at scan I would say that scan in Rx NET is broken In Haskell the seed in a scan is sent out as well Prelude scanl 0 0 Prelude scanl 0 1 2 3 0 1 3 6 With no seed the results look like this Prelude scanl1 1 2 3 1 3 6 Prelude scanl1 But in C# the seed is not send out var xs new 1 2 3 ToObservable var ys new int ToObservable xs Scan accumulator x y x y Subscribe x Console WriteLine 1 2 3 Scan x y x 1 0 x e Console WriteLine Boom 0 e Console WriteLine Done 1 2 3 Scan x y x 1 1 1 2 3 Scan x y x 1 3 1 2 3 Scan x y x 1 6 Done ys Scan accumulator x y x y Subscribe x Console WriteLine Scan x y x 1 0 x e Console WriteLine Boom 0 e Console WriteLine Done Done xs Scan seed 0 accumulator x y x y Subscribe x Console WriteLine 1 2 3 Scan x y x 1 0 x e Console WriteLine Boom 0 e Console WriteLine Done 1 2 3 Scan x y x 1 1 1 2 3 Scan x y x 1 3 1 2 3 Scan x y x 1 6 Done ys Scan seed 0 accumulator x y x y Subscribe x Console WriteLine Scan x y x 1 0 x e Console WriteLine Boom 0 e Console WriteLine Done Done I d say we define for once and for all that see http www haskell org hoogle hoogle scanl xs aggregate op xs scan op last xs aggregate e op xs scan e op last xs aggregate e op f xs scan e op last map f It seems that takeLast 1 has a bug instead of calling onError ot calls onCompleted on the empty sequence I found http msdn microsoft com en us library system reactive linq observable aspx was out of date Now Rx Net has a blocking version of Last and First and a unblocking version of LastAsync and FirstAsync Here is the document I copy from VS c# Summary Returns the first element of an observable sequence Parameters source Source observable sequence Type parameters TSource The type of the elements in the source sequence Returns Sequence containing the first element in the observable sequence Exceptions System ArgumentNullException source is null System InvalidOperationException Asynchronous The source sequence is empty public static IObservable TSource FirstAsync TSource this IObservable TSource source Summary Returns the first element of an observable sequence that satisfies the condition in the predicate Parameters source Source observable sequence predicate A predicate function to evaluate for elements in the source sequence Type parameters TSource The type of the elements in the source sequence Returns Sequence containing the first element in the observable sequence that satisfies the condition in the predicate Exceptions System ArgumentNullException source or predicate is null System InvalidOperationException Asynchronous No element satisfies the condition in the predicate or The source sequence is empty public static IObservable TSource FirstAsync TSource this IObservable TSource source Func TSource bool predicate Summary Returns the last element of an observable sequence Parameters source Source observable sequence Type parameters TSource The type of the elements in the source sequence Returns Sequence containing the last element in the observable sequence Exceptions System ArgumentNullException source is null System InvalidOperationException Asynchronous The source sequence is empty public static IObservable TSource LastAsync TSource this IObservable TSource source Summary Returns the last element of an observable sequence that satisfies the condition in the predicate Parameters source Source observable sequence predicate A predicate function to evaluate for elements in the source sequence Type parameters TSource The type of the elements in the source sequence Returns Sequence containing the last element in the observable sequence that satisfies the condition in the predicate Exceptions System ArgumentNullException source or predicate is null System InvalidOperationException Asynchronous No element satisfies the condition in the predicate or The source sequence is empty public static IObservable TSource LastAsync TSource this IObservable TSource source Func TSource bool predicate @benjchristensen do we need to add the new Rx Net interfaces I have an implementation for this ready This will fax the issue for reduce scan Did you see the comments Sent from my iPad On Nov 4 2013 at 3 51 AM Shixiong Zhu notifications@github com wrote @benjchristensen do we need to add the new Rx Net interfaces Reply to this email directly or view it on GitHub @headinthebox sorry I mean that do we need to add these Rx Net interfaces lastAsync firstAsync into RxJava @zsxwing Yes that s what I meant I have an implementation for them but then recursively found some bugs in other operators @zsxwing @headinthebox We already have a first operator in Observable that is async https github com Netflix RxJava blob master rxjava core src main java rx Observable java#L3919 We solved the problem of duplicate naming for blocking non blocking in RxJava by separating all blocking operators into the BlockingObservable class so it is explicit Everything on Observable is non blocking and returns an Observable except for subscribe which returns Subscription The takeLast operator could have a last method aliased to takeLast 1 in Observable RxJava misses LastAsync and instead uses takeLast n which behaves differently var xs Observable Empty xs TakeLast 1 Dump onCompleted xs LastAsync Dump onError invalidOperation exception That seems non obvious why 2 variants of last should behave differently regarding error propagation Why should lastAsync behave differently than takeLast 1 when last means take the last value Should takeLast 1 emit an error since you have asked for more than are available Same with takeLast 5 if less than 5 are available If wanted without errors then takeUpToLast 5 would take 0 5 items but takeLast 5 would only take 5 or error I just realized that the question what should the operator do if the source observable does not have enough elements should be asked for some other operators as well elementAt reduce Func2 T T T and aggregate Func2 T T T average Longs Floats Doubles min max skip first 2 overloads and takeFirst 2 overloads take takeLast skipLast I d prefer that onError be called instead of ignoring that there were not enough elements That s also what scala collections do And if takeLast on an empty observable calls onError reduce can nicely be implemented using scan @headinthebox I am not aware of a rule that covers this can you provide an answer for @samuelgruetter s question We can then go build the unit tests and get code to match the rule elementAt OnError out of range reduce Func2 and aggregate Func2 that s what started this discussion see above average Longs Floats Doubles same defined as reduce min same defined as reduce max same defined as reduce skip onCompleted first 2 overloads throws for blocking observable onError empty sequence and takeFirst 2 overloads as many elements as it can get ending with onCompleted take I think this is an alias for takeFirst takeLast as many elements as it can get ending with onCompleted skipLast onCompleted The behavior in Rx NET is the same as in Haskell except for the bug in scan discussed up here Prelude take 5 1 3 1 2 3 etc I reviewed these operators in RxJava Here is my conclusion elementAt is correct aggregate is correct reduce is wrong min and max are not implemented However I have already finish it in my branch https github com zsxwing RxJava commits min max Once the reduce issue is fixed I ll send a PR average uses reduce For an empty observable it will throw a DivisionByZero error I think this error is not correct It should be something like UnsupportedOperationException If the reduce issue is fixed it will work correctly takeFirst takeLast skip and skipLast is correct blocking last is wrong See #464 non blocking last is missing blocking first is missing non blocking first is wrong Please let correct me if I have misunderstood something I have completed the blocking and non blocking last impls in https github com Netflix RxJava pull 470 @zsxwing Are you working on any of these others already so we don t duplicate effort Actually seems like reduce is the only one needing fixing as average will fix itself once reduce is done The reduce operator is now fixed for the empty Observable case When the Observable is empty but a seed is passed in it just emits the seed java A reduce on an empty Observable and a seed should just pass the seed through This is confirmed at https github com Netflix RxJava issues 423#issuecomment 27642456 @Test public void testReduceWithEmptyObservableAndSeed Observable Integer observable Observable range 1 0 int value observable reduce 1 new Func2 Integer Integer Integer @Override public Integer call Integer t1 Integer t2 return t1 t2 toBlockingObservable last assertEquals 1 value Please confirm that current code and unit test match the expected behavior and then we can close this or we correct again There is still a difference between Average in RxJava and Rx Net when the observable is empty This is a unit test for Average in RxJava Java @Test public void testEmptyAverage throws Throwable Observable Integer src Observable empty average src subscribe w verify w never onNext anyInt verify w times 1 onError any ArithmeticException class verify w never onCompleted If the observable is empty average emits an ArithmeticException Here is a sample for Average in Rx Net c# IObservable double o Observable Empty int Average o Subscribe x Console WriteLine OnNext x e Console WriteLine OnError e Console WriteLine Done It outputs OnError System InvalidOperationException Sequence contains no elements @benjchristensen Now I m only working on min and max operators I sent the PR #478 for min and max I fixed the Average issue for the empty Observable case in #480 Please help me confirm it Closed as it s fixed',RxJava,false,false,false
20672373,'Implemented the IgnoreElements operator','Hi I implemented the IgnoreElements operator #54 Please take a look Thanks','RxJava pull requests #333 https netflixoss ci cloudbees com job RxJava pull requests 333 SUCCESS This pull request looks good Can you rebase this with the changes to master so it can be cleanly merged again With all the other changes this no longer cleanly merges Thank you @zsxwing for this and all the other pull requests I really appreciate your involvement in the project I rebased the pull request Now it should be able to merge to master directly RxJava pull requests #336 https netflixoss ci cloudbees com job RxJava pull requests 336 SUCCESS This pull request looks good RxJava pull requests #337 https netflixoss ci cloudbees com job RxJava pull requests 337 SUCCESS This pull request looks good',RxJava,true,false,false
20723530,'Manual Merge of Pull Request #407','Added a unit test to #407 while testing it','RxJava pull requests #334 https netflixoss ci cloudbees com job RxJava pull requests 334 SUCCESS This pull request looks good',RxJava,true,false,false
20725364,'PublishSubject ReSubscribe for publish refCount Behavior','Allow publish refCount to support re subscribing to the origin after decrementing the count to 0 then adding new Observers which increment count to 1 The PublishSubject implementation was performing onError onCompleted unsubscribe logic that was put in place long ago and I am now pretty sure it was wrong This was revealed while playing with refCount which intends on allowing a re subscription to the source once new Observers arrive PublishSubject was preventing that The one use case that I m still wondering about though is if someone subscribes to a PublishSubject after it has emitted onCompleted and isn t restarted That Observer would wait forever if it is a single shot PublishSubject use case I m not sure if that s just a bad use and fits into the don t do that scenario or if it s a legit issue that has a solution Right now this code is thread safe in the visibility sense but it s not atomic and could have race conditions between adding removing Observers and event notifications I don t think that s an issue as if someone is concurrently adding removing it s always a race but am not 100 sure if there s a use case I m missing This also assumes as it always did that someone is not invoking onNext concurrently as that would break the Rx contract','See this part of the unit test for the use case that triggered finding this https github com Netflix RxJava pull 426 files#diff 4172660e02404d491e7704449503c56fR121 I d appreciate someone confirming behavior from Rx Net and my questions assumptions in the description above RxJava pull requests #335 https netflixoss ci cloudbees com job RxJava pull requests 335 SUCCESS This pull request looks good',RxJava,true,false,false
20731001,'RFC Initial implementation of OperationObserveInForeground Android','In reference to the discussion in 0 and our work with RxJava on Android here is an initial attempt at providing an Rx operator which wraps the boilerplate required to observe sequences on Android UI components like Fragments and Activities although I should mention that I haven t added support for the latter yet but focused on Fragments from the support v4 library Here s what I did provide an operator which accepts a specialized observer type that is able to expose a Fragment reference This is essential for us to decide whether it s safe to forward messages to that fragment and we can only ask the fragment itself to make that decision schedule observer callbacks on the Android UI thread by default There is some discussions to be had around this I would really appreciate if everyone with and without Android experience could weigh in Specific questions I think need discussing I am terminating the sequence early if the caller does not subscribe using one of the specialized Observer types I provide FragmentObserver or SupportFragmentObserver for native and back compat fragments respectively As mentioned above I must force the caller to give me a reference to the fragment since otherwise callbacks cannot be executed in a safe manner safe w r t not calling back in case Android decided to remove the fragment from the window this is a life cycle event in Android which cannot be intercepted other than asking the fragment whether it s still attached or not I realize this has a smell to it but I don t see another option the specialized observer class keeps weak references to the source observer and the fragment both can be the same object but then again could also not if e g you use inner classes as observers In case the references got cleared messages will be dropped Naming observeInForeground is the best I could come up with which doesn t mean much Feel free to submit better naming suggestions TODO Implement native FragmentObserver in the same manner as SupportFragmentObserver the latter is what we need so I built that one first Add ActivityObserver in the same manner Think about auto unsubscribing from the source sequence in case the references got cleared 0 https groups google com forum fromgroups # topic rxjava 7o_NJw36Enw','RxJava pull requests #339 https netflixoss ci cloudbees com job RxJava pull requests 339 SUCCESS This pull request looks good I thought about this a lot today and I decided to get back to the proverbial drawing board I have another idea for how to build this which circumvents the limitations I mentioned above and is overall less awkward I realized too late that I simply cannot rely on the observer to pass through Android components like fragments since any chain and order of composition might result in the observer being wrapped perhaps multiple times giving me no access to the source observer Closing this one sorry for the noise Will follow up with something better lol just spent this morning to study your code Should have checked here first Yeah sorry about that I actually sat down in the evening the same day and I think solved all problems TM I m about to integrate the new solution with our code base and I want to give it some time to mature in an internal beta The new solution I came up with does not use new observer types or interfaces at all It s all self contained in the operator class It also doesn t use WeakReferences at all at the cost of forcing the caller to unsubscribe in onDestroy events However I think this is a cleaner approach anyway since the wrapped sequence might have to be unsubscribed from anyway I ll probably hold off with a PR to the core project for now though This is all still experimental stuff If you want to follow progress on this fork https github com soundcloud RxJava instead Hi I have just looked at your code Here are just few thoughts I had I understand why you wanted to drop the weak reference but there is still the danger that a lib user forget to unsubscribe in the onDestroy method To mitigate this risk why not release an exception in the method which checks the state of the activity or of the fragment The exception would have a nice message like hey stupid programmer you have forgotten to unsubscribe in the onDestroy method of your fragment activity Of course in the onnext method the error will be catched by Rx and forwarded to the onerror callback It s still better than nothing but may be there are ways to make the app crash Not tested but does Rx would catch the error if it s throwed on the main loop Something else I have several Samsung devices and they have in common to put in log tons of system things which h makes the log difficult to read very boring You have added few things to put in log too If you think you really need log why not use a method to activate logs if needed Last thing I know you have a memento project for keeping variable across device rotation But don t you think this feature should be included in Rx I mean any async task implies the risk of being executed after the death of its activity So any Rx stuff too It s so common that I think anyone would need it Why asking to the user to search for other lib or implement that part himself Is the finalizer guardian idiom useful to protect against when people forget to do it It is not what should be relied upon because finalizers are not trusted or fast but helps when they forget and then can spit out a nasty exception log telling people to start unsubscribing correctly http books google com books id ka2VUBqHiWkC pg PA30 lpg PA30 dq effective java finalizer guardian source bl ots yYKgMhs2S_ sig gaVlaeuWMgQjivfckRJiPr1rlQU hl en sa X ei qwhXUsveFoeliQLYu4HACQ ved 0CD0Q6AEwAg#v onepage q effective 20java 20finalizer 20guardian f false @benjchristensen This idiom is to guaranty the call of a finalizer block But here there is not such block However there is a method isComponentValid called before executing each Observer event It seems to me to be a nice place to put code Is there something I am missing @mttkay As it s not possible to open issue in your fork may be it s a good idea to reopen this issue It could live within the new operator being considered such as in here https github com Netflix RxJava pull 427 files#diff fc6afd15c1e8987df49116260021ba27R27 If that operator Observable is ever garbage collected without having been unsubscribed the guardian could do the cleanup and trigger warnings nasty error messages etc By cleanup you probably mean unsubscribing when the activity fragment is destroyed I was thinking to make the application crash if possible I deeply believe earlier it crashes better it is With the nice message the programmer will rapidly understand the reason If cleanup is automatically done and as J Bloch writes in his book because we can t believe finalizer from being called when we need it the cleanup may be done one time and not the other Moreover why let a dev do bad things like not calling the unsubscribe method if the activity fragment dies Second question I still don t get why we may need a finallizer block I am sorry if the question sounds stupid it s past midnight and I am a bit tired Are you thinking to put it in the isComponentValid method of this class https github com soundcloud RxJava blob android ui component operator rxjava contrib rxjava android src main java rx operators OperationObserveFromAndroidComponent java There are a few points which bugs me in your solution You seem to assume that most people will use Fragment or Activity as an Observable I think it is the opposite Actually but I m never using Android UI components as direct Observers I m still experimenting however This can be easily added though as you proposed earlier with a specific interface for example I see that you are using volatile for componentRef and observerRef Maybe I misunderstand why you re using it but does that mean that you are planning to use your operator from a different thread Because I m not sure that fragment isAdded activity isFinishing are thread safe and thus they shouldn t be used from different threads This could lead to race conditions and hard to reproduce bugs So maybe checking current scheduler thread and raising an exception would be more appropriate than using volatile synchronization keyword Releasing refs only in onNext onError or onCompleted doesn t give enough guarantees e g if nothing is happening in the pipe for a long time I know this a security but a security that doesn t ensure anything eventually I think like pommedeterresautee that an exception or something explicit wld be maybe better Assuming what I just said is rubbish and releasingRef would be a good thing why not calling unsubscribe too isFinishing is true in from onPause if I m not mistaken Not sure people want to unsubscribe in Onpause and resubscribe in onResume everytime I v thought about this only a little though This seems especially true to me with long network calls You don t want to just ignore the result But anyway I guess you can have a kind of headless service in between that will keep the result So maybe this scenario is useless I didn t have time to implement a solution yet but when I thought about this issue last time I thought the best idea would be to have a kind of central manager that you would initialize wh activity starts and finalize when activity stops and register any callback e g an observer in between that must be released later But this requires still a few explicit calls from the user side It is even possible to detach an inner class callback e g an observer defined as an inner class and reattach it later to another activity later I already implemented this idea for an async task like library that you can find there https github com ratamovic robolabor disclaimer work not finished yet and still on hold Sorry if I m not clear this is a bit late PS By the way I mostly agree with you pommedeterresautee I prefer a quick violent and explicit exception or even crash when something is done wrong @ratamovic regarding your first point at the subscription three things are provided an observable an observer and an activity or a fragment Unlike the previous discussions in the new fork the observer has not to be implemented in an activity fragment The Android component is just provided to check if the observable should be unsubscribed or not Regarding the thread issue activity and fragment are probably not thread safe but I don t think it s an issue here IsAdded method and isFinishing will just read a boolean value and not change a state so IMO it s safe Also is finishing is true only if finish is called or if the activity is being destroyed according to the doc http developer android com reference android app Activity html#isFinishing No unsubscribe in onpause Actually while looking quickly at thecode I couldn t find the definition AndroidComponent in the code This maybe why I m getting confused But I still don t see how you handle an Observer that communicates with the UI but is not UI itself About threading Okay I didn t see the observeOn AndroidSchedulers mainThread yesteray My fault In that case be careful with successive access to componentRef when doing if componentRef null isComponentValid componentRef you do successive calls to the volatile var componentRef instead of reading it once in a local variable Hence it can change e g set to null between the two conditions check and it is anyway inefficient Or else I think you must guarantee unsubscribe is called from the UI Thread or you have anyway a problem In addition not related to threading I think you can break the condition so that you can call releaseReferences only once and not every time a new onNext is called i e if x null if isValid else release About isFinishing I m a bit confused because I see that This is often used in onPause to determine whether the activity is simply pausing or completely finishing which means it can be true in onPause to me and that the operator can be true and release its reference in onPause but I just got up too and maybe my thoughts not clear yet AndroidComponent is just generic stuff overridden by fragment or activity class The observer you provide may be an instance of a non static class in your activity or another class you provided UI objects in the constructor or anything I didn t thought about then the observer provided is boxed in a new one to make the necessary checks Regarding isFinishing when the activity is destroyed all the intermediate states are reached including on pause So sometimes on pause is called because the screen is off sometimes because the activity is being destroyed That s why isFinishing is useful there Okay I see it now there are two params in observeFromAndroidComponent So this is generic indeed Sorry I wasn t careful enough I understand why isFinishing is interesting here Haven t thought about this much yet but I m feeling somewhat uncomfortable with it Maybe because this may mean that an Activity may stop receiving data in onPause only if Activity will be destroyed of course before any other activity got time to subscribe to the same source Observable Which means you may lose data Indeed 2 activities can have their onStart onStop calls overlap but not onResume onPause if I m not wrong Not sure again if this is a real life scenario though Guys this is excellent feedback One thing though are we all clear that we re NOT talking about the code in this PR as I closed it I ve reimplemented everything here https github com soundcloud RxJava tree android ui component operator Again sorry for the confusion To avoid further confusion I moved this discussion to a separate GH issue https github com soundcloud RxJava issues 1',RxJava,true,false,false
20785988,'buffer using TimeAndSizeBasedChunks incorrectly forces thread into interrupted state','In TimeAndSizeBasedChunks emitChunk if emitChunk is called from the scheduled action in createChunk i e from the timeout thread calling subscription unsubscribe ends up calling cancel on the future which sets the thread s interrupted state to true This state has an adverse effect on any blocking call performed in that thread','Can you provide a unit test to demonstrate the issue Here are existing unit tests for buffer https github com Netflix RxJava blob master rxjava core src main java rx operators OperationBuffer java#L372 Also what Future are you referring to Are you using custom schedulers I m unable to run the unit tests in eclipse for some reason Here s a unit test from my project While we re on the subject of buffer it would be nice if the observer was not called with an empty list @Test public void testInterrupted throws Exception Observable create new OnSubscribeFunc Integer @Override public Subscription onSubscribe final Observer super Integer t1 final Future t Executors newSingleThreadExecutor submit new Runnable @Override public void run try Thread sleep 10000 catch InterruptedException e return new Subscription @Override public void unsubscribe t cancel true buffer 1000 TimeUnit MILLISECONDS 10 subscribe new Action1 List Integer @Override public void call List Integer t1 try Thread sleep 1000 catch InterruptedException e This should be called e printStackTrace Thread sleep 10000 Regarding the Future no i m not using a custom scheduler Subscriptions create final Future f calls cancel on the future when it is unsubscribed Yes that s what a Subscription of a Future is supposed to do Thanks for submitting the unit test I ll try it out While we re on the subject of buffer it would be nice if the observer was not called with an empty list You re using time so it will emit every 1000ms whatever is buffered even if it s empty',RxJava,false,true,true
20787452,'buffer using TimeBasedChunks results in duplicates being sent onNext','This seems to be isolated to the first chunk @Test public void testDuplicate throws Exception final Set Integer unique new HashSet Integer Observable create new OnSubscribeFunc Integer @Override public Subscription onSubscribe final Observer super Integer t1 final Future t Executors newSingleThreadExecutor submit new Runnable @Override public void run int count 0 for int i 0 i 11 i t1 onNext count try Thread sleep 10 catch InterruptedException e return new Subscription @Override public void unsubscribe t cancel true buffer 100 100 TimeUnit MILLISECONDS subscribe new Action1 List Integer @Override public void call List Integer t1 if t1 isEmpty return LOG info t1 toString for Integer i t1 synchronized unique if unique contains i LOG error Duplicate for i Assert assertFalse unique contains i unique add i Thread sleep 10000','I think this is not a bug I suppose you want to do something like this pre create a chunk sleep 100ms fire the chunk create a new chunk pre However as fire the chunk and create a new chunk run in different threads their order is not determined So if you use buffer 100 100 TimeUnit MILLISECONDS somethink like this may happen pre create a chunk sleep 100ms create a new chunk fire the old chunk pre So before the old chunk is fired the old and new chunks will both receive any results after create a new chunk I think this is not a bug because TimeBasedChunks is a OverlappingChunks which allows such indeterminacy What s the status of this being a bug or not @headinthebox Can you confirm If I change buffer 100 100 TimeUnit MILLISECONDS to buffer 100 TimeUnit MILLISECONDS then I don t see overlaps when I run it many times With 100 100 I could agree that it is a valid race condition but I m also testing with 100 101 and seeing it and that doesn t make sense buffer 100 101 TimeUnit MILLISECONDS With that I see this 0 1 2 3 4 5 6 7 8 9 9 10 Duplicate for 9 That is not expected so I tend to agree that we have a bug The second buffer starting at 101 should not have a value emitted during the first 100ms If I change buffer 100 100 TimeUnit MILLISECONDS to buffer 100 TimeUnit MILLISECONDS then I don t see overlaps when I run it many times And if you change it to buffer 42 TimeUnit MICROSECONDS then some items will be dropped see also #756 That is not expected so I tend to agree that we have a bug 1 This bug should be resolved in the latest release This test now passes java @Test public void testDuplicate throws Exception final Set Integer unique new HashSet Integer Observable create new OnSubscribe Integer @Override public void call final Subscriber super Integer t1 final Future t Executors newSingleThreadExecutor submit new Runnable @Override public void run int count 0 for int i 0 i 11 i t1 onNext count try Thread sleep 10 catch InterruptedException e t1 add Subscriptions from t buffer 100 100 TimeUnit MILLISECONDS subscribe new Action1 List Integer @Override public void call List Integer t1 if t1 isEmpty return System out println t1 toString for Integer i t1 synchronized unique if unique contains i System out println Duplicate for i Assert assertFalse unique contains i unique add i Thread sleep 10000 It emits 0 1 2 3 4 5 6 7 8 9 10',RxJava,false,true,true
20907398,'Fixed issue #428','I fixed the issue #428 This issus is because the wrong order of unsubscribe and emitChunk unsubscribe will cancel the Future and the currrent thread s interrupt status will be set If unsubscribe is called before emitChunk the currrent thread s interrupt status has already set before emitChunk It may confuse users when they have some codes depending on the interrupt status I put emitChunk before unsubscribe and added a unit test for it','RxJava pull requests #341 https netflixoss ci cloudbees com job RxJava pull requests 341 FAILURE Looks like there s a problem with this pull request Is seems rx operators OperationConcat UnitTest testNestedAsyncConcat does not use TimeAndSizeBasedChunks Is this some potential issue RxJava pull requests #342 https netflixoss ci cloudbees com job RxJava pull requests 342 SUCCESS This pull request looks good Thank you for researching and fixing this It seems rx operators OperationConcat UnitTest testNestedAsyncConcat does not use TimeAndSizeBasedChunks Is this some potential issue What about that unit test suggests the need for TimeAndSizeBasedChunks What about that unit test suggests the need for TimeAndSizeBasedChunks No I just want to say this is another example of #383 But what does a flaky unit test in concat have to do with TimeAndSizeBasedChunks Or are you just saying rx operators OperationConcat UnitTest testNestedAsyncConcat is a flaky unit test I just said rx operators OperationConcat UnitTest testNestedAsyncConcat was a flaky unit test',RxJava,true,false,false
20974167,'Unsubscribing does not work when using subscribeOn Schedulers newThread','I m having trouble unsubscribing whenever I use Observable subscribeOn Schedulers newThread on Android I m using rxjava 0 14 3 In my case my observer class does the following Subscription sub myObject getData subscribeOn Schedulers newThread observeOn AndroidSchedulers mainThread subscribe this The getData method creates an observable and the onSubscribeFunc generates some mock data using a new thread final BooleanSubscription subscription new BooleanSubscription Thread t new Thread new Runnable public void run generate data call onNext check subscription isUnsubscribed sleep a bit repeat last two steps t start return subscription When I unsubscribe the Composite subscription I got in the observer isUnsubscribed never returns true in the worker thread and BooleanSubscription unsubscribe never gets called breakpoint never triggered I stepped through the CompositeSubscription unsubscribe method and it seems that it doesn t even contain the BooleanSubscription anywhere in the keySet The interesting this is that if call subscribeOn Schedulers threadPoolForComputation or using AndroidSchedulers mainThread the unsubscription works correctly Am I misusing the Schedulers newThread method or does the NewThreadScheduler have a bug','Could you provide a unit test to reveal this issue I tried similar codes but did not find the bug you described I ve observed similar behaviour using rxjava 0 14 6 also on Android when attempting to unsubscribe from a Subscription created using Schedulers newThread schedulePeriodically The failure is fairly easy to reproduce in the context of the application although it s inconsistent as often the subscriptions are successfully unsubscribed This test demonstrates the problem basically the Observable never receives unsubscribes even though the Observer no longer receives notifications package tests import org junit Test import rx Observable import rx Observer import rx Subscription import rx concurrency Schedulers import rx util functions Func1 import java util concurrent TimeUnit public class UnsubscribeTest @Test public void testUnsubscribe throws InterruptedException Subscription sub Observable interval 1 TimeUnit SECONDS map new Func1 Long Long @Override public Long call Long aLong System out println generated aLong return aLong subscribeOn Schedulers newThread observeOn Schedulers currentThread subscribe new Observer Long @Override public void onCompleted @Override public void onError Throwable e @Override public void onNext Long args System out println Received args Thread sleep 3000 System out println Calling unsubscribe sub unsubscribe Thread sleep 3000 Output is generated 0 Received 0 generated 1 Received 1 Calling unsubscribe generated 2 generated 3 generated 4 generated 5 If I change the subscribeOn thread to Schedulers threadPoolForIO then the output is generated 0 Received 0 generated 1 Received 1 Calling unsubscribe I ll take a look I think this is fixed in https github com Netflix RxJava pull 472 Can someone confirm I think this is fixed in https github com Netflix RxJava pull 472 Can someone confirm Yes I think that s fixed it thanks Great I ll release today or tomorrow Hello guys I m on 0 15 1 and still see the issue The test program above prints the values expected but the whole program just doesn t quit after that I see three RxNewThreadScheduler threads 2 core machine all of them waiting for ThreadPoolExecutor workQueue take These threads aren t marked as daemon threads See NewThreadScheduler L55',RxJava,false,false,false
20995840,'Fixed path to RxScalaDemo scala','','RxJava pull requests #343 https netflixoss ci cloudbees com job RxJava pull requests 343 FAILURE Looks like there s a problem with this pull request I doubt that editing language adaptors rxjava scala README md could have caused this failure Another instance of https github com Netflix RxJava issues 383',RxJava,true,false,false
20998914,'Fixed testOnErrorViaHasNext in issue #383','Hi This PR fixed the issue that testOnErrorViaHasNext fails sometimes It only tries to avoid the failure of unit tests However there is still an issue in the next operator The hasNext may return true but the later next throws IllegalStateException Observable is completed An example unit test throws IllegalStateException java @Test public void test Subject String String obs PublishSubject create Iterator String it next obs iterator assertTrue it hasNext obs onCompleted it next I think @abersnaze is right hasNext should block until either the onNext or onComplete has been called','RxJava pull requests #344 https netflixoss ci cloudbees com job RxJava pull requests 344 SUCCESS This pull request looks good RxJava pull requests #346 https netflixoss ci cloudbees com job RxJava pull requests 346 SUCCESS This pull request looks good Regarding hasNext being blocking that may be the case Should that be researched further and resolved here or as a separate pull request I think it s better to resolve here I ll work on it Thanks Thanks for fixing this Not sure I understand why hasNext needs to block Returning null from takeNext when the completed notification is consumed should work and pass the example unit test above I suppose that for an iterator next should be able to return something if hasNext is true What s more null is a valid value in a observable So we can not simply return a null I know it seems a little counter intuitive but that seems to be what the wiki https github com Netflix RxJava wiki Blocking Observable Operators#next says The next method returns an iterable that on each iteration blocks until the underlying Observable emits another item then returns that item or null if the Observable finishes without emitting another item RxJava pull requests #356 https netflixoss ci cloudbees com job RxJava pull requests 356 FAILURE Looks like there s a problem with this pull request I updated the next operator Now the hasNext method will be blocked until any notification arrives In addition after the observable is completed or fails the following hasNext always return false and next always return null RxJava pull requests #358 https netflixoss ci cloudbees com job RxJava pull requests 358 FAILURE Looks like there s a problem with this pull request I found weird behaviors in Rx Net In the following case c# var e Observable Create int o Console WriteLine subscribed return Disposable Empty SubscribeOn Scheduler ThreadPool Next GetEnumerator Console WriteLine before MoveNext if e MoveNext Console WriteLine Got e Current else Console WriteLine Empty it will output pre subscribed before MoveNext pre In the following another case c# var e Observable Empty int SubscribeOn Scheduler ThreadPool Next GetEnumerator Console WriteLine before MoveNext if e MoveNext Console WriteLine Got e Current else Console WriteLine Empty it will output pre before MoveNext Empty pre Does anybody know the difference between these two cases What is the weirdness And why the complexity with schedulers and toenumerable Sent from my iPad On Oct 21 2013 at 9 45 AM Shixiong Zhu notifications@github com wrote I found weird behaviors in Rx Net In the following case var e Observable Create int o Console WriteLine subscribed return Disposable Empty SubscribeOn Scheduler ThreadPool Next GetEnumerator Console WriteLine before MoveNext if e MoveNext Console WriteLine Got e Current else Console WriteLine Empty it will output subscribed before MoveNext In the following another case var e Observable Empty int SubscribeOn Scheduler ThreadPool Next GetEnumerator Console WriteLine before MoveNext if e MoveNext Console WriteLine Got e Current else Console WriteLine Empty it will output before MoveNext Empty Does anybody know the difference between these two cases Reply to this email directly or view it on GitHub @headinthebox I wonder how Rx Net implements Empty It does not have a onCompleted method My example proves that c# Observable Create int o Console WriteLine subscribed return Disposable Empty is not equals to Observable Empty int So I want to know the essential difference between them Thanks Sorry I misunderstood about Rx Net I removed my related discussion to avoid confusing somebody I updated the PR to follow the iterator contract Thanks for your review @benjchristensen RxJava pull requests #368 https netflixoss ci cloudbees com job RxJava pull requests 368 FAILURE Looks like there s a problem with this pull request still wondering why this implementation runs contrary to the wiki that said i can t find any other implementation of Next operator so can t be 100 sure null if the Observable finishes without emitting another item if the Observable has completed then hasNext should surely return true and next return null perhaps worth noting that this is meant to be a sampler it does not buffer so running java while it hasNext it next is _not_ guaranteed to iterate over the output of the Observable which is perhaps the intention of the blocking code as Observer onNext events that happen between hasNext and next should be lost does storing the unconsumed next value in the hasNext method not also break this contract still wondering why this implementation runs contrary to the wiki It s possible to implement it following the wiki But the wiki is against the Iterator contract in Java I suppose it s better to follow the Iterator contract so that Java users may feel conformable Since hasNext and next are always called together I think it s OK to buffer a value when hasNext is called the problem is without buffering the full Observable you cannot implement the generally accepted contract ie hasNext next can return different results for the same Observable that seems pretty uncomfortable I think the real issue is there isn t a good example of how you would use this operator The name next suggests you use it to get an Iterator that _will_ return the next value from the Observable or null but the implementation does something rather different now it returns an Iterator that is either empty or has _a_ value from the Observable As the main wiki writer I should note that I m attempting to be descriptive rather than prescriptive If the wiki doesn t match the implementation or doesn t match the correct intuitive implementation implement it correctly and then let me know or correct the wiki yourself On Wed Oct 23 2013 at 7 50 AM Peter McDonnell notifications@github com wrote the problem is without buffering the full Observable you cannot implement the generally accepted contract ie hasNext next can return different results for the same Observable that seems pretty uncomfortable I think the real issue is there isn t a good example of how you would use this operator The name next suggests you use it to get an Iteratorthat will return the next value from the Observable or null but the implementation does something rather different now it returns an Iterator that is either empty or has a value from the Observable Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 433#issuecomment 26911239 David M Gross PLP Consulting hasNext next can return different results for the same Observable I think this behavior is very strange Actually hasNext is an indicator that if you will receive an value from next in the Java Iterator contract I tried the Next opeartor in Rx Net and got the similar result c# IObservable int ob Observable Create int o Console WriteLine Subscribed Before onNext Thread Sleep 2000 o OnNext 1 Console WriteLine Subscribed After OnNext o OnCompleted return Disposable Empty var iter ob SubscribeOn Scheduler NewThread Next GetEnumerator Console WriteLine Before MoveNext while iter MoveNext Console WriteLine Find a value Thread Sleep 5000 Console WriteLine Got iter Current Console ReadLine output pre Before MoveNext Subscribed Before onNext Subscribed After OnNext Find a value Got 1 pre In this case Rx Net also blocks in MoveNext And after 5 seconds iter Current returns the cached value So I think my current implementation is same as Rx Net And we need to update the wiki @DavidMGross thanks for the clarification @zsxwing is the semantic of Enumerable not slightly different it consists of a hasNext and next in the same call I don t have a NET setup to test easily but would be curious about what the output is if you 1 omit the o OnNext 1 line so the Observable just completes 2 put a Thread Sleep 3000 before the iter MoveNext so the OnNext has occured before MoveNext is called I ll stop bugging you about it then omit the o OnNext 1 line so the Observable just completes Test case c# IObservable int ob Observable Create int o Console WriteLine Subscribed Before OnCompleted Thread Sleep 2000 o OnCompleted Console WriteLine Subscribed After OnCompleted return Disposable Empty var iter ob SubscribeOn Scheduler NewThread Next GetEnumerator Console WriteLine Before MoveNext while iter MoveNext Console WriteLine Find a value Thread Sleep 5000 Console WriteLine Got iter Current Console WriteLine After MoveNext Console ReadLine Output pre Before MoveNext Subscribed Before OnCompleted Subscribed After OnCompleted After MoveNext pre put a Thread Sleep 3000 before the iter MoveNext so the OnNext has occured before MoveNext is called Test case c# IObservable int ob Observable Create int o Console WriteLine Subscribed Before onNext Thread Sleep 2000 o OnNext 1 Console WriteLine Subscribed After OnNext o OnCompleted return Disposable Empty var iter ob SubscribeOn Scheduler NewThread Next GetEnumerator Thread Sleep 5000 Console WriteLine Before MoveNext while iter MoveNext Console WriteLine Find a value Thread Sleep 5000 Console WriteLine Got iter Current Console WriteLine After MoveNext Console ReadLine Output pre Subscribed Before onNext Subscribed After OnNext Before MoveNext After MoveNext pre These behaviors are consistent with my thought Thanks @zsxwing so maybe the correct wiki def should be something like The next method returns an iterable that on each iteration blocks in Iterator hasNext or Iterator next until the underlying Observable emits another item Iterator next then returns that item If the Observable emits an error then Iterator hasNext will return true and Iterator next will re throw the exception If the Observable finishes without emitting another item then Iterator hasNext call will return false and Iterator next will throw a NoSuchElementException If the Observable emits an error then Iterator hasNext will return true and Iterator next will re throw the exception In my codes if the Observable emits an error then Iterator hasNext and Iterator next will both re throw the exception However you remind me that I should always throw the exception for the following hasNext or next I ll fix it I updated the PR to let hasNext and next always throw the error after the observable fails And rebase it on latest codes RxJava pull requests #373 https netflixoss ci cloudbees com job RxJava pull requests 373 FAILURE Looks like there s a problem with this pull request Let me conclude the next operator If the user only uses next method the next method will be blocked until the new value arrives If the user uses hasNext and next methods together at first the hasNext will be blocked until the new value arrives After that however before the corresponding next method is called hasNext only returns the same result without being blocked After the corresponding next method is called it returns the cached value the following hasNext will be blocked If the iterator reaches the end of the observable the following hasNext will always return false and next will always throw NoSuchElementException If the observable throws any error the following hasNext or next will always throw the error That is the protocol for integrators in net You have to call movenext and then current http msdn microsoft com en us library vstudio system collections ienumerator aspx I always assumed that this was the same in java but the Scala folks told me that typically has next does not block but calling next does Which in Scala means you use or not use parens Not sure if that is true in general It does make iterators hard to implement In PHP the protocol is also a bit different where you start with rewind which is typically ignored in net Sent from my iPad On Oct 28 2013 at 6 22 AM Shixiong Zhu notifications@github com wrote Let me conclude the next operator If the user only uses next method the next method will be blocked until the new value arrives If the user uses hasNext and next methods together at first the hasNext will be blocked until the new value arrives After that however before the corresponding next method is called hasNext only returns the same result without being blocked After the corresponding next method is called it returns the cached value the following hasNext will be blocked If the iterator reaches the end of the observable the following hasNext will always return false and next will always throw NoSuchElementException If the observable throws any error the following hasNext or next will always throw the error Reply to this email directly or view it on GitHub @headinthebox javacoc http docs oracle com javase 6 docs api java util Iterator html and scaladoc http www scala lang org api current #scala collection Iterator do not say how to block So I think it should be OK that we block hasNext For now I could not find any way to let hasNext follow the contract Returns true if the iteration has more elements without blocking hasNext Your explanation of how it works sounds correct merging',RxJava,true,false,false
21008527,'Implemented SerialSubscription and Timeout operator','Implemented Timeout operator and SerialSubscription upon which it is based','RxJava pull requests #345 https netflixoss ci cloudbees com job RxJava pull requests 345 SUCCESS This pull request looks good Merging this as it functions and is well written and well documented and will then look at whether modifications based on #446 make sense',RxJava,true,false,false
21058342,'rx apache http recognizes Transfer Encoding chunked as an HTTP stream','Uses the same infrastructure already in place for Content Type text event stream for HTTP response with chunked encoding Works with Twitter Streaming API','RxJava pull requests #347 https netflixoss ci cloudbees com job RxJava pull requests 347 SUCCESS This pull request looks good',RxJava,true,false,false
21061016,'Reimplemented the reduce operator','Hi I reimplemented the reduce operator The improvements are as follow As I mentioned in #423 reduce should throw an exception when applying on an empty sequence without an initial value Now reduce does not need a takeLast operator and should be more efficient','RxJava pull requests #348 https netflixoss ci cloudbees com job RxJava pull requests 348 SUCCESS This pull request looks good Now reduce does not need a takeLast operator and should be more efficient What is the overhead of takeLast 1 that limits its usage As a side note I think takeLast 1 could be special cased and made far more efficient than takeLast n since it doesn t need a queue just the last value As I mentioned in #423 reduce should throw an exception when applying on an empty sequence without an initial value Can we not achieve this check without re implementing the entire operator This duplicates logic between scan and reduce for accumulation If we can t do it cleanly or efficiently then your implementation looks great The guiding principle for this decision is guideline 6 1 https f cloud github com assets 813492 1340328 4b9b975a 362a 11e3 84b5 8da6a157659a png Hi @benjchristensen I removed the synchronized However I m still confused about concurrency in RxJava Could you review my discussion in #417 and help me solve the problems I also updated the unit tests Finally I reviewed the current operators and could not find a way to throw an exception when the observable is empty Could you provide some suggestion RxJava pull requests #360 https netflixoss ci cloudbees com job RxJava pull requests 360 FAILURE Looks like there s a problem with this pull request RxJava pull requests #361 https netflixoss ci cloudbees com job RxJava pull requests 361 FAILURE Looks like there s a problem with this pull request RxJava pull requests #362 https netflixoss ci cloudbees com job RxJava pull requests 362 FAILURE Looks like there s a problem with this pull request Finally I reviewed the current operators and could not find a way to throw an exception when the observable is empty Could you provide some suggestion Does this do what you need java flatMap o if good return Observable just goodValue else if bad return an error return Observable error new RuntimeException Sorry that I still have no idea about how to use flatMap to implement it If the observable is empty flatMap does nothing So how to throw an exception in such situation Maybe it would be nice to have an assertNonEmpty operator since this could also be useful for other use cases What do you think Materialize and dematerialize are good tool for implementing operators that have behavior based on onError and onCompleted java x from hadValue false x materialize map n if n kind Notification Kind OnNext hadValue true else if n kind Notification Kind OnCompleted hadValue return new Notification new Exception return n dematerialize Thanks @abersnaze It works I added an private assertNonEmpty operator in the Observable I think it s not necessary to be public RxJava pull requests #375 https netflixoss ci cloudbees com job RxJava pull requests 375 FAILURE Looks like there s a problem with this pull request I just had this idea replace the takeLast 1 with takeLast 2 and use a second scan to figure out what to do at the end of the sequence java public Observable T reduce Func2 T T T accumulator Func2 Notification T Notification T Notification T func new Func2 Notification T Notification T Notification T @Override public Notification T call Notification T value Notification T end if end isOnError return end if value null return new Notification T new UnsupportedOperationException Can not apply on an empty sequence return value return create OperationScan scan this accumulator materialize takeLast 2 scan null func dematerialize Sounds good But I m not sure if it s better that using one more scan to eliminate the isEmpty variable It s better that eliminating variable but a little harder to understand I updated this PR to use the new last operator to implement reduce This can be merged now RxJava pull requests #397 https netflixoss ci cloudbees com job RxJava pull requests 397 FAILURE Looks like there s a problem with this pull request It has been fixed in #474',RxJava,true,false,false
21062299,'Fixes Scheduler and Merge','1 Scheduler overload with recursive support Fixed while working with @headinthebox 2 unsubscribe was not propagating to parent Observable on merge Observable Observable T Found and fixed while working with infinite streams Merge was correctly unsubscribing from all children which means it was always working when doing something like merge a b but it wasn t correctly unsubscribing if given a single Observable Observable T','RxJava pull requests #349 https netflixoss ci cloudbees com job RxJava pull requests 349 SUCCESS This pull request looks good',RxJava,true,false,false
21068934,'Kotlin Language Adaptor','Kotlin could be used with RxJava without language adaptors This language adaptor just provide a set of extension functions to enable a more idiomatic usage There are two test classes BasicKotlinTest is just plain Kotlin ExtensionTest is Kotlin with the extensions provided by this adaptor','RxJava pull requests #350 https netflixoss ci cloudbees com job RxJava pull requests 350 FAILURE Looks like there s a problem with this pull request This task is failing language adaptors rxjava scala compileScala FAILED Not related with my Pull Request It s not related to Scala either but the problem is that the jvm ran out of perm gen memory Increasing XX MaxPermSize should solve the problem but I m not sure if this can be done in the gradle files or if it needs changes in the cloudbees config hello any one can help me i am new to github and i want to contribute as i am proficient in java and i can see this project is going with my skills please tell me how to start i dont knw anything how to help so please can anyone guide me thank you Thank you @MarioAriasC for the pull request This is great to have another language added I ll try and get the CloudBees build issue resolved review the structure of the pull request and then merge and release @benjchristensen still the same issue on CloudBees could you please have a look Should not be too hard according to https wiki jenkins ci org display JENKINS Builds failing with OutOfMemoryErrors @samuelgruetter I had increased the PermGen size and it started working for a bit then is failing again so apparently we pushed past the limit I set yet again I ll try another time',RxJava,true,false,false
21235008,'Minimize library size','Hey I am thinking about using the library in an android app but the library size is close to 1mb I saw that the unit tests are being packaged with the production code is there any reason for that Would be possible to reduce the library size','1 Reason https github com Netflix RxJava blob master rxjava core src test java README md Discussed here https github com Netflix RxJava issues 297 Doesn t everyone use ProGuard http developer android com tools help proguard html to strip unused byte code and reduce file size of Android apps anyways which makes this moot Does a couple hundred KB really affect Android apps that significantly particularly in light of ProGuard usage Any further comments on my questions about ProGuard Here at square the android team take a lot of care to keep distributions small This issue does come up as more devs are experimenting with rxjava and it came up again today It is too bad there s a problem with some languages that requires distributing inner test classes in jars If it weren t for this one could consider proguarding rxjava here in the root project and remove work for those consuming in android projects I m hoping someone can be creative and determine a way to address the language issues mentioned so that we can use rxjava without increasing the complexity of proguard config in each project that uses rxjava cc @RayFromSquare Hi @adriancole nice to hear from you If it weren t for this one could consider proguarding rxjava here in the root project and remove work for those consuming in android projects Agreed This is what I used to do not with ProGuard just a simple exclude when creating the jar If this is such a big deal then let s move the unit tests out I still want to know though is it not normal for all Android projects to use ProGuard hi back at you @benjchristensen So we have a number of camps Some don t use proguard at times because some libraries don t work well with proguard like dagger which would lead to custom rules Some here use it minimally for targeted obfuscation but these rules are very simple In short usage isn t universal Interesting thanks for the insight Let s proceed with the unit test refactor Thanks If you have any guideline in mind I can help with the refactor And thx for the awesome library If you can help tackle this @pasviegas I d appreciate it I don t have time in the coming days to do this focused on something else The way I was planning on doing this is taking each inner UnitTest call and refactoring out to a separate class with the same package name and class name Test suffix in the src test path For example Move src main java rx operators OperationAny UnitTest https github com Netflix RxJava blob master rxjava core src main java rx operators OperationAny java#L130 to src test java rx operators OperationAnyTest java thanks @benjchristensen just to keep everyone updated I ll probably send the pull request today Just need to finish couple of classes hehe @pasviegas looking forward to it This has been merged and I ll release a new version soon Thank you @pasviegas for the great and tedious work on this Cool Thank you The library is awesome Thanks @pasviegas',RxJava,false,false,false
21259809,'libGDX support','This is the start of a new contrib project that lays the foundation for RxJava support for libGDX http libgdx badlogicgames com This is still missing tests because it s very difficult to unit test this properly due to the nature of libGDX However I ll be using this a lot in my own Android projects I m not sure whether this should be a contrib subproject of RxJava or maybe a separate repo If you think this should be separate just decline the PR','RxJava pull requests #357 https netflixoss ci cloudbees com job RxJava pull requests 357 FAILURE Looks like there s a problem with this pull request What do you think is the determination for something being contrib or separate To me the benefit of contrib is simplified artifact publishing goes along for the ride and increased visibility for things that are common extensions bindings and add ons The drawback is that the release cycle is tied to RxJava A breaking change in a module will not result in a major revision bump for the RxJava project Thus things are that simple bindings of common projects make perfect sense as contrib modules things we d almost consider putting in core but don t because of dependencies on other libraries Considering that do you think the lifecycle of this library is suited to being part of RxJava or being on its own What is the common model in the JVM world My guess s that at some point RxJava will converge to a stable version and then you want to want to have bindings being released at their own faster pace Erik On Oct 22 2013 at 9 30 PM Ben Christensen notifications@github com wrote What do you think is the determination for something being contrib or separate To me the benefit of contrib is simplified artifact publishing goes along for the ride and increased visibility for things that are common extensions bindings and add ons The drawback is that the release cycle is tied to RxJava A breaking change in a module will not result in a major revision bump for the RxJava project Thus things are that simple bindings of common projects make perfect sense as contrib modules things we d almost consider putting in core but don t because of dependencies on other libraries Considering that do you think the lifecycle of this library is suited to being part of RxJava or being on its own Reply to this email directly or view it on GitHub The release cycle is no problem at all I m just wondering if libgdx is common enough @jmhofer I have no idea about the commonality of libgdx as I don t work in that space I d never heard of it but that doesn t mean much I lean towards this being a separate project but being linked to from here https github com Netflix RxJava wiki#rxjava libraries @headinthebox I have never seen a one size fits all approach Generally the best is to keep them separate and decoupled so they have their own release cycle Submodules work well though when things are tightly coupled but not wanted in the same project so the core stays lean and has less dependencies such as what we re doing with Android Swing in the contrib modules That s exactly what I was trying to say Ben Keep the core as lean as possible then pick and choose what libraries you want On Oct 22 2013 at 9 43 PM Ben Christensen notifications@github com wrote @jmhofer I have no idea about the commonality of libgdx as I don t work in that space I d never heard of it but that doesn t mean much I lean towards this being a separate project but being linked to from here https github com Netflix RxJava wiki#rxjava libraries @headinthebox I have never seen a one size fits all approach Generally the best is to keep them separate and decoupled so they have their own release cycle Submodules work well though when things are tightly coupled but not wanted in the same project so the core stays lean and has less dependencies such as what we re doing with Android Swing in the contrib modules Reply to this email directly or view it on GitHub Keep the core as lean as possible Yes which is why it is a single jar project at this point with no external dependencies The use of rxjava contrib is somewhat fuzzy though as we use it for things that could go in core but we choose not to because they have other dependencies or are extra but are still tightly associated so we want them in the RxJava project and not a 3rd party The rxjava android and rxjava swing contrib modules are good examples of this The rxjava apache http one is murkier It could easily be argued for that to be a separate project and I d probably agree even though I put it there I think it makes sense for this to be kept separate Let s definitely link to it though from https github com Netflix RxJava wiki#rxjava libraries',RxJava,true,false,false
21265913,'Fixed the issue that take does not call onError','I fixed one of the issues in #417 System out println Observable from 1 2 3 take 1 map f toBlockingObservable single is never terminated This issues is because take does not handle the exception throwing from onNext correctly','RxJava pull requests #359 https netflixoss ci cloudbees com job RxJava pull requests 359 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
21329168,'How to execute two observables sequentially','I ve got to http request wrapped by observable Observable T1 request1 Observable T2 request2 I want to execute them sequentially','This will do it Observable concat request1 request2 Yup concat is the one to use I think concat actually don t work well for me Here is simplified problem Observable String geocodeAddressRequest returns address required to create Ride Observable Ride createRideRequest api createRide address i need address from geoCodeAddressRequest to create it I want to have Observable Ride geocodeAddresssThenCreateRideRequest If they are dependent on each other then map flatMap off the first into the second java geocodeAddressRequest flatMap address return api createRide address Thanks Just realized same thing and you replied We need to mark this as question',RxJava,false,false,false
21337737,'OperationSwitch notify onComplete too early','OperationSwitch has to wait that both parent and child complete before complete itself','Patch is mostly a port of https github com Reactive Extensions Rx NET blob master Rx NET Source System Reactive Linq Reactive Linq Observable Switch cs RxJava pull requests #363 https netflixoss ci cloudbees com job RxJava pull requests 363 FAILURE Looks like there s a problem with this pull request RxJava pull requests #364 https netflixoss ci cloudbees com job RxJava pull requests 364 FAILURE Looks like there s a problem with this pull request Thank you @ylecaillez',RxJava,true,false,false
21356071,'How to create observable interval that waits until operation is executed','I need to create observable interval that actually go to next interval only when async operation was finished In net it is possible to achieve with TimeInterval http rxwiki wikidot com 101samples#toc31 I need delay between async calls','So you need to create an new observable every interval such as 100ms Duplicate of issue #90',RxJava,false,false,false
21357074,'Is there delay operation like in Rx NET','Is there delay operation like in Rx NET http rxwiki wikidot com 101samples#toc27','Duplicate of issue #36',RxJava,false,false,false
21365236,'Implemented the Timeout operator','Hi I used SynchronizedObserver to implement the Timeout operator #91 It may be simpler than #434 Considering DateTimeOffset and TimeSpan in C# have the same meaning RxJava only needs 4 overrides I have already implemented all of them Please take a look Thanks','RxJava pull requests #365 https netflixoss ci cloudbees com job RxJava pull requests 365 FAILURE Looks like there s a problem with this pull request Let s evaluate this based on the previous submission and refactor towards simplicity while merging the good parts I ve pulled the other one in so we get the functionality and SerialSubscription and unit tests and now let s iterate on simplifying the concurrency behavior @benjchristensen Do you think which one is better I can help merge these two PRs @zsxwing I would prefer a simpler synchronization model as discussed here https github com Netflix RxJava pull 434#discussion_r6992896',RxJava,true,false,false
21412253,'Caching the result of isInternalImplementation','Currently reflective getPackage call happens on every subscribe invocation This PR sets up a Concurrent HashMap to cache the result of this call per class','RxJava pull requests #367 https netflixoss ci cloudbees com job RxJava pull requests 367 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
21419460,'How to implement polling using Observables','I ve got parametrized rest call with Observable interface api updateAppState params I want to repeat it with delay so I have created delayed version of it Observable AppState delayedApiCall Observable interval delay TimeUnit SECONDS first flatMap new Func1 Long Observable AppState @Override public Observable AppState call Long seconds return lyftApi updateAppState params But now I want to have polling observable that will recreate delayedApiCall with params and produce continuous results I also want observable to continue producing results even if error was returned in delayedApiCall pollingObservable subscribe new Observer AppState onNext AppState appSte onError Throwable e','I think about this implementation Observable create new Observable OnSubscribeFunc AppState public Subscription currentRequest @Override public Subscription onSubscribe final Observer super AppState observer currentRequest createDelayedApiCal subscribe createRequestObserver observer return new Subscription @Override public void unsubscribe currentRequest unsubscribe private Observer AppState createRequestObserver final Observer super AppState observer return new Observer AppState @Override public void onCompleted currentRequest createDelayedApiCal subscribe createRequestObserver observer @Override public void onError Throwable throwable observer onError throwable @Override public void onNext AppState appState observer onNext appState But we have recursive subscribe here Probably this is bad usage of observables Could you share your opinion What about this Observable interval delay TimeUnit SECONDS flatMap new Func1 Long Observable Notification AppState public Observable Notification AppState call Long seconds return lyftApi updateAppState params materialize @samuelgruetter interval won t wait until operation will be completed im also guess that same params will be used for each request in this case Yes 1 What will params depend on 2 Somehow you should make sure that if an updateAppState request is lost in the network and you never get any onNext onComplete or onError you still keep polling That s why I suggested the above approach with interval But you could also combine your recursive approach with the timeout operator PS I had to delete one post because I accidentally hit comment too early on my smartphone Any conclusion on this @benjchristensen probably yes If we will use @samuelgruetter implementation with recently implemented TimeInterval operator Observable interval delay TimeUnit SECONDS timeInterval flatMap new Func1 Long Observable Notification AppState public Observable Notification AppState call Long seconds return lyftApi updateAppState params materialize Also in my case i still have hacky implementation since my delay is dynamic and I need Delay operator to be implemented How about something like this groovy Observable create observer Schedulers newThread schedulePeriodically observer onNext application state from network 0 1000 TimeUnit MILLISECONDS take 10 subscribe v println v Here is Java using manual recursion instead of schedulePeriodically java Observable create new OnSubscribeFunc String @Override public Subscription onSubscribe final Observer super String o return Schedulers newThread schedule 0L new Func2 Scheduler Long Subscription @Override public Subscription call Scheduler inner Long t2 o onNext data from polling return inner schedule t2 this 1000 TimeUnit MILLISECONDS toBlockingObservable forEach new Action1 String @Override public void call String v System out println output v @benjchristensen I think primary problem is that schedulePeriodically do not wait till operation is completed Java ScheduledExecutorService http docs oracle com javase 7 docs api java util concurrent ScheduledExecutorService html has two different methods 1 scheduleWithFixedDelay 2 scheduleAtFixedRate So I think we need to add scheduleWithFixedDelay analog to Rx scheduler @benjchristensen Haven t noticed you second message Thanks a lot for this manual recursion implementation',RxJava,false,false,false
21492304,'Removing println from OperationMerge','','RxJava pull requests #369 https netflixoss ci cloudbees com job RxJava pull requests 369 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
21503151,'Implemented the TimeInterval operator','Hi this PR implemented the TimeInterval operator #90 Please take a look Thanks','RxJava pull requests #370 https netflixoss ci cloudbees com job RxJava pull requests 370 FAILURE Looks like there s a problem with this pull request Looks good thanks @zsxwing',RxJava,true,false,false
21510365,'question how can I show the task progress with RxJava','','This is a snippet of groovy code that will probably do most of what you want java input from 1 2 3 4 we are going to branching off of the input observable three times so cache it cached input cache produce an observable that is the fraction completed In this case 0 25 0 5 0 75 1 fract cached reduce 0 count value count 1 mapMany size cached mapWithIndex value index index 1 size zip the fraction observable with the values to sync the timing of the values coming out with the fraction of completion output Observable zip cached fract value fractionDone side effect to update progress bar with fraction done println done fractionDone return value OR if updating the status of a progress bar produces an observable you ll have to use this for the last zip output Observable merge Observable zip cached fract value fractionDone operation to update progress bar with fraction done results in an observable too update just done fractionDone return zip just value update value2 updateStatus value2 Closing out further conversation can be taken up on https groups google com d forum rxjava',RxJava,false,false,false
21571736,'Implemented the scheduler version of the Return operator','Hi this is the scheduler version of the Return operator #73','RxJava pull requests #371 https netflixoss ci cloudbees com job RxJava pull requests 371 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
21584524,'Fixed issue #417','java public static void main String args System out println started System out println Observable from 1 observeOn Schedulers threadPoolForComputation map f toBlockingObservable single System out println done This issue in #417 is because current map implementation violates the design guild 6 4 Protect calls to user code from within an operator Now current map does not handle the error from the func param which may be user codes When the thread pool scheduler is involved the error from func will throw to the outside and be handled by java util concurrent FutureTask The error will be dropped so the observer will not see it This PR used SafeObserver to protect map from user codes','RxJava pull requests #372 https netflixoss ci cloudbees com job RxJava pull requests 372 FAILURE Looks like there s a problem with this pull request Thank you @zsxwing',RxJava,true,false,false
21652056,'Unsubscribing multiple times','Quoting from an email by @headinthebox to make sure we don t forget about this issue Another bug in RxJava Scala When you create a new subscription it does not remember that is is already disposed In scala using trivial companion object Val s Subscription println hi s unsubscribe s unsubscribe prints hi twice in NET only once In the course I will tell the students it prints only once The issue is already present in Java java public static void main String args Subscription s Subscriptions create new Action0 public void call System out println hi s unsubscribe s unsubscribe also prints hi twice Let s fix this first in Java and then add a companion object Subscription to RxScala','',RxJava,false,false,false
21659652,'Scala Adaptor TODO list and documentation','More complete TODO list for Scala Adaptor and some documentation for CompletenessTest https github com samuelgruetter RxJava blob scalaadaptor language adaptors rxjava scala src test scala rx lang scala CompletenessTest scala','RxJava pull requests #374 https netflixoss ci cloudbees com job RxJava pull requests 374 FAILURE Looks like there s a problem with this pull request I have a fix ready for Bring BooleanSubscription CompositeSubscription MultipleAssignmentSubscription to Scala compositeSubscription subscription instead of setter method add on CompositeSubscription should be From samuelgruetter mailto notifications@github com Sent Sunday October 27 2013 1 21 PM To Netflix RxJava Subject RxJava Scala Adaptor TODO list and documentation #455 More complete TODO list for Scala Adaptor and some documentation for CompletenessTest https github com samuelgruetter RxJava blob scalaadaptor language adaptors rxjava scala src test scala rx lang scala CompletenessTest scala _____ You can merge this Pull Request by running git pull https github com samuelgruetter RxJava scalaadaptor Or view comment on or merge it at https github com Netflix RxJava pull 455 Commit Summary update TODOs according to meeting Merge branch master of github com Netflix RxJava into scalaadaptor add one TODO some documentation for CompletenessTest File Changes M language adaptors rxjava scala TODO md https github com Netflix RxJava pull 455 files#diff 0 49 M language adaptors rxjava scala src test scala rx lang scala CompletenessTest scala https github com Netflix RxJava pull 455 files#diff 1 58 Patch Links https github com Netflix RxJava pull 455 patch https github com Netflix RxJava pull 455 diff',RxJava,true,false,false
21725035,'Question How to consume Observable from client side','Sorry if this is not the best place to ask this but I was looking for some quick suggestions Specifically if my service layer returns an Observable to the controller how does the client side handle the eventual results of that observable Normally you would process the results of the service call in the controller formate the response and send that down to the client What is the best and most FRP way of doing this so as to not tie up the request thread waiting for the results If this question doesn t make sense let me know and I ll try to rephrase Thanks so much for you help in advance','I assume you re referring to having a server side that emits data over a network to a client If so then an async network connection using ServerSentEvents or WebSockets works well to emit the data to the network onNext of each event and then consume that on the client with an Observable consuming the network stream and turning it back into onNext events First of all the RxJava community just rocks Thanks for your quick reply So I think I got it As an example in this article http techblog netflix com 2013 02 rxjava netflix api html it talks about all service calls returning Observables So in the def Observable getVideoGridForDisplay userId method the controller would get the Observable back To render the JSON results and send it back down to the client would the controller block waiting for the onComplete event and then render the results and return in the initial request thread Or would the controller return immediately and send the results down to the client in a web socket connection after the onComplete In a blocking container like Tomcat yes the request thread blocks until onComplete The toBlockingObservable option expose several built in mechanisms for doing this In a non blocking environment like Netty or Servlet 3 1 then you can stay non blocking and write data out from onNext onError and only worry about onCompleted if you have a finite stream close connection Closing out as I haven t heard back on this further conversation can be taken up on https groups google com d forum rxjava or reopen this issue',RxJava,false,false,false
21742721,'Adding utility functions for observables of strings useful for processing non blocking IO','I started developing this for use with the rxjava apache http contrib module to safely and scalable decode infinite observables of byte arrays into strings but thought it should live in core because it could be useful for non blocking disk IO I did not make this part of rx Observable because these operators only work on observables of string The drawback is that discoverability will be harder','RxJava pull requests #376 https netflixoss ci cloudbees com job RxJava pull requests 376 FAILURE Looks like there s a problem with this pull request Open question should static utility classes like this be kept in core or kept external in contrib modules These seems generic enough on Java primitives to be in core as opposed to Swing Android which are kept in contrib modules I d like other feedback before making a decision hello everyone i am new to github and i want to start contributing i am a student of Computer science engg final year with knowledge in java data structure and networking please guide me a bit i found this project and it seems like it matches according to my skills can anyone please help me to start i will be grateful to you @karansinghkjs346 you should ask such question in http groups google com d forum rxjava Your question is irrelevant to this PR However wiki is very helpful for you https github com Netflix RxJava wiki How to Contribute and https github com Netflix RxJava wiki RxJava pull requests #390 https netflixoss ci cloudbees com job RxJava pull requests 390 FAILURE Looks like there s a problem with this pull request RxJava pull requests #391 https netflixoss ci cloudbees com job RxJava pull requests 391 FAILURE Looks like there s a problem with this pull request I have merged your second commit to PR #461 Thanks This looks like useful stuff can you rebase since it can no longer merge cleanly Also I wonder if the assert things should be in something other than BlockingObservable RxJava pull requests #436 https netflixoss ci cloudbees com job RxJava pull requests 436 SUCCESS This pull request looks good That merge picked up a huge number of changes 66 files can you please close this and rebase your changes onto a clean branch',RxJava,true,false,false
21748419,'rxjava android OperationObserveFromAndroidComponent','This is in reference to https github com soundcloud RxJava issues 1 Android applications can use this operator to safely observe a source sequence on the main user interface thread As long as the subscription is unsubscribed from in onDestroy or onDetach no resource leaks will occur I have also added an AndroidObservable class which acts as an entry point for instantiating Android specific observer instances','RxJava pull requests #377 https netflixoss ci cloudbees com job RxJava pull requests 377 FAILURE Looks like there s a problem with this pull request The build failed with an OOM while compiling the Scala module Might just be a configuration issue Regarding CloudBees I ve been trying to increment the memory high enough to get builds working still no luck I may need to get CloudBees support to help @mttkay Would it make sense to change OnSubscribeBase T AndroidComponent isComponentValid implementation to return activity isFinishing in case of an Activity I can send a pull request if you confirm Hi we used to have this but decided it doesn t make sense You might find more information in the GH issue history IIRC the reason was that since the client needs to unsubscribe in onDestroy anyway and since isFinishing is only meaningful during onPause it doesn t really add any value to have this check It s pretty obvious that you re finishing the activity if onDestroy is called and as long as you call unsubscribe in onDestroy all is good On Mon Nov 4 2013 at 11 45 AM V r s Gyula notifications@github com wrote @mttkay https github com mttkay Would it make sense to change OnSubscribeBase isComponentValid implementation to return activity isFinishing in case of an Activity I can send a pull request if you confirm Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 458#issuecomment 27676781',RxJava,true,false,false
21756191,'Fixed issue #454','Hi I used SafeObservableSubscription to fix the issue #454','RxJava pull requests #378 https netflixoss ci cloudbees com job RxJava pull requests 378 FAILURE Looks like there s a problem with this pull request Thanks',RxJava,true,false,false
21955830,'Implemented the Amb operator','Hi this PR implemented the Amb operator #22 I used varargs to support the array version and first second version in one method So in my PR there are only two variants','RxJava pull requests #379 https netflixoss ci cloudbees com job RxJava pull requests 379 FAILURE Looks like there s a problem with this pull request You shouldn t define a vararg method taking a generic type because you cannot use it without getting warnings we ve already had this with other operators Instead define an overload for 2 args 3 args 4 args Yup it s a pain but this is what we ended up doing for zip merge etc instead of using varargs RxJava pull requests #382 https netflixoss ci cloudbees com job RxJava pull requests 382 FAILURE Looks like there s a problem with this pull request Thank you',RxJava,true,false,false
21961128,'Added sleep to avoid testMapWithErrorInFuncAndThreadPoolScheduler fails','Hi due to my mistake testMapWithErrorInFuncAndThreadPoolScheduler may fail in some situation Sorry for that I fixed it in this PR','RxJava pull requests #380 https netflixoss ci cloudbees com job RxJava pull requests 380 FAILURE Looks like there s a problem with this pull request It is preferable to use a CountDownLatch instead of sleep or the TestScheduler CloudBees in particular demonstrates the non determinism of Thread sleep for unit tests I updated the PR and used TestScheduler RxJava pull requests #381 https netflixoss ci cloudbees com job RxJava pull requests 381 FAILURE Looks like there s a problem with this pull request Due to pull request https github com Netflix RxJava pull 466 which touched virtually every file in the project can you please rebase this so it can merge cleanly again I have rebased it RxJava pull requests #389 https netflixoss ci cloudbees com job RxJava pull requests 389 FAILURE Looks like there s a problem with this pull request RxJava pull requests #392 https netflixoss ci cloudbees com job RxJava pull requests 392 FAILURE Looks like there s a problem with this pull request RxJava pull requests #393 https netflixoss ci cloudbees com job RxJava pull requests 393 FAILURE Looks like there s a problem with this pull request RxJava pull requests #394 https netflixoss ci cloudbees com job RxJava pull requests 394 FAILURE Looks like there s a problem with this pull request It has been fixed in #473',RxJava,true,false,false
22003215,'Subscribing to a completed BehaviorSubject','In C# when I subscribe to an already completed BehaviorSubject I only get an onComplete as illustrated by this example cs static void Main var o new List int 1 2 3 ToObservable var subject new BehaviorSubject int 0 o Subscribe subject subject Subscribe i Console WriteLine i e Console WriteLine e Message Console WriteLine complete Console WriteLine done Console ReadLine outputs complete done In the current Java implementation I only get the last element and no onComplete java Observable Integer o Observable from 1 2 3 BehaviorSubject Integer subject BehaviorSubject createWithDefaultValue 0 o subscribe subject subject subscribe new Action1 Integer public void call Integer i System out println i new Action1 Throwable public void call Throwable t t printStackTrace new Action0 public void call System out println complete System out println done outputs 3 done And intuitively I would expect that I get both the last element and onComplete So we have 3 options Which one should RxJava choose','I m asking this because maybe we can use BehaviorSubject to implement the delay https github com Netflix RxJava pull 384 operator Fixed in https github com Netflix RxJava commit 564fba0fbac16bb50e998cca30e2576e448705de',RxJava,false,false,false
22017657,'Added the rest overloads of Timeout operator','Hi this PR implemented the rest overloads of Timeout operator #91 Please take a look Thanks','RxJava pull requests #383 https netflixoss ci cloudbees com job RxJava pull requests 383 FAILURE Looks like there s a problem with this pull request Due to pull request https github com Netflix RxJava pull 466 which touched virtually every file in the project can you please rebase this so it can merge cleanly again RxJava pull requests #388 https netflixoss ci cloudbees com job RxJava pull requests 388 FAILURE Looks like there s a problem with this pull request I have rebased it Thank you @zsxwing',RxJava,true,false,false
22032653,'question Is it right that rx observables BlockingObservable last returns null when the Observable is empty','Now rx observables BlockingObservable last return null when the Observable is empty However null is a valid value in an Observable So when last returns null we can not make a distinction between these two situations I think throwing an IndexOutOfBoundException is more reasonable','Have fixed in #470',RxJava,false,false,false
22036663,'Moving unit tests to test source folders #439','','RxJava pull requests #385 https netflixoss ci cloudbees com job RxJava pull requests 385 FAILURE Looks like there s a problem with this pull request That is an impressive amount of work @pasviegas and changes look mostly clean I have to say this reminds me why I prefer not having tests separated Not thrilled with some of the privates being made package public especially on ones where it breaks the singleton contract I m looking at those right now so I can try and merge without sacrificing those before anything else in the codebase changes and causes conflicts as this is a nasty thing to merge with conflicts I have merged these changes Thank you',RxJava,true,false,false
22098726,'Refactor Unit Tests from Inner Classes to src test','Manual merge of and additions to pull request https github com Netflix RxJava pull 465 to refactor unit tests from inner classes to separate src test folder to accomplish issue https github com Netflix RxJava issues 439 minimize library size Great work by @pasviegas on this pull request','RxJava pull requests #386 https netflixoss ci cloudbees com job RxJava pull requests 386 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
22098878,'Merge Amb Operator in PR https github com Netflix RxJava pull 460','Split unit tests out while merging','RxJava pull requests #387 https netflixoss ci cloudbees com job RxJava pull requests 387 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
22132435,'Unsubscribe is not propagated through a mapMany operation','If you have an Observable and you mapMany from it calling unsubscribe from the last Observable in the chain does not propagate unsubscribe through to the initial Observable This is a particular problem for infinite sequence Observables such as Observable interval as they will now never terminate The following test demonstrates this package tests import org junit Test import rx Observable import rx Observer import rx Subscription import rx concurrency Schedulers import rx subscriptions Subscriptions import rx util functions Func1 import java util concurrent TimeUnit public class UnsubscribeTest @Test public void testUnsubscribe throws InterruptedException Subscription sub Observable interval 1 TimeUnit SECONDS map new Func1 Long Long @Override public Long call Long aLong System out println generated aLong return aLong mapMany new Func1 Long Observable Long @Override public Observable Long call final Long aLong return Observable create new Observable OnSubscribeFunc Long @Override public Subscription onSubscribe Observer super Long observer System out println mapMany for aLong observer onNext aLong return Subscriptions empty subscribeOn Schedulers currentThread observeOn Schedulers currentThread subscribe new Observer Long @Override public void onCompleted To change body of implemented methods use File Settings File Templates @Override public void onError Throwable e To change body of implemented methods use File Settings File Templates @Override public void onNext Long args System out println Received args Thread sleep 3000 System out println Calling unsubscribe sub unsubscribe Thread sleep 3000 The output from running this is as follows generated 0 mapMany for 0 Received 0 generated 1 mapMany for 1 Received 1 generated 2 mapMany for 2 Received 2 Calling unsubscribe generated 3 generated 4 generated 5 From this you can see that unsubscribing from the mapMany Observable is not terminating the interval Observable','Which version did you test I ran your test in the latest version and the output is pre generated 0 mapMany for 0 Received 0 generated 1 mapMany for 1 Received 1 generated 2 mapMany for 2 Received 2 Calling unsubscribe pre Awesome yes it is fixed in 0 14 8 I was using 0 14 2 thanks',RxJava,false,false,false
22160943,'Why are PublishSubject etc considered internal not needed by users in scala lang','https github com Netflix RxJava blob master language adaptors rxjava scala src main scala rx lang scala subjects package scala#L40 I have an instance in an Akka Actor where I d like to pass back an Observable to the a client and then manually convert messages passed to that actor as events on that observable for the client to handle I can do this with scala val ps PublishSubject create Int val o Observable ps send o to client on incoming message ps onNext i Which works fine but it seems like shows that PublishSubject can be used in a not internal way and I certainly would use one out of the scala lang package instead of having to dip outside of it I haven t used RxJava much but I used to do this with a NET Rx project a lot where objects would manage observables and converting non IObservable pattern events into events on those observables Is there a better way to convert Akka message streams arbitrary non RxJava streams into Observable events that I am missing','Probably they have just not been wrapped yet by those contributing to the scala lang module Here is a blog post from @jmhofer working with Akka http jmhofer johoop de p 507 You can see some background on the Scala support being added here https github com Netflix RxJava issues 336 and learn more about the implementation via this presentation starting around the 52 minute mark http youtu be tOMK_FYJREw t 52m13s You can get involved and contribute to this module https github com Netflix RxJava tree master language adaptors rxjava scala Thanks for the resources I ll take a look I worked in C# for years and used Rx extensively I m glad to see it make it s way into scala I ll see what I can contribute Cheers Rob It s me who wrote that PublishSubject etc are considered internal not needed by users but that s wrong please discard it I think @headinthebox started wanted to start writing Scala bindings for these subjects but I m not sure what the status is',RxJava,false,false,false
22242364,'Operator Last','Adds Observable last and fixes behavior of BlockingObservable last based on email discussion with @headinthebox','RxJava pull requests #395 https netflixoss ci cloudbees com job RxJava pull requests 395 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
22243583,'Unit Test Tweaks','','',RxJava,true,false,false
22244469,'BugFix Issue 431 Unsubscribe with Schedulers newThread','Fix bug Unsubscribing does not work when using subscribeOn Schedulers newThread I believe this fixes https github com Netflix RxJava issues 431 The NewThreadScheduler was not using DiscardableAction that supports being unsubscribed','RxJava pull requests #396 https netflixoss ci cloudbees com job RxJava pull requests 396 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
22303924,'Fix non deterministic unit test','the latch was before onError is called use BlockingObservable and expect the IllegalArgumentException to be thrown','RxJava pull requests #398 https netflixoss ci cloudbees com job RxJava pull requests 398 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
22304569,'BugFix Reduce an empty observable','This fixes issue https github com Netflix RxJava issues 423 The fix is based on this comment by @headinthebox https github com Netflix RxJava issues 423#issuecomment 27642532 Thank you @zsxwing for your involvement on this If I have mis interpreted the results of the discussion and this is still wrong please correct me Here is the unit test asserting the behavior java A reduce should fail with an IllegalArgumentException if done on an empty Observable @Test expected IllegalArgumentException class public void testReduceWithEmptyObservable Observable Integer observable Observable range 1 0 observable reduce new Func2 Integer Integer Integer @Override public Integer call Integer t1 Integer t2 return t1 t2 toBlockingObservable forEach new Action1 Integer @Override public void call Integer t1 do nothing we expect an exception instead fail Expected an exception to be thrown','RxJava pull requests #399 https netflixoss ci cloudbees com job RxJava pull requests 399 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
22304793,'Additional unit test for reduce','','RxJava pull requests #400 https netflixoss ci cloudbees com job RxJava pull requests 400 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
22305438,'Don t emit null onComplete when no onNext received in AsyncSubject','Reported via email by @axel22 and @headinthebox','RxJava pull requests #401 https netflixoss ci cloudbees com job RxJava pull requests 401 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
22306027,'CompositeSubscription bugfixes','remove now also unsubscribes the removed subscription added clear method','RxJava pull requests #402 https netflixoss ci cloudbees com job RxJava pull requests 402 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
22314015,'Implemented the Operator Min and MinBy and Operator Max and MaxBy','Hi this PR implemented the Operator Min and MinBy #63 and Operator Max and MaxBy #61 Every operator has 2 variants one for Comparable another for Comparator Please take a look','RxJava pull requests #404 https netflixoss ci cloudbees com job RxJava pull requests 404 SUCCESS This pull request looks good OperationMin and OperationMax are exactly the same except that and are swapped Can t you implement one in terms of the other Or create a general one which takes 1 or 1 to know whether we want or Is the following solution OK Java public static T extends Comparable T Observable T min Observable T source return minMax source 1 public static T extends Comparable T Observable T max Observable T source return minMax source 1 public static T extends Comparable T Observable T minMax Observable T source final long flag return source reduce new Func2 T T T @Override public T call T acc T value if flag acc compareTo value 0 return acc return value flag must be long as Integer MIN_VALUE 1 Integer MIN_VALUE But we will have one multiplication for every compareTo Another solution is java public static T extends Comparable T Observable T min Observable T source return minMax source true public static T extends Comparable T Observable T max Observable T source return minMax source false public static T extends Comparable T Observable T minMax Observable T source final boolean isMin return source reduce new Func2 T T T @Override public T call T acc T value if isMin if acc compareTo value 0 return acc else if acc compareTo value 0 return acc return value @samuelgruetter do you have other better solution I like both of these two solutions with a slight preference for the first one Nice catch with Integer MIN_VALUE A third solution would be to implement max using min and wrapping the given comparator such that it inverts the ordering but I think the first solution is the best Another issue What if there are several minimal elements Does min return the first of them the last of them or is it unspecified This should be documented @samuelgruetter Thanks fro your review I used the 1 1 way to implement it and also updated the document RxJava pull requests #407 https netflixoss ci cloudbees com job RxJava pull requests 407 SUCCESS This pull request looks good Looks good @zsxwing and thanks @samuelgruetter for the review Some nice use of generics in those signatures',RxJava,true,false,false
22314020,'Adds doOnEach operator','I thought this would be a good and simple way to start getting my feet wet with RxJava This implements #40 Any feedback would be great Thanks Scott','Thank you @nullstyle for this PR I always wanted to have doOnEach but never had time to implement it One issue to discuss What should happen if an exception is thrown during the execution of the onNext onError onComplete function passed to doOnEach I m not sure and I don t have a computer right now to test it but I d answer as follows exception in onNext catch and call onError the same way as map does exception in onError or onComplete this must not happen Can someone please test it in C# and correct me if needed Good point I handn t considered behavior when the observer provided to doOnEach is the source of the exception I ll write up a simple C# app to investigate how it behaves Looking at the source for Rx I don t have access to a windows machine at the moment it seems that any errors in the actions provided to Do will call onError on the downstream observables as expressed by this snippet c# public void OnNext TSource value try _parent _onNext value catch Exception ex base _observer OnError ex base Dispose return base _observer OnNext value I ll update my implementation tonight to provide consistent behavior and add some test cases to cover it RxJava pull requests #408 https netflixoss ci cloudbees com job RxJava pull requests 408 SUCCESS This pull request looks good That s correct anytime a user function is invoked it must have error handling around it We sometimes use try catch other times wrap with SafeObserver Thank you for contributing Looks good Only change I d make is put the Observer Action wrappers inside the Operation class so we reduce code in Observable since that class is huge Merging now Thank you for getting involved Thanks for merging I ll work on a separate PR to refactor that code into the operation class this weekend when I get some time Scott',RxJava,true,false,false
22318111,'BugFix Emit an IllegalArgumentException instead of ArithmeticException if the observable is empty','This PR fixed the average issue in #423 If an observable is empty average will emit an IllegalArgumentException instead of ArithmeticException Thanks','RxJava pull requests #405 https netflixoss ci cloudbees com job RxJava pull requests 405 SUCCESS This pull request looks good',RxJava,true,false,false
22441883,'Implement the Using operator','Hi this PR implemented the Using operator #99 Please take a look Thanks','RxJava pull requests #406 https netflixoss ci cloudbees com job RxJava pull requests 406 SUCCESS This pull request looks good Interesting operator hadn t really ever looked at this one Thank you @zsxwing for the implementation',RxJava,true,false,false
22627023,'Wiki documentation missing link','I cannot find rxjava examples supposedly at https github com Netflix RxJava tree master rxjava examples src main which is linked from https github com Netflix RxJava wiki Getting Started','Forgot to change those We started out having a single example project but it didn t work as the number of languages expanded so we ended up moving examples into each language https github com Netflix RxJava tree master language adaptors rxjava groovy src examples https github com Netflix RxJava tree master language adaptors rxjava scala src examples https github com Netflix RxJava tree master language adaptors rxjava clojure src examples etc Updated on wiki',RxJava,false,false,false
22631544,'DoOn Tweaks','do not have 2 method overloads with similar method signatures dynamic languages can not negotiate method dispatch using function arity add doOnCompleted and doOnError methods instead of different doOnEach overloads This is a very slight breaking change by deleting a method added in the last release I did not catch this when I did the code review','@nullstyle take note of this as you re planning on refactoring this code somewhat also as an example of design we need to account for due to the polyglot nature of the library RxJava pull requests #409 https netflixoss ci cloudbees com job RxJava pull requests 409 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
22721283,'Observable a b c zip Observable interval 100 millis never terminates','Hi I m new to RxJava please forgive me if this question feels too trivial I m currently learning by playing in Scala and I was surprised by the observation that scala import rx lang scala _ import scala concurrent duration _ Observable a b c zip Observable interval 100 millis toBlockingObservable toList never terminates After reading the description of zip I was under the impression that it should complete after the the shorter one of the two sequences completes which in this case is the abc the interval is infinite I d expect the zip to unsubscribe from the collections that have not terminated yet after the first one completes but it seems not to behave like that Is the current behavior intentional Thank you Tom Dvo k','The current behavior is not what it should be I ve already reported an issue for this https github com Netflix RxJava issues 387 but no one has fixed it yet Pull requests are welcome The fix is not trivial I spent some time on it last week and fixing this case is simple but it breaks other use cases In practice I think the operator needs to be re implemented from scratch instead of just tweaked for this case This should now be fixed as the zip fixes have been merged',RxJava,false,false,false
22763595,'Added aliases and objects for concrete subject types in Scala','AsyncSubject T BehaviorSubject T PublishSubject T ReplaySubject T','RxJava pull requests #410 https netflixoss ci cloudbees com job RxJava pull requests 410 SUCCESS This pull request looks good This is not really helping as subjects are unrelated to rx lang scala Observable At this point I believe we need to give up on transparent interop from Scala to Java I am finishing up a binding that feels more native Scala and is very close to what I catually promise in my slides Object Observable trait Observable T def asJavaObservable rx Observable _ T object Observer trait Observer T def asJavaObserver rx Observer _ T object Subject trait Subject T R extends Observable R with Observer T val asJavaSubject rx subjects Subject _ T _ R object Scheduler trait Scheduler def asJavaScheduler rx Scheduler object Notification trait Notification T def asJavaNotification rx Notification _ T object Subscription trait Subscription def asJavaSubscription rx Subscription From Rob Emanuele mailto notifications@github com Sent Friday November 15 2013 2 38 PM To Netflix RxJava Subject RxJava Added aliases and objects for concrete subject types in Scala #485 AsyncSubject T BehaviorSubject T PublishSubject T ReplaySubject T _____ You can merge this Pull Request by running git pull https github com lossyrob RxJava subjects Or view comment on or merge it at https github com Netflix RxJava pull 485 Commit Summary Added aliases and objects for concrete subject types File Changes M language adaptors rxjava scala TODO md https github com Netflix RxJava pull 485 files#diff 0 1 M language adaptors rxjava scala src main scala rx lang scala subjects package scala https github com Netflix RxJava pull 485 files#diff 1 78 M rxjava core src main java rx subjects AsyncSubject java https github com Netflix RxJava pull 485 files#diff 2 2 M rxjava core src main java rx subjects PublishSubject java https github com Netflix RxJava pull 485 files#diff 3 2 Patch Links https github com Netflix RxJava pull 485 patch https github com Netflix RxJava pull 485 diff Fair I wanted to use PublishSubjects idiomatically from Scala and wrapping them was in the TODO list but if something better is in the pipeline then that s great Is there a link to the slides you mention',RxJava,true,false,false
22771165,'BugFix AsyncSubject','it was not emitting values to observers that subscribed after onCompleted onError','RxJava pull requests #411 https netflixoss ci cloudbees com job RxJava pull requests 411 SUCCESS This pull request looks good',RxJava,true,false,false
22771787,'Javadoc improements','Adding marble diagrams making the javadocs more consistent in their terminology formatting','RxJava pull requests #412 https netflixoss ci cloudbees com job RxJava pull requests 412 FAILURE Looks like there s a problem with this pull request David this is conflicting and can t merge Yeah I m trying to move over to sourcetree and I m still climbing the learning curve I think I still find git a little baffling in terms of what things I do are local and what things affect the shared repository I tried to merge just the changes in Observable java w o the ones in other files but I m not sure if I successfully pushed my results I ll try to be more methodical today and see if I can get it right On Mon Nov 18 2013 at 8 35 PM Ben Christensen notifications@github com wrote David this is conflicting and can t merge Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 487#issuecomment 28764596 David M Gross PLP Consulting',RxJava,true,false,false
22772473,'Possible Interop with Spring Reactor','Hi Reactor pattern is very much related to Observable So is it possible to have some level of interop with Reactor https github com reactor reactor Suminda','Bindings for it would make sense but probably as part of Reactor itself It doesn t make sense for RxJava itself to try and have bindings for every possible 3rd party library out there and their different release cycles I see you already opened an issue there https github com reactor reactor issues 213 There is a good fit here Only minor concern is if there is an impedance mismatch on speed Reactor Selector based dispatching w dynamic Consumer assignment 10 15M events sec Reactor Selector based dispatching w o dynamic Consumer assignment 20 25M events sec Reactor Processor LMAX Disruptor wrapper no dispatching at all fixed Consumer 90 100M events sec Reactor TCP syslog to HDFS 600k messages sec Source https groups google com d msg reactor framework e3q9IqOKHdk Et9zuw896JEJ If there are performance issues then we should fix them If you make progress on this please let the RxJava community know and if you find performance bottlenecks please help identity and or fix them',RxJava,false,false,false
22775734,'Skip and Concat in Scala Version','In case developers are using both the Scala and Java version is it possible to add Skip and Concat also for consistency but also retain the Scala version','That s not necessary thanks to Scala s value classes In bytecode rx lang scala Observable appears as rx lang scala Observable for the Scala compiler but it appears as rx Observable for the Java compiler So if you write Java code you use skip and concat and if you write Scala code you use drop and To see how this value class magic works have a look at the MovieLib example which consists of MovieLib scala https github com Netflix RxJava blob master language adaptors rxjava scala src examples scala rx lang scala examples MovieLib scala and MovieLibUsage java https github com Netflix RxJava blob master language adaptors rxjava scala src examples java rx lang scala examples MovieLibUsage java Scala bindings are further improving in 0 16 0 and it no longer attempts to transparently interop between Java and Scala Therefore developers will know and can choose which they are working with See https github com Netflix RxJava pull 598 for more details',RxJava,false,false,false
22797875,'Scala Adaptor Inheritance subscriptions and subjects','I tried to add subscriptions and subjects using the value class trick and came to the conclusion that it won t work The problem is that inheritance and value classes don t work together because value classes cannot be extended We want Observable to be a value class and at the same time we want Subject to extend Observable so that doesn t work This PR is very similar to Erik s code https github com headinthebox ScalaBindingsRecent but I added a trait scala trait JavaWrapper W def asJava W which all classes extend This allows us to have an asJava method everywhere instead of asJavaSubject asJavaObserver etc The main challenge was to get the double inheritance Subject extends Observer and Observable working Now all wrappers are done the same way For instance Observable looks as follows scala trait Observable T extends JavaWrapper rx Observable _ T object Observable private Observable class ObservableWrapper T val asJava rx Observable _ T extends Observable T def apply T asJava rx Observable _ T Observable T new ObservableWrapper T asJava In Scala code to convert from Scala types to Java types there s the asJava method and to convert from Java types to Scala types there s an apply method in each companion object When we used value classes such conversions were not necessary in Java because Scala types appeared as Java types for the Java compiler Now they become necessary but note that this PR does not yet contain such conversions but that should be no big problem','RxJava pull requests #413 https netflixoss ci cloudbees com job RxJava pull requests 413 SUCCESS This pull request looks good I m reviewing this with Erik tomorrow and will get this or some variant of it pulled in Yes this PR is incomplete closing',RxJava,true,false,false
22818832,'Baseline checkin for Android sample app','Began work on a sample Android app to help myself understand Rx as applied to a Java client Thought it would be useful for others to see comment on improve and add to Have discussed with @mttkay he has offered to review and possibly contribute as well Greg','RxJava pull requests #414 https netflixoss ci cloudbees com job RxJava pull requests 414 SUCCESS This pull request looks good Thanks Greg I m at the GDE Summit for the next few days but will definitely get to it later this week One thing I noticed we should probably not push Eclipse project files IDE project files can be easily generated from POMs and Gradle build scripts this is also considering that Google is moving quickly to Android Studio which is based around Gradle and IntelliJ I usually try not to alienate any users based on their choice of IDE Let me see if I can contribute a Gradle build file that should be easy since I already had a sandbox style Adnroid Studio project for RxJava stuff on Android here Good work That would be helpful thanks I was unsure about including the eclipse files and I know it s a bit old school The biggest reason was to include the lib pointers but I imagine Gradle has a way of doing that I ll try to look into it more this week g On Mon Nov 18 2013 at 9 16 AM Matthias K ppler notifications@github com wrote Thanks Greg I m at the GDE Summit for the next few days but will definitely get to it later this week One thing I noticed we should probably not push Eclipse project files IDE project files can be easily generated from POMs and Gradle build scripts this is also considering that Google is moving quickly to Android Studio which is based around Gradle and IntelliJ I usually try not to alienate any users based on their choice of IDE Let me see if I can contribute a Gradle build file that should be easy since I already had a sandbox style Adnroid Studio project for RxJava stuff on Android here Good work Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 491#issuecomment 28717758 Closing this out while the work is being done please submit a new one once ready',RxJava,true,false,false
22829267,'Implement the scheduler overloads for Range From StartWith','Hi this PR implemented the scheduler overloads for Range #68 From #98 StartWith #82 Please take a look Thanks','RxJava pull requests #415 https netflixoss ci cloudbees com job RxJava pull requests 415 SUCCESS This pull request looks good This conflicts and can t merge Can you rebase and update the PR please I have updated the PR RxJava pull requests #420 https netflixoss ci cloudbees com job RxJava pull requests 420 SUCCESS This pull request looks good Thanks',RxJava,true,false,false
22857181,'Zip many from scratch missing concat of iterable','','RxJava pull requests #416 https netflixoss ci cloudbees com job RxJava pull requests 416 SUCCESS This pull request looks good RxJava pull requests #417 https netflixoss ci cloudbees com job RxJava pull requests 417 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
22859722,'Operators without co or contravariance','I m looking at the operator definition and found a bunch of places where the lambda functions do not have wildcard bounds specified e g reduce Func2 T T T max Comparator T etc Is there a particular reason these are not reduce Func2 super T super T extends T max Comparator super T','reduce That s a long story see https github com Netflix RxJava pull 369 https github com Netflix RxJava issues 360 and https github com Netflix RxJava issues 336#issuecomment 24094254 In short It s considered unnecessary or not necessary enough to complicate the signature Note though that the signature of reduce is not entirely correct because the covariant type parameter T appears in a contravariant position so you can t use reduce on an Observable extends XXX but only on an Observable XXX To fix this one would need lower bounds for type parameters but Java doesn t support this min max IMHO it would be a good idea to add wildcards what do others think I agree with you I ll fix it It seems we can close this issue now',RxJava,false,false,false
22873108,'Zip many rewritten Concat with iterable Merge with Iterable','I ve rewritten the Zip method to terminate as soon as possible In addition the concat Iterable Observable T and merge Iterable Observable T where missing from Observable','RxJava pull requests #418 https netflixoss ci cloudbees com job RxJava pull requests 418 SUCCESS This pull request looks good @akarnokd Thank you for this I m checking out the branch now to play with it and see how the problematic unit tests behave Would you mind re submitting the pull request though after rebasing this onto a new branch so we don t have all the commit clutter resulting from you working on your master branch The commit Merge origin master https github com akarnokd RxJava commit 0dcbe89f291f3a77f8bbbd5cefd745a12600c40e and commits before that are a result of merging Netflix RxJava master into your master then submitting back from the same branch It is preferable to always commit only to a clean branch and submit a pull request from that so only the relevant commits are applied The only time anything should commit to your forked master is when fetching from the upstream to sync back up Thanks I want to confirm a unit test for this code @headinthebox can you please validate something The following unit test shows how this will correctly complete once the first stream completes However it still waits until ALL items are emitted before the onCompleted is sent I want to ensure that s how it should behave as opposed to skipping those and completing as soon as onComplete is sent like onError should java @Test public void testOnFirstCompletion PublishSubject String oA PublishSubject create PublishSubject String oB PublishSubject create @SuppressWarnings unchecked Observer String observer mock Observer class Observable String o Observable create zip oA oB getConcat2Strings o subscribe observer InOrder inOrder inOrder observer oA onNext a1 inOrder verify observer never onNext anyString oB onNext b1 inOrder verify observer times 1 onNext a1 b1 oB onNext b2 inOrder verify observer never onNext anyString oA onNext a2 inOrder verify observer times 1 onNext a2 b2 oA onNext a3 oA onNext a4 oA onNext a5 oA onCompleted SHOULD ONCOMPLETE BE EMITTED HERE INSTEAD OF WAITING FOR B3 B4 B5 TO BE EMITTED oB onNext b3 oB onNext b4 oB onNext b5 inOrder verify observer times 1 onNext a3 b3 inOrder verify observer times 1 onNext a4 b4 inOrder verify observer times 1 onNext a5 b5 WE RECEIVE THE ONCOMPLETE HERE inOrder verify observer times 1 onCompleted oB onNext b6 oB onNext b7 oB onNext b8 oB onNext b9 never completes infinite stream for example we should receive nothing else despite oB continuing after oA completed inOrder verifyNoMoreInteractions private Func2 String String String getConcat2Strings return new Func2 String String String @Override public String call String t1 String t2 return t1 t2 This confirms the onError event is propagated immediately java @Test public void testOnErrorTermination PublishSubject String oA PublishSubject create PublishSubject String oB PublishSubject create @SuppressWarnings unchecked Observer String observer mock Observer class Observable String o Observable create zip oA oB getConcat2Strings o subscribe observer InOrder inOrder inOrder observer oA onNext a1 inOrder verify observer never onNext anyString oB onNext b1 inOrder verify observer times 1 onNext a1 b1 oB onNext b2 inOrder verify observer never onNext anyString oA onNext a2 inOrder verify observer times 1 onNext a2 b2 oA onNext a3 oA onNext a4 oA onNext a5 oA onError new RuntimeException forced failure it should emit failure immediately inOrder verify observer times 1 onError any RuntimeException class oB onNext b3 oB onNext b4 oB onNext b5 oB onNext b6 oB onNext b7 oB onNext b8 oB onNext b9 never completes infinite stream for example we should receive nothing else despite oB continuing after oA completed inOrder verifyNoMoreInteractions Sorry for the clutter I m new to Git in this manner Will do a new pull shortly Sorry for the clutter I m new to Git in this manner Will do a new pull shortly Not a problem the Git flow for pull requests is not obvious when first starting I totally messed up a few repos when I first started had to wipe them out and start fresh with clean forks until I got the hang of it Closing as replaced by https github com Netflix RxJava pull 497',RxJava,true,false,false
22887162,'Add contravariant for min and max','Hi this PR added contravariant for min and max mentioned in #494','RxJava pull requests #419 https netflixoss ci cloudbees com job RxJava pull requests 419 SUCCESS This pull request looks good',RxJava,true,false,false
22896342,'Zip rewritten from scratch','I hope I managed a clean branch this time','RxJava pull requests #421 https netflixoss ci cloudbees com job RxJava pull requests 421 SUCCESS This pull request looks good That is much cleaner thank you I ll review this again once I get some time',RxJava,true,false,false
22928428,'Implement the Repeat operator','Hi this PR implemented the Repeat operator #70 Please take a look Thanks','RxJava pull requests #422 https netflixoss ci cloudbees com job RxJava pull requests 422 SUCCESS This pull request looks good I believe this stack overflows java Observable from 1 repeat toBlockingObservable forEach new Action1 Integer @Override public void call Integer t1 Stacktrace java lang RuntimeException java lang StackOverflowError at rx observables BlockingObservable forEach BlockingObservable java 159 at rx operators OperationRepeatTest main OperationRepeatTest java 39 Caused by java lang StackOverflowError at java util HashMap Entry init HashMap java 814 at java util HashMap createEntry HashMap java 901 at java util HashMap addEntry HashMap java 888 at java util HashMap put HashMap java 509 at rx subjects ReplaySubject SubscriptionFunc call ReplaySubject java 115 at rx subjects ReplaySubject SubscriptionFunc call ReplaySubject java 1 at rx subjects ReplaySubject DelegateSubscriptionFunc onSubscribe ReplaySubject java 84 at rx Observable subscribe Observable java 224 at rx operators OperationMulticast MulticastConnectableObservable 1 onSubscribe OperationMulticast java 41 at rx Observable subscribe Observable java 224 at rx operators OperationObserveOn ObserveOn onSubscribe OperationObserveOn java 50 at rx Observable subscribe Observable java 224 at rx operators OperationRepeat 1 1 onCompleted OperationRepeat java 82 at rx subjects ReplaySubject onCompleted ReplaySubject java 141 at rx operators OperationMulticast MulticastConnectableObservable 2 onCompleted OperationMulticast java 54 at rx operators OperationToObservableIterable ToObservableIterable onSubscribe OperationToObservableIterable java 48 at rx Observable subscribe Observable java 224 at rx operators OperationMulticast MulticastConnectableObservable connect OperationMulticast java 51 at rx operators OperationRepeat 1 1 onCompleted OperationRepeat java 83 at rx subjects ReplaySubject onCompleted ReplaySubject java 141 at rx operators OperationMulticast MulticastConnectableObservable 2 onCompleted OperationMulticast java 54 at rx operators OperationToObservableIterable ToObservableIterable onSubscribe OperationToObservableIterable java 48 at rx Observable subscribe Observable java 224 at rx operators OperationMulticast MulticastConnectableObservable connect OperationMulticast java 51 at rx operators OperationRepeat 1 1 onCompleted OperationRepeat java 83 at rx subjects ReplaySubject onCompleted ReplaySubject java 141 at rx operators OperationMulticast MulticastConnectableObservable 2 onCompleted OperationMulticast java 54 at rx operators OperationToObservableIterable ToObservableIterable onSubscribe OperationToObservableIterable java 48 at rx Observable subscribe Observable java 224 at rx operators OperationMulticast MulticastConnectableObservable connect OperationMulticast java 51 at rx operators OperationRepeat 1 1 onCompleted OperationRepeat java 83 at rx subjects ReplaySubject onCompleted ReplaySubject java 141 at rx operators OperationMulticast MulticastConnectableObservable 2 onCompleted OperationMulticast java 54 at rx operators OperationToObservableIterable ToObservableIterable onSubscribe OperationToObservableIterable java 48 at rx Observable subscribe Observable java 224 at rx operators OperationMulticast MulticastConnectableObservable connect OperationMulticast java 51 at rx operators OperationRepeat 1 1 onCompleted OperationRepeat java 83 at rx subjects ReplaySubject onCompleted ReplaySubject java 141 at rx operators OperationMulticast MulticastConnectableObservable 2 onCompleted OperationMulticast java 54 at rx operators OperationToObservableIterable ToObservableIterable onSubscribe OperationToObservableIterable java 48 at rx Observable subscribe Observable java 224 etc If Subscriptions has not been touched before the StackOverflow you will instead see this java lang NoClassDefFoundError Could not initialize class rx subscriptions Subscriptions at rx Observable subscribe Observable java 254 at rx observables BlockingObservable protectivelyWrapAndSubscribe BlockingObservable java 93 at rx observables BlockingObservable forEach BlockingObservable java 121 at rx operators OperationRepeatTest main OperationRepeatTest java 39 We need to use the recursive scheduler idiom to implement repeat Small detail in some places you should replace The number of times to repeat the element by The number of times to repeat the source sequence Is there a reason the repeat uses an external Scheduler and the ReplaySubject How about a simpler approach java public static T OnSubscribeFunc T repeat final Observable T source final int count return new OnSubscribeFunc T @Override public Subscription onSubscribe final Observer super T t1 final SerialSubscription sreg new SerialSubscription final Observable T ssource source observeOn Schedulers currentThread Observer T o new Observer T int remaining count @Override public void onNext T args t1 onNext args @Override public void onError Throwable e try t1 onError e finally sreg unsubscribe @Override public void onCompleted if remaining 0 sreg setSubscription ssource subscribe this else t1 onCompleted sreg unsubscribe sreg setSubscription ssource subscribe o return sreg @benjchristensen I think using Schedulers immediate causes the stack overflow problem Here is a test in C# c# static void Main string args IObservable int obs Observable Create int o new Foo o test Scheduler Immediate 0 obs Subscribe x Console WriteLine OnNext x Console ReadLine class Foo IObserver int _o public Foo IObserver int o _o o public IDisposable test IScheduler s int i return s Schedule i 1 scheduler x _o OnNext x return this test scheduler x This code does not cause a stack overflow exception But in RxJava the following unit test will cause a stack overflow exception java @Test public void testRecursiveScheduler1 Observable Integer obs Observable create new OnSubscribeFunc Integer @Override public Subscription onSubscribe final Observer super Integer observer return Schedulers immediate schedule 0 new Func2 Scheduler Integer Subscription @Override public Subscription call Scheduler scheduler Integer i observer onNext i return scheduler schedule i 1 this obs subscribe new Observer Integer @Override public void onCompleted @Override public void onError Throwable e e printStackTrace @Override public void onNext Integer args System out println args I m trying to understand the ImmediateScheduler in Rx Net Seems that it also uses a queue to save the Actions to avoid the stack overflow exception http rx codeplex com SourceControl latest#Rx NET Source System Reactive Core Reactive Concurrency ImmediateScheduler cs http rx codeplex com SourceControl latest#Rx NET Source System Reactive Core Reactive Concurrency LocalScheduler TimerQueue cs RxJava pull requests #444 https netflixoss ci cloudbees com job RxJava pull requests 444 FAILURE Looks like there s a problem with this pull request RxJava pull requests #445 https netflixoss ci cloudbees com job RxJava pull requests 445 FAILURE Looks like there s a problem with this pull request RxJava pull requests #446 https netflixoss ci cloudbees com job RxJava pull requests 446 SUCCESS This pull request looks good The current implementation still has some problems which can not be simply handled in OperationRepeat If using ImmediateScheduler in repeat operator there may be a stack overflow exception mentioned above If using CurrentThreadScheduler the following test will not stop I suppose it should stop when the observer has some error java @Test public void testRepeatWithInfiniteRepeatCountWithCurrentThread Observable String observable repeat foo Schedulers currentThread @SuppressWarnings unchecked Observer String observer Observer String mock Observer class doAnswer new Answer Void private int count 0 @Override public Void answer InvocationOnMock invocation throws Throwable count if count 100 Only verify if repeating 100 times We can not really verify if repeating infinitely throw new RuntimeException some error return null when observer onNext anyString observable subscribe observer InOrder inOrder inOrder observer inOrder verify observer times 100 onNext foo inOrder verify observer onError isA RuntimeException class inOrder verifyNoMoreInteractions You should use the current thread scheduler which is what C# does see my pull request I don t think we need an overload with count just as easy to do a take n afterwards There is an issue with toblocking observable where it does not terminate that does not appear in toeneumerable in NET You should use the current thread scheduler which is what C# does see my pull request Agree But now as the current thread has some issue I use ImmediateScheduler to pass the unit test I don t think we need an overload with count just as easy to do a take n afterwards Could you give me an example How can we know the n to use in take when the observable size is unknown There is an issue with toblocking observable where it does not terminate that does not appear in toeneumerable in NET I suppose my problem it s about SafeObservableSubscription and SafeObserver But maybe we are talking about the same issue since SafeObservableSubscription and SafeObserver are used in toBlockingObservable too This hangs in Rx NET as well 2 1 30214 0 c# Observable Return 1 Repeat Take 100 Subscribe Console WriteLine The issue is in the Repeat subscribe not returning until the infinite re subscription finishes so there is no way the Take method can signal its uplink to terminate as it hasn t yet received a reference to it However this works c# Observable Return 1 Scheduler Default Repeat Take 100 Subscribe Console WriteLine as now the Repeat onCompleted can run in another thread and the Repeat subscribe can return I believe this can be achieved by not subscribing to the raw source in the Repeat subscribe but rather using subscribeOn Schedulers newThread to move the subscription into a parallel thread and let the Repeat subscribe return java public static T OnSubscribeFunc T repeat final Observable T source final int count return new OnSubscribeFunc T @Override public Subscription onSubscribe final Observer super T t1 final SerialSubscription sreg new SerialSubscription final Observable T ssource source subscribeOn Schedulers newThread Observer T o new Observer T int remaining count @Override public void onNext T args t1 onNext args @Override public void onError Throwable e try t1 onError e finally sreg unsubscribe @Override public void onCompleted if remaining 0 sreg setSubscription ssource subscribe this else t1 onCompleted sreg unsubscribe sreg setSubscription ssource subscribe o return sreg I believe this can be achieved by not subscribing to the raw source in the Repeat subscribe but rather using subscribeOn Schedulers newThread to move the subscription into a parallel thread and let the Repeat subscribe return Thanks you remind me one thing There is not an repeat overload with Observable and Scheduler together in Rx Net When I tried to implement the repeat overload I was wondering why there was not a such overload Maybe this is because repeat can not be used with all of Schedulers However even if we do not provide such overload users still can use Schedulers by observeOn For example Observable from 1 repeat take 100 observeOn Schedulers CurrentThread So is it OK that we do not provide this kind of method and warn that should not use repeat with Schedulers CurrentThread or Schedulers immediate in the document I think Rx Net started out its Return operator to run on the threadpool If manually put back there the example works Nowadays it runs on the immediate scheduler causing the problem Even if you warn the user about the scheduler there is no way to know if an incoming observable is dangerous or not This affects other operators such as concat and onerrorresume Return always used the immediate scheduler Same stack overflow issue happens in interval java @Test public void testIntervalWithImmediateScheduler Observable interval 1 TimeUnit MILLISECONDS Schedulers immediate subscribe new Observer Long @Override public void onCompleted System out println onCompleted @Override public void onError Throwable e e printStackTrace @Override public void onNext Long args System out println args CurrentThreadScheduler can work with interval because interval does not use SafeObservableSubscription and SafeObserver I am working with @headinthebox on changes to Schedulers including Interval and will come back to this and https github com Netflix RxJava pull 518 when ready Completed in https github com Netflix RxJava pull 699',RxJava,true,false,false
22946254,'ObserveOn Refactor','Refactor and small fixes of ObserveOn with @headinthebox','RxJava pull requests #423 https netflixoss ci cloudbees com job RxJava pull requests 423 SUCCESS This pull request looks good',RxJava,true,false,false
22948145,'concat with iterable overload merge with iterable overload','','RxJava pull requests #424 https netflixoss ci cloudbees com job RxJava pull requests 424 SUCCESS This pull request looks good This conflicts with the conclusions made in https github com Netflix RxJava issues 418 Thanks I was a bit afraid of this',RxJava,true,false,false
22953930,'ParallelMerge Operator','','RxJava pull requests #425 https netflixoss ci cloudbees com job RxJava pull requests 425 SUCCESS This pull request looks good',RxJava,true,false,false
22962691,'Fix ObserveOn and add ParallelMerge Scheduler overload','ObserveOn was not correctly recursing when the source was async It would create a new scheduler i e a new thread each time Also added unit tests to ParallelMerge','This is debugged and pair programmed with @headinthebox RxJava pull requests #426 https netflixoss ci cloudbees com job RxJava pull requests 426 SUCCESS This pull request looks good',RxJava,true,false,false
22964727,'New Scala Bindings','Alternative Rx bindings for Scala The previous RxScala binding attempt to optimize for seamless interop between Scala and Java The intended interop is illustrated by the following example where in Scala a class is defined that takes an Observable Movie that is transformed using RxScala operators scala class MovieLib val moviesStream Observable Movie val threshold 1200 def shortMovies Observable Movie def longMovies Observable Movie which is then called in Java passing a Java Observable Movie to the constructor java public void test MovieLib lib new MovieLib Observable from lib longMovies subscribe moviePrinter The technique used to obtain this transparency is to use a value class with a private constructor that implements the Rx operators in an idiomatic Scala way and a companion object that is used to construct instances in Scala scala object Observable def apply T asJava rx Observable _ T Observable T new Observable T asJava class Observable T private scala val asJava rx Observable _ T extends AnyVal Idiomatic Scala friendly definitions of Rx operators Since rx lang scala Observable T extends AnyVal the underlying representation of rx lang scala Observable T is the same as rx Observable T Because rx lang scala Observable T is an opaque type in Scala the Scala programmer only sees the Scala friendly operators However in the current the illusion of interop is quickly lost when going beyond this simple example For example but type Notification T and Scheduler T are defined using wrappers and hence they are not compatible with Notification T respectively Scheduler T For instance when materializing an Observable T in Scala to an Observable Notification T we lost the seamless interop with Observable Notification T on the Java side However the real problems with seamless interop show up when we try to creating bindings for other Rx types In particular types that have inheritance or more structure For example RxScala currently defines a type synonym type Observer T rx Observer _ T but no further bindings for observers Similarly for subjects RxScala defines type Subject T R rx subjects Subject _ T _ R The problem with these definitions is that on the Java side subjects are defined as scala public abstract class Subject T R extends Observable R implements Observer T without binding any of the Rx subjects The consequence is that Subject S T in Scala is unrelated to rx lang scala Observable T in Scala but shows up as a rx Observable T The problem however is that if we want to expose subjects in Scala such that they derive from both Observable S and Observer T we cannot use the extend AnyVal trick we used for Observable T and immediately lose transparent interop with Java The problem is even worse because AsyncSubject T BehaviorSubject T all derive from Subject T T so if we want them to derive from a common base Subject T T type in Scala we lose transparency for those as well And again if we expose the various subjects by extending AnyVal they are useless in Scala because they do not inherit from a common base type To avoid implementing all methods of observable and observer on each specific subject we might add implicit conversions to Observable T and Observer T but that still does not give Scala users a native Subject S T type scala object AsyncSubject def apply T AsyncSubject T new AsyncSubject T rx subjects AsyncSubject create class AsyncSubject T private scala val inner rx subjects AsyncSubject T extends AnyVal implicit final def asObservable T subject AsyncSubject T Observable T Observable subject inner implicit final def asObserver T subject AsyncSubject T Observer T subject inner The inheritance problem is not just limited to subjects but also surfaces for subscriptions Rx scala currently defines type Subscription rx Subscription using a type synonym as well and we run into exactly the same problems as with subjects when we try to bind the various Rx subscriptions BooleanSubscription SerialSubscription etc Since we cannot wrap Rx types in Scala such that they are both a transparently interoperable with Java and b feel native and idiomatic to Scala we should decide in favor of optimizing RxScala for Scala and consumption of Rx values from Java but not for Scala as a producer The new bindings feel like a completely native Scala library without needing any complications of the Scala side scala object Observer trait Observable T def asJavaObservable rx Observable _ T object Observer trait Observer T def asJavaObserver rx Observer _ T object Subject trait Subject T R extends Observable R with Observer T val asJavaSubject rx subjects Subject _ T _ R object Scheduler trait Scheduler def asJavaScheduler rx Scheduler object Notification trait Notification T def asJavaNotification rx Notification _ T object Subscription trait Subscription def asJavaSubscription rx Subscription You pay the price when crossing the Scala Java interop boundary which is where it should be The proper way is to put the burden of interop on the Scala side in case you want to create a reusable Rx based library in Scala or wrap and unwrap on the Java side java public static void main String args Observable Movie movies Observable from new Movie 3000 new Movie 1000 new Movie 2000 MovieLib lib new MovieLib toScalaObservable movies lib longMovies asJavaObservable subscribe m System out println A movie of length m lengthInSeconds s Delegation versus Inheritance The obvious thought is that using delegation instead of inheritance http c2 com cgi wiki DelegationIsInheritance will lead to excessive wrapping since all Scala types wrap and delegate to an underlying RxJava implementation Note however that the wrapping happens at query generation time and incurs no overhead when messages are flowing through the pipeline Say we have a query xs map f filter p subscribe o Even though the Scala types are wrappers the callback that is registered with xs is something like x val y f x if p y o asJavaObserver onNext y and hence there is no additional runtime penalty','RxJava pull requests #427 https netflixoss ci cloudbees com job RxJava pull requests 427 SUCCESS This pull request looks good',RxJava,true,false,false
22992409,'Operator toMap ToDictionary and toMultimap ToLookup','Operators toMap and toMultimap I ve tried my best to describe them in the Javadoc','RxJava pull requests #428 https netflixoss ci cloudbees com job RxJava pull requests 428 SUCCESS This pull request looks good The code and unit tests look good We just need to figure out what to do about the overloads that have the same erased signatures We use Groovy for asserting the various overloads work for dynamic languages by putting unit tests here not as comprehensive as I d like https github com Netflix RxJava tree master language adaptors rxjava groovy src test groovy rx lang groovy I m not familiar with Groovy but in the future I ll watch the overloads from this perspective Thank you @akarnokd You can use Groovy more or less as if it is Java 8 write everything as statically typed Java except that when you are going to use an anonymous inner class you pass a lambda with slightly different syntax than Java 8 lambdas I ll look into the Groovy part create a new branch pull',RxJava,true,false,false
23023878,'ToAsync implemented Issue #95','Added 44 overloads of toAsync','RxJava pull requests #429 https netflixoss ci cloudbees com job RxJava pull requests 429 SUCCESS This pull request looks good Can you help me understand the purpose of toAsync Action Is it just that you want to hold off on executing some hunk of code until some cascade of observables is subscribed to and begins to fire or is there more to it than that On Wed Nov 20 2013 at 1 10 PM CloudBees pull request builder plugin notifications@github com wrote RxJava pull requests #429 https netflixoss ci cloudbees com job RxJava pull requests 429 SUCCESS This pull request looks good Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 505#issuecomment 28931217 David M Gross PLP Consulting @DavidMGross As I understand Rx NET it is something like this You have an action A but you don t want to execute it now so you wrap it into an Observable that runs on a background thread Once some observer subscribes the action gets executed on the background thread and a onNext null onComplete is issued to it However it uses an AsyncSubject internally so the action A is executed only once and its result retrievered instantly to late observers The value comes when you want to execute an action with certain parameter values Given an Action1 that takes some parameter you would make its execution asynchronous and you create a function for executing it with a particular parameter java Action1 Integer a1 v lengthlyOperation v Func1 Integer Observable Void async Observable toAsync a1 Observable Void o async call 1 o subscribe doSomethingWhenCompleted async call 2 subscribe doSomethingForParam2 later o subscribe doSomethingWhenCompletedAgain In this example you ll trigger an execution of a1 with value 1 and in parallel a1 with value 2 Later if you subscribe to o again you would get an instant completion There are overloads for functions so you can get some result back as well This seems to be similar to making a Future T into an Observable but there are a bunch of overloads for multi parameter actions and functions not just a simple Callable and Runnable case Thanks Just what I needed On Wed Nov 20 2013 at 2 33 PM akarnokd notifications@github com wrote @DavidMGross https github com DavidMGross As I understand Rx NET it is something like this You have an action A but you don t want to execute it now so you wrap it into an Observable that runs on a background thread Once some observer subscribes the action gets executed on the background thread and a onNext null onComplete is issued to it However it uses an AsyncSubject internally so the action A is executed only once and its result retrievered instantly to late observers The value comes when you want to execute an action with certain parameter values Given an Action1 that takes some parameter you would make its execution asynchronous and you create a function for executing it with a particular parameter Action1 Integer a1 v lengthlyOperation v Func1 Integer Observable Void async Observable toAsync a1 Observable Void o async call 1 o subscribe doSomethingWhenCompleted async call 2 subscribe doSomethingForParam2 latero subscribe doSomethingWhenCompletedAgain In this example you ll trigger an execution of a1 with value 1 and in parallel a1 with value 2 Later if you subscribe to o again you would get an instant completion There are overloads for functions so you can get some result back as well This seems to be similar to making a Future into an Observable but there are a bunch of overloads for multi parameter actions and functions not just a simple Callable and Runnable case Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 505#issuecomment 28938521 David M Gross PLP Consulting @headinthebox I m wondering if these are better suited on a different class than Observable similar to how we separated out BlockingObservable since many of these do not return Observable In other words are these worthy of having on Observable and increasing the surface area of the API significantly or can they live in another utility class The other problem is that many of these method overloads will not work for dynamic languages like Groovy and Clojure as the method arity is the same only the type of Func being accepted is different and those can t be disambiguated by those languages For example toAsync Action0 action and toAsync Func0 R func are ambiguous We need to think through how to specify all of these in a way that is descriptive and usable and consciously understand impact on our polyglot principles Perhaps rx async AsyncFunctions fromFunc0 Func0 R rx async AsyncFunctions fromFunc1 Func1 T1 R rx async AsyncActions fromAction0 Action0 rx async AsyncActions fromAction1 Action1 T1 I suggest the package rx async instead of rx util functions as I d rather avoid package cycles unless we expect the async keyword in some future Java Why not all call them Async and use static import so you can write Async Integer x x Looks really nice @headinthebox I think because of Groovy and others are unable to differentiate based on arity I had to drop a few overloads of toMap and toMultimap because of this Yes we can t have two overloads like this and still support non strongly typed languages async Func1 f async Func2 f Strongly typed languages can differentiate based on the number of args Func1 and Func2 take but others like Groovy Clojure and most likely Javascript can t We should try Java 8 Nashorn to determine how Javascript will behave with functional interfaces as that s going to be a major player on the JVM in the coming years What about having both @headinthebox and @akarnokd s solutions at the same time @headinthebox and I have reviewed this and feel the following is needed These should live in a separate class rx util functions Async The generics need covariance contra variance support added Let s retain the type safe overloads but then probably need a asyncFunc FuncN f method for dynamic languages This is not something we want done typically and definitely not in Observable but makes sense for this utility class so we don t penalize the strongly typed languages Closing See #533 for updated version Closing See #533 for updated version',RxJava,true,false,false
23069439,'Operators And Then When','Issue #23 Issue #88 Issue #100 Can be extended to Plan4 Plan9 and Pattern4 Pattern9 if Action4 Action9 is available Not sure about the ActionN version','RxJava pull requests #430 https netflixoss ci cloudbees com job RxJava pull requests 430 FAILURE Looks like there s a problem with this pull request I don t understand I used the master haven t touched groupBy or the schedulers the build succeeds on my machine although with JDK 7 Now what just another case of https github com Netflix RxJava issues 383#issuecomment 27571436 The OperationGroupByTest test issue has not be fixed yet That is an impressive contribution @akarnokd I don t see any problems in my review The unit tests were essential to understanding and trusting this so thank you for being thorough I m going to merge this and leverage the fact that we re still pre 1 0 so that if there are any issues found we can still fix them even if we need to break a signature',RxJava,true,false,false
23099685,'Operation join','Issue #56','RxJava pull requests #431 https netflixoss ci cloudbees com job RxJava pull requests 431 SUCCESS This pull request looks good This needs to be rebased before it can merge probably because of your other PR I just merged Can you please update or resubmit Will do shortly',RxJava,true,false,false
23102245,'Empty subscribe','','RxJava pull requests #432 https netflixoss ci cloudbees com job RxJava pull requests 432 SUCCESS This pull request looks good',RxJava,true,false,false
23137443,'Operator Generate','Operator Generate 6 variants for Issue #49','RxJava pull requests #433 https netflixoss ci cloudbees com job RxJava pull requests 433 SUCCESS This pull request looks good This PR needs to be rebased so it can merge along with some other questions comments above Closing this PR as both this and the other variant https github com Netflix RxJava pull 519 need further work',RxJava,true,false,false
23165233,'BugFix Zip','This is a manual merge of https github com Netflix RxJava pull 495 where I added some unit tests and suppressed warnings while reviewing the refactor done by @akarnokd I believe this fixes issue https github com Netflix RxJava issues 387','',RxJava,true,false,false
23166809,'Operation GroupByUntil','Issue #52 Note that Rx NET s Subject T once onCompleted or onError d any subsequent subscriptions from observers will immediately receive onCompleted or onError RxJava s PublishSubject however doesn t seem to do that leaving future observers never do anything Since the Rx NET GroupByUntil relied on the described behavior to handle escaped groups the proposed implementation inside the GroupSubject will do this manually','RxJava pull requests #435 https netflixoss ci cloudbees com job RxJava pull requests 435 SUCCESS This pull request looks good Needs to be rebased before it can merge Will do shortly',RxJava,true,false,false
23169949,'Scala Adaptor Details','With https github com Netflix RxJava pull 503 some files were lost so I added them again and I also fixed many other details There are no changes in functionality inheritance only cosmetics Except https github com samuelgruetter RxJava commit 8567fcbaff20859c68ce4c30c7f347be34581fa4 @headinthebox could you please confirm this one line change','@headinthebox @samuelgruetter Please confirm the two of you agree on this and I ll merge RxJava pull requests #437 https netflixoss ci cloudbees com job RxJava pull requests 437 SUCCESS This pull request looks good Looks good Found a small bug copy paste object PublishSubject def apply T value T PublishSubject T new PublishSubject T rx subjects PublishSubject create We need to add as well and have the above call this one I use the above to force type inference object PublishSubject def apply T PublishSubject T new PublishSubject T rx subjects PublishSubject create 2x exactly the same btw please indent code by 4 spaces @headinthebox I still don t understand what you mean with this comment https github com Netflix RxJava pull 512#issuecomment 29163202 This is a trick we often use in C# You pass in a dummy witness of type T to help the compiler infer types If you say PublishSubject it will infer PublishSubject Nothing and you are forced tp write PublishSubject T I never want to write a concrete type anywhere With the current code scala object PublishSubject def apply T PublishSubject T new PublishSubject T rx subjects PublishSubject create we can do the following scala val s1 PublishSubject Int inferred type of s1 PublishSubject Int val s2 PublishSubject inferred type of s2 PublishSubject Nothing val s3 PublishSubject Int PublishSubject also works What else do you want to be possible So you want to write val s4 PublishSubject 0 because you prefer writing 0 over writing Int That s never done in Scala and looks very weird to me',RxJava,true,false,false
23171908,'Operators toMap and toMultimap again','Issue #96 and Issue #97 toMap 3 overloads toMultimap 4 overloads Added groovy test to verify overloading','RxJava pull requests #438 https netflixoss ci cloudbees com job RxJava pull requests 438 SUCCESS This pull request looks good Ah this can t merge anymore because of other commits probably the join operator on your other PR Can you rebase',RxJava,true,false,false
23172535,'Operation Join again','Issue #56','RxJava pull requests #439 https netflixoss ci cloudbees com job RxJava pull requests 439 SUCCESS This pull request looks good',RxJava,true,false,false
23174437,'Operation GroupByUntil again','Issue #52','RxJava pull requests #440 https netflixoss ci cloudbees com job RxJava pull requests 440 SUCCESS This pull request looks good I m going to need to spend more time on this One thing that jumps out right now is the covariance contra variance generics isn t there and thus doesn t match the other groupBy operators Yes this project made me cautious with variances I m going to update the signatures but I ll wait a bit to avoid rebasing all the time',RxJava,true,false,false
23175989,'Adding utility functions for observables of strings useful for processing non blocking IO','I started developing this for use with the rxjava apache http contrib module to safely and scalable decode infinite observables of byte arrays into strings but thought it should live in core because it could be useful for non blocking disk IO I did not make this part of rx Observable because these operators only work on observables of string The drawback is that discoverability will be harder','RxJava pull requests #441 https netflixoss ci cloudbees com job RxJava pull requests 441 SUCCESS This pull request looks good RxJava pull requests #442 https netflixoss ci cloudbees com job RxJava pull requests 442 SUCCESS This pull request looks good RxJava pull requests #451 https netflixoss ci cloudbees com job RxJava pull requests 451 FAILURE Looks like there s a problem with this pull request Looking at this more this seems to fit better as a contrib module Nowhere else in RxJava do we have utility classes for doing specific types of data manipulation Once we have String manipulation we ll open the door for all kinds of others Similar to how Swing and Android utilities are in a separate jar should we have a data transformations contrib module where this stuff goes There are these four that operate on Observables of numbers rx Observable sum Observable Integer rx Observable sumDoubles Observable Double rx Observable sumFloats Observable Float rx Observable sumLongs Observable Long The various aggregation operators like sum are unfortunately monomorphic because Java and NET lack a type like Scala s http www scala lang org api current index html#scala math Numeric However if you squint your eyes the various aggregates are generics I agree with Ben that it is best to keep the core as polymorphic and tight as possible that is operators on Observable T where T is a set of types 1 and have a hopefully thriving ecosystem of domain specific operations to a contrib module There are a couple of tricks that we can pull to still allow for a fluent coding style I wasn t trying to highlight how monomorphic aspect but that It seems inconsistent to the accumulation of java lang Number sum to exist in the core but not the accumulation of java lang String concat to also be part of the core I ll rejigger the PR to put it in a new module so this can be closed RxJava pull requests #455 https netflixoss ci cloudbees com job RxJava pull requests 455 FAILURE Looks like there s a problem with this pull request Much better just a question on the AssertObservable class that doesn t feel like it s in the right place RxJava pull requests #469 https netflixoss ci cloudbees com job RxJava pull requests 469 FAILURE Looks like there s a problem with this pull request RxJava pull requests #470 https netflixoss ci cloudbees com job RxJava pull requests 470 FAILURE Looks like there s a problem with this pull request RxJava pull requests #471 https netflixoss ci cloudbees com job RxJava pull requests 471 SUCCESS This pull request looks good',RxJava,true,false,false
23183694,'ArtifactID for rxjava rxscala should include Scala version','rxjava rxscala is currently published with this artifactID Since Scala libraries compiled for different Scala versions aren t binary compatible the convention is to include the Scala version in artifactID i e rxjava rxscala_2 10 See http www scala sbt org 0 13 0 docs Detailed Topics Cross Build html','1 Is there an simple way to do it in gradle this could be solved when realizing https github com Netflix RxJava issues 589 Yes this will need to be done when we split things up as part of https github com Netflix RxJava issues 589',RxJava,false,false,false
23194435,'Rx java repeat','Implementation of repeat There is an issue with toBlockingObservable when using currentThread','RxJava pull requests #443 https netflixoss ci cloudbees com job RxJava pull requests 443 FAILURE Looks like there s a problem with this pull request As per comment in https github com Netflix RxJava pull 498 this will be looked at again after @headinthebox and I finish some work on Schedulers we re doing',RxJava,true,false,false
23208542,'Operator Generate again','Issue #49 Updated tests to use TestScheduler Removed class TimeSpan and the timeSelectors are expected to return a nanosecond resolution value','RxJava pull requests #447 https netflixoss ci cloudbees com job RxJava pull requests 447 SUCCESS This pull request looks good A small tip about github You can continue to push any commits to your commit The pull request will be updated automatically If you find some conflicts between your remote branch and your local branch you can use force to override your remote branch by force Github will keep the pull request consistent with your remote branch I think it s better than opening another pull request @zsxwing I know my very first pull was such but I received the tip to use clean branches especially when the master changes above me Do you mean https github com Netflix RxJava pull 509#issuecomment 29109489 I think @benjchristensen was suggesting git rebase In addition if it s hard to rebase it on master I also think a new pull request is good Removed class TimeSpan and the timeSelectors are expected to return a nanosecond resolution value We need to support long delayTime TimeUnit unit as discussed at https github com Netflix RxJava pull 509#discussion_r7916351',RxJava,true,false,false
23220515,'Fixed the blocking non blocking first','Hi this PR fixed the last problem in #423 Observable first in RxJava is same as Observable FirstAsync in Rx Net which is a non blocking operator When the source sequence is empty it will emit an IllegalArgumentException Observable takeFirst is an alias of take 1 If the source sequence is empty it will return an empty sequence BlockingObservable first in RxJava is same as Observable First in Rx Net which is a blocking operator When the source sequence is empty it will emit an IllegalArgumentException also added BlockingObservable firstOrDefault Here I attached my test codes for Rx Net c# Console WriteLine Test FirstAsync IObservable int obs Observable Range 1 4 FirstAsync obs Subscribe x Console WriteLine FirstAsync x e Console WriteLine FirstAsync e Console WriteLine FirstAsync completed IObservable int obs Observable Empty int FirstAsync obs Subscribe x Console WriteLine FirstAsync with empty x e Console WriteLine FirstAsync with empty e Console WriteLine FirstAsync with empty completed Console WriteLine Test Take 1 IObservable int obs Observable Range 1 4 Take 1 obs Subscribe x Console WriteLine Take 1 x e Console WriteLine Take 1 e Console WriteLine Take 1 completed IObservable int obs Observable Empty int Take 1 obs Subscribe x Console WriteLine Take 1 with empty x e Console WriteLine Take 1 with empty e Console WriteLine Take 1 with empty completed Console WriteLine Test First 1 int value Observable Range 1 4 First Console WriteLine First value try int value Observable Empty int First catch Exception e Console WriteLine First with empty e The output is pre Test FirstAsync FirstAsync 1 FirstAsync completed FirstAsync with empty System InvalidOperationException Sequence contains no el ements Test Take 1 Take 1 1 Take 1 completed Take 1 with empty completed Test First 1 First 1 First with empty System InvalidOperationException Sequence contains no element s at System Reactive Linq QueryLanguage FirstOrDefaultInternal TSource IObserv able 1 source Boolean throwOnEmpty at System Reactive Linq QueryLanguage First TSource IObservable 1 source at System Reactive Linq Observable First TSource IObservable 1 source at ConsoleApplication1 Program Main String args in C Users szhu documents visual studio 2010 Projects ConsoleApplication1 ConsoleApplication1 Program cs line 190 pre','RxJava pull requests #448 https netflixoss ci cloudbees com job RxJava pull requests 448 SUCCESS This pull request looks good RxJava pull requests #452 https netflixoss ci cloudbees com job RxJava pull requests 452 FAILURE Looks like there s a problem with this pull request This one is on the list for review RxJava pull requests #460 https netflixoss ci cloudbees com job RxJava pull requests 460 SUCCESS This pull request looks good The changes look good basically correcting misunderstandings of first take firstAsync etc @headinthebox Can you weigh in on this RxJava pull requests #492 https netflixoss ci cloudbees com job RxJava pull requests 492 SUCCESS This pull request looks good I rebased it on the latest codes By the way @benjchristensen if you have time could you close the enhancement issues which have already finished It s very helpful to find out what is remaining on the TODO list I checked the opening issues today Here is the issues I think can be closed #14 #15 #22 #23 #24 #25 #32 #38 #39 #41 #56 #61 #63 #68 #69 #78 #79 #80 #82 #83 #88 #90 #91 #98 #99 #100 Sorry that my comment messed up the issues Is there some way to delete the references in other issues Quick question is it worthwhile to have an alias for take 1 that is actually longer takeFirst The reason the operation existed was because we wanted first So let s remove all trivial ones I m OK to remove takeFirst But I worry about breaking the existed public API We can mark it deprecated right now if we want to remove it On Dec 6 2013 at 1 39 PM Shixiong Zhu notifications@github com wrote I m OK to remove takeFirst But I worry about breaking the existed public API Reply to this email directly or view it on GitHub RxJava pull requests #504 https netflixoss ci cloudbees com job RxJava pull requests 504 SUCCESS This pull request looks good Rebased it Any further suggestion RxJava pull requests #526 https netflixoss ci cloudbees com job RxJava pull requests 526 SUCCESS This pull request looks good RxJava pull requests #564 https netflixoss ci cloudbees com job RxJava pull requests 564 SUCCESS This pull request looks good RxJava pull requests #571 https netflixoss ci cloudbees com job RxJava pull requests 571 FAILURE Looks like there s a problem with this pull request I implemented the non blocking single and singeOrDefault and used them to reimplement the blocking nonblocking single singleOrDefault first firstOrDefault last lastOrDefault Here are the differences between these operators table thead tr th RxJava operators th th more than one items in the input sequence th th one item in the input sequence th th empty sequence th th method name in Rx Net th tr thead tbody tr td Observable single td td IllegalArgumentException td td the single item td td IllegalArgumentException td td singleAsync td tr tr td BlockingObservable single td td IllegalArgumentException td td the single item td td IllegalArgumentException td td single td tr tr td Observable singleOrDefault td td IllegalArgumentException td td the single item td td the default value td td singleOrDefaultAsync td tr tr td BlockingObservable singleOrDefault td td IllegalArgumentException td td the single item td td the default value td td singleOrDefault td tr tr td Observable first td td the first item td td the first item td td IllegalArgumentException td td firstAsync td tr tr td BlockingObservable first td td the first item td td the first item td td IllegalArgumentException td td first td tr tr td Observable firstOrDefault td td the first item td td the first item td td the default value td td firstOrDefaultAsync td tr tr td BlockingObservable firstOrDefault td td the first item td td the first item td td the default value td td firstOrDefault td tr tr td Observable last td td the last item td td the last item td td IllegalArgumentException td td lastAsync td tr tr td BlockingObservable last td td the last item td td the last item td td IllegalArgumentException td td last td tr tr td Observable lastOrDefault td td the last item td td the last item td td the default value td td lastOrDefaultAsync td tr tr td BlockingObservable lastOrDefault td td the last item td td the last item td td the default value td td lastOrDefault td tr tbody table I changed public Observable T firstOrDefault Func1 super T Boolean predicate T defaultValue to public Observable T firstOrDefault T defaultValue Func1 super T Boolean predicate to keep these operators consistent However it breaks the previous API RxJava pull requests #572 https netflixoss ci cloudbees com job RxJava pull requests 572 SUCCESS This pull request looks good RxJava pull requests #575 https netflixoss ci cloudbees com job RxJava pull requests 575 SUCCESS This pull request looks good RxJava pull requests #576 https netflixoss ci cloudbees com job RxJava pull requests 576 SUCCESS This pull request looks good Excellent table explaining what this is all did @DavidMGross Can you validate all of our documentation on these operators aligns with that table above Thank you @zsxwing This is a good set of fixes I ve looked over the Wiki docs javadocs and both seem to be aligned with the table now I ve also added the table itself as an appendix to the BlockingObservable wiki page here https github com Netflix RxJava wiki Blocking Observable Operators#appendix similar blocking and non blocking operators On Mon Dec 23 2013 at 12 51 PM Ben Christensen notifications@github com wrote Thank you @zsxwing https github com zsxwing This is a good set of fixes Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 520#issuecomment 31143126 David M Gross PLP Consulting Great work Thanks @DavidMGross',RxJava,true,false,false
23232756,'Unsubscribe from takeLast','When I unsubscribe from an Observable which emits the last value of an infinite stream I expect to get no element This is the case in C# cs var o Observable Interval TimeSpan FromMilliseconds 200 TakeLast 1 var s o Subscribe i Console WriteLine Interesting Infinity i Thread Sleep 1000 s Dispose Thread Sleep 1000 Console WriteLine Press any key Console ReadKey outputs Press any key But with RxJava it s different note that Scala s takeRight calls Java s takeLast scala val o Observable interval 200 millis takeRight 1 val s o subscribe i println s Interesting Infinity i Thread sleep 1000 s unsubscribe Thread sleep 1000 outputs Interesting Infinity 4','It s an issue of interval Here is the unit test to reveal it java @Test public void testIssue521 throws InterruptedException Observable Long o Observable interval 200 TimeUnit MILLISECONDS Subscription s o subscribe new Observer Long @Override public void onCompleted System out println onCompleted @Override public void onError Throwable e @Override public void onNext Long args System out println args Thread sleep 1000 s unsubscribe Output pre 1 2 3 4 onCompleted pre I think unsubscribe should not call onCompleted Here is the case in Rx Net c# var o Observable Interval TimeSpan FromMilliseconds 200 var s o Subscribe i Console WriteLine Interesting Infinity i e Console WriteLine e Console WriteLine onCompleted Thread Sleep 1000 s Dispose Console WriteLine Press any key Console ReadKey Output is pre Interesting Infinity 0 Interesting Infinity 1 Interesting Infinity 2 Interesting Infinity 3 Press any key pre Fixed in https github com Netflix RxJava pull 522',RxJava,false,false,false
23236034,'Fixed the issue #521','Hi this PR fixed the issue #521 Please take a look Thanks','cool thanks RxJava pull requests #449 https netflixoss ci cloudbees com job RxJava pull requests 449 ABORTED This timed out because this demo https github com zsxwing RxJava blob 63d2400e7e7ce0af9d99158fa7032346514b42db language adaptors rxjava scala src test scala rx lang scala examples RxJavaDemos scala is not deactivated not my fault I m not the one who commented out the @Ignore I fixed it in https github com Netflix RxJava pull 512 but that s not yet merged Closing as @samuelgruetter claims this is fixed in #512 that was just merged Nevermind this looks like a different change RxJava pull requests #450 https netflixoss ci cloudbees com job RxJava pull requests 450 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
23269223,'Feature Request Add filterNot to scala language adapter for Observable','Scala has the syntax filter filterNot as being pretty standard it would nice to embed the filterNot directly into the language adapter for Observable','@headinthebox has accepted this and while doing so will review other Scala collection methods as well @headinthebox @zsxwing Do either of you want to do this OK I will take it',RxJava,false,false,false
23284629,'Are there any analog to NET system unit to represent void result','Are there any analog to NET system unit to represent void result http msdn microsoft com en us library system reactive unit v vs 103 aspx Java Void class has no constructor and it is impossible to return something like this Observable from new Void','Void is the absence of data so having an Observable that emits one nothing doesn t make sense You probably want Observable Void Observable empty or Observable Void Observable error e You can also define the type T on a function as Void and then return null from that function I guess you could do Observable just Void null Every time I ve made an API that returns Observable Void is to express an operation that either works calls onCompleted or doesn t calls onError Void null works perfectly',RxJava,false,false,false
23294982,'BugFix Handling of Terminal State for Behavior Publish Subjects','They were not correctly emitting onCompleted when new Observers subscribed after the Subject was terminated Added same logic that already existed on AsyncSubject','RxJava pull requests #453 https netflixoss ci cloudbees com job RxJava pull requests 453 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
23295615,'Manual Merge of toMap toMultiMap','Manual merge of https github com Netflix RxJava pull 513','RxJava pull requests #454 https netflixoss ci cloudbees com job RxJava pull requests 454 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
23332821,Docs,'Javadoc improvements including diagrams wiki links for new operators','RxJava pull requests #456 https netflixoss ci cloudbees com job RxJava pull requests 456 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
23338866,'Operation GroupByUntil','Issue #52 Added variance to lambda parameters Using PublishSubject as it now properly handles subscriptions after its terminal state Can t do much about the scala tests failing','RxJava pull requests #457 https netflixoss ci cloudbees com job RxJava pull requests 457 FAILURE Looks like there s a problem with this pull request @akarnokd While reviewing this @headinthebox and I were comparing with C# and this looks similar so I need to validate the licensing and copyright Is this copy paste modified from the Rx Net codebase or just inspired by and written from scratch The Rx Net code is open source but I need to validate with legal how to represent the licenses and copyrights if this is from there Factually I ve written it from scratch based on the join operator s pattern but I took a strong inspiration for the join operator from the Rx Net sources I didn t copy paste the operator s code but only the test strings from one of the Rx Net tests of this operator The operator looks similar but since GroupedObservable is not an interface in RxJava I had to work around it with the PublishSubject Otherwise I would say the same behavior can be expressed in Java very look alike I admit I haven t bothered giving different names to classes and fields I believe with the given RxJava style constraints there was only one way to implement these operators which thereby look almost the same as the Rx Net versions I certainly don t want to fall into an Oracle vs Google situation but unfortunately certain patterns are already established in RxJava I could have used Locks ignored the try catches used different names etc When I started my R4J library back in 2011 there was no source code available no documentation but only a bunch of videos and blog posts I had no choice but work from them and have a truly clean room implementation So let s say there weren t any Rx Net sources available today but the API documentation would be extensive I could almost certainly do most operators from scratch and in the Java way But unfortunately the documentation is inadequate and the aim to produce compatible behavior makes me look at the C# code to figure out the missing logic I guess half of the RxJava s bugs came from this situation I whish to be a valuable part of the RxJava community and see the reactive concept to become mainstream and standard in Java Please advise given the constraints how I can avoid such situations in the future Thank you for the details I m just being cautious to make sure things are good and I very much appreciate your involvement I m still clarifying some things with legal to understand what derivative means and if we need to include notices copyrights etc from the C# code But unfortunately the documentation is inadequate and the aim to produce compatible behavior makes me look at the C# code to figure out the missing logic I guess half of the RxJava s bugs came from this situation This is correct and why now with @headinthebox involved we re fixing nuanced bugs that resulted from desired behavior not being clear in the signature or documentation I whish to be a valuable part of the RxJava community and see the reactive concept to become mainstream and standard in Java Please advise given the constraints how I can avoid such situations in the future Thank you for getting involved and please continue to be so I m just making sure we figure this out now rather than down the road I ve talked with legal and are good to go Basically add any notices copyrights if needed and if not needed then just the Apache license header like all other files in this project Can you rebase this so it can be merged The master branch has changed enough that this conflicts now Thanks Right away',RxJava,true,false,false
23340869,'Scala Tweaks','Some cleanup from Erik unit test fixes adding license headers','RxJava pull requests #458 https netflixoss ci cloudbees com job RxJava pull requests 458 SUCCESS This pull request looks good nice',RxJava,true,false,false
23342858,'Interval Immediately emit 0','Before it s too late I d like to discuss the following question When should Observable interval t emit its first element which is 0 a right after the observer subscribed or b only after a delay of t Currently we have b but I d vote for a because I ve seen many people stumble over this I think it makes more sense if after n t time it emits n Or a third possiblilty c start with 1 and emit it after a delay of t','The NET semantics is b There is also Observable Timer that allows to do a We should implement that as well http msdn microsoft com en us library system reactive linq observable interval v vs 103 aspx http msdn microsoft com en us library system reactive linq observable timer v vs 103 aspx Why did NET choose b Emitting n after n 1 t time looks like an off by one error to me I stumbled over this because my interpretation of the marble diagram in the docs led me to believe the behavior was a http netflix github io RxJava javadoc rx Observable html#interval long 20java util concurrent TimeUnit If the semantics are kept as b it would help to clarify this in the docs marble diagrams Let me know when you make a decision one way or the other on this and I ll work to keep the wiki marble diagram in sync On Sat Dec 7 2013 at 3 06 PM Michael Richards notifications@github com wrote I stumbled over this because my interpretation of the marble diagram in the docs led me to believe the behavior was a http netflix github io RxJava javadoc rx Observable html#interval long 20java util concurrent TimeUnit If the semantics are kept as b it would help to clarify this in the docs marble diagrams Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 530#issuecomment 30067676 David M Gross PLP Consulting Sitting here with @headinthebox to get this answered The interval operator will always have a delay before emitting so it behaves correctly If an immediate values is wanted then use timer or startsWith 0 interval if you don t care about the values produced by interval The reason for interval and timer is that interval is a convenience overload for timer The timer that would perform this is java public static Observable Long timer long initialDelay long period TimeUnit unit It would used as java Observable timer 0 100 TimeUnit MILLISECONDS That would immediately emit 0 and then increment 1 2 3 n every 100 milliseconds And why not c It still looks like an off by 1 error for me If we have an overload of timer like java public static Observable Long timer long initialValue long initialDelay long period TimeUnit unit we could implement interval period as timer 1 period period unit',RxJava,false,false,false
23347758,'visually distinguish operators that use schedulers etc','visually distinguish operators that use schedulers add distinct doOnEach diagrams','RxJava pull requests #459 https netflixoss ci cloudbees com job RxJava pull requests 459 SUCCESS This pull request looks good',RxJava,true,false,false
23348036,'doOnEach variance','Just to make sure we don t forget about this one doOnEach friends still need extends T super T','This is completed along with a refactoring to having doOnEach doOnNext doOnCompleted and doOnError',RxJava,false,false,false
23372474,'Async conversions','Issue #95 Moved to Async class and into the rx util functions Added variances to lambdas Unfortunately the code looks almost the same as Rx Net','RxJava pull requests #461 https netflixoss ci cloudbees com job RxJava pull requests 461 SUCCESS This pull request looks good',RxJava,true,false,false
23380396,'Race condition in buffer','This snippet scala println Observable 100L 101L Observable interval 50 millis take 10 buffer 200 millis toBlockingObservable toList sometimes outputs this correct List Buffer 100 101 0 1 2 Buffer 3 4 5 6 Buffer 7 8 9 but sometimes also outputs this incorrect List Buffer 0 1 2 Buffer 3 4 5 6 Buffer 7 8 9 Thanks Jean Laurent Huynh for pointing this out The problem might be here https github com Netflix RxJava blob 6ec81dfcb52e1444960e7f349100f56389bdeb4a rxjava core src main java rx operators ChunkedOperation java#L543 in TimeBasedChunkCreator where schedulePeriodically with an initial delay of 0 is called The scheduled action might be executed for the first time only after the first few elements are emitted','Note that the window operation is also affected by this problem since it uses the same TimeBasedChunkCreator Thank you Alexei Alexandrov for pointing this out You are welcome The new buffer and window operators should not exhibit this behavior Can you check close this This looks fixed to me java import java util concurrent TimeUnit import rx Observable public class TestConcat public static void main String args System out println Observable concat Observable from 100L 101L Observable interval 50 TimeUnit MILLISECONDS take 10 buffer 200 TimeUnit MILLISECONDS toList toBlockingObservable single Prints the following every time 100 101 0 1 2 3 4 5 6 7 8 9',RxJava,false,false,false
23382860,'Fix compilation errors due to referencing the Android support library directly','This is to prevent compilation failures in projects that do not link the support v4 library The only other option I saw to fix this would have been to split up the android module into one for native fragments and one for support fragments which I found would come with unjustified overhead Hence I settled for the cheap way which is to sacrifice type safety here Refs https github com soundcloud RxJava issues 2 cc @gbenson','Should add we need this to go in to make headway with the Android samples projects RxJava pull requests #462 https netflixoss ci cloudbees com job RxJava pull requests 462 SUCCESS This pull request looks good #128077',RxJava,true,false,false
23404697,'Rebased version of jmhofer s delay implementation','This is in response to the request in #384 to rebase the delay implementation on top of master','RxJava pull requests #463 https netflixoss ci cloudbees com job RxJava pull requests 463 FAILURE Looks like there s a problem with this pull request RxJava pull requests #464 https netflixoss ci cloudbees com job RxJava pull requests 464 FAILURE Looks like there s a problem with this pull request Nevermind tried to do a good thing but the raw rebase is very broken I ll take a stab at this at a later date if it s not already fixed',RxJava,true,false,false
23415407,'Add scala adapters for doOnEach operator','This re integrates support for doOnEach that was lost in the Scala refactor','RxJava pull requests #465 https netflixoss ci cloudbees com job RxJava pull requests 465 SUCCESS This pull request looks good Thank you @landonf Imho you should first fix https github com Netflix RxJava issues 532 Because then you can get rid of the U T and the asInstanceOf rx Observable T in the Scala code RxJava pull requests #468 https netflixoss ci cloudbees com job RxJava pull requests 468 SUCCESS This pull request looks good @samuelgruetter I m happy to take a look can you expand a bit on what needs doing Ok first concerning this PR I think the only change we need is to replace scala def doOnEach U T observer Observer U Observable T by scala def doOnEach observer Observer T Observable T Now concerning https github com Netflix RxJava issues 532 Apparently it s not strictly necessary to resolve it to make this PR work because implicit conversions perform even more magic than I would have excpected or in other words I d be interested to see if you could implement this PR without implicit conversions and without https github com Netflix RxJava issues 532 but that s only out of curiosity there s no purpose in not using implicit conversions In https github com Netflix RxJava issues 532 I d like the following Java code as well as all similar examples using different overloads of doOnXxx to work java class Fruit class Apple extends Fruit Action1 Fruit printFruit1 new Action1 Fruit public void call Fruit f System out println f getClass getName public void test1 Observable Fruit o Observable from new Fruit new Apple o doOnEach printFruit1 subscribe public void test2 Observable Apple o Observable from new Apple new Apple o doOnEach printFruit1 subscribe With the current Observable java test2 will not compile But if you appropriately replace Action1 T by Action1 super T in Observable java then it will and you will have fixed https github com Netflix RxJava issues 532 @samuelgruetter @headinthebox @landonf Should this be merged or should it be changed as per the last comment Just remove this U T as I described above Only reason I didn t do this myself is that I wanted to introduce @landonf to the magic of Scala generics variance RxJava pull requests #486 https netflixoss ci cloudbees com job RxJava pull requests 486 SUCCESS This pull request looks good @samuelgruetter For which I m much obliged I ve updated this pull request and submitted a new request for #532 Now it looks good Btw doOnError and doOnCompleted could be added as well',RxJava,true,false,false
23419894,'Operation GroupJoin','Issue #53 Steps taken Started out from scratch based on the join operator s pattern Consulted with Rx NET sources to match the data types of left right maps and behavior Added RefCountSubscription class and consulted Rx NET on the unsubscription behavior Looked at WindowObservable and AddRef in the Rx NET sources for their behavior Took a test inspiration from http rxwiki wikidot com 101samples#toc39 @headinthebox While writing the test for the operator I ve noticed that when both duration selectors are never Rx NET never calls onCompleted on the group subjects even though the left and right sources onComplete I haven t seen Rx NET test for this scenario This comes into play when I want to emulate join with groupJoin the outer merge never onCompletes If I understand the behavior corretly when both left and right sources get depleted there is no way a new group or new group value would arrive and all the open groups and the main observer can be onCompleted This is somewhat similar to join and groupByUntil behavior','RxJava pull requests #466 https netflixoss ci cloudbees com job RxJava pull requests 466 SUCCESS This pull request looks good Thanks man Things are a bit slow due to Thanksgiving and Ben travelling but I ll try to have a look between the Turkey and the mashed potatoes This needs to be rebased as it conflicts with the master branch now @headinthebox Are you good with this Will do after GroupByUntil is merged so I don t have to rebase all the time Btw is there a way to add new methods to Observable so it won t conflict all the time Should I add the new methods randomly in the middle not at the end Typically when I m adding operators I put them alphabetically inside Observable and the merge diff behavior seems to handle that better than appending to the end of the file Will create new PR shortly',RxJava,true,false,false
23440853,'Zipping a finite and an infinite Observable','Here are 4 tests testing that zipping a finite and an infinite Observable results in a finite Observable The third of them fails','RxJava pull requests #467 https netflixoss ci cloudbees com job RxJava pull requests 467 FAILURE Looks like there s a problem with this pull request @cloudbees pull request builder yes I know this failure is intended @akarnokd wdyt Sorry about this See my PR for the fix hello @samuelgruetter @akarnokd On the reactive programming course on Coursera I think I met this bug It was asked to create some kind of timeout Observable I tried to use zip for that Observable interval 1 second zip Observable 0 to intTotalSec subscribe t println Received t e println Error e println Timeout It prints what I expected except the timeout never completes So in the end I used the takeUntil with a filtered interval Does your pull request fix my usecase This PR has been mentionned in this Coursera forum post https class coursera org reactive 001 forum thread thread_id 1734 Hi @slorber This PR fixes the bug and your example should terminate correctly thanks',RxJava,true,false,false
23469207,'Purpose of rx util Opening and rx util Closing interfaces','Is there a particular reason these two interfaces are used by the various buffer and window operators instead of allowing arbitrary generic types for opening and closing buffers windows similar to the duration selectors in join groupByUntil','I think they are historical artifacts less types better IMHO On Thu Nov 28 2013 at 2 47 PM akarnokd notifications@github com wrote Is there a particular reason these two interfaces are used by the various buffer and window operators instead of allowing arbitrary generic types for opening and closing buffers windows similar to the duration selectors in join groupByUntil Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 540 On a related issue we should move ObserverBase from rx joins to rx right next to the Observer interface Nobody should directly implement Observer ObserverBase ensure that the Rx contract is enforced It is a bit ugly that you need to override XXXCore so we should also add Observer create or a constructor with overloads that take funcs as well as one that takes an Observer itself which can be unsafe You want to take this See http msdn microsoft com en us library hh211985 v vs 103 aspx https github com mono rx blob master Rx NET Source System Reactive Core Reactive ObserverBase cs did I say already that the MSDN docs suck @headinthebox Sure I would do the refactorings but I think ObserverBase should be placed under rx operators similar to the SafeObserver and SynchronizedObserver classes Probably yes and there is a lot of duplication between all of these various observers so you may want to have a look at that as well If its job is to ensure the contract is kept then that is what SafeObserver does but I think ObserverBase should be placed under rx operators similar to the SafeObserver and SynchronizedObserver classes Yes we have kept the rx package to only the most top level things so I agree this should be elsewhere However thus far the rx operators package is not considered part of the public API and is excluded from Javadocs If we are to have public Observers then it would be an rx observers package like rx observables The rx operators package is internal implementations and can be changed without breaking users I did the refactorings but couldn t get the Observable scala working with it https github com akarnokd RxJava commit 7f3628667ef4d5aa066fa9441b8b6d66f81f0b10 Could someone help with that part RxJava language adaptors rxjava scala src main scala rx lang scala Observable scala 307 error type mismatch found rx lang scala Observable Closing required rx util functions Func0 _ rx Observable Closing val f Func0 _ rx Observable Closing closings asJavaObservable RxJava language adaptors rxjava scala src main scala rx lang scala Observable scala 332 error type mismatch found Opening rx Observable _ Closing required rx util functions Func1 Opening _ rx Observable Closing val closing Func1 Opening _ rx Observable Closing o Opening closings o asJavaObservable RxJava language adaptors rxjava scala src main scala rx lang scala Observable scala 333 error type mismatch found rx Observable _ 15 where type _ 15 Opening required rx Observable Opening Note _ 15 Opening but Java defined class Observable is invariant in type T You may wish to investigate a wildcard type such as _ Opening SLS 3 2 10 val jObs rx Observable _ java util List _ asJavaObservable buffer Opening Closing opening closing RxJava language adaptors rxjava scala src main scala rx lang scala Observable scala 545 error overloaded method window needs result type asJavaObservable window openings asJavaObservable op Opening closings op asJavaObservable RxJava language adaptors rxjava scala src main scala rx lang scala Observable scala 519 error overloaded method value window with alternatives x 1 Int rx Observable rx Observable _ 1 and TClosing x 1 rx util functions Func0 _ rx Observable TClosing rx Observable rx Observable _ 1 cannot be applied to rx util functions Func0 _ 44 val o1 rx Observable _ rx Observable _ asJavaObservable window func Observable is covariant in its type parameter In Scala when you use a Scala type scalac knows this automatically because it s declared where the type is declared using trait Observable T means covariant means contravariant So rx lang scala Observable T actually means an rx lang scala Observable whose type parameter is T or any subclass of T However if you use a Java type there s no or at declaration site so whenever you use rx Observable in Scala you have to write rx Observable _ T Never write rx Observable T',RxJava,false,false,false
23480883,'Operation SkipUntil','Issue #79 Written from scratch Consulted Rx NET sources to verify the behavior there is one difference I ve implemented the OtherObserver such a way that if it is empty it calls onCompleted on the client observer and terminates the whole setup in other words the client observer won t be held up just to skip all elements of the source Observable what if infinite stream is in play','RxJava pull requests #472 https netflixoss ci cloudbees com job RxJava pull requests 472 SUCCESS This pull request looks good RxJava pull requests #473 https netflixoss ci cloudbees com job RxJava pull requests 473 SUCCESS This pull request looks good there is one difference I ve implemented the OtherObserver such a way that if it is empty it calls onCompleted on the client observer and terminates the whole setup TakeUntil and SkipUntil are triggered by either onNext or onError in which case the exception is propagated So when the OtherObserver is empty the result is Observable never not Observable empty PublishSubject Integer source PublishSubject create Observable Integer m source skipUntil Observable empty m subscribe observer verify observer never onError any Throwable class verify observer never onNext any verify observer times 1 onCompleted RxJava pull requests #481 https netflixoss ci cloudbees com job RxJava pull requests 481 SUCCESS This pull request looks good',RxJava,true,false,false
23500686,'Support creating Observable from Android s Sensor','Very early PR to get some guidance over API style and error handling','RxJava pull requests #474 https netflixoss ci cloudbees com job RxJava pull requests 474 SUCCESS This pull request looks good Pushed wrong branch closing RxJava pull requests #475 https netflixoss ci cloudbees com job RxJava pull requests 475 SUCCESS This pull request looks good',RxJava,true,false,false
23501676,'Support creating Observable from Android s Sensor','Very early PR to get some guidance over API testing style and error handling','RxJava pull requests #476 https netflixoss ci cloudbees com job RxJava pull requests 476 SUCCESS This pull request looks good This needs to be rebased as it conflicts with other changes committed @mttkay Can you weigh in on this You should not need a subject Just Observable create whenever you think you need a subject think again To handle @mironov nsk remark I would pass in a function from SensorEvent to T you use that function to project the event to whatever you want to push into the stream public static Observable float fromSensor SensorManager sensorManager int type int rate would become public static T Observable T fromSensor SensorManager sensorManager int type int rate Func1 SensorEvent T selector @mttkay When a user subscribes an Observable he may forget to unsubscribe it which may be a resource leak issue in Android I propose the following helper class to help users manage the Subscriptions related to a Context So the user can simply unsubscribe all of the Subscriptions at the onStop method java public class AndroidSubscriptions private static Map Context CompositeSubscription contextSubscriptions new HashMap Context CompositeSubscription public static synchronized void add Context context Subscription subscription CompositeSubscription parentSubscription contextSubscriptions get context if parentSubscription null parentSubscription new CompositeSubscription contextSubscriptions put context parentSubscription parentSubscription add subscription public static synchronized void unsubscribe Context context CompositeSubscription parentSubscription contextSubscriptions get context if parentSubscription null parentSubscription unsubscribe contextSubscriptions remove context Here I use static methods because I want to use AndroidSubscriptions add like the following codes java public class OperationObserveFromAndroidSensor public static Observable float observeFromAndroidSensor final Context context final SensorManager sensorManager int type final int rate final Sensor sensor sensorManager getDefaultSensor type if sensor null throw new IllegalArgumentException Unsupported sensor type return Observable create new OnSubscribeFunc float @Override public Subscription onSubscribe final Observer super float observer final SensorEventListener listener new SensorEventListener @Override public void onSensorChanged SensorEvent event observer onNext Arrays copyOf event values event values length @Override public void onAccuracyChanged Sensor sensor int accuracy TODO sensorManager registerListener listener sensor rate Subscription subscription Subscriptions create new Action0 @Override public void call sensorManager unregisterListener listener AndroidSubscriptions add context subscription return subscription What s your opinion I m not sure I understand what problem this solves Where do you release the composite subscription for a context The wrapped subscriptions while mapped to the same context might have completely unrelated life cycles too Moreover keeping strong references to Context in a global unsynchronized shared object is a bit of a red flag The composite subscription for a context will be unsubscribed in Activity onStop or onDestroy method like @Override protected void onStop AndroidSubscriptions unsubscribe this super onStop Basically I want to collect all of the subscriptions related to a context When the context is going to be destroyed we can call AndroidSubscriptions unsubscribe context to subscribe them I see what you mean Why not have the composite subscription as a member field in your Activity class That s what we do in our app I still don t see a case here for a shared static field in the library itself On Thu Dec 12 2013 at 10 20 AM Shixiong Zhu notifications@github com wrote Basically I want to collect all of the subscriptions related to a context When the context is going to be destroyed we can call AndroidSubscriptions unsubscribe context to subscribe them Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 543#issuecomment 30400740 @mttkay You re right I gave up this idea as I could not find any elegant way I agree that managing the subscriptions is the app s job Since this can no longer be merged can you close this and re create a new one once the code is ready Closing out as it can t be merged and has been 15 days since involvement please re submit a new PR when this is ready Closing out as it can t be merged and has been 15 days since involvement please re submit a new PR when this is ready',RxJava,true,false,false
23510965,'ReplaySubject emits items received after onError','This snippet scala val sub ReplaySubject Int sub onNext 1 sub onNext 2 sub onError new Exception Kabloooy Gets moved to after onNext 3 sub onNext 3 sub subscribe n println sub1 n e println sub1 e getMessage println sub1 completed println done outputs sub1 1 sub1 2 sub1 3 sub1 Kabloooy done but I would expect sub1 1 sub1 2 sub1 Kabloooy done since items received after onError should not be emitted by ReplaySubject Thank you Dragisa Krsmanovic for pointing this out','Ben and I hacked on subjects earlier this week all subjects are were in pretty bad shape but we ll fix it ReplaySubject is the one I didn t touch I refactored Publish Behavior Async I ll put Replay on my TODO I think this is a trivial fix java @Override public void onNext T args synchronized subscriptions if isDone return history add args for Observer super T observer new ArrayList Observer super T subscriptions values observer onNext args We should also make sure no additional on errors are propagated Sent from my iPad On Nov 30 2013 at 4 52 AM akarnokd notifications@github com wrote I think this is a trivial fix @Override public void onNext T args synchronized subscriptions if isDone return history add args for Observer super T observer new ArrayList Observer super T subscriptions values observer onNext args Reply to this email directly or view it on GitHub',RxJava,false,false,false
23519257,'Fixed Zip issue with infinite streams','Issue #539','RxJava pull requests #477 https netflixoss ci cloudbees com job RxJava pull requests 477 SUCCESS This pull request looks good Do we have similar tests for the error cases as well There are two test methods done previously OperationZipTest testOnErrorTermination and OperationZipTest testAggregatorError I ll add some more tests RxJava pull requests #480 https netflixoss ci cloudbees com job RxJava pull requests 480 SUCCESS This pull request looks good Thanks',RxJava,true,false,false
23519822,'Opening closing','Issue #540 Removed Opening and Closing interfaces and updated method signatures accordingly Moved ObserverBase to rx operators for now and added static methods to wrap or construct one If usefull it and other default implementations may be moved to a new public rx observers package','RxJava pull requests #478 https netflixoss ci cloudbees com job RxJava pull requests 478 SUCCESS This pull request looks good Nice improvement I noticed the duplication as well in one of the earlier comments Here is a bit of history form NET For a long time we promoted the fact that the way to create observers was via Observer create However we found that many people did not understand this and we saw over and over again that people were implementing IObserver by hand and breaking the contract similar to what we saw with Subjects In fact this even leaked into the MSDN docs at some point hope they have been removed So what we did is expose ObserverBase which is what Observer create is implemented in terms internally such that in case people do want to inherit from Observer they would use this base class The price is that you have to override the xxxCore methods since the onXXX methods call those and wrap them in logic to maintain the contract Note that NET has ObservableBase for the same reason Technically there may actually be good reasons to implement Observer using a class since you may want to share state between the methods So both of you are correct this sounds like a cop out but it is really just bowing to reality Hope this helps Erik The way we have solved it in RxJava is that we wrap Observer implementations passed in to Observable subscribe when those implementations are not from the internal RxJava implementation itself Thus I don t see the need to force users to use Observer create or extend from ObserverBase We retain the control of wrapping Observer implementations when we feel the need to and can change that implementation whenever we choose It is simpler and doesn t leak those details into the public API In this case I d rather keep the ObserverBase in rx operators package and not advertise it JoinObserver1 needs to provide a specific API beyond Observer so wrapping it in a SafeObserver is not an option @akarnokd Could you subclass SafeObserver to minimize code duplication @benjchristensen Makes sense as long as everywhere an external observer comes in we are careful to see if it needs to be protected IntellIj tells me that Observer appears 300 times in a parameter position Maybe this is a nice grab it issue we can add to the list Probably most them them are OK but just in case I ll split this into two PRs one for the removal of the Opening and Closing one for refactoring the ObserverBase @headinthebox I ve tried it but it ended up a more convoluted solution The core functionality became an inner class and the outer class needs to forward the API calls to this internal class Basically most of the behavior of SafeObserver had to be subverted java public final class JoinObserver1 T extends SafeObserver T implements JoinObserver public static T JoinObserver1 T create Observable T source Action1 Throwable onError ObserverBaseCore T base new ObserverBaseCore T source onError return new JoinObserver1 T base private final ObserverBaseCore T base private JoinObserver1 ObserverBaseCore T base super new SafeObservableSubscription Subscriptions empty Observer T base this base base public Queue Notification T queue return base queue public void addActivePlan ActivePlan0 activePlan base activePlans add activePlan @Override public void subscribe Object gate this base gate gate base subscription set base source materialize subscribe base @Override public void dequeue base queue remove private static class ObserverBaseCore T implements Observer Notification T private Object gate private final Observable T source private final Action1 Throwable onError private final List ActivePlan0 activePlans private final Queue Notification T queue private final SingleAssignmentSubscription subscription private volatile boolean done public ObserverBaseCore Observable T source Action1 Throwable onError this source source this onError onError queue new LinkedList Notification T subscription new SingleAssignmentSubscription activePlans new ArrayList ActivePlan0 @Override public void onNext Notification T args synchronized gate if done if args isOnError onError call args getThrowable return queue add args remark activePlans might change while iterating for ActivePlan0 a new ArrayList ActivePlan0 activePlans a match @Override public void onError Throwable e not expected @Override public void onCompleted not expected or ignored @Override public void onError Throwable e not expected @Override public void onCompleted not expected or ignored void removeActivePlan ActivePlan0 activePlan base activePlans remove activePlan if base activePlans isEmpty unsubscribe @Override public void unsubscribe if base done base done true base subscription unsubscribe',RxJava,true,false,false
23533417,'Decouple getting a subscription from subscribing','I ve been holding on to this for a while now because it s a major departure and I wanted to make sure that it was really necessary Given all of the issues we ve seen recently with Schedulers and other operators I think it s time to discuss Right now the core method of Subscription subscribe Observer just doesn t work well for synchronous source Observables because downstream operations don t get a Subscription until after the Observable has been force fed all the data For example Observable from 1 2 3 map expensive operation here take 1 The subscribers to this chain of observables will see the correct result be the author might not realize that there is unnecessary computation going on because the expensive operation is also done for 2 and 3 and thrown away be the take operator The solution that I m proposing is to split subscribing to an Observable into two phases The first step is to get the subscription with a new method on Observable called public PartialSubscription T getSubscription Then define PartialSubscription with all of the subscribe methods to start the sending of data to the observer public class PartialSubscription T extends Subscription public void subscribe Observer T observer The existing subscribe OnSubscribeFunc can be deprecated and implemented using partial subscriptions means for backwards compatibility of existing operator implementations but to truly get all of the advantages of this all of the operators would have to be revised I ve submitted an accompanying pull request with implementation implementation details','On branch 2phase this test java Func1 Integer Integer expensive new Func1 Integer Integer @Override public Integer call Integer t1 System out println omg this is so expensive return t1 Action1 Integer printIt new Action1 Integer @Override public void call Integer t1 System out println Got t1 @Test public void go Observable Integer o Observable from 1 2 3 map expensive take 1 o getSubscription subscribe printIt outputs omg this is so expensive Got 1 omg this is so expensive omg this is so expensive On branch master removing getSubscription in go it outputs exactly the same So I don t really get your point I thought you wanted to have only this output omg this is so expensive Got 1 Could you please elaborate Why complicate things unnecessarily You should never use a synchronous source in the matter you describe in the first place That s why schedulers exist A synchronous source is only acceptable for doing cheap short work I hadn t rewritten the from map or take operators to use the two phase subscriptions yet I ve just committed the a unit test you wrote and made it work I don t think it unnecessary If synchronous Observables shouldn t be used than why do they exist Users can t tell if an Observable is synchronous or not If code is written that based on an Observable that is asynchronous and it is later changed to synchronous then it could have unintended consequences Adding a thread doesn t guarantee that the receiver will get scheduled to issue the unsubscribe in time BTW The subscribers to this chain of observables will see the correct result be the author might not realize that there is unnecessary computation going on because the expensive operation is also done for 2 and 3 and thrown away be the take operator In C# new 1 2 3 ToObservable Select x Console WriteLine Expensive 0 x return x Take 1 Subscribe Console WriteLine prints as expected Expensive 1 1 Only is you use the immediate scheduler you get as expected since Immediate is not really a proper scheduler and should be used with extreme care if any Expensive 1 1 Expensive 2 Expensive 3 But all all other schedulers behave properly Too lazy right now to check which scheduler is used by default for this in RxJava but we should use CurrentThread which should take care of your original problem @abersnaze as I point out it should work if you use the current thread scheduler Synchronous observables are like extremely sharp knives Use them only when you know what you are doing or you risk to cut your limbs off CurrentThreadScheduler only seems to work at the granularity of subscribe or not to subscribe to an Observable On the master branch I put these two unit tests The testDontStart test uses take 0 and passes if I insert the current thread scheduler in two key places No amount current thread schedulers seems to make testInterruptable @headinthebox Is there something that I m missing that will make testInterruptable work @Test public void testInterruptable Func1 Integer Integer expensive mock Func1 class when expensive call any Integer class thenReturn 10 Scheduler sched Schedulers currentThread List Integer v Observable from 1 2 3 map expensive subscribeOn sched take 1 subscribeOn sched toList toBlockingObservable single assertEquals 1 v size assertEquals 10 v get 0 intValue verify expensive times 1 call any Integer class @Test public void testDontStart Func1 Integer Integer expensive mock Func1 class when expensive call any Integer class thenReturn 10 Scheduler sched Schedulers currentThread List Integer v Observable from 1 2 3 map expensive subscribeOn sched take 0 subscribeOn sched toList toBlockingObservable single assertEquals 0 v size verify expensive never call any Integer class List Integer v Observable from 1 2 3 map expensive subscribeOn sched Will not work you need to call from with a scheduler See my remark about NET there ToObservable takes a scheduler I ve created a new branch in my fork called 1phase where I ve been testing out your suggestions I haven t been able to get the unit tests working with observerOn currentThreadScheduler I found these comments in the rx operators OperationObserveOn interesting Should observerOn currentThreadScheduler do something different public Subscription onSubscribe final Observer super T observer if scheduler instanceof ImmediateScheduler do nothing if we request ImmediateScheduler so we don t invoke overhead return source subscribe observer else if scheduler instanceof CurrentThreadScheduler do nothing if we request CurrentThreadScheduler so we don t invoke overhead return source subscribe observer else return new Observation observer init You should no start with Observable from 1 2 3 and avoid ImmediateScheduler like the plague Never ever use the Observable from 1 2 3 overload Instead use the one below and pass CurrentThreadScheduler public static T Observable T from Iterable extends T iterable Scheduler scheduler return from iterable observeOn scheduler Sorry if I didn t make this clear but that is what I did in the 1phase branch but I still didn t see any change in behavior This is related to fixing the CurrentThreadScheduler behavior @headinthebox and I are planning on working on that soon The new Subscriber Operator OnSubscribe should handle this case Can you check close',RxJava,false,true,false
23533434,'Changes to allow the initiating of work on an Observable to be done after the Subscription is available','See issue #547 for more details and discussion on this','RxJava pull requests #479 https netflixoss ci cloudbees com job RxJava pull requests 479 FAILURE Looks like there s a problem with this pull request RxJava pull requests #482 https netflixoss ci cloudbees com job RxJava pull requests 482 ABORTED RxJava pull requests #489 https netflixoss ci cloudbees com job RxJava pull requests 489 ABORTED RxJava pull requests #529 https netflixoss ci cloudbees com job RxJava pull requests 529 ABORTED RxJava pull requests #535 https netflixoss ci cloudbees com job RxJava pull requests 535 ABORTED This I believe will get fixed with something I just learned about in Rx Net They have special handling throughout the Observable subscribe logic for CurrentThreadScheduler that allows unsubscribe to work on a single threaded infinite source I will be working on this soon This I believe will get fixed with something I just learned about in Rx Net They have special handling throughout the Observable subscribe logic for CurrentThreadScheduler that allows unsubscribe to work on a single threaded infinite source I will be working on this soon',RxJava,true,false,false
23538979,'Creating Observables in Scala','The constructors for Observables in Scala have multiple problems I d like to start a systematic discussion about this hoping to find a good solution First a list of use cases that we eventually want to cover usecase01 Observable create the mother of all factory methods construct from an OnSubscribeFunc usecase02 an empty Observable usecase03 emit only 1 given element usecase04 emit a given vararg list of elements usecase05 emit all elements of an Iterable usecase06 emit all elements of a possibly infinite Iterable usecase07 emit the single item returned by a Future usecase08 wrap a Java Observable Scala only usecase09 emit only a given exception in onError usecase10 emit a range of integers usecase11 emit one asynchronously calculated element a shorthand for constructing a Future and then applying usecase07 Note Depending on the approach one constructor might cover several usecases since I tried to split them up as much as possible This list only contains very important constructors which are eligible to be called Observable apply Others which have names everyone agrees on such as defer never interval generate etc are not listed Now a first approach01 would be to use the same names as Java does java usecase01 public static T Observable T create OnSubscribeFunc T func usecase02 public static T Observable T empty usecase03 public static T Observable T just T value usecase04 public static T Observable T from T t1 T tN 10 overloads usecase05 public static T Observable T from Iterable extends T iterable usecase06 not yet implemented usecase07 public static T Observable T from Future extends T future usecase08 NA usecase09 public static T Observable T error Throwable exception usecase10 public static Observable Integer range int start int count usecase11 not yet implemented We decided against this because this has problem01 Observable apply is not used so we don t exploit a nice feature of Scala That s why we implemented this approach02 that s version 0 15 1 scala usecase01 def apply T func Observer T Subscription Observable T usecase02 special case of usecase04 usecase03 special case of usecase04 usecase04 def apply T items T Observable T usecase05 special case of usecase04 example Observable myList _ usecase06 not yet implemented not even in Java usecase07 not yet implemented usecase08 def apply T observable rx Observable _ T usecase09 def apply T exception Throwable Observable T usecase10 def apply range Range Observable Int usecase11 not yet implemented But this also turned out to have problems problem02 If I write this scala val o Observable observer Observer Int observer onNext 42 no Subscription returned by mistake Then I don t get an error but o is an Observable Observer Int Unit problem03 Observable new Exception new Exception yields an Observable Exception with 2 elements and is not the same as Observable new Exception Observable new Exception which yields an Observable Nothing with 0 elements terminating with onError Coursera students got confused about this problem04 The varargs apply and the OnSubscribeFunc apply clash in such a way that parameter type inference is lost scala val o1 Observable observer Subscription Error missing parameter type should infer Observer Nothing val o2 Observable Int observer observer onNext 1 Subscription Error missing parameter type should infer Observer Int val o3 Observable Int Observable observer observer onNext 1 Subscription works problem05 Cannot easily construct an Observable emitting one Future one Exception or one Range problem06 It s possible to define both scala def apply T items T Observable T def apply T items Iterable T Observable T but when I want to use it eg Observable List 1 2 3 I get ambiguous reference to overloaded definition both method apply in object Observable of type T items Iterable T rx lang scala Observable T and method apply in object Observable of type T items T rx lang scala Observable T match argument types List Int We could also use implicit conversions approach03 usecase01 Observable create call it Observable apply usecase02 List toObservable usecase03 List 1 toObservable usecase04 List 1 2 3 toObservable usecase05 myIterable toObservable usecase06 myIterable toObservable usecase07 myFuture toObservable usecase08 myJavaObservable toObservable usecase09 Observable error new Exception usecase10 0 to 4 toObservable usecase11 Observable async or something else Here usecases 02 03 04 05 06 and 10 would all be covered by one single implicit conversion from Iterable T to Observable T However I m not yet sure if this approach would lead to other problems I invite everyone to post new approaches and to comment on existing ones And please use increasing unique ids for usecase approach and problem to keep our discussion tidy','@benjchristensen @headinthebox @jmhofer @phaller @retronym @vjovanov @xeno by and everyone else your comments are welcome Here is my 2 cents 1 Observable create note the quotes people is the mother of all constructors so apply should be optimized for that 2 Add as many other overloads as possible that do not interfere with 1 3 Also have explicit names even for create Using extensive overloading on apply is IMHO not that great since you loose intent For example say I want to do Observable just new Exception As a regular value versus Observable error Integer new Exception Trigger onError What about approach04 scala usecase01 Observable create observer usecase02 Observable usecase03 Observable oneValue usecase04 Observable 1 2 3 usecase05 Observable from myIterable usecase06 Observable from myInfiniteIterable usecase07 Observable from myFuture usecase08 internally new Observable javaObservable from outside toScalaObservable javaObservable usecase09 Observable error new Exception usecase10 Observable from 1 to 10 covered by usecase05 usecase11 Observable from Future for the moment Rationale If everyone calls it Observable create why shouldn t we do so too And adding an Observable apply which does the same is not a good idea Two methods with different names which do the same that s confusing people a lot Reserving Observable apply for varargs seems to be a waste at first sight since it s not frequently used in real world code But it s very frequent in unit tests and good code comes with many unit tests so don t treat unit tests as second class citizens Additionally writing documentation and reasoning about Observables becomes more lightweight For instance you can say myFunc Observable 1 2 3 should return Observable 1 4 9 Overloading from with Iterable and Future should not be a problem since these types are disjoint Observable error don t loose intent as Erik says Overloading is less dangerous in Java because you have to pass type arguments explicitly Scala on the other hand will infer these IMO this sort of API is broken scala def foo A as A def foo a X The user thinks they are calling the second method gets something wrong so they types don t line up and they are silently funnelled into the first You are robbing the users of type safety BTW I haven t been following this change closely enough to know if your proposal still falls afoul of my criteria just take that as general advice thanks approach01 and approach02 suffer from exactly this problem but approach03 and approach04 should be fine I think approach04 is the way to go so I made a PR for it https github com Netflix RxJava pull 561 Quoting from an email by @headinthebox The main argument is for using Observable literals as Samuel says you can say myFunc Observable 1 2 3 should returnObservable 1 4 9 However in that case it is not much more verbose to say Observable List 1 4 9 especially since in tests you would write assertEquals List 1 4 9 xs toBlockingObservable toList anyway Also we can add extension methods such as List 1 2 3 toObservable Note that you should really not use Observable List without a scheduler and the varargs overload does not allow for a scheduler so it sets a bad example The easiest way to create an observable is also the wrongest So my proposal is to remove apply args T in favor of create @Test def toObservable val xs List 1 2 3 toObservable toBlockingObservable toList assertEquals List 1 2 3 xs val ys Observable List 1 2 3 toBlockingObservable toList assertEquals List 1 2 3 xs val zs Observable 1 2 3 toBlockingObservable toList assertEquals List 1 2 3 xs I m fine with replacing Observable 1 2 3 by Observable List 1 2 3 List 1 2 3 toObservable But I would not like to have two names for the same method Observable apply Observer Subscription and Observable create Observer Subscription that s very confusing and bloats the already large API unnecessarily We really should decide for either apply or create but not both I d prefer create don t loose intent but not having two methods which do the same is more important for me I don t mind having two at all If we start with one we can always add apply back but if we put it in it is hard to remove Here s a trick by mentioned by @vjovanov which gives us more possibilities Instead of having apply T which makes apply unusable for any other overload we could have just T and apply T T T I did seriously think about this option it does effectively introduces two ways for the same thing which is why I picked items On Dec 12 2013 at 7 01 AM samuelgruetter notifications@github com wrote Here s a trick by mentioned by @vjovanov which gives us more possibilities Instead of having apply T which makes apply unusable for any other overload we could have just T and apply T T T Reply to this email directly or view it on GitHub For the record here s the what we currently have in master approach05 scala usecase01 Observable create observer usecase02 Observable empty usecase03 Observable items oneValue List oneValue toObservable usecase04 Observable items 1 2 3 List 1 2 3 toObservable usecase05 Observable from myIterable myIterable toObservable usecase06 infinite Iterables not yet supported by RxJava usecase07 Observable from myFuture usecase08 toScalaObservable javaObservable usecase09 Observable error new Exception usecase10 Observable from 1 to 10 covered by usecase05 usecase11 Observable from Future for the moment apply is unused here but reserved for Observable create I think it s good to make one release without apply so that everyone notices that there were changes in the constructors This discussion is related to API Design Review From Overloads https github com Netflix RxJava issues 686 and API Design Review better name for just https github com Netflix RxJava issues 685 Hi guys first of all congrats on your hard work on this project Could I ask you to update the readme to reflect the changes in the API The examples still seem to use the old apply API switching from 0 15 1 to 0 16 1 this changes This can be quite confusing for somebody who s just starting out Which examples are you referring to they did not break the build so we are not aware of them If you look in the source there are lots of examples but obviously you have another set in mind Let us know and we ll fix it or even better add them to the test suite and submit a pull request @headinthebox @samuelgruetter @zsxwing Anything to do here Is this done I think we can consider this done Closing Yup Apologies for the late reply The out of date file is the README md under the rx scala language adapter It has some examples such as val first Observable 10 11 12 val second Observable 10 11 12 which still use the old constructors No big deal @lJoublanc Thanks for reporting it Already updated it at #1239',RxJava,false,false,false
23606670,'Provide support for RemotingObservable','Net version supports RemotingObservable http dotnetinside com in framework Reactive Extensions System Reactive Runtime Remoting RemotingObservable Provide a similar solution using Java RMI Library as a first implementation and then prototype other transport mechanism Thoughts','We are experimenting with RemoteObservable strategies but will almost certainly have the implementations as contrib modules because implementations can vary widely For example one I m working on right now uses Netty with simple async message passing I highly doubt RMI makes sense It is basically a disaster to build and operate and far better approaches now exist I have done it in the past and will never do so again Oracle Sun folks themselves talk about how much they despise Java serialization In short Java RMI is effectively deprecated What specifically are the use cases you re looking for in a RemoteObservable I d like to find out if there is a core interface that unifies all use cases and can support different connectivity and serialization strategies as contrib modules 1 Yes I thought RMI would be a clunky implementation but it could be a start I guess to prototype this 2 My usecase is theoretical at the moment but could as well be practical 3 Basically I would like to be able to emit certain business events from some services and listen for those events on another end Currently if I want to achieve this I would have to use something like JMS or PubSub another protocol AMQP the problem is that I want the client to be in control how to enrich filter and transform those events Let s imagine a remote observable emits events AdEvent of type Changed Updated or Inserted the event looks like this case class AdEvent type type id Long version Long case class Ad type type id Long version Long some other attributes Currently I have to filter for ad type on the client level I also have to do transformation and composition on the client level this is less than ideal The ideal solution for me would be to pass a subscription i e set of functions applied e g observable filter e adEvent e type Type CHANGED map e adEvent enrichEvent e enrich method would perform an external call via future and receive data would effectively enrich the event of maybe get it from the cache In turn the object that would arrive to the client would be like a fairly complete domain object The amazing part and this is where I don t know if something like this could work is that enrichEvent e would be invoked on the server side rather than a client side Maybe one would need to use some kind of scripting language to achieve this because in this case actually I would like to pass a computation to be done on the server side Is this something you are working on Mateusz',RxJava,false,false,false
23654781,'observeOn and multiple subscribers','Snippet 1 scala val o Observable 1 2 3 println x0 o observeOn Schedulers threadPoolForComputation subscribe x println a x t println t println a done println x1 o observeOn Schedulers threadPoolForComputation subscribe x println b x t println t println b done println x2 Thread sleep 6000 println x3 outputs as expected this x0 a 1 a 2 a 3 a done x1 x2 b 1 b 2 b 3 b done x3 Snippet 2 scala val o Observable 1 2 3 observeOn Schedulers threadPoolForComputation println x0 o subscribe x println a x t println t println a done println x1 o subscribe x println b x t println t println b done println x2 Thread sleep 6000 println x3 sometimes outputs the same as snippet 1 but sometimes only outputs this x0 a 1 a 2 a 3 x1 a done x2 x3 or this x0 x1 a 1 a 2 x2 a 3 a done x3 order between x and a doesn t matter but the problem is that there are no lines with b Snippet 3 snippet 2 translated to C# cs var o new 1 2 3 ToObservable ObserveOn TaskPoolScheduler Default Console WriteLine x0 o Subscribe x Console WriteLine a x t Console WriteLine t Console WriteLine a done Console WriteLine x1 o Subscribe x Console WriteLine b x t Console WriteLine t Console WriteLine b done Console WriteLine x2 Thread Sleep 6000 Console WriteLine x3 Console ReadKey always prints something like x0 x1 x2 b 1 b 2 b 3 b done a 1 a 2 a 3 a done x3 order between a and b doesn t matter but there are always lines with b So I guess that somehow observeOn does not properly support multiple subscribers but I couldn t find any clue in the source supporting this claim Would be nice if somehow could take look','What I see is that ObserveOn uses a global queue I d rather move the queue inside the onSubscribe method so you have one queue per observer and no interference and perhaps parallel observations of independent observers they don t get into each others queue One more thing It appears the notifications only add to the s CompositeSubscription but never remove an item once done which is a potential memory leak IMO Good catch',RxJava,false,false,false
23658497,'concat concurrency multiple subscribers','This C# snippet cs var o Observable Concat Observable Interval TimeSpan FromMilliseconds 500 Take 2 Observable Interval TimeSpan FromMilliseconds 500 Take 2 o Subscribe x Console WriteLine a x t Console WriteLine t Console WriteLine a done o Subscribe x Console WriteLine b x t Console WriteLine t Console WriteLine b done Console WriteLine all subscribed Thread Sleep 5000 outputs as expected this all subscribed b 0 a 0 b 1 a 1 a 0 b 0 a 1 a done b 1 b done The same translated to Java java Action1 Long printNext final String who return new Action1 Long public void call Long o System out println who o Action1 Throwable printErr final String who return new Action1 Throwable public void call Throwable o System out println who o Action0 printComplete final String who return new Action0 public void call System out println who done @Test public void testConcat2 throws Exception Observable Long o Observable concat Observable interval 500 TimeUnit MILLISECONDS take 2 Observable interval 500 TimeUnit MILLISECONDS take 2 o subscribe printNext a printErr a printComplete a o subscribe printNext b printErr b printComplete b System out println all subscribed Thread sleep 5000 only outputs this all subscribed a 0 a 1 a 0 a 1 a done If I replace the Observable interval by an Observable from the problem disappears so I think the problem only shows up if we have concat concurrency multiple subscribers','The issue is in the Concat operation sharing its innerSubscription among observers I m about to fix that Fixed in #586',RxJava,false,false,false
23659249,'Don t call plugin s handler if handler is given','When an error handler is explicitly supplied don t delegate to the plugin s error handler This looks like a mistake but I m not certain I wasn t able to find documentation on the error handler plugin that describes when it s called My assumption here is that it s a default error handler called when no onError implementation is supplied','RxJava pull requests #483 https netflixoss ci cloudbees com job RxJava pull requests 483 SUCCESS This pull request looks good It calls handleError by design for all onError invocations so we do not want to remove these calls See https github com Netflix RxJava blob master rxjava core src main java rx plugins RxJavaErrorHandler java#L32 This is to allow large systems such as the Netflix API to have a hook into all errors regardless of how Rx sequences perform error handling For example all errors can be logged in a consistent manner Handling of scenarios when an onError handling is not provided is similar to this https github com Netflix RxJava blob master rxjava core src main java rx Observable java#L330 What is the use case that inspired this PR @benjchristensen Thanks for clarifying Looks like the comment we missed was this one https github com Netflix RxJava blob master rxjava core src main java rx plugins RxJavaErrorHandler java#L22 We wanted a default error handler that throws in the event that we do not explicitly define an onError and wrongly assumed this was an appropriate hook So does the default behavior of throwing when an onError handler is not provided work as you expect',RxJava,true,false,false
23666299,'Possible race condition in Subscription scala','Hi I m looking at Subscription scala because I m doing the Coursera Reactive course The code below from Subscription scala looks a bit suspect I think there s a race condition that will happen especially if u takes a long time that could lead to multiple calls to u I m not sure if you consider this an issue as I am not sure if Subscriptions are shared across threads but the use of the AtomicBoolean seems to imply this Would something like def unsubscribe if unsubscribed compareAndSet false true u be better also looks like subclasses eg BooleanSubscription may have this problem If you think this is an issue I can look to fix Regards Mick def apply u Unit Subscription new Subscription private val unsubscribed new AtomicBoolean false def isUnsubscribed unsubscribed get val asJavaSubscription new rx Subscription def unsubscribe if unsubscribed get u unsubscribed set true','A question can unsubscribed be set to true before u finishes If no AtomicBoolean is not enough I think we need a lock It doesn t need a lock it just needs to use compareAndSet getAndSet or some other similar atomic operation For example https github com Netflix RxJava blob master rxjava core src main java rx operators SafeObserver java#L71 https github com Netflix RxJava blob master rxjava core src main java rx operators SafeObservableSubscription java#L59 https github com Netflix RxJava blob master rxjava core src main java rx operators SafeObservableSubscription java#L72 I m somewhat curious as to why Scala adapters are reimplementing this logic rather than leveraging the Java core implementations Subscription in RxScala has one more method def isUnsubscribed Boolean comparing with RxJava https github com Netflix RxJava blob master language adaptors rxjava scala src main scala rx lang scala Subscription scala If we only uss CAS for example def unsubscribe if unsubscribed compareAndSet false true u in this implementation isUnsubscribed can return true before u finishes Is it OK If so I think we need a document to warn such problem The following implementation can guarantee isUnsubscribed always return false before u finishes scala def apply u Unit Subscription new Subscription private val lock new ReentrantLock private val unsubscribed new AtomicBoolean false def isUnsubscribed unsubscribed get val asJavaSubscription new rx Subscription def unsubscribe lock lock try if unsubscribed get u unsubscribed set true finally lock unlock We need a lock because we need to guarantee the codes of the three operators get u and set are a critical section @samuelgruetter can you help me confirm if the following conventions are right If unsubscribe returns isUnsubscribed should return true If u does not finish isUnsubscribed should return false u should only be called once Why are these not just wrapping Java implementations isUnsubscribed was recently added to Subscription by @headinthebox but I think this was a quick hack rather than the intended final solution His idea was that Subscription should have this method since all its subclasses have it anyways But I think we really should keep all logic in Java So best would be to add isUnsubscribed to the Java Subscription as well and have the default Subscriptions create use a BooleanSubscription And once it s fine in Java just wrap it in Scala So the upshot is The implementation is wrong but it is a temporary hack probably and the scala classes should really be wrappers so semantics reside in the java implementation with delegation from scala classes Wrt to semantics and question from zsxwing the call to unsubscribe can return before u completes which seems reasonable and seems to be the behaviour in the java classes @benjchristensen Could you help clarify the semantics of isUnsubscribed in SafeObservableSubscription I discussed this with @headinthebox last week and there isn t a very strong argument for making the major breaking change of adding isUnsubscribed to the Subscription interface It greatly complicates people implementing the interface and creates little value Changing the Subscription interface makes it a non functional interface so it can t be implemented with lambdas It complicates the implementation for the many cases where someone doesn t need to check isUnsubscribed It breaks most codebases using RxJava in a serious way to change this interface It is not required behavior for a Subscription Last of all subscriptions are supposed to be idempotent anyways so unsubscribe can be called multiple times safely without a check to isUnsubscribed If the isUnsubscribed behavior is needed there are many implementations of Subscription that include it BooleanSubscription https github com Netflix RxJava blob master rxjava core src main java rx subscriptions BooleanSubscription java#L32 CompositeSubscription https github com Netflix RxJava blob master rxjava core src main java rx subscriptions CompositeSubscription java#L86 MultipleAssignmentSubscription https github com Netflix RxJava blob master rxjava core src main java rx subscriptions MultipleAssignmentSubscription java#L34 SingleAssignmentSubscription https github com Netflix RxJava blob master rxjava core src main java rx subscriptions SingleAssignmentSubscription java#L77 Considering all of this what is trying to be achieved by adding this method to the Subscription interface @zsxwing SafeObservableSubscription is managing a trinary state to know when it is unsubscribed null not subscribed to yet non null and to UNSUBSCRIBED subscribed non null and to UNSUBSCRIBED unsubscribed This is so that a race condition for using wrap correctly unsubscribes while wrapping if it is already unsubscribed and uses compareAndSet in wrap to safely do this logic This is important so the unsubscribe action is propagated to the actual subscription either when unsubscribe is called or when wrap is called after already having received an unsubscribe request @benjchristensen that makes sense so I ll remove isUnsubscribed from Scala Subscription and hope everyone is happy with it Yes I think it makes sense for Subscription to remain a functional interface with the single unsubscribe method in Java and for Scala to match that @benjchristensen So if SafeObservableSubscription isUnsubscribed returns true it means that either the actualSubscription has been unsubscribed or it s a promise that it will be unsubscribed in the near future automatically Am I right In practice yes It is answering whether the outer SafeObservableSubscription has been unsubscribed which it has been if it returns true It the wrap method has not yet been called then it will unsubscribe in the future to whatever is wrapped For Scala it is OK to have isUnsubscribed since you just call Subscription block making it as convenient as a functional interface Well @headinthebox if you really want isUnsubscribed in Scala Subscription you can have it But then Scala subscription should wrap a Java BooleanSubscription instead of implementing itself the logic of remembering if already unsubscribed @samuelgruetter If the implementation of BooleanSubscription is fixed What I won t see is what type to give to asJavaSubscription in that case The extra code in Scala is pretty thin Fixed in https github com Netflix RxJava pull 598',RxJava,false,false,false
23685091,'skipUntil marble diagram and wiki link in javadoc','','RxJava pull requests #484 https netflixoss ci cloudbees com job RxJava pull requests 484 SUCCESS This pull request looks good',RxJava,true,false,false
23685986,'Are there any build in observers for invoking action if onError or onNext was called','Are there any build in observers for invoking action if onError or onNext was called Typical use case is rest call from UI Before REST call you should disable inteface and if operation success or fails you should reenable it again ProgressDialogFragment show getActivity api someMethpd doOnEach new NextOrErrorObserver DriverApplication new Action0 @Override public void call ProgressDialogFragment dismiss getActivity subscribe new Action1 Result @Override public void call Result result new Action1 Throwable @Override public void call Throwable throwable Currently I implemented one by my self public class NextOrErrorObserver T implements Observer T private Action0 nextOrErrorAction public NextOrErrorObserver Action0 nextOrErrorAction this nextOrErrorAction nextOrErrorAction @Override public void onCompleted @Override public void onError Throwable e nextOrErrorAction call @Override public void onNext T args nextOrErrorAction call BTW I cannot use finallyDo for this Finally do only triggered for onComplete and onError Also I need my method to be called before onNext and onError','Probably we can add additional variation of doOnEach Like doOnNextOrError There are already options for this doOnError http netflix github io RxJava javadoc rx Observable html#doOnError rx util functions Action1 doOnCompleted http netflix github io RxJava javadoc rx Observable html#doOnCompleted rx util functions Action0 doOnEach for various overloads http netflix github io RxJava javadoc rx Observable html#doOnEach rx util functions Action1 20rx util functions Action1 You can put these in the sequence wherever you want before after whichever sequence of the chain @benjchristensen so right now Im using doOnEach with my custom observer There is no doOnNextOrError that I need Do you thinks its reasonable to have this overload in framework I can implement it and make a pull request There is a doOnEach that takes actions for onNext and onError I don t understand how that is different than a doOnNextOrOnError @benjchristensen difference is that i need to run same logic in both onNext and onError If I will use onNext and onError i will need to call ProgressDialogFragment dismiss in each of them Why is that an issue to call it in either of them You can pass the same function to both the onError and onNext args for doOnEach One or the other will be called and ProgressDialogFragment dismiss will be invoked either way @benjchristensen The only problem is that It s very frequent use case So code like this will be repeated very often api doOnEach actionOnNextOrError actionOnNextOrError I just feel that this overload looks much nicer api doOnNextOrError actionOnNextOrError It s not appropriate to do both onNext and onError with the same function as they receive different argument types OnNext receives type T onError receives Throwable Thus your use case is unique in ignoring either argument The onEach operator is not the right place to combine these It sounds like you want something like finallyDo for terminal state after onComplete or onError but before instead of after @benjchristensen You are right I actually used finallyDo before But in mine specific use case I realized that I cannot use finallyDo since the code should be executed before onNext and onError So you think that should be another operator with name like beforeDo Or its not a generic case and my approach with NextOrErrorObserver is fine api someMethpd doOnEach new NextOrErrorObserver DriverApplication new Action0 @Override public void call ProgressDialogFragment dismiss getActivity @benjchristensen I ended with using this custom class which I can supply as an argument to doOnEach public abstract class NextOrErrorAction0 T implements Action0 Observer T @Override public void onCompleted @Override public void onError Throwable e call @Override public void onNext T args call @Override public abstract void call I think your use of doOnEach is appropriate for your use case',RxJava,false,false,false
23707639,'ObserveOn Moved queue into a per observer instance','I don t fully understand why the original didn t work properly My guess is either the shared queue between observers or a race condition on the recursiveScheduler field My implementation seems to work correctly with the test case in #551 java public class ObserveOnTest static class PrintObserver T implements Observer T private final String prefix public PrintObserver String prefix this prefix prefix void printPrefix System out print prefix System out print @Override public void onNext T args synchronized PrintObserver class printPrefix System out println args @Override public void onError Throwable e synchronized PrintObserver class printPrefix System out println e @Override public void onCompleted synchronized PrintObserver class printPrefix System out println done public static void main String args throws Exception Observable Integer o Observable from 1 2 3 Observable Integer o2 o observeOn Schedulers threadPoolForComputation System out println Subscribe A o2 subscribe new PrintObserver a System out println Subscribe B o2 subscribe new PrintObserver b System out println Waiting Thread sleep 1000 System out println Done','RxJava pull requests #485 https netflixoss ci cloudbees com job RxJava pull requests 485 SUCCESS This pull request looks good I think this should work It seems you left some garbage in the ObserveOn class as you introduced Observation private static class ObserveOn T implements OnSubscribeFunc T private final Observable extends T source private final Scheduler scheduler private volatile Scheduler recursiveScheduler final ConcurrentLinkedQueue Notification extends T queue new ConcurrentLinkedQueue Notification extends T final AtomicInteger counter new AtomicInteger 0 Can you also add the sample as a unit test I ll remove the previous version and add the test shortly',RxJava,true,false,false
23711641,'Inconsistent non standard naming convention of RxJava','I ve been taking the Reactive Programming https www coursera org course reactive course on coursera and ran into this issue It is too late to change the method names but perhaps you can talk about it in the documentation so newbies don t get confused Future and Promise in Scala are similar to Guava s ListenableFuture http docs guava libraries googlecode com git history release javadoc com google common util concurrent ListenableFuture html and SettableFuture http docs guava libraries googlecode com git history release javadoc com google common util concurrent SettableFuture html respectively edit I gather this is probably inherited from Microsoft s C# library but I can t be bothered right this minute to register an account on codeplex In RxJava the Observer trait has the methods onCompleted onError onNext These are used to handle an event Likewise the Subject classes have methods named _exactly the same_ but for a different purpose emitting events This is inconsistent with every other use of the naming pattern onEvent out there JS event handlers even scala s Future itself which typically registers a callback to handle the event An equivalent convention is addEventListener used by some Java UI libraries By contrast the method for firing an event is usually named fireEvent or emitEvent or just plain Event Observer does not register callbacks it _is_ the callback so its methods should be called handleComplete handleError handleNext There is no direct analogy in scala a plain Function callback takes that role in the Future ecosystem but it is analogous to a Guava s FutureCallback http docs guava libraries googlecode com git history release javadoc com google common util concurrent FutureCallback html though that suffers from the same problem Subject is similarly inconsistent It is an event source that fires _callbacks registered elsewhere_ so it is analogous to a Promise Its methods should be called complete error emitNext It would be good if the documentation mentioned this inconsistency in naming perhaps even compare it with other similar libraries in a table like the one below as a helpful guide for people to understand the concepts being discussed TL DR Observable Future registers callbacks methods should be called onEvent callback or subscribe handler Observer FutureCallback is the callback handler itself methods should be called handleEvent or eventOccured Subject Promise emits the events methods should be called event or fireEvent or emitEvent','I can understand your concern but I think it s too late to change this And imagine people comming from NET Rx how confused they would be if all methods were named differently As you said improving the documentation on this might be the best solution I d welcome any pull request doing so How does this sound https github com Netflix RxJava wiki Observable#some notes on naming conventions Some Notes on Naming Conventions The names of methods and classes in RxJava hew close to those in Microsoft s Reactive Extensions http msdn microsoft com en us data gg577609 aspx This has led to some confusion as some of these names have different implications in other contexts or seem awkward in the idiom of a particular implementing language For example there is the onEvent naming pattern e g onNext onCompleted onError In many contexts such names would indicate methods by means of which event handlers are registered In the RxJava Observer context however they name the event handlers themselves And in the RxJava Subject context these same names indicate methods that call the Observer s handlers On Wed Dec 4 2013 at 4 26 AM samuelgruetter notifications@github com wrote I can understand your concern but I think it s too late to change this And imagine people comming from NET Rx how confused they would be if all methods were named differently As you said improving the documentation on this might be the best solution I d welcome any pull request doing so Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 558#issuecomment 29800622 David M Gross PLP Consulting The naming conventions of RxJava are striving for conformity with Reactive Extensions Rx across languages We make changes where there is reason to Subscription vs Disposable for example since Disposable is very much a Net thing but the main interfaces of Observable and Observer strive for conformity In other words the use of onEvent naming is consistent with Reactive Extensions as created by @headinthebox at Microsoft As the project README states some of the goals of RxJava are Stay close to the original Rx Net implementation while adjusting naming conventions and idioms to Java All contracts of Rx should be the same Target the JVM not a language to support languages beyond Java itself such as Groovy Clojure and Scala Support Java 6 to include Android support There are many different ways of naming handlers listeners callbacks etc so we have chosen to stick with the Rx naming conventions unless there is strong reason not to such as when a name collides with reserved keywords in Java As for Subjects they are both an Observable and Observer which is why they have the same onNext onError and onCompleted names They inherit these This is desirable so a Subject can be passed in as an Observer to something and subscribed to as an Observable For this reason it would be bad for Subject to have different names not extend Observer as it would break the ability for it to act as an Observer and be used to subscribe to Observables Also whether they are handling or firing an event depends on your perspective If you are inside an Observable and receive an Observer then you are emitting events to the on methods If you are subscribing to an Observable then you are on the receiving end of the on methods Even if we called it handleNext these two perspectives still exist one side emits to it and one side receives As for the registering of a callback that is what the subscribe does Subscribing to an Observable with an Observer is the registration of the callbacks I agree with Ben the important thing here is to be consistent amongst the Rx implementations in NET JavaScript Java PHP Look at it this way Whenever a producer want to produce another message it needs and observer object on which it can call observer onNext v onError or onCompleted That is how in NET events are raised for instance the OnClick method on Button Raises the Click event of the Button control Now when you subscribe to an an event source as a consumer you hand an observer object to the producer that has implementations of the onNext onError and onCompleted methods such that the producer can call these There is no choice for the names of these methods If there is an inconsistency it would be the name OnCompleted instead of onComplete What you amy be suggesting is that you want different names for the various overloads of subscribe Subscription s observable Subcribe v e Subscription s0 observable onNext v Subscription s1 observable onError e Subscription s2 observable onCompleted But that breaks down because now you get back 3 different subscriptions Which points at another big difference in the Rx design when you subscribe to an observable you get back a subscription that you use to unsubscribe instead of explicitly removing the handler Anyway I think it is not that productive to actually to think of Rx in terms of events and event handlers because events are not first class citizens whereas Observables are If you would make events in JavaScript first class you would immediate see that producing and consuming is symmetrical and you would also have a single name OnXXX Hope this helps I understand the intent to be consistent with the existing Rx framework which is why I suggest discussing this in the documentation rather than fixing the issue outright However this justification does not negate the issue that the methods are named in a confusing way In the purest abstract description of these concepts the separate concerns I gave clearly define the workflow separate handler registration event firing event handling OTOH it is simply an implementation detail that Subject is also Observer and Observable and this unnecessarily conflates the abstract concepts mentioned before If I were re designing these libraries from scratch I would make sure both the concepts and names are clearly separated Also whether they are handling or firing an event depends on your perspective If you are inside an Observable and receive an Observer then you are emitting events to the on methods If you are subscribing to an Observable then you are on the receiving end of the on methods This is conflating the concepts here which reinforces my point that the methods are confusingly named If you are inside an Observable you will call out to the event handlers when those events are triggered In a separate call site the application calls in to your on method to register their handler If you are inside an Observer you are the consumer of the event The Observable will call in to your handle method to handle the event If you are the event generator you are the producer of the event You call out to the emit method on the subject to start the process that eventually reaches the consumers of the event My argument may be made more plain by looking at the signatures of the methods methods that register a callback that should be called on take a callback or function as their argument methods that are themselves handling an event that should be called handle take an event object as their argument and are defined by the user 1 and do application level things The framework should not need to care about what happens in here methods that emit events that should be called fire or emit take the event object as the argument but are defined by the framework and eventually call the appropriate registered handlers These methods should usually be private to the framework the application should not ever need to call it unless you want to let the user emit their own events This is desirable so a Subject can be passed in as an Observer to something and subscribed to as an Observable In certain cases especially combinators the emitter method might simply forward to some other handler method However this pass through still has two separate concerns the input vs the output and it would be better to make this explicit by naming each side of the pipe differently This is precisely the reason why scala s Promise Future and guava s SettableFuture has separate complete and onComplete methods regrettably named differently Whenever a producer want to produce another message it needs and observer object Now when you subscribe to an an event source as a consumer you hand an observer object to the producer Here you are only considering the Observer interface as the callback handler Sure there is no choice but this is bypassing the issues I brought up That is how in NET events are raised for instance the OnClick method on Button Raises the Click event of the Button control Then there is a problem in NET s naming too Here onClick emits the event In Observer onNext etc handles the event These are conceptually different yet the name is the same BTW I do not feel particularly strongly how they are named as long as separate concerns are named differently and consistently I originally learnt about this stuff from JavaScript where onX is purely for registering callbacks You typically don t create events yourself but you could and they are called something like document createEvent And event handlers do not have explicit handleX method names you just pass in a simple function 1 Yes when you are writing combinators the framework developer is also the user in this context This is a technicality my argument still stands See my other paragraph about combinators and pipes infinity0 carefully read my comments In Javascript events are not first class which is causing your mental block that is you cannot return an event from a method or pass an event as a parameter Observables are not at all like JavaScript events You are one off An event in JavaScript and NET is a special property of a function type on an object In pseudo C# JS event style class FooBar public event Action EventArgs Click private void onClick EventArgs args var foobar new FooBar Action EventArgs handler args foobar Click handler foobar Click handler versus using Rx style class FooBar public Observable EventArgs Clicks _Clicks asObservable private Subject EventArgs _Clicks private void onClick EventArgs args _Clicks OnNext args var foobar new FooBar var subscription foobar Clicks Subscribe args subscription unSubscribe You are comparing apples to oranges No you are the one who is not reading my comments and completely ignoring the point I am making I never said an Observable is like a JavaScript event and your C# JS example has nothing to do with what I said Your FooBar class does not even exist in JS JS does not have the equivalent of an Observable However it does have handler registration event handling and event firing My issue is with the naming conventions used for the analogous concepts in RxJava which conflate these separate concepts It would appear that @DavidMGross understands what I am talking about so why are you having trouble @infinity0 Just so you re aware @headinthebox is Erik Meijer from the Coursera course and the inventor of Rx @DavidMGross Not sure this is completely accurate And in the RxJava Subject context these same names indicate methods that call the Observer s handlers They are not methods that call the handlers they are the handlers A Subject is an Observer as well as an Observable Many times a Subject is being used to subscribe to an Observable and acts as an Observer to then allow others to subscribe to it This is how the publish multicast replay operators work @benjchristensen that doesn t change any part of what I said If he is correct then he ought to explain it better I m expressing frustration because all of what I wrote was just brushed off with I m wrong To annotate the example above class FooBar public Observable EventArgs Clicks _Clicks asObservable private Subject EventArgs _Clicks 2 private void onClick EventArgs args 3 _Clicks OnNext args var foobar new FooBar var subscription foobar Clicks Subscribe args 1 subscription unSubscribe 1 This is registering a handler for events on Clicks 2 I m assuming this an event handler from the way it s used But it s not for events on Clicks but rather on some external UI button Then the example is missing the code where we actually register this event handler on the UI framework 3 This is event firing When the click event is handled what we re doing in this method we want to fire the next event on _Clicks This would then presumably call the handler we registered in 1 The pattern of register fire handle is a simple conceptual model but when you rename all parts of this process onEvent it disrupts that model in our heads and makes it hard to understand things I am not saying the model is incorrect or that it is itself flawed but rather that the expression of this model can be done in a less confusing way The pattern of register fire handle is a simple conceptual model sure but it is just not the Rx model In Rx you think about transforming collections of values When you deal with a traditional event source in Rx the first thing you do is to hide them as an Observable T stream Let me try to give you another example not involving subjects To create Observable you usually don t use a Subject but Observable Create var source Observable observer Observer T observer onNext v Subscription and subscribe to it by passing in an observer var subscription source Subscribe new Observer def onNext value v Unit Why is the signature of create like this Well because if you look at the Observable T trait you see that it looks like trait Observable T subscribe observer Observer T Subscription trait Observer T onNext T value Unit So the factory function takes a function of the shape Observer T Subscription There is no way around that Say you rename onNext because you think it is confusing it is used in creating an observable and consuming an observable to something else say whatEverYouWantToCallThis trait Observable T subscribe observer Observer T Subscription trait Observer T whatEverYouWantToCallThis T value Unit That will not change Observable Create and you will have to write whatEverYouWantToCallThis to push values into the stream Observable observer Observer T observer whatEverYouWantToCallThis v Subscription and subscribe to it by providing an implementation of an observer that uses the same names var subscription source Subscribe new Observer def whatEverYouWantToCallThis value v Unit That s it There is only one name to choose Think of the Rx naming convention as follows An Observer contains callback methods onNext will be called on each T emitted by an Observable onError will be called on receiving an error Throwable Exception emitted by an Observable onCompleted will be called on completion of an Observable An Observable represents a potential for events zero or more data of type T an error of type Throwable a completion signal Events from an Observable are subscribed to with an Observer which is the handler callback whatever this is done via the Observable subscribe Observer o method Subscribing returns a Subscription that can be unsubscribed to terminate the Observable The reason why subscribe makes sense on an Observable is because it can potentially be infinite so it really is a subscription to all events it may emit The Subject classes are intended to be combinators that s why they implement both The on signatures make sense when viewed in that manner as a Subject is an object that will be invoked on emission of events from an Observable it subscribes to Yes the events can be manually triggered by invoking the on methods directly but general usage is subscribe a Subject to another Observable Conceptually we could capture the Observer passed into the Observable subscribe turn it into an ObserverHandler and expose sendNext sendError sendCompleted methods instead of on This is just adding a new type with little value More types generally cause grief In practice never once has it been confusing when receiving an Observer inside an Observable to invoke the on methods This is very similar to any pub sub system including the original Gang of Four Observer pattern where the Observer has a method such as update T t on it From the subscriber side it is a callback from the publisher side it is for emitting the event The simplicity of Observable Observer is very elegant regardless of whether the Observer methods are called next error completed or onNext onError onCompleted or any other variant Conceptually we could capture the Observer passed into the Observable subscribe turn it into an ObserverHandler In practice never once has it been confusing OK for now I ll take your word on this since I haven t played around enough with this stuff I think I made a mistake in thinking that Subject is the analogue of Promise I now see that this is an imperfect analogy But I ll also have a further look into the difference between operators vs subjects the fact that they both exist seems connected to this issue I still think that on evokes the event based mental model to someone not familiar with this one But thanks for your time both of you and I also hope it s been useful for you too to practise explaining these topics One of the reasons why I had the register handle fire model in my head is because Future and Promises do follow this model you have onComplete on Future to register a Function which is itself the callback and you can call complete on the Promise to fire the event To avoid callback hell you use map or flatMap When Observable was introduced as the many items counterpart to Future I was expecting this model too In fact I might still try an exercise to define a form of Observable that is closer to the interface of Future Promise and see how that s like to use',RxJava,false,false,false
23712653,'Unsubscribed buffer continues producing','version 0 15 1 I don t know whether this is expected behaviour but I believe it isn t since it s verry counterintuitive to me e g in the scala repl import rx lang scala Observable import scala concurrent duration _ val obs Observable interval 100 millis map _ scala util Random nextInt 8 val bObs obs buffer 2 seconds 1 second val subs bObs subscribe x println x subs unsubscribe Eventually the subscribtion bObs continues producing empty Buffers outputting them in the repl whereas I would expect this to stop','Indeed here s something wrong This snippet scala val obs Observable never val bObs obs buffer 200 millis 100 millis val subs bObs subscribe x println x println subscribed Thread sleep 1000 println unsubscribed Thread sleep 2000 outputs subscribed Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer unsubscribed Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer which is wrong After unsubscribe there should be no more Buffers I think the problem is that on this line https github com Netflix RxJava blob fecf2a318e09f4c181fe6245cb9b563e64a9b64a rxjava core src main java rx operators OperationBuffer java#L338 the returned subscription will not call the TimeBasedChunkCreator stop method You re forgetting the subs unsubscribe call in your snippet but the issue remains For that matter same unexpected behaviour with window where production continues after calling unsubscribe val obs Observable never val bObs obs window 200 millis 100 millis val subs bObs subscribe x println x println subscribed Thread sleep 1000 subs unsubscribe println unsubscribed Thread sleep 2000 @pjan LOL yes you re right Same thing happening with me The subscription continues to run but receiving empty buffers after using unsubscribe Fixed in https github com Netflix RxJava pull 596',RxJava,false,false,false
23720337,'Add type variances for doOnEach actions','This fixes the use of contravariant actions issue #532','RxJava pull requests #487 https netflixoss ci cloudbees com job RxJava pull requests 487 SUCCESS This pull request looks good lgtm',RxJava,true,false,false
23728634,'Creating Observables in Scala Approach04','This implements approach04 from https github com Netflix RxJava issues 549 I also moved the toScalaXxx toJavaXxx methods into a separate file so that one can import only these without importing the implicit function conversions There s now also Observable from Future and to test it some tweaks in Notification were necessary Note that this is a breaking change','RxJava pull requests #488 https netflixoss ci cloudbees com job RxJava pull requests 488 SUCCESS This pull request looks good Is this a breaking change for Scala Yes This needs to be rebased Since this is breaking it makes sense to merge before releasing 0 16 0 with the other breaking Scala changes I would appreciate if you provided release notes for this and the other breaking Scala changes to include when I release 0 16 0 rebasing done RxJava pull requests #494 https netflixoss ci cloudbees com job RxJava pull requests 494 SUCCESS This pull request looks good',RxJava,true,false,false
23737359,'Scala Adaptor Improvements by Erik','There are many important improvements by Erik on the branch https github com Applied Duality RxJava tree RxJavaBugFixes and I d like to have them on Netflix master so that everyone works on the same code and that we can avoid duplicate work since some changes I d like to do require changes that Erik has already made @headinthebox hope you re ok with this','RxJava pull requests #490 https netflixoss ci cloudbees com job RxJava pull requests 490 SUCCESS This pull request looks good Are these breaking changes Yes Thanks Samuel I was waiting for your OK on this Ben you want to merge these in so Samuel and I can make progress Are both of you ready for a 0 16 0 release or is more coming before that Can you give me release notes on breaking changes I ll write release notes tonight Samuel you want to make a pull request on my branch so I can pull in your changes I think that still shows up in the RxJava pull request as coming from you I believe so that you get the credit you deserve Or do it in two steps',RxJava,true,false,false
23752614,'Operation GroupByUntil','Issue #52 Rebased','RxJava pull requests #491 https netflixoss ci cloudbees com job RxJava pull requests 491 SUCCESS This pull request looks good',RxJava,true,false,false
23770899,'Different behaviors of SequenceEqual in Rx Net and RxJava','Looks SequenceEqual in Rxjava is not correct In Rx Net SequenceEqual returns an Observable which only has one element indicating if these two sequences are same For example c# var o Observable SequenceEqual Observable Range 1 100 Observable Range 1 100 var s o Subscribe v Console WriteLine Equal v e Console WriteLine e Console WriteLine onCompleted Console WriteLine Press any key Console ReadKey Outputs pre Equal True onCompleted Press any key pre But in RxJava the following codes java Observable sequenceEqual Observable range 1 100 Observable range 1 100 toBlockingObservable forEach new Action1 Boolean @Override public void call Boolean t1 System out println t1 Output 100 true s','I ve noticed that using zip to pair up values is not the same behavior as in Rx NET In Rx NET the operator checks if the length of the streams are the same or not Even if we don t want to do that one could add a simple all operator after the zip java public static T Observable Boolean sequenceEqual Observable extends T first Observable extends T second Func2 super T super T Boolean equality return zip first second equality all Functions Boolean identity Using the materialized view is not an option as errors need to be propagated directly and not compared and generally equals doesn t work on Throwables I can take this this weekend fixed in #575',RxJava,false,false,false
23771239,'Operator GroupJoin v2','Issue #53 Rebased Still @headinthebox While writing the test for the operator I ve noticed that when both duration selectors are never Rx NET never calls onCompleted on the group subjects even though the left and right sources onComplete I haven t seen Rx NET test for this scenario This comes into play when I want to emulate join with groupJoin the outer merge never onCompletes If I understand the behavior corretly when both left and right sources get depleted there is no way a new group or new group value would arrive and all the open groups and the main observer can be onCompleted This is somewhat similar to join and groupByUntil behavior','RxJava pull requests #493 https netflixoss ci cloudbees com job RxJava pull requests 493 SUCCESS This pull request looks good',RxJava,true,false,false
23773317,'Operation Sample with another Observable','Issue #74 Added missing Observable sample Observable U sampler','RxJava pull requests #495 https netflixoss ci cloudbees com job RxJava pull requests 495 SUCCESS This pull request looks good Note if the code sampler code completes before this completes no code onCompleted code event is emitted in par with Rx NET behavior That seems rather odd It could potentially leave something dangling forever I don t know the reason for this behavior in Rx NET but it isn t the first instance i e SkipUntil Maybe the intention was to sample both the onNext and onCompleted if no more sampler no more samples of onNext or onCompleted In addition it samples values only once so unless a new source value appears the sampler won t emit the last value @headinthebox Why does it behave this way The overload with sampler was introduced as we went through the API and changed everything that took time and added an overload that takes an Observable When you sample using interval d it is as if you are giving it an infinite Observable interval d However it would make sense if it behaved like zip where the result stream terminates when either of the input stream terminates or throws Nice catch What is the issue with SkipUntil That one throws when other throw and skips until it produces a regular value It ignores onCompleted Same for TakeUntil I ll change the code to behave like zip SkipUntil I usually scratch my head when I see an operator returning an Observable which never terminates',RxJava,true,false,false
23774419,'Operation Timestamp with Scheduler','Issue #93','RxJava pull requests #496 https netflixoss ci cloudbees com job RxJava pull requests 496 SUCCESS This pull request looks good',RxJava,true,false,false
23790706,'Use lock free strategy for several Subscription implementations','Reduce contention by using CAS Compare And Swap operations to replace subscription in several subscription implementations','RxJava pull requests #497 https netflixoss ci cloudbees com job RxJava pull requests 497 SUCCESS This pull request looks good Can you use 4 space indent to make this modification more clear It s better that keeping consistent Right there is a potential race condition I m going to try to reproduce it via a unit test and find an alternative I checked nullity because it was checked by the previous code As no unit test was covering nullity cases i chose to keep it compatible with null subscription Do you suggest not to check for nullity You need something like this java public void setSubscription final Subscription subscription Subscription q null do Subscription r reference get if r SENTINEL q newReg break if reference compareAndSet r subscription q r break while true if q null q unsubscribe Similar to this https code google com p reactive4java source browse trunk Reactive4Java8 src hu akarnokd reactive4java8 registrations SingleRegistration java What about this version using a read write lock to minimize contention between concurrent setSubscription calls RxJava pull requests #498 https netflixoss ci cloudbees com job RxJava pull requests 498 SUCCESS This pull request looks good Thanks to akarnokd i could get ride of the AtomicBoolean and Read Write lock using a sentinel RxJava pull requests #499 https netflixoss ci cloudbees com job RxJava pull requests 499 SUCCESS This pull request looks good RxJava pull requests #501 https netflixoss ci cloudbees com job RxJava pull requests 501 FAILURE Looks like there s a problem with this pull request RxJava pull requests #502 https netflixoss ci cloudbees com job RxJava pull requests 502 SUCCESS This pull request looks good RxJava pull requests #503 https netflixoss ci cloudbees com job RxJava pull requests 503 SUCCESS This pull request looks good We should add isUnsubscribed to SerialSubscription Not sure if I understand the role of unsubscribe It is set to current when you actually unsubscribe assuming single threaded execution s unsubscribe setSubscription UNSUBSCRIBED current reference get reference compareAndSet current subscription true current unsubscribe subscription UNSUBSCRIBED unsubscribe current Now we do s setSubscription X current reference get current UNSUBSCRIBED because we unsubscribed above subscription unsubscribe and then we do s getSubscription subscription reference get subscription UNSUBSCRIBED return unsubscribe which was set above to current So we are returning an arbitrary old subscription when you do getSubscription Seems you can do without it @Override public void unsubscribe setSubscription UNSUBSCRIBED public void setSubscription final Subscription subscription do final Subscription current reference get if current UNSUBSCRIBED subscription unsubscribe break if reference compareAndSet current subscription current unsubscribe if subscription UNSUBSCRIBED unsubscribe current break while true public Subscription getSubscription Subscription subscription reference get return subscription UNSUBSCRIBED unsubscribe subscription Because we need a way to indicate completion of the subscription and empty is public so clients might swap it in or out reactivating the subscription My example matches the Rx Net way Don t get what you say If you are unsubscribed anyway why not return UNSUBSCRIBED Sorry I couldn t follow jloisel s commits due to the heavy rewriting The field private volatile Subscription unsubscribe seems to be useless one should return Subscriptions empty when unsubscribed The setSubscription UNSUBSCRIBED is an overkill We could just use reference getAndSet UNSUBSCRIBED and unsubscribe the returned value if not null The correct class should look like this java public class SerialSubscription implements Subscription private final AtomicReference Subscription reference new AtomicReference Subscription private static final Subscription UNSUBSCRIBED new Subscription @Override public void unsubscribe @Override public void unsubscribe Subscription q reference getAndSet UNSUBSCRIBED if q null q unsubscribe public void setSubscription final Subscription subscription Subscription q null do final Subscription current reference get if current UNSUBSCRIBED q subscription break if reference compareAndSet current subscription q current break while true if q null q unsubscribe public Subscription getSubscription Subscription subscription reference get return subscription UNSUBSCRIBED Subscriptions empty subscription public boolean isUnsubscribed return reference get UNSUBSCRIBED headinthebox UNSUBSCRIBED is the internal sentinel It should not escape from SerialSubscription internal implementation since it could lead to unexpected behavior We could another complete different approach since managing a thread safe mutable state is difficult shouldn t we make the serial subscription immutable I mean getSubscription method violates encapsulation it let s the internal state escape One could unsubscribe the internal subscription from outside the serial subscription which could lead to double unscribe if then unscribed from serial Shouldn t SerialSubscription be package protected or have at least a static factory method with a private constructor like public static Subscription serial final Subscription delegate return new SerialSubscription delegate And remove getSubscription since it s never used in the api Of course this tends to no backward compatibility on this class since it s public If we tend to have the same behavior as before getSubscription should return null when previously unscribed RxJava pull requests #505 https netflixoss ci cloudbees com job RxJava pull requests 505 SUCCESS This pull request looks good I think we cannot use Subscriptions empty as unsubscribed sentinel since it would behave unexpectedly it one sets empty from outside via setSubscription I tend also to avoid null references in implementation to avoid unnecessary burden which reduces comprehension rx core code base analysis shows that SerialSubscription could be easily immutable But it diverges with Rx contract http msdn microsoft com en us library system reactive disposables serialdisposable v vs 103 aspx Rather than try to have a complex contract for SerialSubscription i would give a try to make it immutable Immutable is thread safe by nature as well as contention free Oh it seems like due to cyclic dependencies like on ResultSink it s not possible to make it immutable RxJava pull requests #525 https netflixoss ci cloudbees com job RxJava pull requests 525 SUCCESS This pull request looks good Looks like an improvement on current implementation and don t see problems Using a state machine here is far preferable to the previous lock based implementation This should help or fix https github com Netflix RxJava issues 577',RxJava,true,false,false
23805990,'javadoc improvements groupJoin groupByUntil timestamp w scheduler','adding marble diagrams and links to the RxJava wiki standardizing javadoc comment formatting','RxJava pull requests #500 https netflixoss ci cloudbees com job RxJava pull requests 500 SUCCESS This pull request looks good @DavidMGross it would be nice to have a separate diagram for this overload of zip java public static R Observable R zip Observable extends Observable ws FuncN extends R zipFunction Today I wanted to explain this operator to some people and a nice marble diagram for this would have been useful As zipFunction maybe just take a Func3 which puts its 3 arguments into one box I ll see what I can come up with On Fri Dec 6 2013 at 4 43 AM samuelgruetter notifications@github com wrote @DavidMGross https github com DavidMGross it would be nice to have a separate diagram for this overload of zip public static R Observable R zip Observable extends Observable ws FuncN extends R zipFunction Today I wanted to explain this operator to some people and a nice marble diagram for this would have been useful As zipFunction maybe just take a Func3 which puts its 3 arguments into one box Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 569#issuecomment 29987282 David M Gross PLP Consulting How does this look https raw github com wiki Netflix RxJava images rx operators zip o png On Fri Dec 6 2013 at 9 59 AM PLP Consulting David Gross davgross@netflix com wrote I ll see what I can come up with On Fri Dec 6 2013 at 4 43 AM samuelgruetter notifications@github com wrote @DavidMGross https github com DavidMGross it would be nice to have a separate diagram for this overload of zip public static R Observable R zip Observable extends Observable ws FuncN extends R zipFunction Today I wanted to explain this operator to some people and a nice marble diagram for this would have been useful As zipFunction maybe just take a Func3 which puts its 3 arguments into one box Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 569#issuecomment 29987282 David M Gross PLP Consulting David M Gross PLP Consulting Nice Two ideas for improvement Having the three observables overlap each other in time would make the diagram more instructive binds stronger than in most languages so you really should add parentheses ie write zip cloud circle triangle triangle because otherwise it is read as zip cloud circle triangle triangle This confused me a lot even though I already knew the semantics of the operator Good suggestions I ll see what I can do On Sun Dec 8 2013 at 7 12 AM samuelgruetter notifications@github com wrote Nice Two ideas for improvement Having the three observables overlap each other in time would make the diagram more instructive binds stronger than in most languages so you really should add parentheses ie write zip cloud circle triangle triangle because otherwise it is read as zip cloud circle triangle triangle This confused me a lot even though I already knew the semantics of the operator Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 569#issuecomment 30083438 David M Gross PLP Consulting',RxJava,true,false,false
23830882,'Re implement GroupBy Operator','The GroupBy operator almost certainly needs to be rewritten History on the discussions and attempts at fixing it can be seen at https github com Netflix RxJava issues 282 and https github com Netflix RxJava pull 289','And please when you do so also make it work with multiple subscribers @manojo and me ran into this issue yesterday and I wanted to open another issue when I just saw this I ve read through both issues but still don t quite understand the problem @benjchristensen and or @samuelgruetter could you please reiterate the requirements and corner cases Edit Somewhat related issue in Rx NET https rx codeplex com workitem 57 Edit Somewhat related issue in Rx NET This should be added to the documentation There s a problem I remember but I don t have a proper test illustrating this right now I used groupBy on a source Observable like Observable interval someTransformationsWhichMakeItFinite but when the source Observable completed the returned Observable Observable T or some of the inner Observable T did not complete Having a good unit test which tests this with concurrency and multiple subscribers would imho be very useful even if it does not reveal a bug it would make it more trustworthy What do you think of the explanation illustration here https github com Netflix RxJava wiki Transforming Observables#groupby and groupbyuntil Note that when groupBy or groupByUntil splits up the source Observable into an Observable that emits Observables it begins to emit items from the source Observable onto these emitted Observables immediately That is to say it does not wait for any Observers to subscribe So if you want to ensure that you see all of the items that are emitted on these new Observables you should take care to subscribe to them right away The following illustration shows how this can cause unexpected behavior In this illustration groupBy is used to separate a source Observable that emits the numbers 1 through 6 into an Observable in red that emits two Observables one that emits the odd numbers from the source Observable and the other that emits the even numbers Then this Observable of Observables shown in red is zipped with another Observable shown in blue that emits the strings odd and even and in the zip function it applies this string label to all of the items emitted by the associated Observable emitted by the Observable shown in red However zip does not apply this zip function until it observes an item emitted by each of the red and the blue source Observables Since odd arrives after the first of these Observables has already emitted 1 when zip has not yet subscribed to this Observable it never observes this 1 and does not apply the zip function to it A similar thing happens with even which arrives after both 2 and 4 are emitted by the Observable emission it is paired with from the red colored Observable For this reason the transformed Observable emitted by zip is missing some of the data from the original Observables On Sun Dec 8 2013 at 7 08 AM samuelgruetter notifications@github com wrote Edit Somewhat related issue in Rx NET This should be added to the documentation There s a problem I remember but I don t have a proper test illustrating this right now I used groupBy on a source Observable like Observable interval someTransformationsWhichMakeItFinite but when the source Observable completed the returned Observable Observable T or some of the inner Observable T did not complete Having a good unit test which tests this with concurrency and multiple subscribers would imho be very useful even if it does not reveal a bug it would make it more trustworthy Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 570#issuecomment 30083341 David M Gross PLP Consulting You can fix the odd even issue by using ReplaySubject in groupBy instead of the default PublishSubject I think this is unnecessarily strong and memory consuming solution which needs to be paid on every groupBy use case not just these non immediate consuming versions For the cases where the immediate consumption is not possible one could use a replay mapped group manually java Observable Integer source Observable from 1 2 3 4 5 6 7 8 9 10 Observable concat source groupBy x x 2 0 map u u replay doOnEach v v connect subscribe System out println Are we happy with the current groupBy behavior Note that groupByUntil does not use the BufferUntilSubscriber subject I guess we want them consistent From what I can tell groupBy is finally working correctly The groupByUntil implementation has not been updated though and needs to be brought inline I imagine From what I can tell groupBy is finally working correctly Nice I ll try some edge cases It was fully re implemented and I know of no problems at this time so closing it',RxJava,false,false,false
23843943,'Operation Sample with Observable v2','Issue #74 Sample will terminate if either the source or the sampler terminates or throws an error The sampler now emits values only in its onNext method Therefore if the sampler completes and there is a sampled value available valueTaken false it won t emit the value before terminating','RxJava pull requests #506 https netflixoss ci cloudbees com job RxJava pull requests 506 SUCCESS This pull request looks good',RxJava,true,false,false
23844710,'ObserveOn fix for observing the same source on the same scheduler by two','different observers Issue #551 cleaned up added test cases','RxJava pull requests #507 https netflixoss ci cloudbees com job RxJava pull requests 507 SUCCESS This pull request looks good Nice refactor Thanks',RxJava,true,false,false
23849102,'Removed Opening and Closing historical artifacts','Issue #540 The build fails due Scala compiler error I don t understand ant scalac RxJava language adaptors rxjava scala src main s cala rx lang scala Observable scala 531 error type mismatch ant scalac found x2 type with underlying type rx Observable _ T ant scalac required T ant scalac Observable T x2 ant scalac ant scalac one error found scala def window Closing closings Observable Closing Observable Observable T val func Func0 _ rx Observable _ Closing closings asJavaObservable val o1 rx Observable _ rx Observable _ asJavaObservable window Closing func val o2 Observable rx Observable _ o1 map x rx Observable _ val x2 x asInstanceOf rx Observable _ T Observable T x2 o2 Could someone help me with this','RxJava pull requests #508 https netflixoss ci cloudbees com job RxJava pull requests 508 FAILURE Looks like there s a problem with this pull request RxJava pull requests #509 https netflixoss ci cloudbees com job RxJava pull requests 509 SUCCESS This pull request looks good RxJava pull requests #510 https netflixoss ci cloudbees com job RxJava pull requests 510 SUCCESS This pull request looks good',RxJava,true,false,false
23858899,'clarify documentation on cache','I lost some time because I didn t read the documentation of cache carefully enough To make it easier for others I tried to make the documentation more explicit here','RxJava pull requests #511 https netflixoss ci cloudbees com job RxJava pull requests 511 SUCCESS This pull request looks good',RxJava,true,false,false
23863207,'Reimplement the SequenceEqual operator','Hi this PR reimplemented the SequenceEqual operator #76 and should fix the issue #564 The wiki page https github com Netflix RxJava wiki Observable Utility Operators#sequenceequal still needs to be updated @DavidMGross could you help update the marble diagram of SequenceEqual Thanks','RxJava pull requests #512 https netflixoss ci cloudbees com job RxJava pull requests 512 SUCCESS This pull request looks good Okay I think I ve got it corrected It only covers one condition so might benefit from having some more examples but it ll do for now On Fri Dec 6 2013 at 7 13 AM CloudBees pull request builder plugin notifications@github com wrote RxJava pull requests #512 https netflixoss ci cloudbees com job RxJava pull requests 512 SUCCESS This pull request looks good Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 575#issuecomment 30001152 David M Gross PLP Consulting @DavidMGross Looks cool Thanks RxJava pull requests #514 https netflixoss ci cloudbees com job RxJava pull requests 514 SUCCESS This pull request looks good Good job just a few things You are using gate to ensure concurrency and you access the firstDone and secondDone while synchronizing over gate I believe these two can be simple boolean fields instead of AtomicBooleans You are setting the firstValues and secondValues in the init method into a volatile fields I believe these can be moved into the constructor and set to a regular private final List type and accessor Optional you might want to call clear on both firstValues and secondValues if there was a termination condition so they don t hold onto queued values until the client observer disappears I really think that sequenceEqual should be implemented in terms of other operators Don t reinvent the wheel with every operator you add In Scala I d do it like this scala def sequenceEqual T o1 Observable T o2 Observable T Observable Boolean val obs1 Observable Option T o1 map Some _ Observable None is concat val obs2 Observable Option T o2 map Some _ Observable None If different length comparing the None of the shorter with Some element of the longer will return false obs1 zip obs2 forall pair pair _1 pair _2 @samuelgruetter great idea Really thanks I overrode the previous commit As their is no Option in Java I use Notification instead RxJava pull requests #515 https netflixoss ci cloudbees com job RxJava pull requests 515 SUCCESS This pull request looks good I also have a question about Notification hasValue java Retrieves a value indicating whether this notification has a value @return a value indicating whether this notification has a value public boolean hasValue return isOnNext value null Here it checks if value is not null But I think value can be null I also checked the Rx Net codes here http rx codeplex com SourceControl latest#Rx NET Source System Reactive Core Reactive Notification cs c# summary Returns true summary public override bool HasValue get return true It returns true directly in OnNextNotification If Notification hasValue has the same meaning in RxJava and Rx Net I think value null needs to be removed RxJava pull requests #516 https netflixoss ci cloudbees com job RxJava pull requests 516 SUCCESS This pull request looks good Much nicer now Regarding hasValue I don t know What is it good for if it s the same as isOnNext And why would one need the current version Imho it could just be removed Something else regarding null values and sequenceEqual with default equality I think you shouldn t call onError NullPointerException but just onNext true or onNext false @samuelgruetter Thanks for reminding me the null issue RxJava pull requests #517 https netflixoss ci cloudbees com job RxJava pull requests 517 SUCCESS This pull request looks good',RxJava,true,false,false
23867297,'Timer and Delay','As pointed out https github com Netflix RxJava pull 384#issuecomment 26843865 by @headinthebox it s possible to implement delay in terms of timer map and concat However there were some tricky points In order to start the timers right after they re created and not just when concat subscribes to them I had to use replay There is bug https github com Netflix RxJava issues 552 which also affects delay I hope that there aren t too many further tricky points that I missed especially since https github com Netflix RxJava issues 552 adds confusion So this will need another review once https github com Netflix RxJava issues 552 is fixed Thanks @jmhofer for your previous work on delay I reused it where possible see commit messages','RxJava pull requests #513 https netflixoss ci cloudbees com job RxJava pull requests 513 SUCCESS This pull request looks good',RxJava,true,false,false
23893849,'Deadlock in 0 15 x between MultipleAssignmentSubscription and CompositeSubscription','Here s the relevant thread dump RxComputationThreadPool 8 at rx subscriptions CompositeSubscription unsubscribe CompositeSubscription java 100 waiting to lock 0x00007f2a2846be00 a rx subscriptions CompositeSubscription at rx subscriptions MultipleAssignmentSubscription unsubscribe MultipleAssignmentSubscription java 43 locked 0x00007f2a26de2a80 a rx subscriptions MultipleAssignmentSubscription at rx subscriptions CompositeSubscription add CompositeSubscription java 92 locked 0x00007f2a2846be60 a rx subscriptions CompositeSubscription at rx concurrency ExecutorScheduler 4 run ExecutorScheduler java 128 at java util concurrent Executors RunnableAdapter call Executors java 471 at java util concurrent FutureTask Sync innerRun FutureTask java 334 at java util concurrent FutureTask run FutureTask java 166 at java util concurrent ScheduledThreadPoolExecutor ScheduledFutureTask access 201 ScheduledThreadPoolExecutor java 178 at java util concurrent ScheduledThreadPoolExecutor ScheduledFutureTask run ScheduledThreadPoolExecutor java 292 at java util concurrent ThreadPoolExecutor runWorker ThreadPoolExecutor java 1145 at java util concurrent ThreadPoolExecutor Worker run ThreadPoolExecutor java 615 at java lang Thread run Thread java 724 RxComputationThreadPool 7 at rx subscriptions MultipleAssignmentSubscription unsubscribe MultipleAssignmentSubscription java 40 waiting to lock 0x00007f2a26de2a80 a rx subscriptions MultipleAssignmentSubscription at rx subscriptions CompositeSubscription add CompositeSubscription java 92 locked 0x00007f2a2846be00 a rx subscriptions CompositeSubscription at rx concurrency ExecutorScheduler 4 run ExecutorScheduler java 128 at java util concurrent Executors RunnableAdapter call Executors java 471 at java util concurrent FutureTask Sync innerRun FutureTask java 334 at java util concurrent FutureTask run FutureTask java 166 at java util concurrent ScheduledThreadPoolExecutor ScheduledFutureTask access 201 ScheduledThreadPoolExecutor java 178 at java util concurrent ScheduledThreadPoolExecutor ScheduledFutureTask run ScheduledThreadPoolExecutor java 292','In English 2 CompositeSubscriptions denoted using last 2 letters of memory address 00 and 60 1 MultipleAssignmentSubscription 80 Thread 7 Composite 00 add MultipleAssignment 80 unsubscribe Thread 8 Composite 60 add MultipleAssignment 80 unsubscribe Composite 00 unsubscribe So I believe there are 2 bugs here a circular reference between subscriptions and a deadlock when unsubscribes happen on circular subscriptions Also based on our codebase rolling back to 0 14 10 did not exhibit the problem yet We also believe that the Scheduler schedule Action1 method is the one creating the MultipleAssignmentSubscription The only other places are OperationRetry and OperationSwitch Generally unsubscribing should not happen while holding locks especially inside these subscription instances I ll take a look at them Thanks for the really quick work @akarnokd Once we ve got the next release of RxJava into our codebase we ll let you know if the issue is resolved Should be fixed in https github com Netflix RxJava pull 593',RxJava,false,true,true
23907449,'A bug in apply u Unit method of Subscription companion object fixed w','hich may cause multiple invocations of u in a multithreaded multi unsubscribe situation Threads may be pre empted after evaluation of condition unsubscribed get which may result in two or more threads executing the consequent block more than once A code that relies on single evaluation of u will fail if that case happens','RxJava pull requests #518 https netflixoss ci cloudbees com job RxJava pull requests 518 SUCCESS This pull request looks good This was fixed by @headinthebox and can be seen here https github com Netflix RxJava blob master language adaptors rxjava scala src main scala rx lang scala Subscription scala#L68 Thank you @ugur zongur for contributing',RxJava,true,false,false
23915692,'CRLF issues','Cannot believe that it is 2013 and we are still having CRLF changes I guess that @akarnokd is using Windows and I have trouble with CRLF in Async java and friends','Yes I m on Windows and using NetBeans 7 4 with default git settings I thought all this line ending is automatically managed by github or the repo as specified here https help github com articles dealing with line endings So the question is should I create a PR with fixed CRLF or will this be handled on the repo level I ll play with those Github settings to see if I can resolve it there',RxJava,false,false,false
23920645,'CRLF fixes','Issue #579 In case the manual mode is chosen','RxJava pull requests #519 https netflixoss ci cloudbees com job RxJava pull requests 519 SUCCESS This pull request looks good I added the gitattributes file in this commit https github com Netflix RxJava commit 4782588aa15a954ea053977d6b740127d31ee3f1 and then let Git renormalize itself as per https help github com articles dealing with line endings#re normalizing a repository',RxJava,true,false,false
23922893,'OperationConcatTest testNestedAsyncConcat failed','While working on a fix for #577 I ve run into a test failure happened randomly org mockito exceptions verification VerificationInOrderFailure Verification in order failure Wanted but not invoked observer onCompleted at rx operators OperationConcatTest testNestedAsyncConcat OperationConcatTest java 259 Wanted anywhere AFTER following interaction observer onNext nine at rx operators SafeObserver onNext SafeObserver java 121 at rx operators OperationConcatTest testNestedAsyncConcat OperationConcatTest java 259 It appears the observer onCompleted in L195 races with the test inOrder verify observer times 1 onCompleted on L259 Adding a latch after L195 and before L259 seems to be a way to fix this but I m not sure of whether this is rather an issue with concat I see plenty of questionable things in there too Thoughts','Not happening a long ago so closing',RxJava,false,false,false
23922978,'Fix Unsubscribe while not holding a lock','For Issue #577','RxJava pull requests #520 https netflixoss ci cloudbees com job RxJava pull requests 520 SUCCESS This pull request looks good This collides with other commits that have been merged Please rebase Will do in the morning my tz',RxJava,true,false,false
23923140,'Concat shares its innerSubscription among observers','I think L59 https github com Netflix RxJava blob master rxjava core src main java rx operators OperationConcat java#L59 in Concat shares the inner subscription among any observers so when two observers subscribe to the same concat structure they get a race on the inner subscription I believe they should run independently In addition on L124 L125 and L134 innerSubscription is accessed while not holding the synchronized nextSequences lock Thoughs','',RxJava,false,false,false
23923603,'Fixes OnCompleted unapply result type','The Scala spec says that an extractor matches a pattern with zero argument pattern if the result type of unapply is Boolean The result type of Option T means that the extractor has exactly one argument pattern of type T The Option Unit result type does work but it s probably a compiler bug Based on the result type the pattern match case OnCompleted should not compile and case OnCompleted should be used instead Using the latter one crashes the compiler Changing the result type of unapply to Boolean does _not_ change any of this so using the pattern case OnCompleted still crashes the compiler but at least the pattern is not suggested by the unapply result type and the pattern match results in one less object allocation The included test does _not_ check for this problem it simply makes sure that it still works correctly when using the correct pattern','RxJava pull requests #521 https netflixoss ci cloudbees com job RxJava pull requests 521 SUCCESS This pull request looks good Seems correct according to http www scala lang org files archive nightly pdfs ScalaReference pdf section 8 1 8 Extractor Patterns even though it looks like the spec hasn t been updated since version 2 8 Well it is correct but only after adapting the argument list cat e scala object e def f u Unit u f f scalac Ywarn adapted args e scala e scala 5 warning Adapting argument list by inserting this is unlikely to be what you want signature e f u Unit Unit given arguments none after adaptation e f Unit f one warning found And I don t think an Option Unit better describes the possible pattern matches than a Boolean Oops don t get me wrong I wanted to say that I think what you re saying is correct and that your changes should be merged in I just added the link to the spec because I wanted to avoid that other people have to search for it themselves Btw in case you haven t seen it yet the feature of inserting was recently discussed here https groups google com forum # topic scala debate zwG8o2YzCWs Uh oh I misunderstood a bit I don t read scala debate so I missed that thread The link in the latest post https gist github com Poita79 7803974 is a nice summary of the fun you can have with @headinthebox Do you want to pull this into the branch you have going or shall I merge it directly Happy to change but I am a bit confused This thread https gist github com Poita79 7803974 seems totally unrelated to unapply Also why does returning Option Unit suggest matching OnCompleted We all know that vs Unit vs is kind of fuzzy It s not related to what type you should use for zero argument pattern Why does Option Unit suggest OnCompleted Why does Option Int suggest OnCompleted someInt Yes you can write OnCompleted instead of OnCompleted in fact you have to because of the compiler bug but it doesn t mean you should I must be missing something here I can write case OnCompleted am I using a different compiler version than you val onCompleted OnCompleted assertEquals onCompleted match case OnCompleted I m using 2 10 3 You are correct case OnCompleted does work But I don t think I said otherwise What I was trying to saying is that the correct result type for an unapply with zero argument pattern is Boolean Why Because of the outdated maybe irrelevant specification for Scala 2 8 Also because normally Boolean is used for such an unapply And because it misleads people I know it misled me This is a stylistic issue and not a bug so closing out If further discussion is wanted then please start a discussion at https groups google com forum # forum rxjava If https github com Netflix RxJava issues 662 is accepted such a discussion won t be necessary because OnCompleted can become an object instead of a class as Scala users would expect',RxJava,true,false,false
23924006,'Operation Timer','Enhancement #92 I ve omitted the absolute time variants because of the earlier comments on Generate Related issue #530','RxJava pull requests #522 https netflixoss ci cloudbees com job RxJava pull requests 522 SUCCESS This pull request looks good Oops Some duplicate work of https github com Netflix RxJava pull 576 Sorry I ve noticed it after the PR At least 50 of mine is new more if you count the test file @samuelgruetter and @akarnokd Can the two of you please review each others code in https github com Netflix RxJava pull 576 and https github com Netflix RxJava pull 585 and determine what the merge of the two should look like and peer review to recommend what I should merge and when it s ready Let s do the usual thing merge @samuelgruetter s work into main and I ll redo my part on the remaining Timer overload thank you',RxJava,true,false,false
23924493,'Fix Concat to allow multiple observers','Issues #552 and #583','RxJava pull requests #523 https netflixoss ci cloudbees com job RxJava pull requests 523 SUCCESS This pull request looks good I think this looks thread safe so will merge though this has become rather difficult to understand if we have deadlocks race conditions etc so if anyone else wants to take a look please do',RxJava,true,false,false
23925093,'Operation LongCount','Issue #60 Straightforward version of the regular count However I would have implemented it differently so the constant boxing unboxing could be avoided','RxJava pull requests #524 https netflixoss ci cloudbees com job RxJava pull requests 524 SUCCESS This pull request looks good',RxJava,true,false,false
23930703,'Observable concat does not','This issue was discovered by Graeme Ludwig during the Coursera Principles of Reactive Programming class scala import rx lang scala _ import rx lang scala _ scala Observable 1 2 3 4 5 6 7 8 9 10 groupBy _ 2 0 filter _ _1 true map _ _2 concat subscribe x println x 2 4 6 8 10 res0 rx lang scala Subscription rx lang scala Subscription anon 1@6e0031c0 scala Observable 1 2 3 4 5 6 7 8 9 10 groupBy _ 2 0 filter _ _1 false map _ _2 concat subscribe x println x 1 3 5 7 9 res1 rx lang scala Subscription rx lang scala Subscription anon 1@3f18dc75 scala Observable 1 2 3 4 5 6 7 8 9 10 groupBy _ 2 0 map _ _2 concat subscribe x println x 1 3 5 7 9 res2 rx lang scala Subscription rx lang scala Subscription anon 1@320bdadc The concat method seems to be misplacing the results of one of the Observables Above was using rxjava scala 0 15 1','Could be the manifestation of Issues #552 and #583 and hopefully fixed by #586 Excuse my lack of Scala knowledge but where does this misplacement happen in the examples above The scala bindings typically add no logic of themselves but just wrap unwrap the underlying Java classes so in the common case the issue is in RxJava as @akernokd suggests @LannyRipple can you repro this in Java I did some testing with Java 8 and it prints the same values with and without the concat fix I think @LannyRipple expected the last one to print 1 3 5 7 9 2 4 6 8 10 so this is rather the good old groupBy issue once concat finishes with the odd values the even group has already finished and there is nothing to print #282 and #289 However the workaround I proposed in #289 works java Observable Integer source Observable from 1 2 3 4 5 6 7 8 9 10 Func1 Integer Boolean gf v v 2 0 ConnectableObservable Integer co source replay Observable concat co groupBy gf map u co where v gf call v u getKey subscribe System out println co connect or java Observable concat source groupBy x x 2 0 map u u replay doOnEach v v connect subscribe System out println Oops Sorry I should have mentioned the output I expected which would have been the odd numbers then the evens I ll make a mental note and reply back to the class forums that groupBy can cause surprising results Thanks for the clarification of the issue',RxJava,false,false,false
23934635,'Migrate Language Adaptors to Top Level Projects of RxLANG','As we approach 1 0 and based on the experience of working on the language adaptors it is going to make sense to let the adaptors move to a first class level and be named RxScala RxClojure RxGroovy etc instead of RxJava Scala RxJava Clojure etc This should also mean they become top level projects of their own with a single dependency on RxJava This does not need to be done immediately but probably as we hit the 1 0 Release Candidate stage Two reasons for this are don t tie the naming to the Java portion of the core function implementations decouple release and versioning cycles particularly important for Scala where it is typical to maintain branches for the different Scala versions such as 2_10 and 2_11 Anyone else agree or disagree','Agree But as you said it needn t be done immediately but would be good to do it for 1 0 Release Candidate',RxJava,false,false,false
23936996,'SerialSubscription is missing isUnsubscribed','public class SerialSubscription implements Subscription @Override public void unsubscribe public void setSubscription final Subscription subscription public Subscription getSubscription http msdn microsoft com en us library system reactive disposables serialdisposable_properties v vs 103 aspx','Fixed in https github com Netflix RxJava pull 593',RxJava,false,false,false
23937118,'BooleanSubscription should be properly wired up to allow inheritance','BooleanSubscription is not properly wired up to allow for inheritance public class BooleanSubscription implements Subscription private final AtomicBoolean unsubscribed new AtomicBoolean false public boolean isUnsubscribed return unsubscribed get @Override public void unsubscribe unsubscribed set true','What would you like to change Subclasses may call on the super isUnsubscribed to check the state and call the super unsubscribe to complete it I we don t want the ability to revive the BooleanSubscription with unsubscribed set false the current implementation is okay with me Unsubscribe should be idempotent I expect to be able to write this new BooleanSubscription override void unsubscribe launch the missiles super unsubscribe and when I call unsubscribe twice the missiles should only be fired once You need something like the ObserverBase java public class BooleanSubscription extends Subscription private final AtomicBoolean state new AtomicBoolean public final boolean isUnsubscribed return state get protected void unsubscribeCore @Overload public final void unsubscribe if state compareAndSet false true unsubscribeCore precisely We have re written Subscriptions and agreed to not have isUnsubscribed added to the Subscription interface and that we didn t need inheritance for the implementations The isUnsubscribed method exists on each of the implementations which each have different ways of deciding if something is unsubscribed',RxJava,false,false,false
23937232,'SerialSubscription and SingleAssignementSubscription naming Subscriptions in general','SerialSubscription has private static final Subscription UNSUBSCRIBED new Subscription SingleAssignmentSubscription has private static final Subscription SENTINEL new Subscription for the same purpose Also these use lockfree implementations the other subscriptions use locks Perhaps someone can go over all subscriptions and implement them in the same style and using the same naming conventions','I have to rebase my Subscription changes anyway so I ll do the renaming to UNSUBSCRIBED_SENTINEL I may help again to use lock free strategy in other subscription implementations @akarnod You should be able to have serialsubscription inherit from multipleassignmentsubscription The difference is that the latter unsubscribes when swapping in a new subscription I think that would show the intent better and make the code more maintanable In fact I think MultipleAssignmentSubscription itself can inherit from BooleanSubscription I don t know I can create many PRs for all kinds of variants but at the end @benjchristensen has to decide I d rather avoid look and feel development',RxJava,false,false,false
23947097,'Lock free subscriptions','Uniform naming of inner components Issue #592 Lock free approach to avoid deadlocks Issue #577 SerialSubscription isUnsubscribe added Issue #590 Remarks IMO an unsubscribed Single Serial Multiple subscription return Subscriptions empty instead of null So unless the user put a null in there he she shouldn t worry about null There was a concurrency bug in @jloisel s reimplementation of CompositeSubscription It allowed multiple threads to enter the mutation part if the current state was already MUTATE I ve added the necessary checks to allow only NORMAL MUTATE transitions','It cannot return Subscriptions empty since the Rx contract is to return null Also returning empty when unsubscribed is ambiguous has it been unsubscribed or has empty been set by the client code RxJava pull requests #527 https netflixoss ci cloudbees com job RxJava pull requests 527 SUCCESS This pull request looks good Good that you fixed the race condition in MultipleAssignementSubscription as well as the contract it was unsubscribing the previous subscription although it shouldn t I ve checked the Rx NET sources SingleAssignmentDisposable returns DefaultDisposable Instance SerialDisposabe returns null RefCountDisposable returns Disposable Empty ScheduledDisposable returns DefaultDisposable Instance So my question is why only SerialDisposable returns null Checking the return of the getSubscription to determine if unsubscription happened is wrong since SerialSubscription can be started with null this is why isUnsubscribed is to be used to check the state It cannot return Subscriptions empty since the Rx contract is to return null I don t think that is actually this strict that is what the implementation does I think it is better to return empty than null The real state is is isUnsubscribed and the properties might as well be write only I think the disposable subscription contract lakes precision and uniformity It doesn t matter to return null or empty what matters is a constant behavior following the least astonishment principle',RxJava,true,false,false
23957944,'Implement the Start operator','Hi this PR implemented the Start operator #81 Please take a look','RxJava pull requests #528 https netflixoss ci cloudbees com job RxJava pull requests 528 SUCCESS This pull request looks good Nice So Observable start Func0 might become the new way of creating Futures Maybe add some tests which illustrate what happens if I subscribe to Observable start before while after its calculation has terminated and what happens if there are several subscribers I think it s correctly implemented but just to make everything more stable and better documented Thanks @samuelgruetter I added more tests Is it necessary to construct a special test that subscribe and func run at the same time I think before and after are enough RxJava pull requests #533 https netflixoss ci cloudbees com job RxJava pull requests 533 SUCCESS This pull request looks good RxJava pull requests #537 https netflixoss ci cloudbees com job RxJava pull requests 537 SUCCESS This pull request looks good',RxJava,true,false,false
23958297,'NullPointerException in the toList operator','The following code will throw a NullPointerException java Observable from String null toList toBlockingObservable single pre Exception in thread main java lang NullPointerException at java util concurrent ConcurrentLinkedQueue checkNotNull ConcurrentLinkedQueue java 807 at java util concurrent ConcurrentLinkedQueue offer ConcurrentLinkedQueue java 326 at java util concurrent ConcurrentLinkedQueue add ConcurrentLinkedQueue java 296 at rx operators OperationToObservableList ToObservableList 1 onNext OperationToObservableList java 62 at rx operators OperationToObservableIterable ToObservableIterable onSubscribe OperationToObservableIterable java 46 at rx Observable subscribe Observable java 236 at rx operators OperationToObservableList ToObservableList onSubscribe OperationToObservableList java 57 at rx Observable subscribe Observable java 236 at rx operators OperationMaterialize MaterializeObservable onSubscribe OperationMaterialize java 57 at rx Observable subscribe Observable java 236 at rx operators OperationToIterator toIterator OperationToIterator java 47 at rx observables BlockingObservable getIterator BlockingObservable java 172 at rx observables BlockingObservable 2 iterator BlockingObservable java 353 at rx observables BlockingObservable _singleOrDefault BlockingObservable java 66 at rx observables BlockingObservable single BlockingObservable java 278 at rx Test main Test java 25 pre The cause is rx operators OperationToObservableList https github com Netflix RxJava blob 069ae42843822b846d450b38a4aa5039182e121f rxjava core src main java rx operators OperationToObservableList java#L58 uses ConcurrentLinkedQueue to cache the values but ConcurrentLinkedQueue rejects null value Is ArrayList or LinkedList enough here','The comment says below that onNext is expected to run concurrently The solution would be to use a null sentinel java final ConcurrentLinkedQueue Object list new ConcurrentLinkedQueue Object final Object NULL_SENTINEL new Object public void onNext T value onNext can be concurrently executed so list must be thread safe list add value null value NULL_SENTINEL public void onError Throwable ex observer onError ex public void onCompleted try copy from LinkedQueue to List since ConcurrentLinkedQueue does not implement the List interface ArrayList T l new ArrayList T list size for T t list @SuppressWarnings unchecked T t0 t NULL_SENTINEL T t T null l add t0 benjchristensen I want to make this list immutable but some clients are sorting this instead of using toSortedList and this change breaks them until we migrate their code observer onNext Collections unmodifiableList l observer onNext l observer onCompleted catch Throwable e onError e According to Rx contract toList does not need to handle concurrency doesn t it Closed as it s fixed in #633',RxJava,false,false,false
23981717,'Fix for buffer not stopping when unsubscribed','Issue #559','RxJava pull requests #530 https netflixoss ci cloudbees com job RxJava pull requests 530 SUCCESS This pull request looks good',RxJava,true,false,false
23992946,'Javadoc updates longCount sample sampler','','RxJava pull requests #531 https netflixoss ci cloudbees com job RxJava pull requests 531 SUCCESS This pull request looks good',RxJava,true,false,false
24013359,'New Scala Bindings','copied from release notes RxScala Release Notes This release of the RxScala bindings builds on the previous 0 15 release to make the Rx bindings for Scala include all Rx types In particular this release focuses on fleshing out the bindings for the Subject and Scheduler types as well as aligning the constructor functions for Observable with those in the RxJava Expect to see ongoing additions to make the Scala binding match the equivalent underlying Java API as well as minor changes in the existing API as we keep fine tuning the experience on our way to a V1 0 release Observer In this release we have made the asJavaObserver property in Observable T as well the the factory method in the companion object that takes an rx Observer private to the Scala bindings package thus properly hiding irrelevant implementation details from the user facing API The Observer T trait now looks like a clean native Scala type scala trait Observer T def onNext value T Unit def onError error Throwable Unit def onCompleted Unit object Observer To create an instance of a specific Observer say Observer SensorEvent in user code you can create a new instance of the Observer trait by implementing any of the methods that you care about scala val printObserver new Observer SensorEvent override def onNext value SensorEvent Unit value toString or you can use one of the overloads of the companion Observer object by passing in implementations of the onNext onError or onCompleted methods Note that typically you do not need to create an Observer since all of the methods that accept an Observer T for instance subscribe usually come with overloads that accept the individual methods onNext onError and onCompleted and will automatically create an Observer for you under the covers While technically it is a breaking change make the asJavaObserver property private you should probably not have touched asJavaObserver in the first place If you really feel you need to access the underlying rx Observer call toJava Observable Just like for Observer the Observable trait now also hides its asJavaObservable property and makes the constructor function in the companion object that takes an rx Observable private but leaves the companion object itself public Again while technically this is a breaking change this should not have any influence on user code scala trait Observable T def subscribe observer Observer T Subscription def apply observer Observer T Subscription object Observable def create T func Observer T Subscription Observable T The major changes in Observable are wrt to the factory methods where too libral use of overloading of the apply method hindered type inference and made Scala code look unnecessarily different than that in other language bindings All factory methods now have their own name corresponding to the Java and NET operators plus overloads that take a Scheduler def from T future Future T Observable T def from T iterable Iterable T Observable T def error T exception Throwable Observable T def empty T Observable T def items T items T Observable T Extension method on toObservable Observable T on List T In the pre release of this version we expose both apply and create for the mother of all creation functions We would like to solicit feedback which of these two names is preferred or both but there is a high probability that only one will be chosen def apply T subscribe Observer T Subscription Observable T def create T subscribe Observer T Subscription Observable T Subject The Subject trait now also hides the underlying Java asJavaSubject rx subjects Subject _ T _ T and takes only a single invariant type parameter T all existing implementations of Subject are parametrized by a single type and this reflects that reality scala trait Subject T extends Observable T with Observer T object Subject def apply Subject T For each kind of subject there is a class with a private constructor and a companion object that you should use to create a new kind of subject The subjects that are available are AsyncSubject T BehaviorSubject T value Subject T ReplaySubject T The latter is still missing various overloads http msdn microsoft com en us library hh211810 v vs 103 aspx which you can expect to appear once they are added to the underlying RxJava implementation Compared with release 0 15 1 the breaking changes in Subject for this release are making asJavaSubject private and collapsing its type parameters neither of these should cause trouble and renaming PublishSubject to Subject Schedulers The biggest breaking change compared to the 0 15 1 release is giving Scheduler the same structure as the other types The trait itself remains unchanged except that we made the underlying Java representation hidden as above as part of this reshuffling the scheduler package has been renamed from rx lang scala concurrency to rx lang scala schedulers There is a high probability that this package renaming will also happen in RxJava scala trait Scheduler In the previous release you created schedulers by selecting them from the Schedulers object as in Schedulers immediate or Schedulers newThread where each would return an instance of the Scheduler trait However several of the scheduler implementations have additional methods such as the TestScheduler which already deviated from the pattern In this release we changed this to make scheduler more like Subject and provide a family of schedulers that you create using their factory function CurrentThreadScheduler ExecutorScheduler executor ImmediateScheduler NewThreadScheduler ScheduledExecutorServiceScheduler scheduledExecutorService TestScheduler ThreadPoolForComputationScheduler ThreadPoolForIOScheduler In the future we expect that this list will grow further with new schedulers as they are imported from NET http msdn microsoft com en us library system reactive concurrency v vs 103 aspx To make your code compile in the new release you will have to change all occurrences of Schedulers xxx into XxxScheduler and import rx lang scala schedulers instead of rx lang scala schedulers Subscriptions The Subscription trait in Scala now has isUnsubscribed as a member effectively collapsing the old Subscription and BooleanSubscription and the latter has been removed from the public surface Pending a bug fix in RxJava SerialSubscription implements its own isUnsubscribed scala trait Subscription def unsubscribe Unit def isUnsubscribed Boolean object Subscription To create a Subscription use one of the following factory methods Subscription Subscription CompositeSubscription subscriptions MultipleAssignmentSubscription SerialSubscription In case you do feel tempted to call new Subscription directly make sure you wire up isUnsubscribed and unsubscribe properly but for all practical purposes you should just use one of the factory methods Notifications All underlying wrapped Java types in the Notification trait are made private like all previous types The companion objects of Notification now have both constructor apply and extractor unapply functions scala object Notification trait Notification T override def equals that Any Boolean override def hashCode Int def apply R onNext T R onError Throwable R onCompleted R R The nested companion objects of Notification now have both constructor apply and extractor unapply functions scala object Notification object OnNext def apply def unapply object OnError def apply def unapply object OnCompleted def apply def unapply To construct a Notification you import rx lang scala Notification _ and use OnNext hello or OnError new Exception Oops or OnCompleted To pattern match on a notification you create a partial function like so case Notification OnNext v v or you use the apply function to pass in functions for each possibility There are no breaking changes for notifications Java Interop Helpers Since the Scala traits wrap the underlying Java types yoo may occasionally will have to wrap an unwrap between the two representations The JavaConversion object provides helper functions of the form toJavaXXX and toScalaXXX for this purpose properly hiding how precisely the wrapped types are stored Note the un wrap conversions are defined as implicits in Scala but in the unlikely event that you do need them be kind to the reader of your code and call them explicitly scala object JavaConversions import language implicitConversions implicit def toJavaNotification T s Notification T rx Notification _ T implicit def toScalaNotification T s rx Notification _ T Notification T implicit def toJavaSubscription s Subscription rx Subscription implicit def toScalaSubscription s rx Subscription Subscription implicit def scalaSchedulerToJavaScheduler s Scheduler rx Scheduler implicit def javaSchedulerToScalaScheduler s rx Scheduler Scheduler implicit def toJavaObserver T s Observer T rx Observer _ T implicit def toScalaObserver T s rx Observer _ T Observer T implicit def toJavaObservable T s Observable T rx Observable _ T implicit def toScalaObservable T observable rx Observable _ T Observable T','RxJava pull requests #532 https netflixoss ci cloudbees com job RxJava pull requests 532 SUCCESS This pull request looks good',RxJava,true,false,false
24075891,'Refactor rx concurrency to rx schedulers','To match the naming convention of rx observables rx subjects and rx subscriptions we have decided to rename rx concurrency to rx schedulers prior to the 1 0 release These commits makes this change Since this is a non trivial breaking change to anyone using Schedulers this leaves the rx concurrency classes in place and deprecates them to give time to migrate These deprecated classes will be deleted prior to the 1 0 release','RxJava pull requests #534 https netflixoss ci cloudbees com job RxJava pull requests 534 SUCCESS This pull request looks good',RxJava,true,false,false
24080591,'BugFix Replay Subject','','RxJava pull requests #536 https netflixoss ci cloudbees com job RxJava pull requests 536 SUCCESS This pull request looks good',RxJava,true,false,false
24081337,'Version 0 16 0 Release Candidate','Following are the changes and release notes for 0 16 0 Since so much has changed for this release I want to give people a chance to review and try the code before releasing Changes ### Version 0 16 0 Maven Central http search maven org #search 7Cga 7C1 7Cg 3A 22com netflix rxjava 22 20AND 20v 3A 220 16 0 22 ### Pull 516 https github com Netflix RxJava pull 516 rxjava string module with StringObservable Pull 533 https github com Netflix RxJava pull 533 Operator ToAsync Pull 535 https github com Netflix RxJava pull 535 Fix compilation errors due to referencing the Android support library directly Pull 545 https github com Netflix RxJava pull 545 Fixed Zip issue with infinite streams Pull 539 https github com Netflix RxJava pull 539 Zipping a finite and an infinite Observable Pull 541 https github com Netflix RxJava pull 541 Operator SkipUntil Pull 537 https github com Netflix RxJava pull 537 Add scala adapters for doOnEach operator Pull 560 https github com Netflix RxJava pull 560 Add type variances for doOnEach actions Pull 562 https github com Netflix RxJava pull 562 Scala Adaptor Improvements Pull 563 https github com Netflix RxJava pull 563 Operator GroupByUntil Pull 561 https github com Netflix RxJava pull 561 Revised Approach to Creating Observables in Scala Pull 565 https github com Netflix RxJava pull 565 Operator GroupJoin v2 Pull 567 https github com Netflix RxJava pull 567 Operator Timestamp with Scheduler Pull 568 https github com Netflix RxJava pull 568 Use lock free strategy for several Subscription implementations Pull 571 https github com Netflix RxJava pull 571 Operator Sample with Observable v2 Pull 572 https github com Netflix RxJava pull 572 Multiple Subscriptions to ObserveOn Pull 573 https github com Netflix RxJava pull 573 Removed Opening and Closing historical artifacts Pull 575 https github com Netflix RxJava pull 575 Operator SequenceEqual reimplementation Pull 587 https github com Netflix RxJava pull 587 Operator LongCount Pull 586 https github com Netflix RxJava pull 586 Fix Concat to allow multiple observers Pull 598 https github com Netflix RxJava pull 598 New Scala Bindings Pull 596 https github com Netflix RxJava pull 596 Fix for buffer not stopping when unsubscribed Pull 576 https github com Netflix RxJava pull 576 Operators Timer and Delay Pull 593 https github com Netflix RxJava pull 593 Lock free subscriptions Pull 599 https github com Netflix RxJava pull 599 Refactor rx concurrency to rx schedulers Pull 600 https github com Netflix RxJava pull 600 BugFix Replay Subject Pull 594 https github com Netflix RxJava pull 594 Operator Start This release includes breaking changes to Scala bindings Details are below The rx concurrency package has been renamed to rx schedulers Existing classes still remain in rx concurrency but are deprecated Use of rx concurrency should be migrated to rx schedulers as these deprecated classes will be removed in a future release Many bug fixes and behavior changes to match Rx Net ### Scala Release Notes This release of the RxScala bindings builds on the previous 0 15 release to make the Rx bindings for Scala include all Rx types In particular this release focuses on fleshing out the bindings for the Subject and Scheduler types as well as aligning the constructor functions for Observable with those in the RxJava Expect to see ongoing additions to make the Scala binding match the equivalent underlying Java API as well as minor changes in the existing API as we keep fine tuning the experience on our way to a V1 0 release Observer In this release we have made the asJavaObserver property in Observable T as well the the factory method in the companion object that takes an rx Observer private to the Scala bindings package thus properly hiding irrelevant implementation details from the user facing API The Observer T trait now looks like a clean native Scala type scala trait Observer T def onNext value T Unit def onError error Throwable Unit def onCompleted Unit object Observer To create an instance of a specific Observer say Observer SensorEvent in user code you can create a new instance of the Observer trait by implementing any of the methods that you care about scala val printObserver new Observer SensorEvent override def onNext value SensorEvent Unit value toString or you can use one of the overloads of the companion Observer object by passing in implementations of the onNext onError or onCompleted methods Note that typically you do not need to create an Observer since all of the methods that accept an Observer T for instance subscribe usually come with overloads that accept the individual methods onNext onError and onCompleted and will automatically create an Observer for you under the covers While technically it is a breaking change make the asJavaObserver property private you should probably not have touched asJavaObserver in the first place If you really feel you need to access the underlying rx Observer call toJava Observable Just like for Observer the Observable trait now also hides its asJavaObservable property and makes the constructor function in the companion object that takes an rx Observable private but leaves the companion object itself public Again while technically this is a breaking change this should not have any influence on user code scala trait Observable T def subscribe observer Observer T Subscription def apply observer Observer T Subscription object Observable def create T func Observer T Subscription Observable T The major changes in Observable are wrt to the factory methods where too libral use of overloading of the apply method hindered type inference and made Scala code look unnecessarily different than that in other language bindings All factory methods now have their own name corresponding to the Java and NET operators plus overloads that take a Scheduler def from T future Future T Observable T def from T iterable Iterable T Observable T def error T exception Throwable Observable T def empty T Observable T def items T items T Observable T Extension method on toObservable Observable T on List T In the pre release of this version we expose both apply and create for the mother of all creation functions We would like to solicit feedback which of these two names is preferred or both but there is a high probability that only one will be chosen def apply T subscribe Observer T Subscription Observable T def create T subscribe Observer T Subscription Observable T Subject The Subject trait now also hides the underlying Java asJavaSubject rx subjects Subject _ T _ T and takes only a single invariant type parameter T all existing implementations of Subject are parametrized by a single type and this reflects that reality scala trait Subject T extends Observable T with Observer T object Subject def apply Subject T For each kind of subject there is a class with a private constructor and a companion object that you should use to create a new kind of subject The subjects that are available are AsyncSubject T BehaviorSubject T value Subject T ReplaySubject T The latter is still missing various overloads http msdn microsoft com en us library hh211810 v vs 103 aspx which you can expect to appear once they are added to the underlying RxJava implementation Compared with release 0 15 1 the breaking changes in Subject for this release are making asJavaSubject private and collapsing its type parameters neither of these should cause trouble and renaming PublishSubject to Subject Schedulers The biggest breaking change compared to the 0 15 1 release is giving Scheduler the same structure as the other types The trait itself remains unchanged except that we made the underlying Java representation hidden as above as part of this reshuffling the scheduler package has been renamed from rx lang scala concurrency to rx lang scala schedulers There is a high probability that this package renaming will also happen in RxJava scala trait Scheduler In the previous release you created schedulers by selecting them from the Schedulers object as in Schedulers immediate or Schedulers newThread where each would return an instance of the Scheduler trait However several of the scheduler implementations have additional methods such as the TestScheduler which already deviated from the pattern In this release we changed this to make scheduler more like Subject and provide a family of schedulers that you create using their factory function CurrentThreadScheduler ExecutorScheduler executor ImmediateScheduler NewThreadScheduler ScheduledExecutorServiceScheduler scheduledExecutorService TestScheduler ThreadPoolForComputationScheduler ThreadPoolForIOScheduler In the future we expect that this list will grow further with new schedulers as they are imported from NET http msdn microsoft com en us library system reactive concurrency v vs 103 aspx To make your code compile in the new release you will have to change all occurrences of Schedulers xxx into XxxScheduler and import rx lang scala schedulers instead of rx lang scala schedulers Subscriptions The Subscription trait in Scala now has isUnsubscribed as a member effectively collapsing the old Subscription and BooleanSubscription and the latter has been removed from the public surface Pending a bug fix in RxJava SerialSubscription implements its own isUnsubscribed scala trait Subscription def unsubscribe Unit def isUnsubscribed Boolean object Subscription To create a Subscription use one of the following factory methods Subscription Subscription CompositeSubscription subscriptions MultipleAssignmentSubscription SerialSubscription In case you do feel tempted to call new Subscription directly make sure you wire up isUnsubscribed and unsubscribe properly but for all practical purposes you should just use one of the factory methods Notifications All underlying wrapped Java types in the Notification trait are made private like all previous types The companion objects of Notification now have both constructor apply and extractor unapply functions scala object Notification trait Notification T override def equals that Any Boolean override def hashCode Int def apply R onNext T R onError Throwable R onCompleted R R The nested companion objects of Notification now have both constructor apply and extractor unapply functions scala object Notification object OnNext def apply def unapply object OnError def apply def unapply object OnCompleted def apply def unapply To construct a Notification you import rx lang scala Notification _ and use OnNext hello or OnError new Exception Oops or OnCompleted To pattern match on a notification you create a partial function like so case Notification OnNext v v or you use the apply function to pass in functions for each possibility There are no breaking changes for notifications Java Interop Helpers Since the Scala traits wrap the underlying Java types yoo may occasionally will have to wrap an unwrap between the two representations The JavaConversion object provides helper functions of the form toJavaXXX and toScalaXXX for this purpose properly hiding how precisely the wrapped types are stored Note the un wrap conversions are defined as implicits in Scala but in the unlikely event that you do need them be kind to the reader of your code and call them explicitly scala object JavaConversions import language implicitConversions implicit def toJavaNotification T s Notification T rx Notification _ T implicit def toScalaNotification T s rx Notification _ T Notification T implicit def toJavaSubscription s Subscription rx Subscription implicit def toScalaSubscription s rx Subscription Subscription implicit def scalaSchedulerToJavaScheduler s Scheduler rx Scheduler implicit def javaSchedulerToScalaScheduler s rx Scheduler Scheduler implicit def toJavaObserver T s Observer T rx Observer _ T implicit def toScalaObserver T s rx Observer _ T Observer T implicit def toJavaObservable T s Observable T rx Observable _ T implicit def toScalaObservable T observable rx Observable _ T Observable T','Items of discussion or that I would like to resolve before releasing ReplaySubject has a different style from other Subject implementations I m not tied to either approach nor am I sure that the idea of an AbstractSubject was the right way to go I m not convinced that Subject implementations have correct thread safety or concurrency behavior For example we synchronize on subscriptions but not event emission and I m not sure whether that means we re vulnerable to losing events or not x Yet more observeOn fixes tweaks are needed I d like to eliminate the rx util dumping ground Put exceptions into rx exceptions or rx util exceptions Put functions into rx functions or rx util functions Where does Range go TimeInterval Timestamped perhaps in rx observables x Why is Timestamped not camelCase whereas TimeInterval is Should AbstractSubject be public I think it should be package private particularly as I don t necessarily agree with the approach even though I wrote it For consistency should we have rx operators with classes named OperatorXYZ or rx operations and classes named OperationXYZ ObserverBase needs to be package private or moved into a non advertised package like rx operators Why is Timestamped not camelCase whereas TimeInterval is Because timestamp is a single word like java sql Timestamp ObserveOn fixes https github com Netflix RxJava pull 602 Because timestamp is a single word like java sql Timestamp I guess you re right Never mind I ve looked at the Subject implementations and they seem to be incorrect due to the following reasons the AbstractSubject allows the concurrent execution of onNext and onError onCompleted calls i e the emitNotification doesn t lock on SUBSCRIPTION_LOCK PublishSubject AsyncSubject and BehaviorSubject seem to overwrite the last notification value even after the termination condition as the call state currentValue set new Notification T is always executed in the subjects onXXX methods regardless of the state New subscribers may observe various states when subscribing the AbstractSubject allows the concurrent execution of onNext and onError onCompleted calls All of Rx allows this as it is up to the provider to obey the contract and not call them concurrently That is why we don t synchronize everything in Rx for performance reasons Rx Design Guideline 6 8 6 8 Avoid serializing operators As all Rx operators are bound to guideline 6 7 operators can safely assume that their inputs are serialized Adding too much synchronization would clutter the code and can lead to performance degradation If an observable sequence is not following the Rx contract see chapter 0 it is up to the developer writing the end user application to fix the observable sequence by calling the Synchronize operator at the first place the developer gets a hold of the observable sequence This way the scope of additional synchronization is limited to where it is needed Due to this a Subject implementation should not need to synchronize onNext onCompleted onError calls They do need to handle subscribe unsubscribe concurrent access It is however tricky to achieve both of these since we want to ensure we don t have race conditions in observers subscribing and seeing the correct view of events That said we don t want to add unnecessary synchronization For example on PublishSubject it is completely fine during a concurrent race between onNext and subscribe that it may or may not get that onNext event That s the nature of concurrently subscribing to a hot Observable We don t want to pay the overhead of synchronization on onNext just so that occasional subscribe events can occur cc @akarnokd @headinthebox @zsxwing I am ready to release 0 16 0 after running it on a Netflix API production canary to assert performance and functionality of the core operators schedulers etc at least of what we use not new operators I m blocked on a build issue that I can t solve until tomorrow at the office so will release sometime Tuesday hopefully',RxJava,false,false,false
24089368,'ObserveOn Fixes','refactor to remove imperative assignment of innerScheduler for clearer concurrency and data access fix subscription leak Composite MultipleAssignment instead of just Composite remove confusing conditional logic for inner outer scheduler','RxJava pull requests #538 https netflixoss ci cloudbees com job RxJava pull requests 538 ABORTED @akarnokd good question but in your code you would call onError on the same observer Which is strange and then the call to onError can fail itself What you propose is when the onNext of an observer in a subscribe fails you would call the onError of that same observer @headinthebox True Maybe the not accept needs to be altered or left out entirely and not switch case d here with the proper handling of onError throws case Generally onNext errors are left to the outer SafeObserver wrapper to handle and only user provided functions are directly handled There may be an edge case to make this work though since we re hopping threads I ll need to play with some unit tests See here for where the on methods are handled https github com Netflix RxJava blob master rxjava core src main java rx Observable java#L235 Here is the SafeObserver handling the onNext failure https github com Netflix RxJava blob master rxjava core src main java rx operators SafeObserver java#L125 And then if onError fails it handles it as well https github com Netflix RxJava blob master rxjava core src main java rx operators SafeObserver java#L89 This is not logic we want to replicate everywhere nor should we need to do this at every layer of wrapping which is why we only add it to externally provided Observer instances This unit test suggests that the error handling is working okay due to SafeObserver wrapping the user provided Observer java Test that an error from a user provided Observer onNext is handled and emitted to the onError even when done across thread boundaries with observeOn @Test public void testOnNextErrorAcrossThread throws InterruptedException final CountDownLatch latch new CountDownLatch 1 final AtomicReference Throwable caughtError new AtomicReference Throwable Observable Long o Observable interval 50 TimeUnit MILLISECONDS Observer Long observer new Observer Long @Override public void onCompleted System out println completed latch countDown @Override public void onError Throwable e System out println error e caughtError set e latch countDown @Override public void onNext Long args throw new RuntimeException forced failure o observeOn Schedulers newThread subscribe observer latch await 2000 TimeUnit MILLISECONDS assertNotNull caughtError get Is there some use case I m missing RxJava pull requests #545 https netflixoss ci cloudbees com job RxJava pull requests 545 ABORTED A bit unexpected In RxJava val xs Observable from 1 to 200 NewThreadScheduler subscribe x throw new Exception boom e println e getMessage throw e prints boom In NET it throws the exception on the worker thread http social msdn microsoft com Forums en US ee5dba5d eea9 4d85 8f58 c2e1c71ef33a about the contracts in rx exceptions and blocking forum rx http blogs msdn com b rxteam archive 2012 06 20 reactive extensions v2 0 release candidate available now aspx Which is unexpected Net or Java behavior The Java behavior You cannot totally guard against exceptions thrown in user supplied subscribe What happens when an exception is thrown in onCompleted or in onError On in when the onError that get invoked because the onNext threw throws Similarly when you inside Observable create you have to catch exceptions inside closures It correctly will throw on the thread if the onError handler also fails If they have a valid onError handler why would we not want to call it That s completely unexpected for an error to be thrown when they have provided a valid onError handler thus we always try and pass to onError and only if that also fails then throw on whatever random thread it s on See here https github com Netflix RxJava blob ec88d58a5fd4159c7b5392f47b40db2e7a2c57b8 rxjava core src main java rx operators SafeObserver java#L88 IMHO it give a false sense of security and it is unpredictable When you see xs subscribe it may a call onError b swallow the exception c throw on a random thread or d a and b or e a and c Which is not any better than not doing anything special since then you have the same set of outcomes Yes it may result in that if the user implemented both a bad onNext and onError but that is a valid case for unexpected behavior We found in production that it was a real surprise and problem when onNext errors weren t propagated to onError because we teach everyone that when using Rx all errors will be propagated to onError Also when people do things right and push side effects into the subscribe onNext it s easy to get failures there but very rarely is their onError handler complex enough to also fail In short catching an onNext failure and propagating to onError is the least surprising way of propagating errors and handles the most common cases If someone s inError handler is also broken we have no choice but to throw but then do so with a message that very clearly states how bad that is and what happened I m going to proceed with this merge and we can discuss SafeObserver behavior elsewhere as it is a different topic than this No I m not going to merge Unit tests aren t passing on this but they are on the master branch Go ahead This change has caused non determinism with the following unit tests rx operators OperationParallelTest testParallel rx operators OperationParallelMergeTest testNumberOfThreads rx operators OperationMergeDelayErrorTest testCompositeErrorDelayed2 rx operators OperationParallelMergeTest testNumberOfThreadsOnScheduledMerge rx operators OperationGroupByTest testError I have revised this pull request The previous update was accidentally subscribing to the source Observable on the new thread instead of only observing on the new thread I reverted the code added the unit tests and then refactored to just fix the Subscription leak Otherwise the structure is similar as before RxJava pull requests #552 https netflixoss ci cloudbees com job RxJava pull requests 552 SUCCESS This pull request looks good',RxJava,true,false,false
24111890,'Significant restructuring of subscriptions','I ve re abstracted the subscriptions to be more uniform and maintenance friendly Enhanced BooleanSubscription to support inheritance and single unsubscription action through onUnsubscribe Issue #591 Added BooleanSubscription withAction to allow wrapping a single time unsubscription action Created AbstractAtomicSubscription which manages the lock free manipulations through callbacks Rewritted MultipleAssignmentSubscription to have two extension points in its logic which allows simpler subclass implementations of SerialSubscription and SingleAssignmentSubscription MultipleAssignmentSubscription does not extend AbstractAtomicSubscription because it has a much simpler state transition logic whereas the AbstractAtomicSubscription with its callbacks would be an overkill Rewritten CompositeSubscription and RefCountSubscription to use AbstractAtomicSubscription Modified SafeObservableSubscription to use SingleAssignmentSubscription instead of duplicating its behavior Extended Subscriptions with an unsubscribeAll method to capture the exception collection behavior when unsubscribing from multiple subscriptions Added empty0 empty1 and empty2 convenience methods to Actions Haven t checked if such no op ActionX instances are created manually somewhere BONUS ValuedCompositeSubscription T class where a value can be associated with a Subscription key','RxJava pull requests #539 https netflixoss ci cloudbees com job RxJava pull requests 539 SUCCESS This pull request looks good RxJava pull requests #540 https netflixoss ci cloudbees com job RxJava pull requests 540 SUCCESS This pull request looks good @headinthebox does this match what you were hoping for regarding Subscriptions',RxJava,true,false,false
24126868,'Added op join to concat objects with separator between elements','Straightforward a 1 c with separator becomes a 1 c','RxJava pull requests #541 https netflixoss ci cloudbees com job RxJava pull requests 541 SUCCESS This pull request looks good',RxJava,true,false,false
24140177,'Subjects reimplemented','Reimplemented all 4 kinds of subjects with the following properties The onNext onError and onCompleted are fully thread safe against subscription and unsubscription A terminated subject won t accept any new events AsyncSubject PublishSubject and BehaviorSubject will re emit just the very first exception when an observer subscribes to them Emitting events to subscribed observers is done while holding the state lock In Rx NET when an event is received the list of observers is retrieved while holding the lock then outside the lock the list is traversed and the events are propagated to the observers Note however if an observer unsubscribes right after the unlock and before the event propagation it will still appear in the list and will receive the event IMO this is an undesired behavior The drawback of my solution is that it might be possible to deadlock the subjects i e when an observer deliberately passes the source subject to another thread which sends an event to the subject and waits for its completion Added the Notification acceptSafe which will capture the exception of the onNext and propagate it through the onError Its return value indicates if the observer can still be used after i e no terminal event was delivered Added the reusable state classes to AbstractSubject although none of the subjects use this class any more There is an UnsubscribeTester class which seems to be out of place Can this be moved into the test directory','RxJava pull requests #542 https netflixoss ci cloudbees com job RxJava pull requests 542 SUCCESS This pull request looks good Holding the lock while dispatching events i e executing arbitrary code seems pretty dangerous In my experience I ve always ended up regretting it when I did this In Rx NET when an event is received the list of observers is retrieved while holding the lock then outside the lock the list is traversed and the events are propagated to the observers Note however if an observer unsubscribes right after the unlock and before the event propagation it will still appear in the list and will receive the event IMO this is an undesired behavior Unsubscribing does a best effort don t hold the lock @akarnokd Thanks for this @headinthebox and I are reviewing and will end up with some merged refactored form So this specific PR won t be merged No problem Based on this discussion I ve tried my hand in pull request https github com Netflix RxJava pull 651 I d appreciate your review Sure Closing as we ended up doing this in https github com Netflix RxJava pull 651 Thank you very much for the work on this and the significant performance gains you helped achieve',RxJava,true,false,false
24142294,'Operation Timer again','Operation Timer readded Note that the master version has the timer operator with wrong return type compared to Rx NET Void vs Long I ve replaced the the methods and use places','RxJava pull requests #543 https netflixoss ci cloudbees com job RxJava pull requests 543 SUCCESS This pull request looks good This conflicts with master Naturally',RxJava,true,false,false
24143842,'Javadoc improvements','consistent nomenclature consistent standard javadoc formatting more precise descriptions timer marble digram wiki link delay marble diagram wiki link','RxJava pull requests #544 https netflixoss ci cloudbees com job RxJava pull requests 544 SUCCESS This pull request looks good',RxJava,true,false,false
24157618,'Gradle mockito junit not downloaded to cache','I am using InteilliJ to edit RxJava and friends but it seems that the mockito junit jars are not present in gradle cache This is IntelliJ apparently expects to find them So I need to add them as additional external libraries unlike all the other ones Anyone with gradle skills can check that out','Discussed with @headinthebox closing out',RxJava,false,false,false
24162183,'Operation Timer 3 0',Rebased,'RxJava pull requests #546 https netflixoss ci cloudbees com job RxJava pull requests 546 SUCCESS This pull request looks good',RxJava,true,false,false
24164239,'NPE in rx subjects AbstractSubject emitNotification','The problem is describe here https groups google com forum # topic rxjava x6B5bim4uoE Callstack Exception in thread AWT EventQueue 0 java lang NullPointerException at rx subjects AbstractSubject emitNotification AbstractSubject java 98 at rx subjects AbstractSubject emitNotification AbstractSubject java 116 at rx subjects PublishSubject onNext PublishSubject java 82 at rx operators OperationMulticast MulticastConnectableObservable 2 onNext OperationMulticast java 64 at rx operators SynchronizedObserver onNext SynchronizedObserver java 86 at rx operators OperationMerge MergeObservable ChildObserver onNext OperationMerge java 267 at rm rx test gui GuiRx 4 1 mouseClicked GuiRx java 180 at java awt AWTEventMulticaster mouseClicked AWTEventMulticaster java 270','I checked the AbstractSubject codes and found this bug The following codes do not check if Observer super T o is null java protected static T void emitNotification final SubjectState T state final Action2 SubjectState T Observer super T onEach for Subscription s snapshotOfObservers state Observer super T o state observers get s emit notifications to this observer emitNotification state currentValue get o onEach action if applicable if onEach null onEach call state o I think #605 will fix this issue @akarnokd can you confirm it Thanks PR #605 doesn t exhibit this bug as I make copy of the observers values collection when dispatching values Subjects were completely re written and I don t believe this can happen I looked at the sample code on Google Groups but it was far too complicated to quickly pull in and run and had many dependencies If you want to provide a simpler test case I can assert that this is truly fixed otherwise I believe 0 16 0 will fix it as Subjects have a rewritten subscription manager that uses a state machine to correctly keep control of the Observers We just encountered this problem in our live app This is with version 0 15 1 Was anyone able to confirm that this is fixed with 0 16 x This shouldn t happen anymore Could you check with the latest version and close I can confirm this is fixed for us',RxJava,false,false,false
24204671,'Serial subscription fix','Changed Scala bindings fro SerialSubscription to use underlying isUnsubscribed implementation','RxJava pull requests #547 https netflixoss ci cloudbees com job RxJava pull requests 547 ABORTED',RxJava,true,false,false
24204753,'Replay additional overloads','Issue #71 Added several overloads of the replay operator limited buffer limited time window buffer time scheduler overloads versions which perform a projection before the replay Added missing multicast overload','RxJava pull requests #548 https netflixoss ci cloudbees com job RxJava pull requests 548 SUCCESS This pull request looks good Could you give me an explanation of what the selector does and why it s useful and also what the version of replay that uses a subject factory is all about The javadocs are opaque to me and the MSDN docs Intro to Rx aren t helpful either On Thu Dec 12 2013 at 12 53 PM CloudBees pull request builder plugin notifications@github com wrote RxJava pull requests #548 https netflixoss ci cloudbees com job RxJava pull requests 548 SUCCESS This pull request looks good Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 612#issuecomment 30460606 David M Gross PLP Consulting I m not sure myself I think it allows transforming the subject s output without the danger of resubscribing to the uplink source I couldn t find any tests for them in the Rx NET sources',RxJava,true,false,false
24208920,'CombineLatest incorrect','I ve looked into the OperationCombineLatest implementation and I think it is incorrectly implemented Doesn t seem to allow multiple observers on the same combiner as the Aggregator is per source observable and not per subscribing observer I think the contract requires that no onNext value is lost on any of the source observers yet since they are not synchronized with each other a source observer might overwrite its current value while the collection is running Thoughts','Fixed in https github com Netflix RxJava pull 708',RxJava,false,false,false
24210399,'Merge delay error doesn t synchronize onNext calls','The merge operation passes calls to the actual observer through an instance of SynchronizedObserver but merge delay error doesn t This is causing overlapping calls to onNext and all sorts of concurrency bugs in our server','Saw errors in those in my tests yesterday as well Fixed and merged',RxJava,false,true,true
24210893,'Copied the code from OperationMerge to fix synchronization','for #614','RxJava pull requests #549 https netflixoss ci cloudbees com job RxJava pull requests 549 SUCCESS This pull request looks good Amazing this made it almost a year or more without us seeing a bug in prod Thanks for catching and fixing',RxJava,true,false,false
24215789,'Combine latest fix','Fixes potential issues mentioned in #613 Question it emits a row while holding a lock This ensures a FIFO behavior towards the client observer Do we want such strong guarantee','RxJava pull requests #550 https netflixoss ci cloudbees com job RxJava pull requests 550 SUCCESS This pull request looks good',RxJava,true,false,false
24220689,'replay and timer javadocs diagrams wiki links','','RxJava pull requests #551 https netflixoss ci cloudbees com job RxJava pull requests 551 SUCCESS This pull request looks good',RxJava,true,false,false
24229636,'Observable Observable T to List List T','I saw a few places in the code where people were converting Observable Observable T into List List T by doing blocking operations on the inner observable Observable from new Integer 1 2 3 4 5 6 XXXX window 3 map new Func1 Observable Integer List Integer @Override public List Integer call Observable Integer o return o toList toBlockingObservable single toBlockingObservable forEach new Action1 List Integer @Override public void call List Integer t lists add t That is dangerous for instance when XXX is Schedulers currentThread Only block if needed at the outermost level Instead do this Observable concat Observable from new Integer 1 2 3 4 5 6 XXXX window 3 map new Func1 Observable Integer Observable List Integer @Override public Observable List Integer call Observable Integer xs return xs toList toBlockingObservable forEach new Action1 List Integer @Override public void call List Integer xs lists add xs','Agreed that should be a pattern we avoid Note to anyone writing tests to pay attention to this',RxJava,false,false,false
24231526,'UnitTest to assert thread safety of Executor Scheduler','The Executor thread pools hop threads when using observeOn so this tests that it is thread safe when doing so The test performs non thread safe mutations which should fail or at least be non deterministic if memory visibility problems or concurrency is occurring','RxJava pull requests #553 https netflixoss ci cloudbees com job RxJava pull requests 553 SUCCESS This pull request looks good',RxJava,true,false,false
24233022,'Subscription overhaul2','Renamed and changed things according to comments in #603','RxJava pull requests #554 https netflixoss ci cloudbees com job RxJava pull requests 554 SUCCESS This pull request looks good note I like to keep the number of different Subscriptions as small as possible note What is the use case for ValuedCompositeSubscription Use case for ValuedCompositeSubscription associate observers with their subscriptions java ValuedCompositeSubscription Observable super T observers but I usually ended up using regular map and locks anyway So it is not that essential SafeObservableSubscription was implemented way before SingleAssignmentSubscription I d support the latter one and drop the former I like MultipleAssignmentSubscription SerialSubscription SingleAssignmentSubscription hierarchy Why not AbstractAssignmentSubscription MultipleAssignmentSubscription SerialSubscription SingleAssignmentSubscription adds setSubscription throws if sets twice like val SingleAssignmentSubscription extends BooleanSubscription allows to setSubscription twice leaves previous unchanged like var MultipleAssignmentSubscription extends SingleAssignmentSubscription allows to setSubscription twice unsubscribes old one SerialSubscription extends MultipleAssignmentSubscription previous Here I d need to suppress override onPreSwap in MultipleAssignmentSubscription instead of overriding an empty onPreSwap with the state check Inspired changes done in https github com Netflix RxJava pull 661 Inspired changes done in https github com Netflix RxJava pull 661',RxJava,true,false,false
24234218,'SerialSubscription From','Update scala bindings for SerialSubscription since underlying type now implements isUnsubscribed Changed Observable from to use currentThreadScheduler principle of least surprise Used scheduler in create instead of observerOn Fixed blocking tests','RxJava pull requests #555 https netflixoss ci cloudbees com job RxJava pull requests 555 SUCCESS This pull request looks good',RxJava,true,false,false
24278817,'Operators Observables from functionals Action0 Func0 Runnable Calla','ble I ve created 4 operators that turn into ordinary action function calls into Observables but unlike start and Async the functions are called on each subscription instead of only once They can be thought of a more generalized from T value Each method is named according to the accepted type to avoid overload issues with Java 8 various dynamic languages The 4 additional overloads lets the user specify the scheduler where the function is called By default the functions are called on the threadPoolForComputation I don t know if there are Rx NET equivalents of these or they ever existed','RxJava pull requests #556 https netflixoss ci cloudbees com job RxJava pull requests 556 FAILURE Looks like there s a problem with this pull request 9 threads were busy with something else Right now I d like to pass on adding these as it adds to the surface area of the API without strong reason These are all wrapper methods of Observable create which already takes a function and it is trivial to invoke an Action Callable Runnable etc from within the OnSubscribeFunc I m not yet convinced that they are globally useful and worth increasing the already huge Observable signature particular the from operator How about introducing ObservableEx like Rx NET had once This way these tools don t get lost but are not part of core Merge these into https github com Netflix RxJava pull 696 instead',RxJava,true,false,false
24317029,'Clojure Observable from converts list to to an observable of a single list value','I m trying out the clojure example code https github com Netflix RxJava blob master language adaptors rxjava clojure src examples clojure rx lang clojure examples rx_examples clj#L28 and the results seem wrong With the following clojure defn hello args Observable from args subscribe rx action v println str Hello v hello Ben George I expected the observable to emit two distinct values Ben and George before completing resulting in one line of output per name However the repl output is clojure Hello Ben George So it seems the entire args list is emitted as a single value Tried 0 15 1 as well as current master at 7ec374c','clojure defn hello args Observable from Ben George hardcode the list subscribe rx action v println str Hello v hello Ben George Works fine Very strange The Clojure compiler has many versions of Observable from to choose from and here it picks the wrong one You ll need to give it a hint clojure Observable from java lang Iterable args that should do it Thanks that works Not cool though it s reasonable to expect it to just work Welcome to Java interop with dynamic types',RxJava,false,false,false
24319068,'BehaviorSubject 1 toBlockingObservable next iterator next never completes','The scala expression scala BehaviorSubject 1 toBlockingObservable next iterator next never completes as of RxJava 0 15 1 To my understanding it should simply return 1 since BehaviorSubject always has at least one value to provide The fact that the following scala code correctly returns 1 scala BehaviorSubject 1 take 1 toBlockingObservable single assures me about this assumption even more firmly Is this a bug in the implementation or do I misunderstand something Thank you best regards Tom Dvo k','This might be a bug in the underlying OperationNext L147 ignoring the very first value sent by the behavior subject I think you need the latest operator #59 not implemented yet rather than the next operator Each time you fetch an item from the iterator returned by next you will receive the next incoming item in the Observable In your example when you fetch an item from the iterator 1 has already been emitted so it will be skipped I m not sure I follow Exactly at which point has 1 already been emitted It has not been emitted after the toBlockingObservable call because the second example still yields an item So somehow the next iterator next must have swallowed one item while the call to single manages not to swallow it and emit it as I d expect Could you please elaborate in more detail on what is the conceptual not implementation difference between the two I m still not convinced that the next call should skip the item provided by the BehaviorSubject Thank you very much In the current RxJava version when the code comes to BehaviorSubject 1 toBlockingObservable next the next operator subscribes to the behavior subject The behavior subject immediately pushes down the value 1 In the next s Observer there is a check to see if there is someone waiting for a value Since the code above hasn t reached the iterator next yet which would indicate a demand for a value the value 1 gets ignored Now the chain of call is returning and the iterator next is executed blocking for a value to arrive which won t In BehaviorSubject 1 take 1 toBlockingObservable single the single operator uses toIterable internally which buffers all values including the very first 1 therefore you ll see the 1 Hope it clears things That clarifies a lot to me about the implementation Furthermore you have pointed me to the toBlockingObservable toIterable operator which is actually exactly what I have been looking for but didn t found and tried to emulate with the next iterator calls that in reality seem to have a slightly different semantics than I originally expected Thank you indeed Tom Dvo k I confirmed that it does not work java System out println BehaviorSubject create 1 take 1 toBlockingObservable single System out println BehaviorSubject create 1 toBlockingObservable next iterator next Someone will need to spend some time looking at OperationNext Interestingly this one works java System out println BehaviorSubject create 1 toBlockingObservable toIterable iterator next I had an explanation some time ago Bottom line is that the next can t work in this setup As of 0 20 RC3 these work java System out println BehaviorSubject create 1 take 1 toBlocking single System out println BehaviorSubject create 2 toBlocking toIterable iterator next this still does not java System out println BehaviorSubject create 3 toBlocking next iterator next A possible fix that allows the 3rd behavior is in https github com Netflix RxJava pull 1501',RxJava,false,false,false
24319708,'observeOn doesn t behave as expected','clojure ns rx lang clojure examples rx examples require rx lang clojure interop as rx import rx Observable rx subscriptions Subscriptions rx schedulers Schedulers java util concurrent TimeUnit println Thread currentThread Observable interval 100 TimeUnit MILLISECONDS #_ Schedulers currentThread take 5 observeOn Schedulers currentThread subscribe rx action v this file is created but the content do not match spit tmp tid txt Thread currentThread println v this output never reaches the repl So Observable interval spawns a new thread and the subscribed callback is invoked in that thread by default I need to use observeOn to ensure the cb is invoked in the current thread so that the println output makes it to the repl tmp tid txt does get created so the cb is called but the println output never makes it to the repl If i schedule Observable interval in the current thread commented out the output is visible though the repl hangs afterwards for some reason but the observeOn itself doesn t seem to do the job it s meant to The contents of tmp tid txt don t match the current thread reported by the println either Is this a bug or am I doing something wrong','though the repl hangs afterwards for some reason I believe this is related to a bug where CurrentThreadScheduler can not be unsubscribed from since it is all single threaded and thus not async and never returns the Subscription so take 5 is meaningless to it We should be able to unsubscribe from a CurrentThread scheduled Observable though and @headinthebox and I were looking at this last week to determine how to do so We looked at the Rx Net implementation and it s very non elegant to make it work thread locals and other such fun It s on my plate to tackle In the meantime for anything that is infinite such as interval you ll want to use something with real concurrency such as NewThread or Schedulers threadPoolForComputation The contents of tmp tid txt don t match the current thread reported The file contains this Thread RxComputationThreadPool 6 5 main and that is correct since interval uses the thread pool by default The Schedulers currentThread Scheduler tells it to run on the current thread whatever it is using a trampoline It is the same as using Immediate which uses the current thread except it does trampolining If you change to use Schedulers immediate for the interval you ll get what you re expecting and it will block on the current thread sleeping for each interval since there is no concurrency clojure Observable interval 100 TimeUnit MILLISECONDS Schedulers immediate take 5 observeOn Schedulers currentThread subscribe rx action v this file is created but the content do not match spit tmp tid txt Thread currentThread println v this output never reaches the repl outputs to file Thread nREPL worker 2 5 main It now stays on the main thread and observeOn in effect does nothing since it is told to use Schedulers currentThread so it stays on the main thread Generally observeOn is meant for moving the work from one thread to another such as from a background worker thread to a UI thread for rendering Using observeOn with ImmediateScheduler or CurrentThreadScheduler doesn t really make sense as it ends up being a pass thru Thanks for the detailed answer The fact that Interval runs in the current thread by default is a little surprising but I can live with that and I m guessing it s dictated by compat with Net if nothing else The example you provided does get the output to the repl it hangs but that s expected now But I don t need the interval to run in the current thread just the callback and I still haven t found the secret handshake for that As I understand it observeOn determines where the cb is run Since I wasn t getting any output I guessed that the cb ended up running on the wrong thread and made it explicit where it should run IIRC the default is that cb s are run in the same thread as the generated event Given your feedback I expected this to work Observable interval 100 TimeUnit MILLISECONDS Schedulers newThread take 5 observeOn Schedulers immediate at least one of these should work depending on #_ observeOn Schedulers currentThread the specific nature of #_ no op my misunderstanding subscribe rx action v this file is created but the content do not match spit tmp tid txt Thread currentThread println v this output never reaches the repl Which I read as the interval runs in a new thread Forever for now while the observeOn call ensures the cb is invoked in the current thread That should reward me with output to the repl It doesn t block but no output is generated The fact that Interval runs in the current thread by default is a little surprising The interval operator by default runs on a separate thread You would you have to pass Schedulers immediate or Schedulers currentThread to make it run on the current thread But I don t need the interval to run in the current thread just the callback and I still haven t found the secret handshake for that ObserveOn has no way to automatically make something jump back to the main thread the REPL is on That would require the main thread offering an event loop or something to hook into and a Scheduler implementation that knows how to schedule work onto it similar to the Android and Swing modules which know how to schedule work into their UI event loops while the observeOn call ensures the cb is invoked in the current thread The observeOn operator schedules work on whatever Scheduler it is given Think of it as moving the work from one thread to another or one Scheduler to another Thus it doesn t determine anything it just puts the work where you tell it Thus in your code Observable interval and take are running on the new thread you tell it to use Schedulers newThread then you tell it to observeOn the immediate Scheduler which is a no op and it will continue using the Schedulers newThread you provided at the beginning so subscribe will still run on the new thread Here are two examples one blocking another non blocking clojure Observable interval 100 TimeUnit MILLISECONDS take 5 subscribe rx action v println non blocking v java lang Thread currentThread Observable interval 100 TimeUnit MILLISECONDS take 5 toBlockingObservable forEach rx action v println blocking v java lang Thread currentThread The REPL shows this Observable interval 100 TimeUnit MILLISECONDS take 5 toBlockingObservable forEach rx action v println blocking v java lang Thread currentThread nil Observable interval 100 TimeUnit MILLISECONDS take 5 subscribe rx action v println non blocking v java lang Thread currentThread # SafeObservableSubscription rx operators SafeObservableSubscription@5034037e The console shows this blocking 0 # Thread Thread RxComputationThreadPool 4 5 main blocking 1 # Thread Thread RxComputationThreadPool 4 5 main blocking 2 # Thread Thread RxComputationThreadPool 4 5 main blocking 3 # Thread Thread RxComputationThreadPool 4 5 main blocking 4 # Thread Thread RxComputationThreadPool 4 5 main non blocking 0 # Thread Thread RxComputationThreadPool 2 5 main non blocking 1 # Thread Thread RxComputationThreadPool 2 5 main non blocking 2 # Thread Thread RxComputationThreadPool 2 5 main non blocking 3 # Thread Thread RxComputationThreadPool 2 5 main non blocking 4 # Thread Thread RxComputationThreadPool 2 5 main If I want it to emit to the REPL I would need to have it all run on the REPL thread then I get this Observable interval 100 TimeUnit MILLISECONDS Schedulers currentThread take 5 subscribe rx action v println non blocking v java lang Thread currentThread non blocking 0 # Thread Thread nREPL worker 2 5 main non blocking 1 # Thread Thread nREPL worker 2 5 main non blocking 2 # Thread Thread nREPL worker 2 5 main non blocking 3 # Thread Thread nREPL worker 2 5 main non blocking 4 # Thread Thread nREPL worker 2 5 main This then causes the bug with CurrentThreadScheduler that it never unsubscribes and hangs the REPL I don t know enough about how the Clojure REPL works I m a beginner with Clojure to know if there is a way to hook a Scheduler into it If so that would be a great contribution to the rxjava clojure module Now to see how observeOn behaves clojure Observable interval 100 TimeUnit MILLISECONDS run on default which is Schedulers threadPoolForComputation take 5 print out the value and what thread it is on before doing observeOn doOnNext rx action v println interval emitted v on thread java lang Thread currentThread observeOn Schedulers newThread move it to a new thread from here onwords subscribe rx action v receive the output and show what thread it is one println output v on thread java lang Thread currentThread The REPL shows Observable interval 100 TimeUnit MILLISECONDS run on default which is Schedulers threadPoolForComputation take 5 print out the value and what thread it is on before doing observeOn doOnNext rx action v println interval emitted v on thread java lang Thread currentThread observeOn Schedulers newThread move it to a new thread from here onwords subscribe rx action v receive the output and show what thread it is one println output v on thread java lang Thread currentThread # SafeObservableSubscription rx operators SafeObservableSubscription@6df85c2c The console shows interval emitted 0 on thread # Thread Thread RxComputationThreadPool 6 5 main output 0 on thread # Thread Thread RxNewThreadScheduler 4 5 main interval emitted 1 on thread # Thread Thread RxComputationThreadPool 6 5 main output 1 on thread # Thread Thread RxNewThreadScheduler 4 5 main interval emitted 2 on thread # Thread Thread RxComputationThreadPool 6 5 main output 2 on thread # Thread Thread RxNewThreadScheduler 4 5 main interval emitted 3 on thread # Thread Thread RxComputationThreadPool 6 5 main output 3 on thread # Thread Thread RxNewThreadScheduler 4 5 main interval emitted 4 on thread # Thread Thread RxComputationThreadPool 6 5 main output 4 on thread # Thread Thread RxNewThreadScheduler 4 5 main If I want to emit something to the REPL without using println I can return a List containing the output like this clojure Observable interval 100 TimeUnit MILLISECONDS run on default which is Schedulers threadPoolForComputation take 5 observeOn Schedulers newThread move it to a new thread from here onwords map rx fn v receive the output and show what thread it is one str output v on thread java lang Thread currentThread toList toBlockingObservable single This now returns the ArrayList in the REPL Observable interval 100 TimeUnit MILLISECONDS run on default which is Schedulers threadPoolForComputation take 5 observeOn Schedulers newThread move it to a new thread from here onwords map rx fn v receive the output and show what thread it is one str output v on thread java lang Thread currentThread toList toBlockingObservable single # ArrayList output 0 on thread Thread RxNewThreadScheduler 8 5 main output 1 on thread Thread RxNewThreadScheduler 8 5 main output 2 on thread Thread RxNewThreadScheduler 8 5 main output 3 on thread Thread RxNewThreadScheduler 8 5 main output 4 on thread Thread RxNewThreadScheduler 8 5 main Hope this is helpful cc @daveray in case you can provide better insight particularly regarding REPL console output That s a fantastic answer Noting that doOnNext is a recent addition I needed to pull and recompile I realize now part of the issue is that I use emacs cider so println output in another thread ends up in the nrepl buffer rather then the repl buffer where I expected it Yes it doesn t make sense to ask for work to be schedueled in the currentThread without something there to process schedueled work my bad Still puzzled by how in your last example the result gets returned to the current thread does each call after observeOn block the current thread in turn is single magical In any case that was very helpful and realizing the behavior I described is not a bug I ll close this now Thanks again Still puzzled by how in your last example the result gets returned to the current thread does each call after observeOn block the current thread in turn is single magical It s the call to toBlockingObservable that makes it block Anytime you want to go from non blocking to blocking you can use toBlockingObservable which then exposes a variety of blocking operators They are useful when doing unit tests playing around REPLs etc or when bridging from async to sync in a mixed codebase See here for more info about BlockingObservable https github com Netflix RxJava wiki Blocking Observable Operators Right but everything you ve shown me so far suggests that the blocking observable will still live in another thread I can only hope that I m not the only person who finds all this quite subtle I ll read up on it rather then taking up more of your time truly admire your dedication Happy new year Yes it happens on the background thread where it is scheduled The toBlockingObservable doesn t change that It just blocks and returns type T instead of Observable T or Subscription Outside of a REPL it might make more sense where the assignment is explicit groovy this returns a non blocking Observable and is lazy so not running yet Observable Long i Observable interval 100 TimeUnit MILLISECONDS take 5 this executes the above and returns a Subscription and does so asynchronously non blocking Subscription s i subscribe v println v or I can block and fetch the last value long lastValue i toBlockingObservable last The toBlockingObservable does not change where the work is done but it blocks the current thread to wait for the value which then is assigned and unblocks the current thread which then has it This is what the REPL is doing in my example where it gets the list of values returned to the REPL thread itself and it blocks the REPL thread until the value is returned The return type explains what is going on',RxJava,false,false,false
24340282,'Added BO Latest fixed BO next BO mostRecent BO toIterable','Implemented Latest Issue #59 Fixed Next and MostRecent to connect to the source observable only when the iterator is asked for Fixed ToIterable next not properly handling the completed status repeated calls to just the next would simply block on the empty queue','RxJava pull requests #557 https netflixoss ci cloudbees com job RxJava pull requests 557 SUCCESS This pull request looks good RxJava pull requests #559 https netflixoss ci cloudbees com job RxJava pull requests 559 FAILURE Looks like there s a problem with this pull request RxJava pull requests #560 https netflixoss ci cloudbees com job RxJava pull requests 560 SUCCESS This pull request looks good Does this capture the essentials more or less or should I draw up a more complicated example with hasNext calls https raw github com wiki Netflix RxJava images rx operators B next png https raw github com wiki Netflix RxJava images rx operators B latest png On Tue Dec 17 2013 at 1 11 AM CloudBees pull request builder plugin notifications@github com wrote RxJava pull requests #560 https netflixoss ci cloudbees com job RxJava pull requests 560 SUCCESS This pull request looks good Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 626#issuecomment 30735813 David M Gross PLP Consulting I imagined something like these next https docs google com file d 0B4T7ZW3brESKYllwckdxcG11TTg latest https docs google com file d 0B4T7ZW3brESKSkt6cjUtSEhUX2s Hmmm It looks like I don t understand latest I figured the second next call in your latest illustration would return the pink item since that is the latest unreturned item at the time the next call is made Instead you have it skip that one and the red item emitted after the next call is made and instead pick up the green item I don t understand the logic that governs this decision On Tue Dec 17 2013 at 12 32 PM akarnokd notifications@github com wrote I imagined something like these next https docs google com file d 0B4T7ZW3brESKYllwckdxcG11TTg latest https docs google com file d 0B4T7ZW3brESKSkt6cjUtSEhUX2s Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 626#issuecomment 30787987 David M Gross PLP Consulting @DavidMGross I think your diagram is right The codes look correct and much clearer @DavidMGross this is due to the internal race between placing a value in the oNotif and removing one So even if the next has woken up it still could be preempted and a new Notification placed by onNext overwrites the previous value Technically the red item wakes up next but the green arrives just in time so it is emitted Thank you for these fixes Thank you for these fixes',RxJava,true,false,false
24361728,'Add a parallel execution function for processing a single emitted item from an observable over concurrent fucntions','We have the following use case We create an observable which emits a single value This value passes through a couple of standard Rx map functions sequentially After the sequential functions it then needs to have multiple validation functions to be executed concurrently These are slow operations since they require I O with external systems If we can perform them in parallel we can significantly reduce our users s perceived execution time Note that this is different than the current parallel and parallelMap functions These perform the same function over multiple emitted items I need to perform multiple different functions in parallel over a single emitted value It seems that the last step might need to be a zip or similar so that the user can provide an aggregation function and then emit a single value from the result of the parallel aggregation Thoughts','Are you looking for something like this java static void sleep long ms System out println Sleeping for ms ms on thread Thread currentThread getId try Thread sleep ms catch InterruptedException e e printStackTrace static Observable Boolean doExpensiveTestsInParallel Observable Integer obs return obs flatMap new Func1 Integer Observable Boolean public Observable Boolean call final Integer i Func0 Boolean expensiveTest1 new Func0 Boolean public Boolean call sleep 200 return i 30 Func0 Boolean expensiveTest2 new Func0 Boolean public Boolean call sleep 100 return i 5 2 Func0 Boolean expensiveTest3 new Func0 Boolean public Boolean call sleep 300 return i 100 return Observable merge Observable start expensiveTest1 Schedulers threadPoolForIO Observable start expensiveTest2 Schedulers threadPoolForIO Observable start expensiveTest3 Schedulers threadPoolForIO all Functions Boolean identity That s very close However in my case the functions themselves are quite complex and touch a lot of integration points Rather than have them as embedded functions I create classes that implements Func1 or Action1 Therefore I need the ability to have both Func1 or Action11 to be invoked This allows use to unit test each of our complex functions or actions and receive the input as an argument to the call method You can see an example of how we do this at Netflix here https speakerdeck com benjchristensen rxjava goto aarhus 2013 slide 142 Inside a flatMap we kick off multiple async calls you can do computation whereas we do IO and then merge or zip them together Use merge if you don t care about their ordering or getting them back all at once',RxJava,false,false,false
24370954,'Properly wired up SynchronizedObserver within MergeDelayError operator','Previous pull request for this issue https github com Netflix RxJava pull 615 missed the step of connecting SynchronizedObserver to ParentObserver','RxJava pull requests #558 https netflixoss ci cloudbees com job RxJava pull requests 558 SUCCESS This pull request looks good',RxJava,true,false,false
24376440,'ToBlockingObservable wraps exception so I can t handle it with try catch','try Result result api getResult params toBlockingObservable last catch final Throwable e cannot catch MyException here because it wrapped with RuntimeException spawned by blockingobservable if e instanceof MyException','Checked exceptions need to be wrapped as the Iterable interface doesn t allow throwing implementations Therefore anything that is not subclass of RuntimeException or Error is wrapped into a RuntimeException Use getCause to extract the MyException Using onErrorReturn or other error handling methods of Observable and only blocking at the very end would be better style since you can use your error handling logic for both non blocking and blocking code @akarnokd I think that should be highlight in docs because it s not obvious @samuelgruetter nice tip It doesn t wrap RuntimeException only if it is a checked Exception So is the exception you were expecting a checked Exception If it was a RuntimeException then it should have thrown it and your catch would work otherwise we have a bug',RxJava,false,false,false
24413779,'Exception in onCompleted not propagate to onError','When an exception occurred in onCompleted the exception is not propagate to onError Code of rx operators SafeObserver @Override public void onCompleted if isFinished compareAndSet false true try actual onCompleted catch Throwable e handle errors if the onCompleted implementation fails not just if the Observable fails onError e auto unsubscribe subscription unsubscribe In our case isFinished is already TRUE so onError does nothing @Override public void onError Throwable e if isFinished compareAndSet false true','That s intentional According to Rx Contract A observer should not receive both onCompleted and onError You need to handle the exception in onCompleted by yourself 2013 12 17 7 38 00 https f cloud github com assets 1000778 1763512 eab38080 670f 11e3 819b 385674e19cbb png Ok the grammar the contract is clear So I don t understand why in SafeObserver there is this code catch Throwable e handle errors if the onCompleted implementation fails not just if the Observable fails onError e It s in contradiction with the grammar and because isFinished is set to true it is useless Why not call a global errorHandler or something like that in the catch I don t understand Regards Ronan Ha yep that code is pretty useless Kind of funny I ll submit a fix shortly',RxJava,false,false,false
24436816,'Make NewThreadScheduler create Daemon threads','This matches the behavior of Schedulers COMPUTATION_EXECUTOR and Schedulers IO_EXECUTOR See https groups google com forum # topic rxjava Qe1qi0aHtnE and https github com Netflix RxJava issues 431#issuecomment 30767610','RxJava pull requests #561 https netflixoss ci cloudbees com job RxJava pull requests 561 FAILURE Looks like there s a problem with this pull request This solves the non termination problem but should those terminations be so harsh Perhaps allowing the core threads to timeout might be a better alternative to all of these schedulers although the tuning of timeout value could be of concern I don t understand what you mean Can you elaborate For example what timeout are you referring to This code should not prevent the JVM from exiting java public static void main String args Observable from 1 2 3 4 observeOn Schedulers newThread toBlockingObservable forEach new Action1 Integer @Override public void call Integer i System out println i i It should be application logic that chooses to block not the exit of a JVM I was talking about the thread pool and core thread timeouts aka keepalive time java private static class EventLoopScheduler extends Scheduler private final ExecutorService executor private EventLoopScheduler ThreadPoolExecutor e ThreadPoolExecutor Executors newFixedThreadPool 1 new ThreadFactory @Override public Thread newThread Runnable r return new Thread r RxNewThreadScheduler count incrementAndGet e setKeepAliveTime 1 TimeUnit SECONDS mabe lower maybe greater time in general e allowCoreThreadTimeOut true executor e The problem I encounter with daemon threaded pools is that when the main thread exists these threads stop immediately and don t finish their given tasks This is why there are sleep calls in various tests They require a similar subscribe new pool unsubscribe shutdown pool pattern to be used I guess there are pros and cons for both cases If something needs to be waited on then toBlockingObservable or some other similar approach should be used to block the main thread until the application completes We don t want the main thread waiting on Scheduler threads If an app let s the main thread complete then the app should finish Sleep and timeouts are non deterministic and incorrect for using to keep an application running Fair enough But there is still an issue with NewThreadScheduler Even if quitting the application removes these threads performing thousand scheduling operation will yield thousand threads or an exception about the inability to create more threads So until the application quits these threads stay I suggest adding the java e setKeepAliveTime 50 TimeUnit MILLISECONDS e allowCoreThreadTimeOut true from my example to the NewThreadScheduler to be safe 50 milliseconds might be to big since threads are no way to be reused so decreasing it to zero is also possible Test program public static void main String args throws Exception BlockingObservable Integer source Observable from 1 observeOn Schedulers newThread toBlockingObservable for int i 0 i 20000 i Thread sleep 1 source single if i 1000 0 System out println i RxJava pull requests #562 https netflixoss ci cloudbees com job RxJava pull requests 562 SUCCESS This pull request looks good Should I open a new issue for the thread exhaustion problem',RxJava,true,false,false
24458376,'NewThreadScheduler thread exhaustion','The current implementation of NewThreadScheduler creates a new ThreadPoolExecutor for each non recursive schedule invocation The pool is never terminated except when the application terminates therefore pools no longer in use still keep one thread active blocked on waiting for the next task which can t arrive If too many pools are created the operating system might run out of fresh threads causing native thread creation failed throughout the application To demonstrate the problem here is a small test case java public class NewThreadSchedulerTest @Test public void testExhaustion throws InterruptedException Scheduler s Schedulers newThread BlockingObservable Integer source Observable from 1 subscribeOn s toBlockingObservable for int i 0 i 10000 i Assert assertEquals Integer 1 source single This test fails on my Windows 7 x86 after about 4000 iterations Its equivalent Rx NET code however works fine C# class Program static void Main string args IScheduler s NewThreadScheduler Default IObservable int source Observable ToObservable new int 1 s SubscribeOn s int sum 0 for int i 0 i 10000 i sum source Single Thread Sleep 1 if i 256 0 Console Write i Console Write Console WriteLine sum The program s thread count remains about 15 It seems that RxNET uses vanilla threads in combination with some kind of CurrentThreadScheduler in it and has an explicit option to quit if no more tasks are queued or pending I ve tried to fix NewThreadScheduler by setting a keepalive on the thread pool but unfortunately it breaks the OperationParallelMergeTest because a restarted thread in the thread pool will get a different identifier I ve tried adding wip counter to capture when to terminate the pool but didn t work probably due escaped scheduler reference is invoked outside the callback function action Any ideas','I think the issue is two fold 1 NewThreadScheduler does not shutdown the executor in the subscription it returns 2 BlockingObservable does not obey guideline 4 3 and unsubscribe when it completes Generally we rely upon a user provided Observer and the SafeObserver doing this but BlockingObservable never receives a user provided Observer 4 3 Assume resources are cleaned up after an OnError or OnCompleted message Paragraph 4 1 states that no more messages should arrive after an OnError or OnCompleted message This makes it possible to cleanup any resource used by the subscription the moment an OnError or OnCompleted arrives Cleaning up resources immediately will make sure that any side effect occurs in a predictable fashion It also makes sure that the runtime can reclaim these resources Sample Observable Using new FileStream @ d temp test txt FileMode Create fs Observable Range 0 10000 Select v Encoding ASCII GetBytes v ToString WriteToStream fs Subscribe In this sample the Using operator creates a resource that will be disposed upon unsubscription The Rx contract for cleanup ensures that unsubscription will be called automatically once an OnError or OnCompleted message is sent I m working on this I ve confirmed it s what I thought the BlockingObservable doesn t call unsubscribe when onComplete onError happen and thus the resources are not freed The example code works fine if BlockingObservable is not involved and a normal async subscribe is used Before fixing BO would it be possible to merge our PRs changing the same files so we don t have to rebase everything again Unfortunately there is no good way to detect if an iteration has stopped in Java We can have a forEach overload that takes a predicate Yeah I can merge it I intend on working more on this tonight just haven t had time to finish it during my day hours For an iteration stopping isn t it sufficient to know that we have exited that block of code and just have the completion marker style thing invoked right after we exit the iteration When Java 7 introduced the DirectoryStream they faced a similar issue one would need to call close on the Iterator but then you can t use for each loop for enumeration The solution was to have DirectoryStream Closeable and return only a single Iterator therefore this pattern is established java try DirectoryStream ds list for Path p ds if p toString endsWith xml break We can have a BlockingObservable onetimeIterable returning an IterableUnsubscribable instance and require a similar pattern Alternatively the following forEach overload could do the trick java BlockingObservable forEachUntil Func1 T Boolean breakoutConsumer Where the function breakoutConsumer should return true if it wishes to continue the loop That seems to solve a different problem breaking out of a forEach loop on an infinite stream as opposed to knowing when it completes The takeUntil operator already enables conditionally breaking an infinite stream forEachUntil is just merging those together What exactly is the use case you were referring to for this statement there is no good way to detect if an iteration has stopped in Java The TakeUntil seems to be appropriate but we still need a BO await to run to run through the results and block A case java public Integer one return Observable from 1 subscibeOn Schedulers threadPoolForComputation repeat toBlockingObservable toIterable iterator next We don t have the IDisposable in Java which seems to handle exactly these issues What is the issue in that code example other than the one we already know that causes BlockingObservable to not correctly unsubscribe Up to the toBlockingObservable it is an infinite stream of 1s We take the first value of this stream and leave the whole thing There is no way the BO can detect that nothing is iterating it further and can t stop because the upstream won t complete One would need a way to tell the Iterator to stop I d argue that next on an infinite iterator is bad code Same way that calling toList on an infinite stream is bad code Yes if you know that it is an infinite iterator The example could feature a range 1 10000000 scheduleOn Schedulers threadPoolForComputation toBlockingObservable toIterable iterator next which it is finite yet wasteful We could return a subclass of Iterable and Iterator that allow unsubscribing When someone uses the StoppableIterable and StoppableIterator without calling stop that is definitely a bad code When you have just the Iterable there is no contract or way to do the stopping Similar problem appeared with Streams in the Lambda dev recently Closing this as the original test case now passes as expected',RxJava,false,false,false
24466146,'Fixed issue #595 about null in toList operator','just fixed the issue #595 about null values I suppose that toList does not need to handle the concurrent problem so I use ArrayList','RxJava pull requests #563 https netflixoss ci cloudbees com job RxJava pull requests 563 SUCCESS This pull request looks good Thanks',RxJava,true,false,false
24477040,'More operators in Rx Net','I extracted the method names from RxJava and Rx Net and compared them I find some operators in Rx Net version 2 0 20823 0 do not appear in the MSDN Do we need to implement them before 1 0 Here is the list x any exist isEmpty asobservable case catch onErrorResumeNext chunkify collect deferasync delaysubscription x do doOnEach dowhile x finally finallyDo x firstasync #520 x firstordefaultasync firstOrDefault for x foreach BO forEach foreachasync fromasync x fromasyncpattern unnecessary x fromevent unnecessary x fromeventpattern unnecessary x generate #519 x getenumerator unnecessary as we have BO toIterable if x lastasync x lastordefault BO lastOrDefault lastordefaultasync x latest #626 x mostrecent BO mostRecent x next BO next x refcount ConnectableObservable refCount x repeat #518 x return from just x select map x selectmany flatMap x single BO single singleasync x singleordefault BO singleOrDefault singleordefaultasync startasync switch switchOnNext takelastbuffer x throttle debounce x throw error x toarray unnecessary x toasync Async toAsync x todictionary toMap x toenumerable BO toIterable x toevent unnecessary x toeventpattern unnecessary x tolookup toMultimap x toobservable from wait while Thoughts','Nice list Catch onErrorResumeNext FromAsyncPattern won t implement #46 Generate PR available #519 still debating on return type LastOrDefault BO lastOrDefault MostRecent BO mostRecent Repeat PR available #518 StartAsync start Switch switchOnNext Throttle debounce I don t recognize the rest Updated StartAsync is not the start operator Summary Invokes the asynchronous function surfacing the result through an observable sequence The CancellationToken is shared by all subscriptions on the resulting observable sequence See the remarks section for more information Parameters functionAsync Asynchronous function to run Type parameters TResult The type of the result returned by the asynchronous function Returns An observable sequence exposing the function s result value or an exception Exceptions System ArgumentNullException functionAsync is null Remarks The function is started immediately not during the subscription of the resulting sequence Multiple subscriptions to the resulting sequence can observe the function s result If any subscription to the resulting sequence is disposed the CancellationToken is set The observer associated to the disposed subscription won t see the TaskCanceledException but other observers will You can protect against this using the Catch operator Be careful when handing out the resulting sequence because of this behavior The most common use is to have a single subscription to the resulting sequence which controls the CancellationToken state Alternatively you can control subscription behavior using multicast operators public static IObservable TResult StartAsync TResult Func CancellationToken Task TResult functionAsync Here is what s missing and what they generally do AsObservable Hides the identity of an observable sequence Case Uses a selector to determine which source to return i e in onSubscribe a Func0 selector is called and an Observable looked up in a map then subscribed to it Chunkify Produces an enumerable sequence of consecutive possibly empty chunks of the source sequence i e implemented as source collect new ArrayList lst x lst add x return lst u new ArrayList Collect Produces an enumerable sequence that returns elements collected aggregated from the source sequence between consecutive iterations For example you start out with an empty list and each onNext adds to the list Once the iterator next takes the current list it is replaced by a fresh list Depending on the frequency of next you might get lists with various sizes DeferAsync Returns an observable sequence that starts the specified asynchronous factory function whenever a new observer subscribes Implemented as Defer StartAsync factory Merge where factory is a Func0 Task IObservable TValue DelaySubscription Time shifts the observable sequence by delaying the subscription with the specified relative time duration Does not timeshift the unsubscribe DoWhile Repeats the given source as long as the specified condition holds where the condition is evaluated after each repeated source completed I e repeat only if condition holds do subscribe run while condition For Concatenates the observable sequences obtained by running the resultSelector for each element in the given enumerable source The difference from a plain concat is that the source iterable is consumed on demand rather than all at once ForEachAsync Invokes an action for each element in the observable sequence and returns a Task object that will get signaled when the sequence terminates like making a whole sequence of observations into a big Future Dual of fromFuture toAsync in some sense FromAsync Converts to asynchronous function into an observable sequence Each subscription to the resulting sequence causes the function to be started The CancellationToken passed to the asynchronous function is tied to the observable sequence s subscription that triggered the function s invocation and can be used for best effort cancellation Implemented as Defer StartAsync functionAsync where functionAsync is Func Task TResult or Func CancellationToken Task TResult If If the specified condition evaluates true select the thenSource sequence Otherwise select the elseSource sequence Condition is evaluated on subscription GroupBy with capacity overloads v2 2 GroupByUntil with capacity overloads v2 2 SingleAsync Returns the only element of an observable sequence and reports an exception if there is not exactly one element in the observable sequence Returns an observable with a single element or exception SingleOrDefaultAsync Returns the only element of an observable sequence or a default value if the observable sequence is empty this method reports an exception if there is more than one element in the observable sequence StartAsync see comment https github com Netflix RxJava issues 634#issuecomment 30827770 above TakeLast overload with time window i e return the last 2 seconds worth of source values once it finishes TakeLastBuffer Returns a list with the specified number of contiguous elements from the end of an observable sequence Has time based overloads Almost like takeLast but emits a single list of elements Wait Waits for the observable sequence to complete and returns the last element of the sequence If the sequence terminates with an OnError notification the exception is throw Returns T Looks like a source takeLast 1 toBlockingObservable single While Repeats the given source as long as the specified condition holds where the condition is evaluated before each repeated source is subscribed to I e while condition subscribe @zsxwing or anyone else do you want to do some of these I ll do them in batches do I don t have to rebase and restart from master all the time I ll start with DoWhile While If Case Continuing with Chunkify Collect Wait and For Update Wait is practically BO last Since we don t usually do aliases I ll skip Wait Next DeferSubscription TakeLast TakeLastBuffer I can add SingleAsync and SingleOrDefaultAsync in PR #520 directly Do we really need DeferAsync ForEachAsync FromAsync StartAsync We have no CancellationToken in Java It appears to me that CancellationToken is used for cancelling tasks basically a similar way you would use FutureTask and check its isCancelled but since these tokens come from the outside you can signal cancellations to multiple tasks at once Since we have the Subscription infrastructure for that I d vote for not implementing those variants Doing AsObservable GroupBy and GroupByUntil variants Anyone want to implement all the TestSchedulers CancellationToken is really only useful when you have async await A can take those as well unless someone else beats me to it while I do the ops mentioned above Doing lastasync and lastordefaultasync @headinthebox what features do you miss from the current TestScheduler I m looking at Rx NET sources of VirtualScheduler TestScheduler and HistoricalScheduler but it is not apparent to me what the functional requirements are Never mind I ll start doing it Btw I m starting to require the enhancements of my PRs to avoid feature duplication These are done Switch switchOnNext Throttle debounce The async ones don t use the async suffix in RxJava since the non async ones are on BlockingObservable instead Thus some of those in the list are already implemented just without the async suffix @zsxwing How is the lastasync operator you say you re doing different than last https github com Netflix RxJava blob master rxjava core src main java rx Observable java#L5740 that is already implemented It is non blocking We have last and takeLast last Returns an Observable that emits the last item emitted by the source or an IllegalArgumentException if the source Observable is empty takeLast int count Returns an Observable that emits only the last count items emitted by the source Observable Difference between takeLast 1 and last just being the IllegalArgumentException on take You were involved in both of these I though so I m confused why we re pursuing lastasync What is a use case for asObservable to hide identity Rx NET uses it all around the place to hide subjects @headinthebox might explain it better Interesting though what value is there in hiding it If it is returned as an Observable not a Subject people will use it as an Observable Is it to prevent people reflecting or inspecting a type and then interacting with the Subject Yup as @benjchristensen says it is to prevent downcasting etc In NET people are pretty paranoid about this Say you have a method that returns an Iterable T but really it is an Array T Now that opens a potential security hole since the caller can use the Iterable as a an Array @zsxwing How is the lastasync operator you say you re doing different than last https github com Netflix RxJava blob master rxjava core src main java rx Observable java#L5740 that is already implemented It is non blocking Sorry Forgot it We just need to add LastOrDefaultAsync Hope this comment https github com Netflix RxJava pull 520#issuecomment 30936173 can make these operators clear If no problem I can add this table to the wiki Looking into DeferAsync StartAsync and SingleAsync Looking into DeferAsync StartAsync and SingleAsync SingleAsync has already done in #520 Doing ForEachAsync and FromAsync and probably will amend PR #645 The fromAsync behavior seems to be covered in from overloads that take a Scheduler such as this https github com Netflix RxJava blob master rxjava core src main java rx Observable java#L753 No this FromAsync is a completely different operation it uses a factory to get a future of a value which is then observed per subscriber Already added the table to the wiki https github com Netflix RxJava wiki Blocking Observable Operators#appendix similar blocking and non blocking operators On Thu Dec 19 2013 at 5 57 PM Shixiong Zhu notifications@github com wrote @zsxwing https github com zsxwing How is the lastasync operator you say you re doing different than last https github com Netflix RxJava blob master rxjava core src main java rx Observable java#L5740 that is already implemented It is non blocking Sorry Forgot it We just need to add LastOrDefaultAsync Hope this comment #520 comment https github com Netflix RxJava pull 520#issuecomment 30936173 can make these operators clear If no problem I can add this table to the wiki Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 634#issuecomment 30983749 David M Gross PLP Consulting @headinthebox and I reviewed the list All remaining items have been struck out as they should not be implemented Great work getting all the others done',RxJava,false,false,false
24491159,'Operators switchCase Case ifThen If doWhile DoWhile WhileDo W','hile Issue #634 No MSDN references available','RxJava pull requests #565 https netflixoss ci cloudbees com job RxJava pull requests 565 SUCCESS This pull request looks good',RxJava,true,false,false
24515040,'Operators BO chunkify BO collect O forIterable','Issue #634 Any suggestions for a name instead of forIterable','RxJava pull requests #566 https netflixoss ci cloudbees com job RxJava pull requests 566 SUCCESS This pull request looks good Split into two',RxJava,true,false,false
24518961,'Why subscribe with single action for onNext design to crush if error happened','Why subscribe with single action for onNext designed to crush if error happened I thought that missing of onError should just silently fail observable1 subscribe new Action1 MyResult will crush if onError is called What is preferred way to subscribe if I want silently fail onError Using my own observer','I can t tell the reason but we have the following overload Subscription subscribe final Action1 super T onNext final Action1 Throwable onError where you can specify your error handler Alternatively you need to implement Observer T to get all 3 kinds of events I don t see this as being any different than writing regular code without a try catch and then a RuntimeException being thrown If error handling is ignored and a RuntimeException occurs it will throw Absence of an error handler should not mean swallow errors silently and fail without any way of knowing something happened That results in very non obvious bugs and bad system operations If errors want to be swallowed that needs to be a conscious choice Two simple approaches that come to mind for swallowing errors are 1 An empty handler can be passed in such as to the overload @akarnokd mentioned or a fully qualified implementation of Observer with the onError method doing nothing Using the overloads though allows code such as groovy observableWithError subscribe value println value throwable do nothing 2 Use the onErrorResumeNext operator in your sequence and make it return Observable empty groovy observableWithError onErrorResumeNext Observable empty subscribe value println value Hope this helps Is this answered sufficiently or do you still think something is done wrong @benjchristensen Yeah I thinks it s clear now Thanks a lot',RxJava,false,false,false
24521072,'Operators DelaySubscription TakeLast w time TakeLastBuffer','Issue #634','RxJava pull requests #567 https netflixoss ci cloudbees com job RxJava pull requests 567 SUCCESS This pull request looks good This looks good merging Two requests going forward though 1 Please do not mix different operators into a single pull request that are not related The delaySubscription and take operators have nothing to do with each other and confused the review 2 When you add method signatures that Rx Net does not have it would be helpful for you to call them out Thank you Will separate unrelated ops from now on',RxJava,true,false,false
24521857,'Moved the descriptions of some operators to a new wiki page','Conditional and Boolean Operators adjusting the javadoc links accordingly','RxJava pull requests #568 https netflixoss ci cloudbees com job RxJava pull requests 568 SUCCESS This pull request looks good',RxJava,true,false,false
24541406,'Scala Publish','The current Scala bindings for publish are as follows def publish Subscription Observable T val javaCO asJavaObservable publish javaCO connect toScalaObservable T javaCO This has a couple of downsides It forces every caller has to invent names for the two pieces whereas they already have names given by the callee val foo bar baz publish vs val bar baz publish bar subscribe bar connect It hides the fact that publish returns a connectable observable so you cannot call refcount Why split up a nice object into a tuple of unrelated things Maybe that makes sense if you want to pass the two pieces around separately but that is typically not the case of connectable observables If I don t hear anyone screaming loudly I am going to change this to mimic the Java signature','When I came up with this Subscription Observable pattern the Scala Observable extended AnyVal so it was final and I could not make a ConnectableObservable extending it But now this problem is gone so I think it makes sense to replace Subscription Observable by ConnectableObservable of course not only in publish but also in multicast and replay There s a similar situation with groupBy In Java we have a GroupedObservable K T and in Scala we have a Observable K Observable T Here however I wouldn t change anything because an Observable emitting tuples which map keys to Observables makes more sense than claiming that the key is part of the Observable and also the tuples allow nice for comprehensions like for key obs o groupBy @headinthebox @samuelgruetter Has this been resolved Should be resolved in #1160',RxJava,false,false,false
24545602,'Operators AsObservable GroupBy w maxGroups GroupByUntil w maxGroups','Issue #634 Implemented both maxGroups variants on top of my groupByUntil so it won t conflict with any potentially rewritten groupBy','RxJava pull requests #569 https netflixoss ci cloudbees com job RxJava pull requests 569 SUCCESS This pull request looks good While reviewing we @headinthebox and I see the maxGroups stuff and don t see matching behavior in Rx Net Can you explain what is being added beyond Rx Net and why While at it can you please separate out asObservable and groupByUntil Mentioned here http rx codeplex com discussions 468747 and code is here http rx codeplex com SourceControl latest#Rx NET Source System Reactive Linq Reactive Linq Observable GroupByUntil cs I ll split the ops into two PRs',RxJava,true,false,false
24560307,'TestScheduler infrastructure enhancements','Enhanced TestScheduler Mentioned in issue #634 and in the forum HistoricalScheduler https groups google com forum # topic rxjava 4vmsg5Rs5sU Notes Inspired by Rx NET HistoricalScheduler appears to be just a variant of the TestScheduler where times are absolute DateTimeOffset s Since we don t do java util Date overloads anywhere I didn t implement this If you need to work with real time i e System currentTimeMillis just advance the TestScheduler by ctm before doing anything else The Recorded class the TestScheduler scheduleAbsolute and TestScheduler scheduleRelative methods use millisecond resolution time due to two reasons TestScheduler now is in milliseconds No real need of higher resolution as TestScheduler operates on virtual time and aimed for testing purposes only Virtual time can be scaled up or down as neccessary Added the package rx observers I guess we can move the SafeObserver ObserverBase and SynchronizedObserver into these packages not done in this PR The package s JavaDoc visibility can be decided independently I put the new ColdObservable HotObservable and TestableObservable types into rx observables Do we have a main distribution and a test distribution of RxJava i e if someone wants to use these types to test his her own operators does he she need to download a different library Added some behavior to Notification In addition I suggested the deprecation of new Notification to create an OnCompleted kind of notification since virtually there is no way or reason to distinguish between one OnCompleted event from another I ve added a factory method instead which returns a single constant instance I haven t changed any use place of the old constructor See TestSchedulerTest for the use cases','RxJava pull requests #570 https netflixoss ci cloudbees com job RxJava pull requests 570 SUCCESS This pull request looks good We are holding off on decisions related to this one for now as @headinthebox is reviewing the design of test schedulers including the comparison against Rx Net A lot has changed since this so closing out for now I would like this conversation to be picked up again between you and @headinthebox to determine what TestScheduler should become Okay',RxJava,true,false,false
24593176,'Fixed OutOfMemoryError with CPU scheduler in recursive mode','Found an issue in Rx NET https rx codeplex com discussions 431558 regarding an out of memory situation due to long chained subscriptions when using recursive scheduling The following test program crashes or just hangs indefinitely java public class RunRecursiveScheduling Generates an observable sequence by iterating a state from an initial state until the condition returns false public static TState R OnSubscribeFunc R generate final TState initialState final Func1 TState Boolean condition final Func1 TState TState iterate final Func1 TState R resultSelector final Scheduler scheduler return new OnSubscribeFunc R @Override public Subscription onSubscribe final Observer super R observer return scheduler schedule initialState new Func2 Scheduler TState Subscription @Override public Subscription call Scheduler s TState state boolean hasNext try hasNext condition call state catch Throwable t observer onError t return Subscriptions empty if hasNext R result try result resultSelector call state catch Throwable t observer onError t return Subscriptions empty observer onNext result TState nextState try nextState iterate call state catch Throwable t observer onError t return Subscriptions empty return s schedule nextState this observer onCompleted return Subscriptions empty public static void main String args throws Exception Observable Integer source Observable create generate 0 a true a a 1 a a Schedulers threadPoolForComputation CountDownLatch latch new CountDownLatch 1 Subscription s source subscribe v if v 100_000 0 System out println v if v 10_000_000 latch countDown e e printStackTrace latch countDown latch countDown latch await System out println Wait done s unsubscribe System out println Unsubscribe done The issue lies in the fact that CPU scheduler and perhaps the others are not really reentrant therefore they create new composite subscriptions whenever a recursive scheduling happens So instead of showing a simple subscription to the outside world a chain of subscription is extended on every recursive schedule call A working solution is to have a different scheduler shown to the Func2 Scheduler T Subscription than the actual CPU scheduler This new scheduler called ReentrantScheduler maintains internal subscriptions which get replaced if a recursive scheduling is executed I found three issues with this new approach and the old tests In SchedulersTest testRecursiveScheduler2 the logic relied on the expectation that the call on L338 is executed at least once if the outer subscription is unsubscribed The new logic stops the schedule chain instantly so it is very unlikely the call on L338 gets executed after this In OperationObserveOn Observation tries to solve the underlying issue as well with its own subscription replacer logic I haven t changed the operator as it might not work with non CPU scheduler after that The ReentrantSchehduler maintains two subscriptions One for the result of the schedule calls and one for the the DiscardableAction s The former subscriptions can be swapped out without unsubscribing the previous completed schedule but I m not sure about the DiscardableAction s if I unsubscribe them tests hang because it basically cancels itself and no further task is executed This might be a conceptual error in ReentrantScheduler perhaps it should not return the entire composite on each schedule call but rather return the content of the actionSub only','RxJava pull requests #573 https netflixoss ci cloudbees com job RxJava pull requests 573 SUCCESS This pull request looks good whenever a recursive scheduling happens That sounds like a simple issue as an internal scheduler once complete should have no reference to anything else If CompositeSubscription is being held it sounds like a use for SerialSubscription or MultipleAssignmentSubscription I have not yet grokked why this PR is changing so much when recursion already works fine on Schedulers Here is infinite recursion happening inside observeOn using inner schedulers correctly and without StackOverflow or OutOfMemory Thus I don t believe the actual interfaces are incorrect just something we re doing wrong with the subscriptions inside the Executor implementation similar to how when BlockingObservable is used it doesn t correctly cleanup https github com Netflix RxJava issues 632 java protected static void testRecursion throws InterruptedException Observable Long source Observable interval 1 TimeUnit MILLISECONDS observeOn Schedulers newThread final CountDownLatch latch new CountDownLatch 1 source subscribe new Action1 Long @Override public void call Long l if l 1000 0 System out println l wait indefinitely latch await new thread EventLoopScheduler 0 1000 2000 3000 4000 5000 173000 Recursion only works when the observeOn is used but many operators use schedulers directly which are not reentrant so they will chain up the subscriptions Closing Revised in PR #648 This seems like it s a bug inside current Schedulers as recursion should work without memory leaks Here is the histogram showing the leak JVM version is 24 45 b08 Iterating over heap This may take a while Object Histogram num #instances #bytes Class description 1 1488649 83360752 java lang Object 2 2976652 47626432 java util concurrent atomic AtomicReference 3 1488325 47626400 rx schedulers DiscardableAction 4 1488324 47626368 java util concurrent FutureTask 5 1488330 35719920 java util ArrayList 6 1488324 35719776 rx subscriptions CompositeSubscription State 7 1488456 23815296 java lang Integer 8 1488326 23813216 java util concurrent atomic AtomicBoolean 9 1488326 23813216 rx operators SafeObservableSubscription 10 1488325 23813200 rx subscriptions CompositeSubscription 11 1488324 23813184 rx subscriptions Subscriptions 3 12 7036 905920 MethodKlass 13 7036 813896 ConstMethodKlass 14 499 567648 ConstantPoolKlass 15 499 348832 InstanceKlassKlass 16 447 339168 ConstantPoolCacheKlass 17 2051 148592 char 18 702 106856 byte 19 569 68872 java lang Class 20 830 52568 System ObjArray 21 2027 48648 java lang String 22 769 44128 short 23 124 40800 MethodDataKlass 24 785 31400 java util TreeMap Entry 25 53 28408 ObjArrayKlassKlass 26 138 9936 java lang reflect Field 27 218 6976 java util concurrent ConcurrentHashMap HashEntry 28 192 6568 java lang String 29 138 4416 java util HashMap Entry 30 8 4288 TypeArrayKlassKlass 31 178 4272 java util LinkedList Node 32 116 3712 java util Hashtable Entry 33 97 3104 java util LinkedList 34 193 3088 java lang Object 35 46 2944 java net URL 36 30 2848 java util HashMap Entry 37 66 2704 java util concurrent ConcurrentHashMap HashEntry 38 66 2640 java util concurrent ConcurrentHashMap Segment 39 72 2304 java util concurrent locks ReentrantLock NonfairSync 40 11 2288 KlassKlass 41 38 1824 sun util locale LocaleObjectCache CacheEntry 42 36 1728 java util HashMap 43 5 1696 int 44 36 1440 java util LinkedHashMap Entry 45 18 1296 java lang reflect Constructor 46 16 1280 java util WeakHashMap Entry 47 1 1040 java lang Integer 48 26 1040 java lang ref SoftReference 49 6 992 java util Hashtable Entry 50 16 896 java util WeakHashMap 51 21 840 java lang ref Finalizer I will dig in to this and get it resolved We do not need new subscription or scheduler types to solve this',RxJava,true,false,false
24598322,'Throw the checked exception without declaring it','It uses the deprecated method Thread stop Throwable to throw an exception without declaring it','The non deprecated way of doing this if I understand your goal is the so called SneakyThrow approach http stackoverflow com questions 14038649 java sneakythrow of exceptions type erasure RxJava pull requests #574 https netflixoss ci cloudbees com job RxJava pull requests 574 FAILURE Looks like there s a problem with this pull request I saw that one but this way seems so much simpler This looks like a very dangerous thing You are basically killing the current thread which could be a thread of a thread pool and incur a thread recreation fee as well That s what throwing any exception does The real danger is that a user incorrectly assumes that because a checked exception isn t declared that only subclasses RuntimeException can be thrown I m not convinced we should be attempting sneaky throw at all In Java people do not expect checked exceptions to be thrown without declaration I don t like checked exceptions but I like confusing and non obvious behavior less Is the problem of RuntimeException wrapping for BlockingObservable serious enough to fight against the language Are there other major libraries that do this I didn t even consider the idea of a sneaky throw until I ran into it with Java calling a Groovy closure Not that Groovy is anything to aspire to Not that Groovy is anything to aspire to Ha I feel that this comment is the key to this discussion The real danger is that a user incorrectly assumes that because a checked exception isn t declared that only subclasses RuntimeException can be thrown My opinion is that we should not try and do a sneaky throw as the least surprising thing we can do it wrap an Exception Throwable in a RuntimeException and everyone will catch it instead of them getting Exception Throwable thrown past their try catch block and blowing up their app Does anyone have a strong reason to pursue this sneaky throw approach in light of this perspective I will close this out in the next couple days if I hear nothing to convince otherwise',RxJava,true,false,false
24613844,'Operators startFuture StartAsync and deferFuture DeferAsync','Issue #634 They are basically 1 2 layer deep indirections around Futures and Observables','RxJava pull requests #577 https netflixoss ci cloudbees com job RxJava pull requests 577 SUCCESS This pull request looks good RxJava pull requests #579 https netflixoss ci cloudbees com job RxJava pull requests 579 FAILURE Looks like there s a problem with this pull request RxJava pull requests #580 https netflixoss ci cloudbees com job RxJava pull requests 580 SUCCESS This pull request looks good Could someone give me a summary of the differences between the following three operators fromFuture Future from Future startFuture Future On Fri Dec 20 2013 at 6 29 AM CloudBees pull request builder plugin notifications@github com wrote RxJava pull requests #580 https netflixoss ci cloudbees com job RxJava pull requests 580 SUCCESS This pull request looks good Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 645#issuecomment 31012682 David M Gross PLP Consulting from Future synchronously awaits the completion of the Future while in the subscribe method java Future f from f subscribe observer we get here only if f has completed subsequent subscriptions will immediately receive the output of f startFuture Func Future T It immediately calls the factory function and and returns the Observable of the call to from Future If the factory call fails returns an Ebservable error with the exception instead This awaits the completion of the future so new subscribers may get the result immediately fromFuture Func Future T This defers the factory function call into the subscription phase so practically every subscribing observer will get a fresh future So they are basically linked as Future f Func0 Future factory someFuture from f startFuture from factory call fromFuture defer from factory call Hope this helps Hmmm okay I think I understand that but now I m confused at the difference between fromFuture and deferFuture On Fri Dec 20 2013 at 12 51 PM akarnokd notifications@github com wrote synchronously awaits the completion of the Future while in the subscribe method java Future f from f subscribe observer we get here only if f has completed subsequent subscriptions will immediately receive the output of f It immediately calls the factory function and and returns the Observable of the call to from Future If the factory call fails returns an Ebservable error with the exception instead This awaits the completion of the future so new subscribers may get the result immediately fromFuture Func Future T This defers the factory function call into the subscription phase so practically every subscribing observer will get a fresh future So they are basically linked as Future f Func0 Future factory someFuture from f startFuture from factory call fromFuture defer from factory call Hope this helps Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 645#issuecomment 31040678 David M Gross PLP Consulting This is where it becomes full circle The factory returns a future which returns an observable sequence that is relayed to the subscriber deferFuture defer merge from factory call Where merge is used because from returns an observable of observable of T Ahhh I think I m beginning to see the light On Fri Dec 20 2013 at 4 36 PM akarnokd notifications@github com wrote This is where it becomes full circle The factory returns a future which returns an observable sequence that is relayed to the subscriber deferFuture defer merge from factory call Where merge is used because from returns an observable of observable of T Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 645#issuecomment 31052018 David M Gross PLP Consulting Speaking with @headinthebox the history of these from Rx Net is to support integration with async await which Java does not have Thus it does not seem appropriate to implement them for Java Anytime this functionality is needed it is trivial to do inside Observable create Can you provide reasons to add these other than matching Rx Net If it s only to match Rx Net then we will pass on them They greatly complicate the API and have easier solutions by using the create from methods that already exist I can t be sure how much legacy code with Futures are out there that could be interfaced with RxJava this way So can t give a definite reason Maybe this and other unwanted operators could be moved under the contribution section Merge these into https github com Netflix RxJava pull 696 instead Merge these into https github com Netflix RxJava pull 696 instead',RxJava,true,false,false
24622484,'Operator BO forEachFuture','Issue #634 I tried to find a random place in BO but it is likely this or the other PRs will not merge one after another','RxJava pull requests #578 https netflixoss ci cloudbees com job RxJava pull requests 578 SUCCESS This pull request looks good In Rx Net it had clean design with Task and async await In Java we don t This and other similar pull requests don t make much sense and are greatly complicating the API In Java the Future FutureTask Callable Runnable CompletableFuture set of classes do not play well with the non blocking reactive style of Rx nor is there good conformity across JVM languages Scala Groovy Clojure with different concurrency models and libraries or even Java libraries such as Guava and Akka I think that all of these additions you are proposing related to java util concurrent interop should be pushed into a separate contrib module and not part of core Perhaps rxjava contrib rxjava java future or something along those lines In short the goal is to keep rxjava core focused on the basics of Observable and non blocking operators Interop with the various different approaches to concurrency should be kept separate In retrospect even the Async java stuff should likely be moved out to this new contrib module Yes a contrib module would be much cleaner Great I m glad we agree I ll setup the module for you Merge these into https github com Netflix RxJava pull 696 instead',RxJava,true,false,false
24637079,'Operation Generate Timed','Issue #49 I hope the Func1 TState Long TimeUnit will suffice I kept the absolute time variant in the OperationGenerate and in tests but haven t exposed them in Observable','RxJava pull requests #581 https netflixoss ci cloudbees com job RxJava pull requests 581 SUCCESS This pull request looks good As per @headinthebox this is really only used in demos and super complicated and thus should not be added to RxJava Anything that can be done via generate should instead be done inside Observable create OnSubscribeFunc f optionally with a Scheduler',RxJava,true,false,false
24646414,'Reentrant scheduling2','Revised version of PR #643 Added scheduleRunnable overloads to Scheduler directly to avoid constant wrapping between Runnable and Action0 Removed the helper interface Reworked ReentrantScheduler to work with a parent scheduler directly Replaced ForwardSubscription with IncrementalSubscription as the first one didn t correctly managed the orderly nature of swapping subscriptions an unfortunate thread scheduling could have swapped in an older subscription before a new subscription In my opinion the Scheduler and its implementations should use Runnable as the internal unit of work instead of Action0 Since the Executor s require Runnable anyway less wrapping means less memory and better performance The Scheduler interface can retain the Action0 overloads but no other implementation should need to deal with them','RxJava pull requests #582 https netflixoss ci cloudbees com job RxJava pull requests 582 SUCCESS This pull request looks good This seems like it s a bug inside current Schedulers as recursion should work without memory leaks Here is the histogram showing the leak JVM version is 24 45 b08 Iterating over heap This may take a while Object Histogram num #instances #bytes Class description 1 1488649 83360752 java lang Object 2 2976652 47626432 java util concurrent atomic AtomicReference 3 1488325 47626400 rx schedulers DiscardableAction 4 1488324 47626368 java util concurrent FutureTask 5 1488330 35719920 java util ArrayList 6 1488324 35719776 rx subscriptions CompositeSubscription State 7 1488456 23815296 java lang Integer 8 1488326 23813216 java util concurrent atomic AtomicBoolean 9 1488326 23813216 rx operators SafeObservableSubscription 10 1488325 23813200 rx subscriptions CompositeSubscription 11 1488324 23813184 rx subscriptions Subscriptions 3 12 7036 905920 MethodKlass 13 7036 813896 ConstMethodKlass 14 499 567648 ConstantPoolKlass 15 499 348832 InstanceKlassKlass 16 447 339168 ConstantPoolCacheKlass 17 2051 148592 char 18 702 106856 byte 19 569 68872 java lang Class 20 830 52568 System ObjArray 21 2027 48648 java lang String 22 769 44128 short 23 124 40800 MethodDataKlass 24 785 31400 java util TreeMap Entry 25 53 28408 ObjArrayKlassKlass 26 138 9936 java lang reflect Field 27 218 6976 java util concurrent ConcurrentHashMap HashEntry 28 192 6568 java lang String 29 138 4416 java util HashMap Entry 30 8 4288 TypeArrayKlassKlass 31 178 4272 java util LinkedList Node 32 116 3712 java util Hashtable Entry 33 97 3104 java util LinkedList 34 193 3088 java lang Object 35 46 2944 java net URL 36 30 2848 java util HashMap Entry 37 66 2704 java util concurrent ConcurrentHashMap HashEntry 38 66 2640 java util concurrent ConcurrentHashMap Segment 39 72 2304 java util concurrent locks ReentrantLock NonfairSync 40 11 2288 KlassKlass 41 38 1824 sun util locale LocaleObjectCache CacheEntry 42 36 1728 java util HashMap 43 5 1696 int 44 36 1440 java util LinkedHashMap Entry 45 18 1296 java lang reflect Constructor 46 16 1280 java util WeakHashMap Entry 47 1 1040 java lang Integer 48 26 1040 java lang ref SoftReference 49 6 992 java util Hashtable Entry 50 16 896 java util WeakHashMap 51 21 840 java lang ref Finalizer I will dig in to where this leak is occurring We should not need new subscription or scheduler types to solve this otherwise anything using schedulers is broken Code in Java 6 for proving the leak as modified from the original Java 8 bug report java Generates an observable sequence by iterating a state from an initial state until the condition returns false public static TState R OnSubscribeFunc R generate final TState initialState final Func1 TState Boolean condition final Func1 TState TState iterate final Func1 TState R resultSelector final Scheduler scheduler return new OnSubscribeFunc R @Override public Subscription onSubscribe final Observer super R observer return scheduler schedule initialState new Func2 Scheduler TState Subscription @Override public Subscription call Scheduler s TState state boolean hasNext try hasNext condition call state catch Throwable t observer onError t return Subscriptions empty if hasNext R result try result resultSelector call state catch Throwable t observer onError t return Subscriptions empty observer onNext result TState nextState try nextState iterate call state catch Throwable t observer onError t return Subscriptions empty return s schedule nextState this observer onCompleted return Subscriptions empty public static void main String args throws Exception Thread sleep 10000 Observable Integer source Observable create generate 0 new Func1 Integer Boolean @Override public Boolean call Integer t1 return true new Func1 Integer Integer @Override public Integer call Integer t return t 1 new Func1 Integer Integer @Override public Integer call Integer t return t Schedulers newThread final CountDownLatch latch new CountDownLatch 1 Subscription s source subscribe new Observer Integer @Override public void onCompleted latch countDown @Override public void onError Throwable e e printStackTrace latch countDown @Override public void onNext Integer v if v 100000 0 System out println v if v 10000000 latch countDown latch await System out println Wait done s unsubscribe System out println Unsubscribe done @headinthebox will try in Net This memory leak is fixed in https github com Netflix RxJava pull 712',RxJava,true,false,false
24653304,'Refactored BoundedReplaySubject concurrency enhancements','Refactored the formerly rx operators OperationReplay CustomReplaySubject into rx subjects BoundedReplaySubject with all sorts of create factory methods Also mentioned in the forum https groups google com forum # topic rxjava SqwS5kz lRA Changed to the concurrency logic The former Lock is now split into a ReadWriteLock In write phase the buffer is updated in read phase the observers are notified New subscribers will enter the read phase so replaying can be run in parallel with the already subscribed observers However the source side of the subject is still blocked while replaying I can t imagine any non convoluted way to make this less blocking or lock free','RxJava pull requests #583 https netflixoss ci cloudbees com job RxJava pull requests 583 SUCCESS This pull request looks good I found a concurrency bug in the read write refactorings and PR #651 enhancements should appear in here as well',RxJava,true,false,false
24675193,'Fatal Exception java lang RuntimeException java lang RuntimeException in SafeObserver','I get Fatal Exception java lang RuntimeException java lang RuntimeException in SafeObserver in cases when both onError and onNext will through exception inside observable1 subscribe new Observer Configs @Override public void onCompleted @Override public void onError Throwable e throw new UnknownError Ooooppsss @Override public void onNext Configs args throw new UnknownError Ooooppsss Stack trace java lang RuntimeException Error occurred when trying to propagate error to Observer onError at rx operators SafeObserver onError SafeObserver java 109 at rx operators SafeObserver onNext SafeObserver java 125 at rx Notification accept Notification java 121 at rx operators OperationObserveOn ObserveOn 2 call OperationObserveOn java 121 at rx operators OperationObserveOn ObserveOn 2 call OperationObserveOn java 116 at rx Scheduler 3 call Scheduler java 163 at rx Scheduler 3 call Scheduler java 159 at rx android concurrency HandlerThreadScheduler 1 run HandlerThreadScheduler java 82 at android os Handler handleCallback Handler java 733 at android os Handler dispatchMessage Handler java 95 at android os Looper loop Looper java 136 at android app ActivityThread main ActivityThread java 5017 at java lang reflect Method invokeNative Native Method at java lang reflect Method invoke Method java 515 at com android internal os ZygoteInit MethodAndArgsCaller run ZygoteInit java 779 at com android internal os ZygoteInit main ZygoteInit java 595 at dalvik system NativeStart main Native Method Caused by rx util CompositeException UnknownError Ooooppsss UnknownError Ooooppsss at rx operators SafeObserver onError SafeObserver java 109 at rx operators SafeObserver onNext SafeObserver java 125 at rx Notification accept Notification java 121 at rx operators OperationObserveOn ObserveOn 2 call OperationObserveOn java 121 at rx operators OperationObserveOn ObserveOn 2 call OperationObserveOn java 116 at rx Scheduler 3 call Scheduler java 163 at rx Scheduler 3 call Scheduler java 159 at rx android concurrency HandlerThreadScheduler 1 run HandlerThreadScheduler java 82 at android os Handler handleCallback Handler java 733 at android os Handler dispatchMessage Handler java 95 at android os Looper loop Looper java 136 at android app ActivityThread main ActivityThread java 5017 at java lang reflect Method invokeNative Native Method at java lang reflect Method invoke Method java 515 at com android internal os ZygoteInit MethodAndArgsCaller run ZygoteInit java 779 at com android internal os ZygoteInit main ZygoteInit java 595 at dalvik system NativeStart main Native Method','Issue is very typical for Android Assume that we do some work with UI in onNext and onError This work will fail with exception if activity was closed by the time async operation is completed So we need to ensure that all exceptions in onError and onNext will be suppressed If you want to suppress everything then you need to make sure you don t throw from within onError or an onErrorResumeNext operator You can swallow the errors if you want but RxJava won t swallow them automatically @benjchristensen got it thanks',RxJava,false,false,false
24676813,'Subjects Refactor Non Blocking Common Abstraction Performance','These changes evolved out of reviewing pull request https github com Netflix RxJava pull 605 and code reviewing master branch with @headinthebox and validating functionality against Net I also spent some time to figure out a non blocking design that I believe is working The results for ReplaySubject is that it performs faster than what is currently in master and does not block in almost all cases I have not yet perf tested the other 3 Subjects Common logic composed inside SubjectSubscriptionManager used by all 4 Subjects ReplaySubject does not block while replaying to new subscribers Added unit tests and fixed behavior while reviewing with @headinthebox compared to Rx Net Uses mostly non blocking approach I believe it s all correct unit and long running tests have been used to prove it The tests found concurrency problems during development and became stable once I got the design correct As with all concurrent code I may be missing something The only place it blocks is if a new Observer subscribes completes replay and onComplete onError are in process It will wait for those to complete before applying the terminal state on itself As for performance for relative comparison my machine gets these numbers for the master branch ArrayList with raw values synchronized access Run 10 11 993 341 ops sec Run 11 11 719 523 ops sec Run 12 11 965 214 ops sec Run 13 11 814 730 ops sec Run 14 11 947 459 ops sec This commit gets these numbers ArrayList with raw values non blocking no synchronization Run 10 16 069 678 ops sec Run 11 15 954 688 ops sec Run 12 16 158 874 ops sec Run 13 16 209 504 ops sec Run 14 16 151 174 ops sec I m curious about adding bounded support and using a circular array rather than ArrayList and seeing if it performs better The performance tests are inside SubjectPerformanceTests and inspired by tests done in the non blocking code workshop with Martin Thompson Some of the code is not as elegant as I d like but was done for performance reasons For example I had a much more elegant version using a simple linked list but it had horrible performance Another example is that using Notification to wrap every onNext so we have a single data structure is very inefficient so it maintains T without wrapping and then conditional logic to check for terminal state These and other things have been determined while doing perf tests during development and I have consciously moved towards performance rather than the most elegant code I d appreciate feedback on concurrency problems if any exist or ways of getting more performance out while achieving the same functional requirements','RxJava pull requests #584 https netflixoss ci cloudbees com job RxJava pull requests 584 SUCCESS This pull request looks good RxJava pull requests #591 https netflixoss ci cloudbees com job RxJava pull requests 591 SUCCESS This pull request looks good',RxJava,true,false,false
24681528,'Subjects fixes performance improvements','Based on PR #651 Improvements upon Ben s excellent work Original performance for me was 1 662 152 ops sec on average Storing subscriptions and observers in arrays rather than in a Map inside SubjectSubscriptionManager This adds 2 340 000 ops sec on average total 4 000 000 ops sec so far SafeObserver uses a volatile for the actual Observer which is swapped to a nopObserver if a terminal case occurs This avoids an atomic get and if statement and adds a 100 000 ops second on average total 4 100 000 ops sec so far I suggest adding a create option to set the initial buffer size not done here which would reduce the number of array resizes With 2048 as a sweet spot on my machine this adds 1 100 000 ops second total 5 200 000 so far Bounded version We have a boundable ReplaySubject in main named CustomReplaySubject and PR #649 to improve a bit upon its performance It might benefit from the changes above as well It would be a more tricky implementation in terms of the replay operation since the buffer would be in constant virtual index motion including its start and end so observers would need to atomically get a value from it whose index could get below the virtual start index of the buffer Will think about this','RxJava pull requests #585 https netflixoss ci cloudbees com job RxJava pull requests 585 SUCCESS This pull request looks good RxJava pull requests #586 https netflixoss ci cloudbees com job RxJava pull requests 586 SUCCESS This pull request looks good Wow nice performance improvements ArrayList with raw values non blocking no synchronization Run 10 16 069 678 ops sec Run 11 15 954 688 ops sec Run 12 16 158 874 ops sec Run 13 16 209 504 ops sec Run 14 16 151 174 ops sec Map to Arrays and other enhancements from https github com Netflix RxJava pull 652 Run 10 54 231 405 ops sec Run 11 56 239 490 ops sec Run 12 55 424 384 ops sec Run 13 56 370 421 ops sec Run 14 56 617 767 ops sec I m going to revert the SafeObserver changes as they are trivial improvements at best Old SafeObserver Run 0 3 751 704 ops sec Run 1 34 619 086 ops sec Run 2 30 483 715 ops sec Run 3 27 746 023 ops sec Run 4 54 078 608 ops sec Run 5 55 107 045 ops sec Run 6 53 935 396 ops sec Run 7 54 947 168 ops sec Run 8 57 024 246 ops sec Run 9 55 059 712 ops sec Run 10 56 904 832 ops sec Run 11 55 919 967 ops sec Run 12 55 076 087 ops sec Run 13 55 066 685 ops sec Run 14 55 025 476 ops sec Run 0 3 839 266 ops sec Run 1 34 115 371 ops sec Run 2 29 675 175 ops sec Run 3 28 677 042 ops sec Run 4 55 405 652 ops sec Run 5 55 260 220 ops sec Run 6 55 147 464 ops sec Run 7 54 261 126 ops sec Run 8 53 941 505 ops sec Run 9 54 324 501 ops sec Run 10 55 125 576 ops sec Run 11 56 102 870 ops sec Run 12 55 061 834 ops sec Run 13 55 476 039 ops sec Run 14 55 073 054 ops sec Run 0 3 704 536 ops sec Run 1 34 694 514 ops sec Run 2 30 778 227 ops sec Run 3 28 441 329 ops sec Run 4 54 116 946 ops sec Run 5 55 204 699 ops sec Run 6 54 859 450 ops sec Run 7 55 214 757 ops sec Run 8 55 005 500 ops sec Run 9 55 339 118 ops sec Run 10 55 501 903 ops sec Run 11 55 074 570 ops sec Run 12 55 102 187 ops sec Run 13 55 756 278 ops sec Run 14 54 768 411 ops sec New SafeObserver Run 0 3 983 308 ops sec Run 1 34 767 250 ops sec Run 2 30 806 957 ops sec Run 3 29 855 113 ops sec Run 4 57 451 453 ops sec Run 5 55 515 152 ops sec Run 6 56 086 822 ops sec Run 7 56 295 529 ops sec Run 8 55 371 905 ops sec Run 9 55 816 653 ops sec Run 10 55 793 296 ops sec Run 11 56 011 426 ops sec Run 12 55 568 521 ops sec Run 13 55 396 137 ops sec Run 14 56 353 267 ops sec Run 0 3 933 367 ops sec Run 1 34 498 342 ops sec Run 2 30 233 584 ops sec Run 3 29 179 785 ops sec Run 4 55 761 874 ops sec Run 5 55 948 124 ops sec Run 6 55 264 801 ops sec Run 7 56 267 020 ops sec Run 8 57 474 567 ops sec Run 9 55 879 657 ops sec Run 10 55 998 880 ops sec Run 11 56 044 073 ops sec Run 12 55 498 515 ops sec Run 13 56 204 720 ops sec Run 14 55 845 954 ops sec Run 0 3 981 914 ops sec Run 1 34 160 822 ops sec Run 2 30 873 631 ops sec Run 3 29 135 067 ops sec Run 4 55 845 330 ops sec Run 5 55 101 883 ops sec Run 6 55 724 276 ops sec Run 7 56 085 564 ops sec Run 8 55 639 942 ops sec Run 9 56 464 955 ops sec Run 10 55 453 275 ops sec Run 11 56 115 463 ops sec Run 12 56 509 945 ops sec Run 13 53 863 348 ops sec Run 14 55 866 858 ops sec The rest of the changes are awesome thank you',RxJava,true,false,false
24687279,'More operators overloads','Rx NET 2 2 2 Aggregate aggregate seed accumulator resultselector Average average Func1 T Number valueselector Buffer Buffer Observable U bufferBoundaries CreateAsync Create Func1 Observer R Task Create Func1 Observer R Task Action Create Func1 Observer R Task IDisposable Create Func2 Observer R CancellationToken Task Create Func2 Observer R CancellationToken Task Action Create Func2 Observer R CancellationToken Task IDisposable Delay Delay Func1 T Observable TDelay Delay Func0 Observable D1 subscriptionDelay Func1 T Observable D2 itemDelay Empty Empty T witness Empty Scheduler T witness Never Never T witness Publish publish Func1 Observable TSource Observable TResult sel publish TSource initialValue publish Func1 Observable TSource Observable TResult sel TSource initialValue PublishLast publishLast Func1 Observable TSource Observable TResult sel SelectMany flatMap SelectMany Func2 T Integer Observable R SelectMany Func1 T Task R SelectMany Func2 T Integer Task R SelectMany Func2 T CancellationToken Task R SelectMany Func3 T Integer CancellationTokenk Task R SelectMany Func1 T Observable U collection Func2 T U R resultSel SelectMany Func1 T Integer Observable U collection Func4 T Integer U Integr R resultSel SelectMany Func1 T Task U Func2 T U R SelectMany Func2 T Integer Task U Func2 T Integer U R SelectMany Func2 T CT Task U Func2 T U R SelectMany Func3 T Integer CT Task U Func2 T Integer U R SelectMany Func1 T Observable R onNext Func1 Exception Observable R onError Func0 Observable R onCompleted SelectMany Func2 T Integer Observable R onNext Func1 Exception Observable R onError Func0 Observable R onCompleted SelectMany Func1 T IEnumerable R SelectMany Func2 T Integer IEnumerable R SelectMany Func2 T IEnumerable U Func2 T U R SelectMany Func3 T Integer IEnumerable U Func4 T Integer U Integer R Skip Skip Timespan Skip Timespan Scheduler SkipLast SkipLast Timespan SkipLast Timespan Scheduler Sum sum Func1 T Number valueselector Take Take Timespan Take Timespan Scheduler TakeLast TakeLast Timespan TakeLast Timespan Scheduler TakeLast Timespan Scheduler duration Scheduler drain Throttle debounce Throttle Func1 T Observable TThrottleDuration Timeout Timeout Func1 T Observable TTimeout Timeout Func1 T Observable TTimeout Observable T other Timeout Func0 Observable TFirstTimeout Func1 T Observable TTimeout Timeout Func0 Observable TFirstTimeout Func1 T Observable TTimeout Observable T other Throw error error Throwable t T witness error Throwable t Scheduler T witness Using async Using Func1 CancellationToken Task TResource Func2 TResource CancellationToken Task Observable T Where Where Func2 T Integer Boolean Window Window Observable U windowBoundaries Zip Zip IEnumerable Observable S sources Func1 IList S R selector Zip Iterable U other Func2 T U R result Potential Java specific operators overloads just Func0 R factory return the value of the factory for the subscriber In one of my PRs lock Lock lock or synchronize Lock lock to support j u c Locks for synchronization Using with java io Closeable using Func0 C Func1 C Observable T usingFuture Func1 BooleanSubscription Future C Func2 C BooleanSubscription Future Observable T','Reviewed by @headinthebox and I for things that should not be added and used strikethrough so they are still on the list but marked to not work on lock Lock lock or synchronize Lock lock to support j u c Locks for synchronization What is a use case when this would ever be needed @headinthebox mentioned that it s not really used in Rx Net so likely not worth us adding Okay no worries I won t start working on the remaining ones for at least a week Closing this and ignoring just Func0 R factory',RxJava,false,false,false
24689457,'Empty Error and Never overloads with type witness','Witness variants for #653','RxJava pull requests #587 https netflixoss ci cloudbees com job RxJava pull requests 587 SUCCESS This pull request looks good Is it necessary to have such overloads I just think it s wired that passing an unused var I think this witness trick is common in C# but I ve never seen it in Java so I would not add these overloads It depends on how many times you write the following pattern java import static rx Observable concat from 1 2 3 empty incompatible types Object vs Integer in Java 8 concat from 1 2 3 empty 4 concat from 1 2 3 Observable Integer empty merge just 4 error new Exception incompatible types Object vs Integer in Java 8 merge just 4 error new Exception 5 merge just 4 Observable Integer error new Exception Instead of adding overloads everywhere we have the cast operator that solves this issue so a user can do either of these java Observable String s Observable empty cast String class take 1 Observable String s Observable String empty take 1 Even if we were to use the witness patter it would be better to take Class T rather than T so that we don t have to pass random values in java Observable String s Observable empty String class take 1 This is equally elegant but requires overloads for all similar use cases In Net this is essential because you cannot write the type of an anonymous type as per @headinthebox and this isn t a problem in Java',RxJava,true,false,false
24691273,'Skip SkipLast Take TakeLast with time','Issue #653','RxJava pull requests #588 https netflixoss ci cloudbees com job RxJava pull requests 588 SUCCESS This pull request looks good RxJava pull requests #589 https netflixoss ci cloudbees com job RxJava pull requests 589 SUCCESS This pull request looks good RxJava pull requests #592 https netflixoss ci cloudbees com job RxJava pull requests 592 SUCCESS This pull request looks good What is the reason for the drain concept I know it exists in Net but I don t believe we need this in Java I can imagine concern with not wanting a Timer thread to do long running work but we don t have that issue with our Scheduler implementations We always have the time aspects of our schedulers running on separate threads such as GenericScheduledExecutorService in the case of NewThreadScheduler so we don t block time events I think it was added to avoid scheduling onNext calls individually but rather emit everything in one go I haven t found any other places where this kind of overload was present in Rx NET Should I remove that overload Are the other variants okay to stay I ll resubmit this since it conflicts with master anyway',RxJava,true,false,false
24695148,'Scheduler to that forces observable executed only when Fragment Activity is resumed','Common problem in Android is too force all async operation that touch UI to be stopped when activity fragment is paused I think Rx Scheduler is great candidate for that public class AndroidComponentScheduler private static final Handler MAIN_THREAD_HANDLER new Handler Looper getMainLooper public static Scheduler create Fragment fragment return new FragmentScheduler fragment public static class FragmentScheduler extends Scheduler private Fragment fragment public FragmentScheduler Fragment fragment this fragment fragment @Override public T Subscription schedule T state Func2 super Scheduler super T extends Subscription action return schedule state action 0L TimeUnit MILLISECONDS @Override public T Subscription schedule final T state final Func2 super Scheduler super T extends Subscription action long delayTime TimeUnit unit final SafeObservableSubscription subscription new SafeObservableSubscription final Scheduler _scheduler this MAIN_THREAD_HANDLER postDelayed new Runnable @Override public void run if fragment null fragment isResumed subscription wrap action call _scheduler state else fragment null unit toMillis delayTime return subscription @benjchristensen @mttkay What s your opinion I saw class called AndroidObservable in rxjava contrib but its usage is very complicated and also it requires manual unsubscribe onDestroy','That s an interesting idea Could you sketch a typical flow of how you d schedule an action that way I don t fully understand how you d use this In particular I m wondering 1 Does the fragment schedule itself or who would be responsible for that 2 where would you see the scheduler to live In the host activity 3 It looks as if once scheduled only one attempt is made to execute the action If the fragment is not resumed will another attempt be made once it gets resumed 4 If the fragment is resumed and the action fires but I detach the fragment before the action returns how do you deal with that One thing we should probably do as well is release the fragment reference when the client unsubscribes Currently the reference lives as long as the delay as far as I can tell Should look like this public void onButton1Click View view api observeOn AndroidComponentSchedulers create this subscribe new Observer MyResult public void onNext MyResult result Scheduler will be used like MainThreadScheduler but in addition to execution on UI thread it will guarantee execution while component is resumed possible other event like not yet detached 1 Does the fragment schedule itself or who would be responsible for that I think it should be normal main thread scheduler that uses Handler#postDelayed but it will also prevent execution when android component is not accessible 2 where would you see the scheduler to live In the host activity New instance of scheduler is created for each operation 3 It looks as if once scheduled only one attempt is made to execute the action If the fragment is not resumed will another attempt be made once it gets resumed That would be great to try attempt execute operation once fragment is resumed but I think it will introduce to much complexity You don t know how long you app will be inactive Also state of data could be no longer actual So my suggestion is to ignore it Potential problem i see that you probably want to execute code that not related to UI even if app is in background In this case that code will be also dismissed Example onNext User user non ui logic userSession setUser user ui related logic which cannot be executed without resumed fragment ProgressDialog dismiss 4 If the fragment is resumed and the action fires but I detach the fragment before the action returns how do you deal with that According to implementation that I mentioned in my first post if your fragment will be resumed before operation is complete its reference will be alive But if operation completed in background and you caught that your fragment is not resumed you will remove reference to it One thing we should probably do as well is release the fragment reference when the client unsubscribes Currently the reference lives as long as the delay as far as I can tell Good catch But how we can detect unsubscribe in scheduler But how we can detect unsubscribe in scheduler Schedulers have nothing to do with unsubscribe I don t know enough about Android to comment intelligently on this Can you provide a use case that doesn t assume understanding of what Fragments and Activities are in Android and perhaps I can then help @benjchristensen Primary idea is that you want to prevent execution of onNext onError onComplete when app was paused Example Imagine you make request about nearby restaurants to show them on the map Before request was completed you paused app As soon as request is completed you trying to access map to update markers which will cause application crush since app is paused and map cannot be accessed @lexer Is this discussion something that needs to be revived or can we close this',RxJava,false,false,false
24717848,'Operations Aggregate Average and Sum with selector','Issue #653 Remarks I know we can combine ops to get one of the new aggregate variant but I think it might be worth having a direct version which avoids nesting several layers of Observables Observers and Subscriptions The averageInteger and sumInteger and the other types are handy if we want to use chained operation invocations with less overhead java Observable from a bb ccc sumInteger s s length toBlockingObservable single instead of java Observable sumIntegers Observable from a bb ccc map s s length toBlockingObservable single','RxJava pull requests #590 https netflixoss ci cloudbees com job RxJava pull requests 590 SUCCESS This pull request looks good This establishes or strengthens a precedent of adding a large number of helper methods for very specific cases to the already massive Observable so I d like to explore one of two routes 1 Move mathematical operators to a separate Observable in rx observable NumericalObservable or something like that 2 Move them into a contrib module like https github com Netflix RxJava blob master rxjava contrib rxjava string src main java rx observables StringObservable java I d go for NumericalObservable on this one as it is primarily useful out of box whereas Futures may go into contrib',RxJava,true,false,false
24718687,'BehaviorSubject Race Condition','Need to investigate the BehaviorSubject as it likely has the same problem as Rx Net as reported here http twistedoakstudios com blog Post8424_deadlocks in practice dont hold locks while notifying Note that Subjects were just re implemented but kept the same behavior and for the BehaviorSubject the race between returning the current value and subscribing for subsequent values appears to be wrong Use case onNext 1 2 3 4 5 6 7 8 9 Observer subscribe between 3 4 should receive 3 4 5 6 7 8 9 The likely bug is that in a race it could receive 3 6 7 8 9','There are a few some missing suggestions that I didn t have in my PR which also involves BehaviorSubject I ll take a look at this as well The queue drain approach can be adapted to also ensure you don t miss notifications All you have to do is queue the subscription as well Queue drain is a fully general synchronization mechanism akin to using an actor Note that if you do this the initial value may not arrive immediately if the behavior subject is being touched on another thread but it can be fixed by introducing a second queue specific to the subscription that was initialized with the latest value while atomically subscribing So a no deadlock no reorder no thread hopping for initial value subscription would look like initialValueSent false missedDrainCount 0 create drain queue Q for subscription sync this add observer to enqueue new value onto Q sync Q other threads must not push initial value if initialValueSent missedDrainCount tryDrain Q enqueue current value onto Q forward value to caller before returning and perhaps some later values too tryDrain Q allow other threads to forward future values sync Q initialValueSent true in case observers were enqueueing while we set the flag pretty sure reading missedDrainCount is safe to touch without locking now this can be done without the loop but requires modifying the Q to drain N while missedDrainCount 0 tryDrain Q I think that s right just off the top of my head though If you re willing to allow the initial value to thread hop it s a lot simpler of course enqueue add observer to enqueue send latest value tryDrain tryDrain assuming you re using the queue as your only synchronization mechanism If you re also using locks you probably need to lock around the enqueues I think this is still an unsolved problem Do we still want to put effort into this I was thinking about trying to solve it similar to the groupBy solution but haven t spent the time to determine if it can be made to work I ve implemented a potential fix here https github com akarnokd RxJava blob BehaviorSubjectTimeGapFix rxjava core src main java rx subjects BehaviorSubject java but can t create a PR right now due to a github 500 error A simple publish benchmark for PublishSubject is 83 MOps s BehaviorSubject new 47MOps s BehaviorSubject master is 48 MOps sec Fix just merged',RxJava,false,false,false
24721317,'Missing fixes from the subject rewrite','Two small changes Prevent overwriting the terminal notification in BehaviorSubject so new subscribers to a terminated subject can see the error completion Call Thread currentThread interrupt if the terminationLatch await throws','RxJava pull requests #593 https netflixoss ci cloudbees com job RxJava pull requests 593 SUCCESS This pull request looks good Thanks @akarnokd',RxJava,true,false,false
24722219,'Hopefully fixed missing notifications if part of the subscription is del','ayed Fix suggestion to issue #658 Basically it is a spin lock between onNext and the subscription It has the additional effect of locking out concurrent subscriptions but these would most likely clash on the state swap anyway','RxJava pull requests #594 https netflixoss ci cloudbees com job RxJava pull requests 594 SUCCESS This pull request looks good Added test case to illustrate the underlying issue If I comment out the new mutating part it will fail typically with values 3 7 8 9 3 4 5 6 7 8 9 RxJava pull requests #595 https netflixoss ci cloudbees com job RxJava pull requests 595 SUCCESS This pull request looks good I ll have to spend more time on this one later to think through Okay',RxJava,true,false,false
24723244,'Subscriptions Rewrite','Refactor rewrite of Subscriptions by @headinthebox and myself after reviewing the various different implementations We removed SingleAssignmentSubscription while trying to reduce surface area and simplify code Moved to a non blocking state machine model that does not lock or busy spin during mutation states','RxJava pull requests #596 https netflixoss ci cloudbees com job RxJava pull requests 596 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
24724719,'One single global stateless OnCompleted Notification object','Instead of creating a new OnCompleted Notification object every time we need one we could have one global instance accessible by a factory method on Notification suggested by @akarnokd here https github com Netflix RxJava pull 651#discussion_r8519794 Advantages 1 Better performance since fewer object garbage creation 2 Scala adaptor could have an object OnCompleted instead of a class OnCompleted which has to wrap a Java OnCompleted object Maybe we could also get 2 without any changes in Java but then we might need to define clearly if the toScalaNotification toJavaNotification methods have to preserve object identity or only equals','Does this really make much of a difference when the onNext notification is still needed and will overwhelm the number of onCompleted notifications when an Observable emits more than 1 onNext In general we probably need to move away from or be cautious about the use of materialize and Notification for internal operators as the cost is quite high as shown by performance work done on the ReplaySubject https github com Netflix RxJava commit a144b0e20a44a4d84ec58ccf2d213672a4aacd75 and https github com Netflix RxJava commit 8425eff1d1ae7bdf63ed454518cc8f460320f1d9 The reason why I opened this is that I want to make OnCompleted a singleton object in the Scala adaptor This is possible with the current Java Notifications but before I do it I want to check if there will be changes in the Java Notifications so that I can avoid doing the work twice I think there might be changes in the Java Notifications because I see some issues 1 Creating a new Notification object for each OnCompleted requires more memory than having one single OnCompleted object 2 You can t make Notifications for Observable Exception because new Notification new Exception is ambiguous Should it be an OnNext or an OnError Notification 3 IMO a library should never expose constructors but always keep them private and provide factory methods since it gives the library implementors more flexibility the issue we re discussing here is an example for this 4 In the Scala adaptor we want a single object OnCompleted because this is exposed to the users when they want to do pattern matching so it would be nice to have the same structure in Java There s a non breaking way to solve these issues 1 As @benjchristensen points out this won t make much of a difference when the onNext notification is still needed and will overwhelm the number of onCompleted notifications when an Observable emits more than 1 onNext 2 Don t make Observables of exceptions because that confuses everyone 3 Disagree with me because I wrote IMO 4 It s enough to have toJavaXxx toScalaXxx myJavaXxx equals myJavaXxx we don t need to guarantee that toJavaXxx toScalaXxx myJavaXxx myJavaXxx where is the Java so it s possible to have a singleton OnCompleted object in Scala and many OnCompleted instances in Java And there s also a breaking but clean and nice way to solve these issues Remove or deprecate the constructors and replace them by factory methods I m for the second way but since both ways are fine for the Scala adaptor I won t insist more than this and let you decide And once it s decided I ll make the changes in the Scala adaptor I agree with Ben It does not seem to matter much perf wise to special case Notification OnCompleted also since whenever you use Notifications you are already paying a hug interpretative overhead in doing case analysis But maybe I am missing something That said in Scala Notification OnCompleted is already using a factory method so if you really want to use a singleton object you can do that in Scala Just tried to make a static OnCompletedNotification but can t do it as it uses generics and must have a type T as the signature is Notification T I don t see how to make a static representation even if we want to while having it be type safe To make it work without casting we would need a Bottom type such that we can say OnCompletedNotification extends Notification Bottom and a way to mark Notification as covariant Since Java doesn t have this we could use one Notification instance which serves as the global OnCompleted instead of creating a separate class for it This globalOnCompleted would have type Notification Void and we would cast it to Notification T but for users everything would be typesafe Done could you close the issue',RxJava,false,false,false
24725674,'BO collect and BO chunkify','Refactored BO collect and BO chunkify out of PR #636 Mentioned in issue #634','RxJava pull requests #597 https netflixoss ci cloudbees com job RxJava pull requests 597 FAILURE Looks like there s a problem with this pull request There is a compilation issue with master in file OperationTakeLast due to the removal of SingleAssignmentSubscription RxJava pull requests #598 https netflixoss ci cloudbees com job RxJava pull requests 598 FAILURE Looks like there s a problem with this pull request This looks good though we have discovered that Java 8 Stream has a collect interface and we re considering whether we should change to match it on both the Observable and BlockingObservable versions instead of exactly matching Rx Net in this case cc @headinthebox for API review Take a look at the collect operator here https github com Netflix RxJava commit fd6dd169e6e119f72d65042f3adb947623ae2766 Closing this out as it will need to be recreated and discussed again @akarnokd and @headinthebox please coordinate',RxJava,true,false,false
24726763,'Operation AsObservable','Split from PR #641','RxJava pull requests #599 https netflixoss ci cloudbees com job RxJava pull requests 599 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
24727268,'GroupByUntil with maxGroups','Split from #641 Purpose limit the active groups to a certain number If new group is opened the oldest group is closed','RxJava pull requests #600 https netflixoss ci cloudbees com job RxJava pull requests 600 FAILURE Looks like there s a problem with this pull request Why not remove the one that got a notification last Not sure if this specific behavior particularly useful I don t know I think it matches Rx NET s signature but I can t really look into ConcurrentDictionary It is possible the capacity is just for the initial capacity of the map and has nothing to do with limiting the groups @akarnokd Since we already have groupByUntil in Observable what is the reason for adding more overloads with maxGroups Where is this use case and signature coming from Closing based on discussion above I guess this PR can be ignored',RxJava,true,false,false
24728899,'PRs failing','Due to refactored subscriptions OperationTakeLast I m about to submit a PR for this Scala override attempt of the now final class C work RxJava language adaptors rxjava scala src main scala rx lang scala subscriptions BooleanSubscription scala 30 error illegal inheritance from final class BooleanSubscription override val asJavaSubscription rx subscriptions BooleanSubscription new rx subscriptions BooleanSubscription Is someone working on this latter','I ll fix the Scala one Thanks @headinthebox The Scala compiler isn t that nice with me as with you Fixed',RxJava,false,false,false
24729305,'Operators Skip SkipLast Take with time','Rebased version without the drain scheduler variant Fixes issue mentioned in #666 as well','RxJava pull requests #601 https netflixoss ci cloudbees com job RxJava pull requests 601 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
24730127,'Operator forIterable 2','Split from #636 This operator behaves differently than concat Iterable It allows projecting a potentially infinite sequence onto Observables concatenated one after each other The input Iterable sequence is not traversed upfront like concat Iterable and concat Observable would do','RxJava pull requests #602 https netflixoss ci cloudbees com job RxJava pull requests 602 FAILURE Looks like there s a problem with this pull request I believe what you want is accomplished with concatMap that was recently added java Observable Integer result Observable from keys concatMap new Func1 Integer Observable Integer @Override public Observable Integer call Integer t1 return Observable from 1 2 3 subscribeOn Schedulers currentThread Here is a unit test from your code converted to this and it passes java @Test public void testForIterableLongSequence int n 250 List Integer keys new ArrayList Integer n List Integer expected new ArrayList Integer 3 n for int i 1 i n i keys add n for int j 1 j 3 j expected add j Observable Integer result Observable from keys concatMap new Func1 Integer Observable Integer @Override public Observable Integer call Integer t1 return Observable from 1 2 3 subscribeOn Schedulers currentThread Observer Object o mock Observer class InOrder inOrder inOrder o result subscribe o for Integer i expected inOrder verify o times 1 onNext i inOrder verify o times 1 onCompleted inOrder verifyNoMoreInteractions verify o never onError any Throwable class True Since the newer ConcatMap does the same thing this PR can be skipped',RxJava,true,false,false
24731155,'Javadoc improvements','diagrams for switchCase doWhile whileDo ifThen delaySubscription single singleOrDefault takeFirst takeLast and variant forms of these standardizing javadoc comment formatting standardizing nomenclature','RxJava pull requests #603 https netflixoss ci cloudbees com job RxJava pull requests 603 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
24735330,'API Design Tweaks','Some changes resulting from review with @headinthebox and @jhusain General principles pursued are to simplify the mental model and surface area of the API','RxJava pull requests #604 https netflixoss ci cloudbees com job RxJava pull requests 604 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
24735538,'API Design Review Aggregate and Math Functions','Several operators on rx Observable are intended for aggregation and potentially dangerous on long running or infinite Observables Similar to how blocking operators were moved to BlockingObservable it has been suggested that aggregation operators be collected into an AggregateObservable or something similarly named This could be further broken into AggregateObservable and NumberObservable for ones specifically operating on numbers as the type would be extends Number rather than T Some of these operators include average max add maxBy keySelector min add minBy sum contains count longCount toList reduce cc @headinthebox and @jhusain','Average min max and sum went into rxjava math Do we want to move the rest too From the rest I would rarely want to count the elements in a stream Agreed we should not lead people towards reducing streams to single values We still have contains count longCount toList reduce @headinthebox @akarnokd Should we leave these It seems that toList and reduce would be pretty jarring to remove People get what they ask for on those The contains and count are trivial and don t bother me being in the API I suggest we leave these 4 Except for ToList which I do often use I m happy to remove the others but happy to keep them as well I think we just leave them They don t bother me Closing this out',RxJava,false,false,false
24735548,'API Design Review DelaySubscription','What is the delaySubscription operator for and should we delete it cc @headinthebox and @jhusain','@headinthebox Should we keep this This one comes from NET I never use it myself I think it is mostly useful for testing where you can delay the subscription to fuzz Skipping it then',RxJava,false,false,false
24735582,'API Design Review Join','Should the rx join behavior remain inside rx Observable or should there be a separate home for this functionality In short is the utility of join functionality common enough to have on rx Observable or should it be on something else such as rx join Joins or rx join JoinObservable or rx observables JoinObservable cc @headinthebox and @jhusain','This was moved into a separate module in https github com Netflix RxJava pull 1049',RxJava,false,false,false
24735610,'API Design Review rx join ObserverBase','The rx join ObserverBase class should not be public as part of the rxjava core API It needs to be deleted or made private It replicates behavior of SafeObserver which is also kept private cc @headinthebox and @jhusain','',RxJava,false,false,false
24735637,'API Design Review Zip Overload Without Function','While reviewing the zip operators it was suggested we add an overload that returns Observable List R and doesn t take a function It would allow zipping without explicitly defining a function If we had tuples we would return those Since we don t we ll return List R cc @headinthebox and @jhusain','More precisely this transposes iterable observable T to observable list t Do we still want this overload Not for me Closing not important and additive so it can always be done later',RxJava,false,false,false
24735723,'API Design Review SafeObserver via Reflection or Marker Interface','The SafeObserver wrapper is applied to all Observer implementations passed into Observable subscribe by users but it is not applied to any Observer implementations that originate from within the rx operators package This is so we achieve the desired safety and error handling while not paying the cost of wrapping trusted Observer implementations from internal operators Today it uses reflection to look at the package the Observer originates from It then caches this information for performance See here https github com Netflix RxJava blob master rxjava core src main java rx Observable java#L238 and here https github com Netflix RxJava blob master rxjava core src main java rx Observable java#L6822 It is not pretty but it works The other way is we could put marker interfaces such as TrustedObserver on all Observer implementations we use in rx operators or elsewhere that should not be wrapped Pros doesn t involve reflection obvious can be used by non internal operators Cons marker interfaces require remembering to put them where they should be they can be put where they re not supposed to be can be used by non internal operators and misused they are an extra type to maintain in the public API serving little value Neither approach is pretty Is there another approach If not which of these two is preferable and why cc @headinthebox and @jhusain','Since Observable code changes often enough those links will become wrong so here is the valid code java Whether a given @link Function is an internal implementation inside rx packages or not p For why this is being used see https github com Netflix RxJava issues 216 for discussion on Guideline 6 4 Protect calls to user code from within an operator Note If strong reasons for not depending on package names comes up then the implementation of this method can change to looking for a marker interface @param o @return @code true if the given function is an internal implementation and @code false otherwise private boolean isInternalImplementation Object o if o null return true prevent double wrapping yeah it happens if o instanceof SafeObserver return true Class clazz o getClass if internalClassMap containsKey clazz don t need to do reflection return internalClassMap get clazz else we treat the following package as internal and don t wrap it Package p o getClass getPackage it can be null Boolean isInternal p null p getName startsWith rx operators internalClassMap put clazz isInternal return isInternal java if isInternalImplementation observer Subscription s onSubscribeFunction onSubscribe observer if s null this generally shouldn t be the case on a trusted onSubscribe but in case it happens we want to gracefully handle it the same as SafeObservableSubscription does return hook onSubscribeReturn this Subscriptions empty else return hook onSubscribeReturn this s else SafeObservableSubscription subscription new SafeObservableSubscription subscription wrap onSubscribeFunction onSubscribe new SafeObserver T subscription observer return hook onSubscribeReturn this subscription FWIW I d lean toward option 2 Wouldn t this still result in using reflection though since you d have to check for the annotation at runtime marker interfaces require remembering to put them where they should be True Is this something that could be caught using static analysis they can be put where they re not supposed to be But so can any class level annotation And it can be made only applicable to classes via the target property I don t see this being an issue really can be used by non internal operators and misused Sure Then again whoever misuses this to mark a misbehaving observer as trusted is only shooting themselves in the foot You get what you ask for they are an extra type to maintain in the public API serving little value Are you referring to the marker interface What s the maintenance overhead though apart from having to remember applying it to internal observers Would be interested in hearing what others have to say Another option I ve become more comfortable with and that @headinthebox prefers is that we add Observable unsafeSubscribe that Operator implementations can use and it does what it says subscribe without any safety wrapping It would directly invoke the inner OnSubscribe function Yes that s what I would prefer F for unsafe during code reviews to spot where people may shoot themselves in the foot that don t know what they are doing but allow full power in case you need to implement a new operator I see I would find it a bit odd though to find unsafeSubscribe invocations throughout my client code even when I know it s safe It would raise eye brows for people not as familiar with the peculiarities of the library Do you create operators that act on nested Observables Examples are repeat retry merge Those are the only scenario where an unsafeSubscribe is needed Otherwise normal Operator implementations like map take filter etc do not need to Here is an example location where it is doing an unsafe subscribe https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorRepeat java source c#L80 Whereas in map you ll see it never subscribes because it is a Subscriber Subscriber transformation that gets lifted into the Observable https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorMap java I intend on doing this in 0 18 along with Scheduler changes Do my last explanations make sense or is there still concern about this change The only time when this will need to be used is when implementing operators that do nested subscriptions 1 On Mon Mar 31 2014 at 7 34 PM Ben Christensen notifications@github com wrote I intend on doing this in 0 18 along with Scheduler changes Do my last explanations make sense or is there still concern about this change The only time when this will need to be used is when implementing operators that do nested subscriptions Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 676#issuecomment 39117035 Thanks for the positive confirmation @mttkay I ll proceed with this Completed in https github com Netflix RxJava pull 1010',RxJava,false,false,false
24735787,'API Design Review Replay Selector T R without ConnectableObservable','Why are there replay overloads that convert from T to R like a map operator return Observable instead of ConnectableObservable java public R Observable R replay Func1 super Observable T extends Observable R selector It seems that someone should just use observable map T R replay and that it should always return ConnectableObservable cc @headinthebox and @jhusain','I never understood this operator and the current implementation works different than Rx NET java public class ReplayMulticast public static void main String args Observable Integer source Observable from 1 2 3 4 doOnNext v System out println Sideeffect Observable Integer result source replay o o take 2 for int i 1 i 3 i System out printf d n i result subscribe System out println Throwable printStackTrace System out println Done that prints 1 Sideeffect 1 Sideeffect 2 Done Sideeffect Sideeffect 2 Sideeffect 1 Sideeffect 2 Done Sideeffect Sideeffect An infinite stream would never stop Rx NET prints 1 Sideeffect 1 Sideeffect 2 Done 2 Sideeffect 1 Sideeffect 2 Done Regardless I don t get the operator Replay has way to many overloads personally I never use replay so I am not the right person to ask which ones to keep @headinthebox Now is the time for a review of these and deleting any if we want to Can you specify which ones so we don t confuse each other on subjective non obvious decisions Here are all the overloads The ones that create a ConnectableObservable ConnectableObservable T replay ConnectableObservable T replay int bufferSize ConnectableObservable T replay int bufferSize long time TimeUnit unit ConnectableObservable T replay int bufferSize long time TimeUnit unit Scheduler scheduler ConnectableObservable T replay int bufferSize Scheduler scheduler ConnectableObservable T replay long time TimeUnit unit ConnectableObservable T replay long time TimeUnit unit Scheduler scheduler ConnectableObservable T replay Scheduler scheduler And the corresponding ones that take a function and create a regular observable Observable R replay Func1 super Observable T extends Observable R selector Observable R replay Func1 super Observable T extends Observable R selector final int bufferSize Observable R replay Func1 super Observable T extends Observable R selector int bufferSize long time TimeUnit unit Observable R replay Func1 super Observable T extends Observable R selector final int bufferSize final long time final TimeUnit unit final Scheduler scheduler Observable R replay Func1 super Observable T extends Observable R selector final int bufferSize final Scheduler scheduler Observable R replay Func1 super Observable T extends Observable R selector long time TimeUnit unit Observable R replay Func1 super Observable T extends Observable R selector final long time final TimeUnit unit final Scheduler scheduler Observable R replay Func1 super Observable T extends Observable R selector final Scheduler scheduler These latter ones are similar to the Publish overload that takes a function Observable R publish Func1 super Observable T extends Observable R selector where the source observable is published inside the function If you like replay which I personally don t in fact I have not used it in the last 2 years all the overloads make sense So unfortunately I guess that if we keep replay we need all of them @akarnokd The NET behavior is the correct one When you call source replay replayedSource replayedSource take 2 the function gets a private copy source replay that it can use Since source is finite it should replay the side effects and take the first two elements @headinthebox thanks I suspected so Luckily the issue I mentioned above was fixed and RxJava should behave as Rx NET now @akarnokd great and @benjchristensen sorry for not being able to prune this bunch but it makes Rx extra super Closing out review has decided that what we have is what we want Thanks @akarnokd and @headinthebox',RxJava,false,false,false
24735879,'API Design Review Java 8 Stream Naming Conventions','Let s compare against the Java 8 Streams API and try to match as closely to it as possible We can add aliases where it makes sense and possibly deprecate and migrate to their names if they are better The idea is to support Java developers as they use the Stream API and then want to move to async and be as similar as possible It should try and achieve the Principle of Least Surprise http en wikipedia org wiki Principle_of_least_astonishment for developers Ideally someone could have code written for the Stream API and just swap out the Stream for an Observable and it just work cc @headinthebox and @jhusain cc @bondolo from Oracle if you have any thoughts on this','Unless one uses call site lambdas just swapping won t work due base functional type mismatch java stream filter v v 2 0 observable filter v v 2 0 but Predicate Integer p v v 2 0 stream filter p observable filter p type mismatch observable filter p test Some renames matches of functionality Stream API Observable API filter where mapToInt primitive observable sorted N A peek limit take n forEach doOnEach toArray toBlockingObservable toList toArray anyMatch exists toBlockingObservable single count count toBlockingObservable single allMatch all toBlockingObservable single noneMatch all not toBlockingObservable single findFirst materialize toBlockingObservable first findAny N A would be identifal to findFirst Some Stream methods exit the stream this is why there are that many toBlockingObservable calls in the table Keep the Net naming and usage intact much as possible Any language specific idioms can core exit with this This would help towards less confusion and easy portability in case you maintain a net API also This can be extended to the other language bindings also E g idiomatic Scala API should ideally not hide the Net of F# usage as in this case F# being closer to Scala Clojure than C# I sympathize with the plight of the cross platform RX user I am one However I strongly disagree with the idea of using non idiomatic names just to make porting code between platforms easier We tried that with RxJS and it caused no end of confusion There are many RX users who use RX across platforms However there is a much larger potential audience that does not yet use RX will very likely be exposed to Streams and will approach reactive programming for the first time in the next two years J Dictated using voice recognition Please forgive the typos On Dec 27 2013 at 6 29 AM Suminda Dharmasena notifications@github com wrote Keep the Net naming and usage intact much as possible Any language specific idioms can core exit with this This would help towards less confusion and easy portability in case you maintain a net API also This can be extended to the other language bindings also E g idiomatic Scala API should ideally not hide the Net of F# usage as in this case F# being closer to Scala Clojure than C# Reply to this email directly or view it on GitHub What I say is use idiomatic names wherever possible but leave the more familiar naming and usage also The idiomatic changes would be a few so there will be little overhead Best is that if there is a possibility feasibility coordinate across the Rx implementations and the net project is also open source so there is coherence and API convergence These are the only ones that seem worth considering Stream API Observable API filter where limit take n forEach doOnEach We have already done filter I am okay with aliasing take and limit The forEach name may also be good The question then is whether it s a synonym with doOnEach or subscribe Action1 T I think it s the later as someone shouldn t need to forEach f subscribe Should we alias subscribe with forEach java void forEach Action1 super T void forEach Action1 super T Action1 Throwable void forEach Action1 super T Action1 Throwable Action0 @benjchristensen I agree with the latter especially people coming from java 8 streams it s not obvious that in Rx you then have to subscribe in addition OK with forEach I think RxJs has that as well Let s move ahead with this Completed in https github com Netflix RxJava pull 1232 java public static void main String args Observable from 1 2 3 forEach System out println Observable from 1 2 3 toBlocking forEach System out println Observable from 1 2 3 limit 2 forEach System out println Note that in JavaScript this method removes the data from the monad That said we should definitely match the stream APIs closely as possible for Java 8 Dictated using voice recognition Please forgive the typos On May 20 2014 at 9 14 AM headinthebox notifications@github com wrote OK with forEach I think RxJs has that as well Reply to this email directly or view it on GitHub We have both the non blocking and blocking forms of forEach now The blocking one removes it from the monad java Observable from 1 2 3 forEach System out println Observable from 1 2 3 toBlocking forEach System out println Makes sense',RxJava,false,false,false
24735933,'API Design Review Timer Interval','It seems timer is almost replicating interval but doing so with a non obvious name An operator named timer suggests it s related to scheduling work in the future but it s actually about a stream of numbers Let s consider removing timer and improving interval to achieve what it does Perhaps we can also have a better name for simply getting an infinite stream of numbers with or without time involved Perhaps an obvious name like Observable numbers or something equally apparent cc @headinthebox and @jhusain','We also should consider the example of Observable range start count It seems like it should also be capable of doing Observable range start and just start at a value and keep counting but then it s not really a range but that s what we want to do and don t have the ability to do Timer has the ability to determine when it first fires set an interval just like interval So perhaps we should remove interval Sent from my iPad On Dec 23 2013 at 9 47 PM Ben Christensen notifications@github com wrote It seems timer is almost replicating interval but doing so with a non obvious name An operator named timer suggests it s related to scheduling work in the future but it s actually about a stream of numbers Let s consider removing timer and improving interval to achieve what it does Perhaps we can also have a better name for simply getting an infinite stream of numbers with or without time involved Perhaps an obvious name like Observable numbers or something equally apparent cc @headinthebox and @jhusain Reply to this email directly or view it on GitHub Interval was removed by one of my PRs so I guess this is settled They are still there right now java Returns an Observable that emits a sequential number every specified interval of time p img width 640 src https raw github com wiki Netflix RxJava images rx operators interval png @param interval interval size in time units see below @param unit time units to use for the interval size @return an Observable that emits a sequential number each time interval @see a href https github com Netflix RxJava wiki Creating Observables#wiki interval RxJava Wiki interval a @see a href http msdn microsoft com en us library hh229027 aspx MSDN Observable Interval a public final static Observable Long interval long interval TimeUnit unit return create new OperatorTimerPeriodically interval interval unit Schedulers computation Returns an Observable that emits a sequential number every specified interval of time on a specified Scheduler p img width 640 src https raw github com wiki Netflix RxJava images rx operators interval s png @param interval interval size in time units see below @param unit time units to use for the interval size @param scheduler the Scheduler to use for scheduling the items @return an Observable that emits a sequential number each time interval @see a href https github com Netflix RxJava wiki Creating Observables#wiki interval RxJava Wiki interval a @see a href http msdn microsoft com en us library hh228911 aspx MSDN Observable Interval a public final static Observable Long interval long interval TimeUnit unit Scheduler scheduler return create new OperatorTimerPeriodically interval interval unit scheduler I meant they use the same implementation as the timer methods and now serve as aliases Oh Should we keep interval and timer in the API Programmers coming from other flavors of Rx may expect to discover interval Don t see why not Leaving as is',RxJava,false,false,false
24736081,'API Design Review Async Future','We have started collecting functionality related to Async java Observable start and similar such as in https github com Netflix RxJava pull 645 and https github com Netflix RxJava pull 622 These do not directly apply to the goals of rxjava core in enabling async Observable behavior but are valuable utilities for converting to and from Observable and executing work asynchronously Having them in the core however has the following drawbacks they increase API surface area code and byte size they complicate the mental model by mixing multiple different concepts they are tied to the java util concurrent model different Java libraries such as Guava and Akka have different models each JVM language has different concurrency models and libraries work can be executed asynchronous in many ways such as actors event loops or thread pools and rxjava core is purposefully non opinionated about the source of concurrency or asynchronocity For these reasons it is felt that this functionality should be removed and or not accepted into rxjava core but instead placed in a contrib module This is similar to how rxjava android and rxjava swing add additional functionality https github com Netflix RxJava tree master rxjava contrib cc @headinthebox and @jhusain','The Async class and related operators has been moved into rxjava async util https github com Netflix RxJava tree master rxjava contrib rxjava async util',RxJava,false,false,false
24736110,'API Design Review defaultIfEmpty Observable','There is a defaultIfEmpty that returns value T Should we have one that accepts an Observable T as a default to subscribe to It would be like onEmptyResumeNext Observable T similar to onErrorResumeNext Observable T cc @headinthebox and @jhusain','There are several operators has a default value e g singleOrDefault firstOrDefault lastOrDefault elementAtOrDefault Can we add an overload that accepts a function to generate the default value Like Java public final Observable T singleOrDefault Func0 T defaultValue Is s helpful for rxjava scala to implement the call by name version of these operators Here is firstOrElse in rxjava scala Scala def firstOrElse U T default U Observable U this take 1 foldLeft Option U None v Option U e U Some e map case Some element element case None default If we have the function overload of firstOrDefault we can implement it like Scala def firstOrElse U T default U Observable U asJavaObservable firstOrDefault default cc @samuelgruetter Seems like onEmptyReturn T t and onEmptyResumeNext Observable T o would be better naming conventions But since we already have defaultIfEmpty do we want defaultIfEmpty T t defaultIfEmpty Observable T t Closing as not important We can always revisit this in the future if it comes interesting again',RxJava,false,false,false
24736188,'API Design Review Share','Similar to how we have the Observable cache operator as an easy to understand helper over multicast replay it is suggested to use Observable share for the multicast publish as a shortcut to Observable publish refCount which is typically rather non obvious and non discoverable for people new to the library The suggestion is that Observable share would meet the majority of multicast use cases for sharing an Observable not needing the complexity of handling the ConnectableObservable directly or knowing to use refCount It would also match with RxJS https github com Reactive Extensions RxJS blob master doc api core observable md#rxobservableprototypeshare cc @headinthebox @jhusain and @mattpodwysocki','@headinthebox and @akarnokd Do you like the idea of share being a cover for publish refCount Note that RxJS already does this Adding it isn t a big deal but I can t comment on whether the name share is discoverable enough I d like to hear from users who had trouble with publish refcount being inconvenient My only insight into this is that I often see the question struggle of how to use publish and connect and refCount is always a surprise My only insight into this is that I often see the question struggle of how to use publish and connect and refCount is always a surprise I m fine as you mention RxJs has this They also have pluck which sounds cool Personally I like to be explicit but I can see the value of share Oops github ui fooled me into accidentally closing @headinthebox @benjchristensen yeah we gave it some thought before we committed to it but in the long run it was worth it Thanks for the insight @mattpodwysocki Let s proceed with this It leaves us with cache and share as the most common multicasting use cases and the rest for the more complicated scenarios What is cache in this respect replay refCount or something else It s just ReplaySubject without refCount Once it is subscribed to once it receives all values from the origin and caches them all and replays them all back to whoever subscribes Thus it is a big massive memory leak if used incorrectly but that s how toList and default replaySubject are anyways This is most commonly used in request response style network calls where it is a single or finite response expected Code https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorCache java Done in https github com Netflix RxJava pull 1231 I do a lot of RX training and every time I have to teach connectable observable I lose a third of the room That s frustrating because Cache and Share meet more than 90 of all use cases I think we should follow the principle that only complete subscriptions are cached A cached observable has two states 1 Uncached 2 Cached In the uncached state the observable is similar to a share observable Concurrent subscribers should share a single ref counted subscription The only difference is that late concurrent subscribers are caught up by immediately getting the contents of the buffer Once in an onCompleted or onError message is received the cached observable goes into the cached state At this point the observable behaves exactly like a replay subject never issuing another call to the underlying data source The data itself is cashed within the ReplaySubject should not go away ever until all references to the cached observable are freed This is what users expect rather than the cached data being tied to a particular subscription as in replay refCount If all concurrent subscribers unsubscribe before the subscription has completed the data in the cash should be purged and the observable should return to the uncached state J Dictated using voice recognition Please forgive the typos On May 20 2014 at 9 24 AM Ben Christensen notifications@github com wrote It s just ReplaySubject without refCount Once it is subscribed to once it receives all values from the origin and caches them all and replays them all back to whoever subscribes Thus it is a big massive memory leak if used incorrectly but that s how toList and default replaySubject are anyways This is most commonly used in request response style network calls where it is a single or finite response expected Code https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorCache java Reply to this email directly or view it on GitHub The data itself is cashed within the ReplaySubject should not go away ever until all references to the cached observable are freed Yes this is how we implemented cache It lets garbage collection free it we don t proactively do anything the way refCount does as it s not what people expect here If all concurrent subscribers unsubscribe before the subscription has completed the data in the cash should be purged and the observable should return to the uncached state This isn t as obvious That would mean it could be resubscribed to and re execute the work which would be surprising to people This could happen all the time if they are using take n as it would never onComplete and always be unsubscribed The cache operator caches the entire origin If it s an infinite stream it won t work well and something like take will need to be done BEFORE the cache operator is applied',RxJava,false,false,false
24736237,'API Design Review Conditionals','Discussion with @headinthebox suggests that the conditional operators really don t belong in RxJava at least not the core as they were added to Rx Net for very specific use cases in F# These include ifThen switchCase doWhile whileDo Are there reasons to keep these If so do we move them out of Observable or should we delete them cc @headinthebox and @jhusain','http msdn microsoft com en us library dd233182 aspx I don t know of anyone using this for real in Rx NET These could be moved into a rxjava contrib rxjava dotnet legacy package along with those ops that have been added just to match Rx Net These can be used for CEP scenarios to reason over multiple streams It is best that they stay in some form or other as Java does not have anonymous classes like C# where they could be easily avoided by joining fields into a anonymous class They are more needed in the JVM implimentation than in net @sirinath can you give a concrete example I don t see the connection between these operators which are intended to overload imperative control structures in F# computation expressions and anonymous types If this is extended to accept an observable sequence as the condition selector then it would be more useful Say I want to buy using signal A if vol is greater than a certain threshold plus some other computationally expensive conditions and signal B otherwise only if I am trading that instrument for the day and I only trade 0 5 of instruments The current form is somewhat useful if we want to certain set of signals at start of the day but this is something you can do otherwise eagerly at a cost Also it would be useful if the conditional is also an observable sequence as you can select between streams than at subscription Using Linq you can aggregate multiple items into anonymous class and select what is needed at the end from this in a further query This is more difficult though possible in Java than C# hence it will be good to have the conditional functionality extended for other use cases More powerful it would be if you have linq Expressions This is also possible through Commons JCI or directly using Janino Perhaps at a later stage Also the conditions or index can be extended to a function to take 1 item from each stream and return the appropriate values boolean index for each item If not subscribers the condition is not evaluated and if possible each item can be discarded from the streams This would be a more convinient way to use this functionality @sirinath Could you provide a concrete example I am not sure that I understand what you are after precisely Migrating conditionals to a contrib module https github com Netflix RxJava pull 714 Here is a link to documentation on their usage http weblogs asp net podwysocki archive 2010 06 18 introduction to the reactive extensions for javascript conditionals aspx @headinthebox Add an extra overload with Func bool TResult TResult condition for if and Func TValue TResult selector etc if a b a equals obj1 b equals obj2 strm1 strm2 this case condition is evaluated as needed but for each element coming in @headinthebox In a nutshell the extension will help combination and generation Something you can consider for the main implementation also',RxJava,false,false,false
24736278,'API Design Review DelayError','The mergeDelayError operator has been in RxJava from very early and evolved out of experience with the Netflix API use cases It is not from Rx Net It has proved very valuable and it has been suggested that this pattern be expanded to other combinatorial operators where lazily handling errors is sometimes appropriate These include concatDelayError combineLatestDelayError switchLatestDelayError Are there others Any reason not to do this cc @headinthebox and @jhusain','Talking about these operators In the NET version there is an overload that limits the amount of concurrency http msdn microsoft com en us library hh211914 v vs 103 aspx while merging which does not seem to be present in RxJava I can take this overload of merge this weekend Still open to do Related to this is flatMapDelayError https github com Netflix RxJava issues 301 @zsxwing would be great We should also make sure that the same consistency is applied for mergeMap i e I want the same overloads on concatMap maybe I should open a new issue for that',RxJava,false,false,false
24736325,'API Design Review better name for just','The just operator seems misplaced and non discoverable The from operator is preferable but we can t have from T Scheduler because if T is Object then from Object Scheduler can t be disambiguated from from Object Object Ideas on a new name or different approach cc @headinthebox and @jhusain','We can always do Observable repeat x take 1 or Observable repeat x 1 That was the argument for not including return in C# Enumerable I think it s too late to remove just and it works The two primary entry points are Observable from and Observable just',RxJava,false,false,false
24736439,'API Design Review From Overloads','There is dislike of the multiple arities of from especially how the 10 arity option always comes up and autocompletes first observablefrom https f cloud github com assets 813492 1804703 21095cf2 6c62 11e3 8029 9da176f8c908 png For history changes from vararg to multiple arity overloads was done here https github com Netflix RxJava pull 361 and https github com Netflix RxJava issues 359 An alternative is just accept from Iterable T and people call it as from Arrays asList 1 2 3 4 5 which doesn t give the vararg warnings but this is verbose On the flip side the arities from 4 10 seem unnecessary and for demo code only Perhaps we deprecate the from T T T and higher arities For higher we would use the from Iterable T solution Are there better ways cc @headinthebox and @jhusain','Maybe we should only keep from T and deprecate the higher arities and just as well Java 8 streams use of T t and of T values Not sure if we mustopen the can of worms of varargs but the Oracle folks don t seem to shy away from it The SafeVarargs annotation is on their side The @SafeVarargs definitely solves the issue Need to figure out if we can adopt @SafeVarargs and build with Java 7 just for that but leave everything else as Java 6 so Android support is not affected I just learned that @SafeVarargs doesn t solve this problem when nested generics are involved screen shot 2014 03 27 at 12 34 16 pm https cloud githubusercontent com assets 813492 2542395 eea93e70 b5e6 11e3 8313 90eda2b5efa3 png In this screenshot note the first one is still causing warnings whereas the second is not The Observable having generics causes the problem despite Arrays asList using @SafeVarargs It looks like we have 3 choices 1 Leave code as is with the 9 arity overloads for from merge and concat 2 Remove all the arity overloads and make developers do something like Arrays asList to pass into a single Iterable overload Devs end up with the same vararg warnings 3 Use varargs and just deal with the warnings the same as if we go with option 2 If these are the only options I d vote for 3 purely because I generally dislike approach 1 violates the zero one infinity rule 1 and because 2 adds nothing over 3 except verbosity 1 http www catb org jargon html Z Zero One Infinity Rule html I too vote for 3 as it makes the API far cleaner especially if we end up needing to provide Scheduler overloads for merge and mergeDelayError as a result of this https github com Netflix RxJava issues 998#issuecomment 38947959 @samuelgruetter @akarnokd @zsxwing What are your opinions on this matter Use the builder pattern instead of varargs java Observable TCommon fromBuilder add v1 add v2 add v3 build map etc I d rather keep what we have right now than that java Observable from v1 v2 v3 map Two more ideas Introduce an add or append or endWith method so that we could use something like java Observable TCommon just v1 add v2 add v3 map etc This is similar to @akarnokd s idea above but a bit less verbose and a bit less efficient And if v1 v2 all have the same type we can even omit the TCommon Or if we keep the low arity from this could be the escape if we still need higher arities java Observable from v1 v2 v3 add v4 add v5 map etc Separate methods for low arities and varargs for high arities java public final static T Observable T from T t1 public final static T Observable T from T t1 T t2 public final static T Observable T from T t1 T t2 T t3 public final static T Observable T from T t1 T t2 T t3 T t4 T ts This covers everything except cases with 4 or more arguments of generic type which should be quite rare By the time you are at such high arity it is easier to put the values in an array and convert that This kind of code is only used in small samples from 1 2 or anything you can enumerate statically is not a very interesting asynchronous data stream and so far we have been able to keep the builder pattern out let s keep it that way So let s go for option 3 So @headinthebox you think we should go completely vararg and just deal with the warnings that drove us to the current code Or that we should keep the 1 2 and 3 arity overloads and then 4 is with varargs By the way this isn t just for from the common use cases are for merge concat mergeDelayError etc you think we should go completely vararg Yes Also go completely vararg for concat In concat the arguments are always generic so users will always get a warning see https github com Netflix RxJava issues 359 Annoying yes but the Java type system is a freaking mess anyway and just a mirage because of erasure BTW can we put @SuppressWarnings unchecked in the library source to suppress warnings for users No the SuppressWarnings is for the call site not the function definition The SafeVarargs annotation is a Java 7 feature for the function definition and it works for simple types like T but not nested generics which Java also has issues with such as Observable T which is what concat and others require Therefore even if we could adopt Java 7 SafeVarargs is helpful for from but not concat merge etc My comment above at https github com Netflix RxJava issues 686#issuecomment 38850583 shows when I found out that SafeVarargs wouldn t solve the issue What a mess So the alternative is many mechanical overloads with separate type parameters f A Z The alternative is what we have right now manually creating all of the overloads It makes it so it doesn t give warnings but it means we have lots of overloads and painful autocomplete in IDEs So we either have warnings in the IDE or autocomplete mess We have to pick a poison it seems I don t know which is worse it s probably a personal opinion Agreed I guess many people treat warnings as errors we should probably go for autocomplete mess It is unfortunate that there seems to be no way in the Java IDEs to control autocomplete In Visual Studio you can decorate your API to control what pops up I m going to close this out and choose to leave the code as is opting to avoid warnings and leave the autocomplete mess',RxJava,false,false,false
24736552,'API Design Review Instance Concat Merge Flatten Zip','An idea that has floated for the past year including https github com Netflix RxJava issues 295 is to add instance method for flatten During API review this came up again along with instance methods for each of the combination operators concat merge flatten zip Because of how Java types work and without targeted extension methods we can not only make these apply to Observable Observable T and be type safe We could however do things like If we have an Observable Observable T observable flatten cast MyType class observable flattenTo MyType class If we have an Observable T it would basically just pass thru without applying the flattening since it s already flat cc @headinthebox and @jhusain','Another issue about the instance implementation is the conflict of the static method signature and the instance one For example public static T Observable T concat Observable extends Observable extends T observables and public Observable T concat Observable extends T that Given that there s import static With such a change you get The ability to write o merge instead of merge o o1 zip o2 instead of zip o1 o2 o1 concat o2 instead of concat o1 o2 which is just code cosmetics But the price is high Lost typesafety Several ways to do the same thing bloats the API If the programmer thinks an expression is an Observable of Observables but in fact it s only an Observable instead of getting an error the case just pass thru without applying the flattening since it s already flat applies This is a source of confusion As you can see I don t like the idea Would it be worth while to move all of the static operators to a different class maybe something like ObservableOfObservables java and ObservableOfNumbers java so that won t clash with the instance revisions the conflict of the static method signature and the instance one It would not accept another Observable to flatten merge concat with it is only for operating on the current Observable The intent of the instance methods is not for use cases such as o1 zip o2 That is of little value and in fact confusing It is to flatten merge zip an Observable Observable T For example o flatten or o merge Thus the instance signature would be Observable T flatten without arguments or Observable T concat Observable T merge etc just code cosmetics One could argue that about the entire Rx chaining pattern Why have instance methods at all if code cosmetics was not a concern the case just pass thru without applying the flattening since it s already flat applies This is a source of confusion It offers support for interesting use cases where an Observable Object can return a mixture of T and Observable T and then be flattened into a single Observable Flatten specifically is considered for recursive flattening such that it could work on Observable T Observable Observable T or even Observable Observable Observable T and a mixture of them Whether that s confusing or not is in the eye of the beholder I can argue that switch is not easy to understand and it is perfectly type safe and does exactly what it says it will do The flatMap operator is hard to understand for many particularly those new to the functional style yet flatten makes perfect sense Perhaps the confusing part could be reduced by only having a flatten instance method and leaving concat merge zip as static only The flatten operator could be considered the recursive merge that will flatten whatever it is given whether it is already T or Observable T or Observable Observable T For most people map flatten makes more sense to them than flatMap mergeMap concatMap Lost typesafety It s little different than when Observable Map String Object gets used to move data around or Observable Object The flatten operator would not be something that can accidentally be used and break the static typing of any other operator by hitting an overload such as concat Object Object so it s a developers choice to use it or not Several ways to do the same thing bloats the API It s doing something that static methods don t permit particularly if we allow flatten to be recursive I m not convinced either way on whether this is a good or bad thing but the following is preferable code java o map filter map flatten take than breaking the order of the chain into this java flatten o map filter map take @benjchristensen now it makes more sense Recursive flattening of heterogeneous Observables sounds interesting A reminder that this and https github com Netflix RxJava issues 295 are related We now have mergeWith concatWith ambWith zipWith etc so closing this out The flatten method is handled by #295',RxJava,false,false,false
24737260,'Fix SafeObserver handling of onComplete errors','Fixes https github com Netflix RxJava issues 630','RxJava pull requests #605 https netflixoss ci cloudbees com job RxJava pull requests 605 FAILURE Looks like there s a problem with this pull request So the contract becomes onNext onCompleted onError onError Not really This is handling out of contract scenarios A proper observer should never fail on any of these notifications thus SafeObserver logic should never apply but bugs exist and this is all about making a system operational despite code not complying with the Rx contract and having bugs Got it Thanks',RxJava,true,false,false
24749638,'Removed ObserverBase','For issue #674 Removed ObserverBase and adapted JoinObserver1','RxJava pull requests #606 https netflixoss ci cloudbees com job RxJava pull requests 606 FAILURE Looks like there s a problem with this pull request Thank you',RxJava,true,false,false
24754020,'Fixed Scala bindings','','RxJava pull requests #607 https netflixoss ci cloudbees com job RxJava pull requests 607 SUCCESS This pull request looks good Thanks Erik',RxJava,true,false,false
24755700,'javadoc improvements','diagrams for switchLatest mergeMap concatMap switchMap mapWithIndex doOnNext change text to note deprecation of aggregate standardized formatting force image size in ReplaySubject javadoc','RxJava pull requests #608 https netflixoss ci cloudbees com job RxJava pull requests 608 SUCCESS This pull request looks good Thanks David for keeping on top of this',RxJava,true,false,false
24779077,'How to map exceptions','I have Observable MyResult that could produce onError with Exception1 I want to remap it so I can handle Exception1 and rethrow my own Exception2 What is the proper way to do it','You need to implement your own Observer and perform the remapping there java final Observer Object actual Observable error new Exception subscribe new Observer Object public void onNext Object a actual onNext a public void onCompleted actual onCompleted public void onError Throwable e if e instanceof Exception actual onError new RuntimeException e If you need to do this regularly you can have your own operator for it java public class MapException public static T E extends Exception Observable T mapException final Observable T source final Func1 super Throwable E errorSelector return Observable create new OnSubscribeFunc T @Override public Subscription onSubscribe final Observer super T t1 Observer T o new Observer T @Override public void onNext T args t1 onNext args @Override public void onError Throwable e E f try f errorSelector call e catch Throwable t t1 onError t return t1 onError f @Override public void onCompleted t1 onCompleted return source subscribe o public static void main String args throws InterruptedException Func1 Throwable IOException ioe new Func1 Throwable IOException @Override public IOException call Throwable t1 return new IOException t1 getMessage t1 getCause Observable Integer source mapException concat from 1 2 3 error new RuntimeException Forced failure ioe final CountDownLatch latch new CountDownLatch 1 source subscribe new Action1 Object @Override public void call Object t1 System out println t1 new Action1 Throwable @Override public void call Throwable t1 t1 printStackTrace latch countDown new Action0 @Override public void call latch countDown latch await 10 TimeUnit SECONDS You can use onErrorResumeNext http netflix github io RxJava javadoc rx Observable html#onErrorResumeNext rx util functions Func1 Inside the function perform your conditional logic and return Observables as appropriate such as using Observable error with your new Exception @benjchristensen When I return converted exception it seems some sort of recursion calls are made and I receive my exceptions many times This works for me as expected java public class MapException2 public static void main String args throws InterruptedException Observable Integer source concat from 1 2 3 error new RuntimeException Forced failure Observable Integer result source onErrorResumeNext e concat from 4 5 6 error new IOException e getMessage e getCause result subscribe System out println Throwable printStackTrace Thread sleep 1000 prints the numbers 1 6 and an IOException stacktrace',RxJava,false,false,false
24789801,'Kotlin M6 2','Version updated for Kotlin M6 2','RxJava pull requests #609 https netflixoss ci cloudbees com job RxJava pull requests 609 SUCCESS This pull request looks good Thanks',RxJava,true,false,false
24797424,'Change page from Mathematical Operators to Mathematical and Aggregate Operators','move toList reduce concat toSortedList toMap and toMultiMap to that page deprecate aggregate in favor of reduce should I move takeLast last and takeLastBuffer to the Aggregate operators page they don t operate on the aggregate exactly but they do wait until the source completes before emitting anything','RxJava pull requests #610 https netflixoss ci cloudbees com job RxJava pull requests 610 SUCCESS This pull request looks good RxJava pull requests #611 https netflixoss ci cloudbees com job RxJava pull requests 611 FAILURE Looks like there s a problem with this pull request RxJava pull requests #612 https netflixoss ci cloudbees com job RxJava pull requests 612 SUCCESS This pull request looks good',RxJava,true,false,false
24824656,'API Design Review','My thoughts on the API Design Review Try to be faithful to the MS implementation much as possible where feasible Any enhancements can also live along side the core implementation With other language bindings also coming from MS it is good that there are consistency among the implementations So idiomatic Rx comes before any other implementations','cc @headinthebox @jhusain @mattpodwysocki Try to be faithful to the MS implementation much as possible where feasible Of course',RxJava,false,false,false
24829940,'New contrib module rxjava async util','Home for async utility functions with juc Future Actions Functions etc that don t need to be in rxjava core As per discussions at https github com Netflix RxJava pull 646#issuecomment 31147005 https github com Netflix RxJava pull 645#issuecomment 31146492 https github com Netflix RxJava pull 622#issuecomment 31144128 cc @akarnokd','@akarnokd Do you want to extend this branch and merge the various PRs in to it that belong here If you don t like the name go ahead and propose something I couldn t think of anything better but only spent a couple minutes on this I want something generic enough to cover the various utilities At the same time I feel this name may be too broad as these utilities may not apply at all to other JVM languages but that s probably fine as that s why it s a contrib module RxJava pull requests #613 https netflixoss ci cloudbees com job RxJava pull requests 613 FAILURE Looks like there s a problem with this pull request Thanks @benjchristensen the name is okay I ll update and resubmit the relevant PRs Should Observable from Future and its overloads from before be moved into this module Leave Observable from Future in Observable for now We ll need to do a deprecation process on those if we remove them I m closing this PR as you will take my branch and re submit a new one I m sorry I don t quite understand I check out your branch then once all ops are added I submit a PR against RXJava master Yes',RxJava,true,false,false
24832376,'Manual Merge of Pull #667','Manual merge of https github com Netflix RxJava pull 667','RxJava pull requests #614 https netflixoss ci cloudbees com job RxJava pull requests 614 SUCCESS This pull request looks good',RxJava,true,false,false
24833724,'Merge of Pull 657 Average and Sum','','RxJava pull requests #615 https netflixoss ci cloudbees com job RxJava pull requests 615 SUCCESS This pull request looks good I m not crazy about the naming average averageInteger f averageDoubles averageDouble f averageFloats averageFloat f averageLongs averageLong f It doesn t seem to have much rhyme or reason to it Why are the versions that take functions singular and the versions that don t are plural e g Long vs Longs Why is the function paired up with averageInteger f just called average instead of averageIntegers when all the other functions follow that pattern On Fri Dec 27 2013 at 1 18 PM CloudBees pull request builder plugin notifications@github com wrote RxJava pull requests #615 https netflixoss ci cloudbees com job RxJava pull requests 615 SUCCESS This pull request looks good Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 698#issuecomment 31280530 David M Gross PLP Consulting I wanted to avoid overload problems in other languages and simply named the ops differently I wondered why average didn t include the type in the name Is it more common to average a stream of ints I wondered why the originals where plurals in the first place I wanted to avoid overload problems in other languages and simply named the ops differently This is actually a problem with type erasure not the language interop This code java public static Observable Integer average Observable Integer source return OperationAverage average source public static Observable Double average Observable Double source return OperationAverage average source Results in this error Method average Observable Integer has the same erasure average Observable T as another method in type Observable T We can rename the methods Doing so now Names standardized here https github com benjchristensen RxJava commit f8fc1cb4c23f4782605451bfc0cea043b6a5e7e4',RxJava,true,false,false
24834240,'Repeat Operator','merge and slight modification of https github com Netflix RxJava pull 518 done with @headinthebox','RxJava pull requests #616 https netflixoss ci cloudbees com job RxJava pull requests 616 SUCCESS This pull request looks good',RxJava,true,false,false
24834608,'various javadoc improvements','diagrams for skip t single take t skipLast t adding diagrams improving javadocs for sumFoo averageFoo operators adding diagram to repeat','RxJava pull requests #617 https netflixoss ci cloudbees com job RxJava pull requests 617 SUCCESS This pull request looks good You re awesome Real time documentation as we write code',RxJava,true,false,false
24834822,'Collect Operator','Added with @headinthebox while reviewing Java 8 Streams https github com Netflix RxJava issues 678','RxJava pull requests #618 https netflixoss ci cloudbees com job RxJava pull requests 618 SUCCESS This pull request looks good Not exactly how Stream works java R R collect Supplier R supplier BiConsumer R super T accumulator BiConsumer R R combiner and java R A R collect Collector super T A R collector where java public interface Collector T A R Supplier A supplier BiConsumer A T accumulator BinaryOperator A combiner Function A R finisher The main difference is that the Steam and my version exits the stream observable The second is that it doesn t let the initial state be per subscriber So if I want to collect into an ArrayList multiple subscribers will collect into the same ArrayList The second is that it doesn t let the initial state be per subscriber So if I want to collect into an ArrayList multiple subscribers will collect into the same ArrayList The reduce and scan operator would have the same problem then correct Not exactly how Stream works Understood It s not meant to Stream is seeking to achieve something that works in both sequential and parallel execution Observable only ever emits items sequentially The parallel operator is the only thing in RxJava that currently enables concurrent execution The valid discussion would be whether we want Observable toParallel that returns a ParallelObservable with different overloads of certain operators Thus far as @headinthebox and I have discussed it there has not been a valid reason for this complication Wouldn t this cause dependency problems What dependency problems The reduce and scan operator would have the same problem then correct That s true but these are used to transfer values which are stateless such as Integer and Double Of course one could just create a new ArrayList in reduce on each function call and be that the new state but this collect doesn t allow to do that So basically its a trivial wrapping around a Func2 and reduce and as such might not worth adding IMO Understood It s not meant to Stream is seeking to achieve something that works in both sequential and parallel execution Observable only ever emits items sequentially I wasn t referring to the parallel capability of the stream but to two things You don t end up with a Stream R after the collection but a direct value of R You can specify a per consumer state object via function callback Now Stream is single consumer only but Observable is not What dependency problems Dependency problem a reference to jUnit in Observable import static org junit Assert',RxJava,true,false,false
24835848,'Standardise isUnsubscribed','Would it be possible to add an intermediate interface between Subscription and the default Subscription implementations that exposes the isUnsubscribed method I can only offer the use cases in the upcoming rxjava async util module where certain operators can use a shared cancellation token The alternative is to ask the clients to wrap their token into BooleanSubscription and don t forget to unsubscribe it instead of the wrapped subscription','@headinthebox and I have discussed this at length while reviewing Subscription implementations and I really don t see a valid use case for having a collection such as List extends IsUnsubscribedSubscription The concrete type is always available in operators What does rxjava async util need to do that necessitates this StartFuture and DeferFuture have overloads which share a cancellation token between subscribers However I must admit I haven t looked at C# s CancellationToken class to see what it does beyond isDisposed I ll figure something out Thanks',RxJava,false,false,false
24836407,'Small Tweaks','Some small changes while reviewing code','RxJava pull requests #619 https netflixoss ci cloudbees com job RxJava pull requests 619 SUCCESS This pull request looks good',RxJava,true,false,false
24838927,'New contrib module rxjava async util','Added startFuture deferFuture forEachFuture operators Left out the CancellationToken resembling overloads as I was in doubt they can be meaningfully used If a task is cancelled it is enough to check the Thread currentThread isInterrupted flag','RxJava pull requests #620 https netflixoss ci cloudbees com job RxJava pull requests 620 SUCCESS This pull request looks good Why is this changing 7700 lines of Observable and most of ObservableTests I don t know Maybe a line ending anomaly from your branch RxJava pull requests #622 https netflixoss ci cloudbees com job RxJava pull requests 622 SUCCESS This pull request looks good This pull request merged the master branch instead of rebasing so has lots of unnecessary and unrelated changes I have created a new pull request after cherry picking just the relevant changes and avoiding the merge with master artifacts https github com Netflix RxJava pull 706',RxJava,true,false,false
24854832,'adjust javadocs for new sumFoo averageFoo method names','','RxJava pull requests #621 https netflixoss ci cloudbees com job RxJava pull requests 621 SUCCESS This pull request looks good',RxJava,true,false,false
24892001,'Clean merge of rxjava async util','Manual merge of https github com Netflix RxJava pull 704 by cherry picking relevant changes','RxJava pull requests #623 https netflixoss ci cloudbees com job RxJava pull requests 623 SUCCESS This pull request looks good Ugh broke this pull request RxJava pull requests #624 https netflixoss ci cloudbees com job RxJava pull requests 624 FAILURE Looks like there s a problem with this pull request Looks like I got a properly cleaned merge in https github com Netflix RxJava pull 707',RxJava,true,false,false
24893601,'Merge of rxjava async util','Manual merge of https github com Netflix RxJava pull 704','RxJava pull requests #625 https netflixoss ci cloudbees com job RxJava pull requests 625 SUCCESS This pull request looks good',RxJava,true,false,false
24894305,'Combine latest fix','Manual merge of https github com Netflix RxJava pull 616 I would like to get a version of this that doesn t use a lock in the onNext method but have chosen to merge this for now to get the functionality correct and then followup later with a refactor or rewrite when I or someone else has time','RxJava pull requests #626 https netflixoss ci cloudbees com job RxJava pull requests 626 SUCCESS This pull request looks good',RxJava,true,false,false
24903667,'Lotsa javadoc improvements','diagrams for previously undiagram d methods links to wiki docs where available standardizing format nomenclature','RxJava pull requests #627 https netflixoss ci cloudbees com job RxJava pull requests 627 SUCCESS This pull request looks good',RxJava,true,false,false
24907643,'Created new wiki page for the operators in the Async class','adjusted javadoc links accordingly added new sections for previously un wiki documented operators in Async added links to those in javadocs','RxJava pull requests #628 https netflixoss ci cloudbees com job RxJava pull requests 628 SUCCESS This pull request looks good',RxJava,true,false,false
24912373,'Recursion on ExecutorService with 1 Thread is Slow','Recursion on NewThreadScheduler or ExecutorScheduler with 1 thread is fast As number of threads increase in the pool it increasingly slows down My guess is it s adding overhead jumping between threads and or CPUs and thus having cache misses or something along those lines I found this while testing TestRecursionMemoryUsage and trying Schedulers threadPoolForComputation versus Schedulers newThread I confirmed that this changes the performance Executors newScheduledThreadPool 2 vs Executors newScheduledThreadPool 1 The real code uses numCores for that value which is worse We need to look at a way of using a thread pool sized to the number of threads on the machine so we re not launching new threads every time a scheduler is used but that recursion efficiently uses the same thread','Removed ExecutorScheduler and replaced with ComputationScheduler that has a pool of event loops https github com Netflix RxJava pull 1048',RxJava,false,false,false
24928836,'Fix Scheduler Memory Leaks','The NewThreadScheduler CurrentThreadScheduler and ExecutorScheduler all had memory leaks when doing recursion with the Func2 method signature This pull request fixes that along with improving the unit test coverage The fix involved treating outer and inner schedulers differently with inner being the place where recursion happens The memory behavior can be tested using TestRecursionMemoryUsage This fixes the problems reported in https github com Netflix RxJava pull 643 and https github com Netflix RxJava pull 648 but does not change the Scheduler or Subscription interfaces or public implementation details','@headinthebox working on this made me think our work on Outer Inner schedulers may still be worthwhile as the distinction is important in usage particularly for recursion The branch is at https github com benjchristensen RxJava blob scheduler refactor inner outer rxjava core src main java rx Scheduler java#L104 Many if not all of the issues I found were related to treating outer and inner schedulers the same RxJava pull requests #629 https netflixoss ci cloudbees com job RxJava pull requests 629 FAILURE Looks like there s a problem with this pull request Apparently I have some non deterministic tests rx schedulers ExecutorSchedulerTests recursionUsingFunc2 rx schedulers ExecutorSchedulerTests recursionUsingAction0 I ll spend some time looking at them a little later before I merge this If anyone else wants to review or provide guidance on improving this please jump in RxJava pull requests #630 https netflixoss ci cloudbees com job RxJava pull requests 630 FAILURE Looks like there s a problem with this pull request RxJava pull requests #631 https netflixoss ci cloudbees com job RxJava pull requests 631 SUCCESS This pull request looks good',RxJava,true,false,false
24951785,'ExecutorScheduler Concurrency and Performance Issues','The ExecutorScheduler or at least the backing implementation of Schedulers threadPoolForComputation is needed because 1 It allows concurrent execution if used in a pattern other than sequential recursion In other words it doesn t protect against misuse https github com Netflix RxJava pull 712#discussion_r8602294 2 Performance is very bad when doing recursion https github com Netflix RxJava issues 711','Removed ExecutorScheduler and replaced with ComputationScheduler that has a pool of event loops https github com Netflix RxJava pull 1048 I seem to be failing to understand how ComputationScheduler is a replacement for ExecutorScheduler I was using ExecutorScheduler because I needed certain code to run in a certain thread Specifically I was using observeOn so the observer would be executed on the Android main thread I d also be perfectly happy with a scheduler that wraps a scala concurrent ExecutionContext instead as that would be more idiomatic for Scala Is there a way to do either with ComputationScheduler I used it to bound the number of IO requests in progress at the same time to avoid saturating the memory of the receiver on Android I guess I will have to find another way I seem to be failing to understand how ComputationScheduler is a replacement for ExecutorScheduler It s not a direct replacement The ExecutorScheduler had significant problems as this issue discusses Specifically I was using observeOn so the observer would be executed on the Android main thread You should use the AndroidScheduler https github com Netflix RxJava tree master rxjava contrib rxjava android#observing on arbitrary threads as that would be more idiomatic for Scala That should be done as part of rxjava scala https github com Netflix RxJava tree master language adaptors rxjava scala I used it to bound the number of IO requests in progress at the same time This is a valid use case at Netflix we use Hystrix for that server side but that s not helpful for Android I m totally okay with ExecutorScheduler coming back as long as it complies with the contract which it never has It is not obvious how to make it work The concurrent throttling case can be solved in other ways including a Scheduler implementation that has a bounded number of threads but that correctly use event loops on top of each thread I know @akarnokd was experimenting with a fixed side event loop pool that could be used for this If that was adopted into the core library it would probably be something like Schedulers fixedPool int num but the problem with that is it s a factory that produces a new pool every time so users would have to make sure to create it and store a reference to it otherwise it would not work This is quite different from how the other Schedulers are used where the factory methods are invoked every time such as Schedulers io Schedulers computation and Schedulers newThread What do you all think should be done I would like to see the ExecutorScheduler come back without the default thread pool concurrency ExecutorScheduler was the simplest way to delegate scheduling to the glib event loop java public class GlibExecutor implements Executor @Override public void execute @NotNull final Runnable runnable Glib idleAdd new Handler public boolean run runnable run return false It looks like I now have to subclass rx Scheduler directly That seems straight forward enough but the ExecutorScheduler was very nice here',RxJava,false,false,false
24991866,'rxjava computation expressions','The conditional operators are going in this contrib module See https github com Netflix RxJava issues 683','RxJava pull requests #632 https netflixoss ci cloudbees com job RxJava pull requests 632 SUCCESS This pull request looks good',RxJava,true,false,false
24993757,'Add missing type hint to clojure example',#623,'RxJava pull requests #633 https netflixoss ci cloudbees com job RxJava pull requests 633 SUCCESS This pull request looks good',RxJava,true,false,false
24996210,'Scala Adapter Observable trait has only the seed version of scan','In the documentation https github com Netflix RxJava wiki Transforming Observables#scan it says that there are two forms of scan my_observable scan accumulator_closure which seeds with the next value of my_observable and my_observable scan initial_seed accumulator_closure which seeds with initial_seed However the Scala adapter only provides the latter of these two See http rxscala github io scaladoc index html#rx lang scala Observable Is this missing for a reason','I imagine that such a method would look something like scala def scan T accumulator T T T Observable T toScalaObservable T asJavaObservable scan new Func2 T T T def call t1 T t2 T T accumulator t1 t2 Fixed check the code to appreciate the beauty of covariance Hmm I m not exactly sure what you re referring to The last commit affecting https github com Netflix RxJava blob master language adaptors rxjava scala src main scala rx lang scala Observable scala was from 10 days ago In general how would I go about writing a scan without an initial seed @samuela he s referring to this PR https github com Netflix RxJava pull 717 which is not yet merged Awesome thanks',RxJava,false,false,false
25002256,'Added ConnectableObservable','Fixed test Added overload for scan Added trivial test for scan','RxJava pull requests #634 https netflixoss ci cloudbees com job RxJava pull requests 634 SUCCESS This pull request looks good While we re on scan There s a small inconsistency with fold In the Scala collections there are operations called fold reduce and scan which take an associative accumulator and may process the list in any order to improve performance If you want a guaranteed order and or your accumulator is not associative you can use foldLeft foldRight reduceLeft reduceRight scanLeft scanRight But now with Observables only the xxxLeft methods make sense To be very consistent with Scala collections we should thus call them foldLeft reduceLeft and scanLeft and have no operators called fold reduce and scan Or the second option would be to call them just fold reduce and scan since there s only one version per operator so we would have to rename the operator currently called foldLeft to fold',RxJava,true,false,false
25022586,'Implemented the Merge overloads','Hi this PR implemented the overloads of merge in #62 Please take a look','RxJava pull requests #635 https netflixoss ci cloudbees com job RxJava pull requests 635 FAILURE Looks like there s a problem with this pull request RxJava pull requests #636 https netflixoss ci cloudbees com job RxJava pull requests 636 FAILURE Looks like there s a problem with this pull request I checked the failure in the groovy unit tests Here is the problem In the groovy unit test there is an assumption The following Observable groovy Observable merge Observable from 6 Observable error new NullPointerException Observable from 7 should emit 6 and emit a NullPointerException later However my implementation uses from Iterable extends T iterable to create an Observable extends Observable extends T The default scheduler is Schedulers currentThread which make the previous assumption failed As emitting 6 will be delayed so the Observable will only emit a NullPointerException I suppose merge does not need to provide such order guarantee Thoughts Why would 6 be delayed CurrentThreadScheduler doesn t change the order It should subscribe to them in order particularly since there is no concurrency and thus no race conditions here I wanna use the following codes to discuss Java Observable Integer o1 Observable from 6 Observable Integer o2 Observable Integer error new NullPointerException Observable Integer o3 Observable from 7 Observable Integer o Observable merge o1 o2 o3 In this example when we subscribe o the order is subscribe o schedule emit o1 emit o2 emit o3 emit o1 subscribe o1 schedule emit 6 emit o2 subscribe o2 NullPointerException emit o3 subscribe o3 schedule emit 7 emit 6 emit 7 The problem is that Observable error new NullPointerException throws the exception directly when it s subscribed The behavior is like using Schedulers immediate So actually we can say that there are two types of Scheduler involved here If we wanna guarantee the order Observable error new NullPointerException need to be changed to Observable error new NullPointerException Schedulers currentThread Just found using Schedulers currentThread in error still can t fix this problem For the nested merge for example 123 Observable merge 124 Observable from 1 2 3 125 Observable merge 126 Observable from 6 127 Observable error new NullPointerException Schedulers currentThread 128 Observable from 7 129 Observable from 4 5 130 subscribe result a received result exception a error exception The order is 1 2 3 4 5 6 NullPointerException 7 Now I can only find two solutions Do not promise any order Use Schedulers immediate when using from Iterable extends T iterable to create an Observable extends Observable extends T just like the previous merge implementation RxJava pull requests #643 https netflixoss ci cloudbees com job RxJava pull requests 643 SUCCESS This pull request looks good Rebased #724 helped pass the groovy tests I m holding off on this for now as I m stabilizing 0 16 0 for release and am already in the midst of testing on Netflix production canaries I ll review this for 0 16 1 once 0 16 0 is released',RxJava,true,false,false
25024635,'map doesn t work with random numbers','This may be specific to the Scala Adapter or a general issue I m not sure It may also be simply disallowed somewhere in the documentation but I couldn t find anything mentioning it scala val o Observable interval 250 millis map x math random take 10 var id o map x x o subscribe n println n n id subscribe n println id n produces n 0 16257918600676124 id 0 015701253635574397 n 0 65811522451999 id 0 6745847570884935 n 0 08592558068181289 id 0 6761688548540207 n 0 1511738754239501 id 0 37751043543314455 n 0 3335425497156287 id 0 2433811198187099 Of course we expect the values of the two Observables to be equal but they aren t related whatsoever','This behavior is the expected behavior Remove the line var id and replace the line id subscribe by a second o subscribe and you will see that the two outputs are still different The reason is that everywhere in Rx each subscriber gets its own version of the Observable it subscribes to So here each subscriber gets its own Observable interval so x math random is executed seperately for each subscriber If you want several observers to share the same Observable you should use the publish operator You have discovered the distinction between hot and cold observables and the evil that is side effects http www introtorx com content v1 0 10621 0 14_HotAndColdObservables html following up on a previous comment your code should read something like this val start o Observable interval 250 millis map x math random take 10 publish val id o map x x start o subscribe x println s n x id subscribe x println s id x Note that we will be changing the Scala bindings to use ConnectableObservable so while this code work now in the future you would write something like so val observable Observable interval 250 millis map x math random take 10 publish val id observable map x x observable subscribe x println s n x id subscribe x println s id x observable connect Ah gotcha thanks for the clarification',RxJava,false,false,false
25056752,'Added Observable timeout wrappers to scala adapter','Added the four timeout methods on Observable in the Scala adaptor Note for the java scala type interop http stackoverflow com q 20912151','Scala novice here This is untested and needs review @AppliedDuality RxJava pull requests #637 https netflixoss ci cloudbees com job RxJava pull requests 637 SUCCESS This pull request looks good I ll have a look I will be looking at all missing operators in the Scala bindings in the next couple of days LGTM thanks @hura for contributing You re welcome Thanks for clarifying my questions on stackoverflow Now everything is clear and makes sense Cheers Yup I see no problems Merging based on last comment by @headinthebox and review by @samuelgruetter Thanks @hura',RxJava,true,false,false
25066725,'Add groupByUntil operator to scala adapter','I have the following use case I create an observable that streams in timestamped data I would like to aggregate this data into distinct sequences based upon time ranges in which the data arrives first 5 seconds next 5 seconds etc and have it emitted as completed sequences from an observable To be more explicit let s call the type of my timestamped data observable Observable T Using groupBy gives me Observable TimeRange Observable T Next I can perform a map to remove the TimeRange component from grouping tuple Observable Observable T Then I can use toSeq to make the inner most Observable return a single sequence for each group This is where I run into trouble Since the groupBy operator doesn t have a mechanism for closing a group the inner most observables will not emit their sequences until all of my timestamped data has been streamed in Unless I am mistaken there isn t an easy way to do this with the current set of operators the API provides Thoughts EDIT Upon reviewing the documentation there is a function called groupByUntil which appears in rxJava but not in the scala adapter','Can t you just use Observable s scala def buffer timespan Duration Observable Seq T No because I do not necessarily want my data to be streamed in real time The distinction is that def buffer timespan Duration Observable Seq T will only work if my timestamps correspond exactly to the current time My data is streamed in with timestamps attached to it The function above separates the data into groups based upon durations that pass at runtime however I would like to separate my data based upon the time stamps that are part of it s signature As I mentioned in my above edit there is a function groupByUntil which I am fairly certain would solve my problem but it is not yet available in the scala adapter Your problem might also be solved using this overload of buffer java public TOpening TClosing Observable List T buffer Observable extends TOpening bufferOpenings Func1 super TOpening extends Observable extends TClosing bufferClosingSelector The type parameters TOpening and TClosing were recently added and have not yet found their way into the Scala adapter And as you said groupByUntil is also missing Pull requests are welcome Not quite a pull request but here is a solution that works for our purposes scala def bufferByKey T K o Observable T keyFunc T K Observable List T o scan None asInstanceOf Option K List asInstanceOf List T None asInstanceOf Option List T lastState Option K List T Option List T newVal T val lastKey acc emit lastState val nk keyFunc newVal lastKey match case None Some nk newVal acc None case Some k if k nk Some k newVal acc None else Some nk List newVal Some acc flatMap case _ _ None Observable case _ _ Some acc Observable acc reverse I think it would be much nicer to build this into the Java core with the chunking stuff but oh well This solution also won t emit elements from the last change in keys to the closing of the Observable For example scala val o Observable Int Observable 1 to 11 val x bufferByKey o x Int x 3 0 x subscribe x println x x will output x List 1 2 x List 3 x List 4 5 x List 6 x List 7 8 x List 9 Note the absence of 10 and 11 @samuela Nice solution The more I m looking into it it looks like almost every function that is being ported from the rxjava code is just a subset of scan and flatMap For instance def buffer T o Observable T openings T Boolean closings T T Boolean type S Boolean Option T Seq T Boolean o scan S false None Seq false case open first buffered closing elem if open val Some unwrapped_first first val is_closed closings unwrapped_first elem is_closed first elem buffered is_closed else val is_opened openings elem if is_opened is_opened Some elem Seq elem false else is_opened None Seq false flatMap case _ _ buffered closing closing match case true Observable buffered reverse case false Observable @samuelgruetter Have you guys ever thought about replacing some of the other functions in the library with solutions like these it seems like it would be easier for you guys to maintain it looks like almost every function that is being ported from the rxjava code is just a subset of scan and flatMap Theoretically yes and as a general rule we want to use existing operators to build other ones whenever it makes sense In fact that s part of the Rx Design Guidelines from Rx Net Sometimes however it s not very efficient to do this as it involves extra levels of abstraction so we don t do it Another way of viewing this is that on the outside we want to be functional and immutable in nature but on the inside we often use imperative mutable approaches for performance An example is we have started to make some code less elegant and remove abstractions such as the use of Notification T to improve performance by quite a lot All that said I ll be the first to state that all operators in RxJava are not yet implemented to the same degree of quality nor are they all as battle tested as we d like There s a reason we re not yet to a 1 0 release I m not convinced buffer and window are completely correct and certainly not convinced that their performance and implementation is as good as it can be I know groupBy has problems and basically needs a re write Some use a non locking approach others use locks It s the nature of an open source project with a 20 contributors and a team improving it s understanding of the various operators over time We have chosen to optimize for speed of getting functionality coverage of operators into the project and then iterating on improving rather than only allowing 2 or 3 people to slowly try and get through it I was working with @headinthebox Erik Meijer today on an approach for starting to clean up our operator implementations and establish a pattern for all future refactorings and implementations to follow as we are maturing and approaching towards 1 0 now that we ve almost gotten all operators in and have the public API solidifying This will likely involve common patterns for concurrency error handling performance testing etc as right now it s been ad hoc based on who contributed and the intensity of the review done Another example is that operators heavily used by the Netflix API are far more trusted than ones not used at Netflix I hope this provides some background As for this operator missing on the Scala side that should be a very easy contribution and now that 0 16 0 is out which was a big chunk of work we can quickly iterate on new releases I can push 0 16 1 tomorrow if someone wants to submit the PR for adding groupByUntil to Scala @benjchristensen thank you for the explanation It s reassuring to hear a candid report on the state of the project For those of us interested in contributing to the RxJava project is there any documentation on the implementation that we could use to get started In terms of this issue specifically is this a method which you would like to be included and if so would solutions like the one I gave previously be acceptable I suppose that adding such a method to only the Scala adapter might be frowned upon Is this so I suppose that adding such a method to only the Scala adapter might be frowned upon Is this so Our goal is for base functionality to be done in rxjava core so it becomes available to all languages thus we would rather not implement an operator only in one of the language bindings The language bindings should be specific to exposing functionality in an idiomatic manner to that language and or bridging with libraries and techniques of that language Scala Futures for example Thus we d prefer that operators or other common functionality like Schedulers Subscriptions etc be implemented in rxjava core and then exposed in the Scala bindings is there any documentation on the implementation that we could use to get started This Wiki page is a very basic introduction https github com Netflix RxJava wiki How to Contribute It is from the beginning of the project though and I think I need to provide a much more detailed document now that lays out the roadmap to 1 0 plans for graduating language bindings to their own top level projects patterns for operator implementation etc Certainly that makes sense Ok if I get a chance I ll try to put a pull request together for this later Thanks @samuela for your involvement We made good progress in 2013 but still have maturation to do and your help is appreciated @zsxwing Is this done yet If not can you do so in the Scala module I think this can be closed',RxJava,false,false,false
25086356,'Possible Bug in Buffer function','I believe I have found a bug in the below definition def buffer closings Observable Closing Observable Seq T Consider the following code that should be expected to produce an observable of sequences terminated at every even number import the Closing object class import rx lang scala util _ set up a basic observable val start obs Observable interval 250 millis publish prevent the example from going forever val o obs take 10 produce a closing at every even number do not emit otherwise val closings o flatMap case x if x 2 0 Observable Closing else Observable pass the closings observable into the buffer function val buffered o buffer closings print out the results buffered subscribe x println x start When I run this I get strange output and the program locks up Buffer 0 Buffer 1 Buffer 2 Buffer 3 Buffer Buffer Buffer 4 Buffer 5 Buffer Buffer Buffer Buffer Buffer Buffer 6 Buffer Buffer 7 Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer Buffer 8 Buffer Buffer Buffer Buffer 9','I think it s not a bug Note that the Observable Closing function you pass to buffer is called once for each opened buffer and it should return an Observable emitting only 1 Closing object but yours emits many Closing objects This confuses the buffer operator and makes it behave weirdly If you replace the line scala val buffered o buffer closings by scala val buffered o buffer closings take 1 it works as expected but yours emits many Closing objects This confuses the buffer operator and makes it behave weirdly This still might be a bug in buffer If exactly one onNext or onClose is expected then when one of them is fired the closing observable should be unsubscribed For example o buffer interval 1 seconds should unsubscribe from interval after 1 second @akarnokd you re right but I suggest we first should agree on the semantics of buffer The question is Should users be allowed to give an Observable emitting more than 1 closing object Both make sense for me but we should clearly document our choice Ahh thanks for the clarification about it only emitting one Closing The scaladoc currently reads like this for the description of the closings function The function which is used to produce an rx lang scala Observable for every buffer created When this rx lang scala Observable produces a rx lang scala util Closing object the associated buffer is emitted and replaced with a new one Could it be made more explicit that the Observable produces one and only one Closing object I didn t pick up on that when I read through it Additionally I just started working with a more recent version of the repo and encountered more suspicious looking behavior from this example of the buffer function Please correct me if I have a misunderstanding if its use val obs Observable interval 250 millis val o obs take 20 val closings o flatMap case x if x 3 0 Observable items x else Observable items val buffered o buffer closings take 1 buffered subscribe x println x I would expect this code to print out buffers of 3 items however when run I get the following output Buffer 0 Buffer 1 Buffer 2 Buffer 17 Buffer 18 Buffer 19 I believe in the previous example @chrisgrimm meant scala val obs Observable interval 250 millis val o obs take 20 val closings o flatMap case x if x 3 0 Observable items Closing else Observable items val buffered o buffer closings take 1 buffered subscribe x println x I can confirm that it doesn t work More strange behavior on 0 15 1 scala val o Observable 1 to 20 val closings o flatMap case x if x 3 0 Observable Closing else Observable val buffered o buffer closings take 1 buffered subscribe x println x produces Buffer Buffer Buffer Buffer Buffer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @chrisgrimm and @samuela the output of your examples is correct because you forgot to use publish If you have not yet done so you should read about the difference between hot and cold Observables see http www introtorx com content v1 0 10621 0 14_HotAndColdObservables html and note that Observable interval 250 millis and Observable 1 to 20 both are cold Observables and play their items to each subscriber separately Is this still a problem Closing no response in a long time and buffer has had significant bug fixes in recent releases @chrisgrimm and @samuela Please re open if there are still issues',RxJava,false,false,false
25129087,'Deprecate multiple arity from','added @Deprecated annotations where it was only part of the Javadoc deprecated where which is a duplicate of filter kept from early days matching Rx Net See https github com Netflix RxJava issues 686','RxJava pull requests #638 https netflixoss ci cloudbees com job RxJava pull requests 638 SUCCESS This pull request looks good',RxJava,true,false,false
25131019,'Revert use of CurrentThreadScheduler for Observable from','Use ImmediateScheduler as performance is 4x faster and CurrentThreadScheduler currently offers no benefit it doesn t solve the unsubscribe problem Performance numbers Observable from Arrays asList 1L 2L 3L 4L 5L 6L 7L 8L 9L 10L scheduler Schedulers immediate Run 0 1 849 947 ops sec Run 1 2 076 067 ops sec Run 2 2 114 688 ops sec Run 3 2 114 301 ops sec Run 4 2 102 543 ops sec Schedulers currentThread Run 0 548 862 ops sec Run 1 559 955 ops sec Run 2 581 412 ops sec Run 3 562 187 ops sec Run 4 565 723 ops sec Observable from Arrays asList 1L scheduler Schedulers immediate Run 10 4 113 672 ops sec Run 11 4 068 351 ops sec Run 12 4 070 318 ops sec Run 13 4 161 793 ops sec Run 14 4 156 725 ops sec Schedulers currentThread Run 10 1 692 286 ops sec Run 11 1 765 054 ops sec Run 12 1 763 100 ops sec Run 13 1 770 907 ops sec Run 14 1 732 291 ops sec','RxJava pull requests #639 https netflixoss ci cloudbees com job RxJava pull requests 639 ABORTED',RxJava,true,false,false
25131025,'Simpler computation io naming for Schedulers','simpler no one remembers the current names when talking about them does not tie naming to a particular implementation involving thread pools versus a pool of event loops or something similar as we likely will change the implementation see https github com Netflix RxJava issues 713','',RxJava,true,false,false
25136797,'The test has to wait on each action independently','Reduced the size of the iterable because I think it was blowing through the stack','RxJava pull requests #640 https netflixoss ci cloudbees com job RxJava pull requests 640 SUCCESS This pull request looks good Fixed in https github com Netflix RxJava pull 727',RxJava,true,false,false
25143826,'ImmediateScheduler optimization for toObservableIterable','the ImmediateScheduler no longer schedules itself but uses a loop 10 20x faster to use a loop rather than schedule itself recursively','RxJava pull requests #642 https netflixoss ci cloudbees com job RxJava pull requests 642 SUCCESS This pull request looks good',RxJava,true,false,false
25205753,'Scala Adapter Improve the type signature of scan','Currently the type signature looks like scala def scan R initialValue R accumulator R T R Observable R https github com Netflix RxJava blob master language adaptors rxjava scala src main scala rx lang scala Observable scala#L1141 This forces us to write things like scala val x o scan None asInstanceOf Option Int last curr if curr 2 0 Some curr else None instead of simply scala val x o scan None last curr if curr 2 0 Some curr else None I think a better type signature would look something like scala def scan R initialValue _ R accumulator R T R Observable R','The signature scala def scan R initialValue _ R accumulator R T R Observable R is not accepted by the compiler because here R already means _ R For function arguments you can always give an instance of a subtype You probably meant a signature like this scala def scan R I R initialValue I accumulator R T R Observable R This compiles but doesn t solve your problem The problem is that Scala s type inference is not as smart as we would like it to be To work around this problem you just have to give some more typing information but definitely there s no need to do casts Either use an ascription scala val x1 o scan None Option Int last curr if curr 2 0 Some curr else None Or explicitly provide the type parameter scala val x2 o scan Option Int None last curr if curr 2 0 Some curr else None Ah my mistake I had higher expectations for Scala s type inference and wrote that up without testing it at all Thanks for the clarification',RxJava,false,false,false
25290986,'0 16 Build Fails','I m on 72f043e01358ac853ad31b928edde99c50a892b4 and the build fails language adaptors rxjava scala examplesClasses UP TO DATE language adaptors rxjava scala build UP TO DATE rxjava contrib rxjava android compileJava FAILURE Build failed with an exception What went wrong Could not resolve all dependencies for configuration rxjava contrib rxjava android provided Artifact org apache maven wagon wagon provider api 1 0 beta 6@jar not found Try Run with stacktrace option to get the stack trace Run with info or debug option to get more log output BUILD FAILED Total time 18 165 secs Strangely running with the debug option doesn t seem to produce any errors','The project is building https netflixoss ci cloudbees com job RxJava master Perhaps your local grade or maven caches are corrupted probably yet another instance of https github com Netflix RxJava issues 406 Yup for some reason my maven cache was corrupted rm r m2 did the trick Thanks guys',RxJava,false,false,false
25299048,'Improve Error Handling and Stacktraces When Unsubscribe Fails','The stacktraces were a mess when onError failed or was not implemented and unsubscribe also failed That is a far edge case and means code is broken and breaking the Rx contracts but that s just when we need clear stacktraces The CompositeException and SafeObserver class now do a dance and wire together a causal chain to provide a stacktrace that can identity all the points of error Also standardized and simplified the RxJavaPlugin onErrorHandler while working in the vicinity This came about after I was asked to help debug a problem and couldn t do it by looking at the thrown exception I had to use a debugger and step through','RxJava pull requests #644 https netflixoss ci cloudbees com job RxJava pull requests 644 SUCCESS This pull request looks good',RxJava,true,false,false
25318974,'Replaced Thread sleep with CountDownLatch to fix the flaky test failures','Fixed the test failures in https github com Netflix RxJava issues 383#issuecomment 30081304 and #581','RxJava pull requests #645 https netflixoss ci cloudbees com job RxJava pull requests 645 SUCCESS This pull request looks good Thank you',RxJava,true,false,false
25356088,'Ported groupByUntil function to scala adapter','Ported the groupByUntil function to scala adapter This is my first time contributing please let me know if anything is off','RxJava pull requests #646 https netflixoss ci cloudbees com job RxJava pull requests 646 SUCCESS This pull request looks good Thanks @chrisgrimm for contributing Some comments If we add wildcards to the Duration Observable in Java commit https github com samuelgruetter RxJava commit cb8bf8cf75fc0fa696f9c7292aba5c8397e0d6f0 then we can get rid of the cast in Scala commit https github com samuelgruetter RxJava commit d51001c98c8ae3546a8ec0d6ef4c6da00f8e0acf There s an important difference between the signature we have in Java and your signature in Scala In Java the durationSelector gets a GroupedObservable so it can extract the key if it wants to do so but in Scala it only gets an Observable so it cannot know the key When we add an operator to the Scala Observable we usually also add an example to RxScalaDemo https github com Netflix RxJava blob master language adaptors rxjava scala src examples scala rx lang scala examples RxScalaDemo scala These examples needn t test the functionality because that s already done in Java but they test the signature If you can write a meaningful example then your signature is good And these examples are also a useful piece of documentation @samuelgruetter Okay cool I ll amend my changes to reflect these comments shortly If you get these changes in today I ll release tomorrow Tuesday US time @benjchristensen Sorry for the delay I just woke up I added the example changed the groupByUntil operator so that the conversion in the scala adapter wasn t necessary and changed the signature of the closings function to include the key of the group in question RxJava pull requests #666 https netflixoss ci cloudbees com job RxJava pull requests 666 SUCCESS This pull request looks good Thanks @chrisgrimm',RxJava,true,false,false
25387363,'Buffer with Observable boundary','Mentined in Issue #653 1 overload where the user can specify the capacity of the internal buffer','RxJava pull requests #647 https netflixoss ci cloudbees com job RxJava pull requests 647 SUCCESS This pull request looks good',RxJava,true,false,false
25391845,'Delay with subscription and item delaying observables','Listed in #653 Note onError and onCompleted events of the source are immediately propagated and will prevent emitting any pending values','RxJava pull requests #648 https netflixoss ci cloudbees com job RxJava pull requests 648 SUCCESS This pull request looks good RxJava pull requests #660 https netflixoss ci cloudbees com job RxJava pull requests 660 SUCCESS This pull request looks good',RxJava,true,false,false
25394914,'Window with Observable boundary','Listed in issue #653','RxJava pull requests #649 https netflixoss ci cloudbees com job RxJava pull requests 649 SUCCESS This pull request looks good',RxJava,true,false,false
25398724,'MergeMap with Iterable and resultSelector overloads','Listed in #653','Forgot an overload RxJava pull requests #650 https netflixoss ci cloudbees com job RxJava pull requests 650 SUCCESS This pull request looks good RxJava pull requests #651 https netflixoss ci cloudbees com job RxJava pull requests 651 SUCCESS This pull request looks good Looks these operators can be implemented by composing the existing operators I agree there is likely some simplification we can do on this but I m going to merge as the public APIs look correct and unit tests are good We can iterate on the implementation internally',RxJava,true,false,false
25416596,'Weird behaviour of switch when the outer sequence completes but the last inner still has elements','Hi all I just ran into a behavior of switch as of RxJava 0 16 0 that I don t think is correct When the outer sequence completes but the last inner sequence that the operator was subscribed to still has some elements I d expect the operator to either also complete immediately or pass on the rest of the elements in the inner sequence and complete when the inner sequence completes However the output of the code below makes me think that neither is the case with the current implementation When I try to run scala import rx lang scala Observable import rx lang scala schedulers NewThreadScheduler import scala concurrent duration import duration _ val source Observable Observable String Observable items Observable interval 200 milli NewThreadScheduler map a _ toString take 10 Observable interval 200 milli NewThreadScheduler map b _ toString take 10 zip Observable interval 500 milli NewThreadScheduler map _ _1 val items source switch toBlockingObservable toList println items it prints at least for me List a 0 a 1 b 0 b 1 b 2 b 3 b 4 b 5 b 6 That seems correct for the a s two of them fit into the 500 milli window but why there were 6 b s emitted I don t understand and it seems to me as quite an arbitrary number Thank you for any insights Best regards Tom Dvo k','Confirm this is a bug in switch I see another issue The op uses MultipleAssignmentSubscription to store the inner subscription When the switch to the next occurs it does not unsubscribe from the previous Observable which will keep running indefinitely I think child should be SerialSubscription instead latest does not need volatile as it s protected by synchronized gate and never used outside the lock Sorry @akarnokd you re right The initial step is not thread safe If latest is not volatile latest can not be guaranteed to be 0 I was wrong didn t see the synchronized Btw instance initialization esures that the latest field is seen to be 0 no need for volatile While you are at it could you move any unsubscribe outside the synchronization block Just refreshed my java concurrency knowledge latest is ensured to be 0 by synchronized rather than instance initialization Right When you call new SourceObserver the constructor is guaranteed to make fields visible From JSR 133 3 5 Final Fields a thread that can only see a reference to an object after that object has been completely initialized is guaranteed to see the correctly initialized values for that object s nal elds http download oracle com otn pub jcp memory_model 1 0 prd oth G F memory_model 1_0 prd spec pdf AuthParam 1389609770_22e201e49d67d0a8ae6bcaccaedd8518 the constructor is only guaranteed to make final fields visible However I don t know if the default value 0 of a non final field will be visible to other threads If publication is not safe then there is no happens before relationship between the assignment of the instance s fields and its unsafe publication If the instance contains final fields then Java inserts a memory barrier at the end of the constructor and publication is ensured to be safe From JLS 17 4 4 Synchronization Order http docs oracle com javase specs jls se7 html jls 17 html#jls 17 4 4 The write of the default value zero false or null to each variable synchronizes with the first action in every thread Although it may seem a little strange to write a default value to a variable before the object containing the variable is allocated conceptually every object is created at the start of the program with its default initialized values So if a field is the default value zero false or null and does not be assigned the default value is always visible to every thread The buffer operator has been rewritten with extra effort for making sure values don t fall between two windows if timespan timeshift Does it work for you Closing as no further comments in a long time This is likely fixed with the recent fixes to buffer @dvtomas Please re open if there are still issues',RxJava,false,false,false
25439925,'Publish and PublishLast overloads','Listed in #653 These operators use the existing multicast and subject infrastructure so I omitted any direct tests','RxJava pull requests #652 https netflixoss ci cloudbees com job RxJava pull requests 652 SUCCESS This pull request looks good RxJava pull requests #653 https netflixoss ci cloudbees com job RxJava pull requests 653 SUCCESS This pull request looks good',RxJava,true,false,false
25440650,'Debounce with selector','Listed in #653','RxJava pull requests #654 https netflixoss ci cloudbees com job RxJava pull requests 654 SUCCESS This pull request looks good',RxJava,true,false,false
25441473,'Timeout with selector overloads','Listed in #653','RxJava pull requests #655 https netflixoss ci cloudbees com job RxJava pull requests 655 SUCCESS This pull request looks good',RxJava,true,false,false
25442544,'Zip with iterable removed old aggregator version and updated tests','Listed in #653','RxJava pull requests #656 https netflixoss ci cloudbees com job RxJava pull requests 656 SUCCESS This pull request looks good These are instance methods none of our zip operators are at the instance level I would have thought we d add the zip overloads with Iterable to match the existing static ones I went according to #653 where there was 2 zip overloads without strike through Agreed on the overloads but they should be static correct No The intention was to chain them to an existing observable java Observable from 1 2 3 zip Arrays asList 4 5 6 a b a b Makes sense wasn t sure as it was different than all the other zip methods Thanks for confirming',RxJava,true,false,false
25443746,'Build with Gradle 1 10','Required that the IDE plugins also be applied to the root because of the improved Scala support with the IDEA plugin','The main benefit of the upgrade besides the usual performance improvements etc is the fix for http issues gradle org browse GRADLE 2709 RxJava pull requests #657 https netflixoss ci cloudbees com job RxJava pull requests 657 SUCCESS This pull request looks good Thanks @alkemist',RxJava,true,false,false
25462304,'Replaces AtomicReference with a length 1 array','This patch replaces the usage of an AtomicReference in BlockingObservable forEach to hold an exception set from within a closure with an array of length 1 thus avoiding the cost of the memory barriers issued when the AtomicReference s internal volatile field is accessed','This might not worth it since exceptions will be set only once RxJava pull requests #658 https netflixoss ci cloudbees com job RxJava pull requests 658 SUCCESS This pull request looks good Prefer the previous one too IMO AtomicReference is clearer An AtomicReference is usually used for different kinds of problems To just get around the compiler disallowing mutability of captures variables I think this approach is actually more intuitive Can you provide metrics on performance memory improvements for this change If this change is indeed material then it should be part of an overall improvement to the library not just this single location From my point of view this is not thread safe There is a reason why AtomicIntegerArray exists http stackoverflow com questions 2236184 how to declare array elements volatile in java Memory visibility of the reference to the array is guaranteed to be up to date for all threads because the field is final But writes to the array are not thread safe because array individual fields are not accessed with volatile semantics It is provably thread safe Notice that lach countdown has a happens before relationship with latch await I ll provide the metrics as soon as I have some free time You re right i forgot to look at entire source watching just diff instead I would rather use an Exchanger although it s a single way exchange a synchronousQueue or a settable future You can even implement your own AbstractQueuedSynchronizer But my first rule for optimizations is Don t optimize And my second one Optimize if you found a performance hog by profiling the issue and demonstrate it with a unit test first',RxJava,true,false,false
25474530,'Observable interface','The core purposes of the Observable type visitation of elements detection of completion and detection of errors are currently tangled with a set of fluent utility methods This tangling makes the core contract of observability harder to understand and it makes sub typing less straightforward and less flexible To resolve this situation I have refactored an interface out of Observable which I have tentatively dubbed IObservable Ideally the interface itself would be called Observable and the class FluentObservable See Guava s FluentIterable alongside the JDK s Iterable for another example of this pattern However I did not want to break backward compatibility All public methods now accept IObservable instead of Observable in their argument lists while those that returned Observable continue to do so This pattern gives the best of both worlds any IObservable implementation can be used anywhere Observable and its subclasses can and we don t lose the convenience of the fluent API In particular any IObservable can be converted into an Observable via the new method Observable from IObservable This change should be 100 backwards compatible at compile time though the changed signatures mean that it is not backwards compatible at the binary level I have observed a number of breaking API changes on master over the last few weeks so hopefully that is not a deal breaker If it is we can always restore overloads that accept Observable in addition to IObservable but that seemed like a pretty large amount of duplication and complexity for a small benefit so I have not done it so far','RxJava pull requests #659 https netflixoss ci cloudbees com job RxJava pull requests 659 SUCCESS This pull request looks good The library originally had an Observable interface and associated implementation It was removed because in practice it does not work due to all methods hanging off of Observable 100 methods on an interface all needing complex implementations and by design intended to comply with a specific contract made alternate implementations impractical and thus the interface was noise If we had extension methods like C# we would design it with a pure interface like Rx Net but Java doesn t support that Observables should not be created via inheritance they are created via Observable create Thus the OnSubscribeFunc is the light weight interface anything can implement and then become an Observable for application of operators I agree that an interface with hundreds of methods would be ungainly and inappropriate It would also not meet the goal of separating the core contract of observability from the utility methods and it is not what I have done In my opinion if observability cannot be expressed as concisely as iterability the API has room for improvement The IObservable interface contains only a single method subscribe Observer Please review my first commit https github com rickbw RxJava commit bcb2a6049a4f823225b85da2f3f0000db2c0ab5a I think you will see what I mean Here s an example class MyObservable implements IObservable String public Subscription subscribe Observer super String ob return new MySubscription IObservable String obs new MyObservable Observable from obs multicast For another example of the same pattern see http docs guava libraries googlecode com git javadoc com google common collect FluentIterable html The reason that OnSubscribeFunc works as well as it does is that it does what an I Observable interface itself should do My next task will be to replace OnSubscribeFunc with IObservable This should be trivial since the only difference between them is a difference in the method name subscribe vs onSubscribe Look for an update to this pull request soon One could argue that having the separate OnSubscribeFunc is also unnecessary as the single parameter callback could be done via Func1 Observer super T Subscription If you look at my reactive4java library I implemented it with Observable interface and static methods on the Reactive class This was later extended to have an ObservableBuilder to allow the fluent usage However after joining RxJava I can now see that merging all these things into a class based Observable is a better choice even Java 8 default methods can t really compete with it What are you trying to achieve from this change There is very little value in an IObservable interface with a single subscribe method on it The value of rx Observable is all the operators not the simple pub sub interfaces If there is just an IObservable publish everyone ends up working with Observable and ignoring the IObservable otherwise they always have to convert from IObservable to Observable That s what we had in our code base at Netflix originally and the interface was useless and a nuisance RxJava pull requests #672 https netflixoss ci cloudbees com job RxJava pull requests 672 FAILURE Looks like there s a problem with this pull request I have completed replacing OnSubscribeFunc with IObservable I will resolve the merge conflicts next Ben you write that there is little value in an observable interface with a single subscribe method on it Yet in the master branch that is exactly what OnSubscribeFunc is and the whole API is built on it Likewise the value in the Java Collections API isn t in the Iterable interface which is just hasNext and next yet the entire library is built on it So I don t see it as a question of moving or removing value I see it as a question of the separation of concerns When I hear that Iterable is a good tool for building incremental pull based algorithms I go to the docs and I see a concise API that I can immediately understand When I hear that Observable is a push based Iterable analog I go to the docs and see dozens of methods related and unrelated My goal is to make the API easier to understand and compose by separating concerns the ability to observe something is different from what algorithms you might devise if you had the ability to do so IObservable is the former Observable is the latter The fluent API has not been sacrificed in any way in fact it is lighter and easier to understand now Previously some operations provided Observable s and others provided OnSubscribeFunc s This was frustrating since the documentation for Observable create OnSubscribeFunc said that OnSubscribeFunc was required to behave just like Observable itself anyway and the latter objects had to be wrapped in the former So the code was full of stuff like create op create arg2 create arg2 create arg3 Now all operators return IObservable s of one concrete type or another and they can all be composed in the same way so you can just write op arg1 arg2 arg3 I understand the concern about having to constantly wrap stuff and I can t speak to your code base But I can say from working with the RxJava code base that I have actually removed a lot more calls to Observable create OnSubscribeFunc than I have added calls to Observable from IObservable In fact many operators no longer depend on Observable at all anymore because all they need to do is subscribe My goal is to make the API easier to understand and compose by separating concerns Please give me an example of something that doesn t compose today the Iterable interface which is just hasNext and next Practically no code ever exposes or uses Iterable directly It is always a List or Collection that is used I understand the concern about having to constantly wrap stuff Returning IObservable from application code is not the solution as that means all code bases will have to wrap it into an Observable for it to be any use I have completed replacing OnSubscribeFunc with IObservable I will resolve the merge conflicts next Please don t spend time on this while there is still not agreement on the approach being taken What you are suggesting be changed is something we actively moved away from over a year ago thus it would require several people all deciding to reverse course I am also not happy with the IObservable interface convention That is non idiomatic in Java We have purposefully not included the I in front of interfaces such as Observer Scheduler Subscription as that is a Net convention not Java Lastly the possible migration to using bind would further change this discussion and certainly the implementation https github com Netflix RxJava issues 746 Returning IObservable from application code is not the solution Agreed I am _not_ suggesting returning IObservable instead of Observable and have not made any such change I am very much in favor of the fluent API and would not want to damage it I _am_ suggesting _accepting_ IObservable in place of Observable in argument lists I am also suggesting returning IObservable in place of OnSubscribeFunc since the latter is already required to behave exactly like Observable anyway Please give me an example of something that doesn t compose today For example see OperationCombineLatestTest in master which looks like this Observable String combineLatestW Observable create combineLatest Observable create w1 Observable create w2 Observable create w3 getConcat3StringsCombineLatestFunction combineLatestW subscribe w and in this pull request which looks like this IObservable String combineLatestW combineLatest w1 w2 w3 getConcat3StringsCombineLatestFunction combineLatestW subscribe w As you can see objects which are required to behave like observables can now actually be used as observables There are not more wrapper objects there are fewer Of course you ll have to tell me the extent to which your application code resembles your test code Practically no code ever exposes or uses Iterable directly That s an interesting perspective it s not my experience I ve used Iterable frequently at a couple of different employers It s great for incremental processing of medium to large data sets where you want to encourage clients to process elements one at a time and discourage waiting for a large fetch to happen and loading the whole result set into memory I am also not happy with the IObservable interface convention Agreed I wanted something short that suggested that the object met the core contract of observability and I couldn t come up with anything better If we come to an agreement on the approach then it will be trivial to change the name to whatever you like Thanks for your engagement on this request Re bind you re right that it would have significant implications for the specifics of the API However the general approach of distinguishing the fundamental contract in Observable and accepting any object with that contract in create and other methods would be unchanged From what I see in your gist the fundamental operation would no longer subscribe Observer T it would be observe Observer T Func0 OperatorSubscription You ve redefined the former in terms of the latter Therefore observe is what I d want to extract into an interface Your proposed successor to OnSubscribeFunc is Action2 Observer T OperatorSubscription Once again there is a near perfect symmetry between the input output signature for that type and for the fundamental method of Observable itself You ve designed APIs for Observable with that symmetry twice now I must be on to something The only difference is that there seems to be some discussion around whether observe should accept OperatorSubscription or Func0 OperatorSubscription I would suggest that whichever you choose you keep the argument to create and the signature of observe consistent with each other That is go with either Action2 Observer T Func0 OperatorSubscription and observe Observer T Func0 OperatorSubscription or Action2 Observer T OperatorSubscription and observe Observer T OperatorSubscription Considering the current state of the master branch what would you propose to be done differently The signatures are now this java Observable create public final static T Observable T create OnSubscribe T f Observable OnSubscribe typed function interface public static interface OnSubscribe T extends Action1 Observer super T lift function public R Observable R lift final Func1 Observer super R Observer super T bind Observer public abstract class Observer T implements Subscription public abstract void onNext T t public abstract void onError Throwable e public abstract void onCompleted public final void add Subscription s public final void unsubscribe public final boolean isUnsubscribed Subject public abstract class Subject T R extends Observer T public abstract Observable R toObservable Bear with me because I haven t been able to follow all of the reasoning that has gone into the changes in between when last we talked and the current state We might have to iterate here But here are my thoughts I think notionally there s an object that represents a stream of data Observable an object that consumes that data Observer and a third that represents that association between them that is the state of the stream Subscription If we analogize with iteration an Observable is like an Iterable an Observer is like the block of code inside the for loop and a Subscription is like the state of the iteration you can start iterating and you can stop iterating whenever you want even if the data stream has more elements in it Each of these objects has a really simple job to do so it should be possible to describe each with an interface of just a couple of methods When you write a for loop there s a moment when you start the stream by passing the block of code to execute for each element Therefore Observable needs a method to start pushing data that accepts the Observable subscribe Like in a loop that block of code can exit the iteration any time so the Observable needs to be passed the Subscription as well as the data Unlike in a loop the stream may deliver elements asynchronously so the party that started the iteration may also want to stop the iteration therefore subscribe should also _return_ the Subscription All that yields the following java Note similarities to cancellation of Futures public interface Subscription void unsubscribe boolean isUnsubscribed public interface Observer T void onNext T t Subscription s Could pass Subscription here too but by definition iteration is ending void onError Throwable e void onCompleted public interface Observable T Subscription subscribe Observer super T o Then you need a concrete class to provide a library of useful methods for operating on Observable s in a fluent API style If I were starting the API from scratch I would call this FluentObservable because it s descriptive and its analogous to Guava s FluentIterable with which I m quite familiar I would accept plain interface Observable s in the argument lists of this class to make the API as flexible as possible and I would return FluentObservable to make chaining as easy as possible That yields java public class FluentObservable T implements Observable T private Observable super T delegate initialize in constructor not shown Replaces create OnSubscribe public static FluentObservable T from Observable super T delegate return argument if already Fluent else return new wrapper public X FluentIterable X combineInSomeWay Observable X other Lots more Your lift method would be unchanged I think Subscription add looks like a Composite design pattern trying to get out I would define a CompositeSubscription class that implements Subscription and also composes other Subscription s and handles the multiplexing among them Subject doesn t add any concrete implementation so I would make it also an interface extending the Observer interface but otherwise unchanged from what you ve shown Is that description clear What do you think Thank you for the detailed thoughts on this I agree with your assessment that Observable Observer and Subscription have very simple clear definitions at their core and that their jobs are pretty straight forward Where I view things differently is that the Observable interface is of little value in practice if it is solely this java public interface Observable T Subscription subscribe Observer super T o Everyone would end up using FluentObservable only which defeats the purpose of the Observable interface Remember that we started the library like that We literally had IObservable and Observable matching what Rx Net has But since we don t have extension methods it doesn t work With Observable containing only subscribe no API will ever return it like this java public Observable getData They will instead return the type that creates all the value java public FluentObservable getData otherwise all consumption would end up being java FluentObservable from getData map instead of java getData map On real world code with dozens of API calls all returning Observable T this becomes a mess of FluentObservable from getter everywhere in the code Thus what you re actually describing is equivalent to what we now have as Observable OnSubscribe your Observable interface Observable FluentObservable No API deals in or returns Observable OnSubscribe which then forces Observable create being performed The OnSubscribe type is an internal type not a public API type which is what Observable is used as In other words APIs return Observable like this java public Observable SomeData getData return Observable create new OnSubscribe SomeData @Override public void call Subscriber super SomeData o o onNext new SomeData o onCompleted They do not return the function java public OnSubscribe SomeData getDataFunction return new OnSubscribe SomeData @Override public void call Subscriber super SomeData o o onNext new SomeData o onCompleted as it would then need to be turned into an Observable before it s usable Now if these types were being baked into the JDK my position would be different on having a base interface as it would be a fixed signature that could never be changed once released and all libraries would be interoperating via the same interfaces with different implementations For this library however the interface and implementation will always go together and there is not a common lingua franca between libraries for what represents an Observable Interop between libraries will always require a bridge like the FluentObservable from Within the library though it should work as cleanly as possible with as few types as possible These perspectives and the experience of having tried separate interface implementation have shaped the design of RxJava and are why we choose for the abstract class Observable being the core class of the library that is intended for exposure in library APIs and user code and not a simple interface that needs to be wrapped to use Considering these reasons what specifically are you trying to achieve by making OnSubscribe become the major interface everyone builds APIs against instead of the concrete Observable with all the operators on it I d like to understand the use cases you re pursuing I m evaluating RxJava for a proposed data access layer primarily but not necessarily over HTTP REST for eHarmony That layer would be used in many projects by multiple teams so I want to make sure that the API building blocks are as clean and simple as possible for the sake of usability but also of training and understanding You re right that OnSubscribeFunc is the equivalent of what I am calling IObservable My proposal boils down to 1 moving this to a top level type 2 renaming it and renaming onSubscribe to subscribe 3 making Observable implement that type and 4 changing argument lists to accept that type Given that I m not sure I understand what you mean when you say that such an interface has no value and is an internal type My understanding is that absolutely every RxJava user implements OnSubscribeFunc many times and every time they do they have to call a wrapper method to use their class Is that an incorrect impression Regarding those wrapper methods i e Observable create OnSubscribeFunc in master I have counted the calls in the version of master I last merged and in my branch My branch contains 292 calls master contains more than twice as many 664 Let me turn it around a little if I may You clearly recognize the value of a simple one method interface for your users to implement because you ve given them one OnSubscribeFunc The documentation around this interface mostly attached to Observable create requires that it obey the exact same contract as Observable with respect to subscribing Given that what is the benefit of keeping those two types in separate type hierarchies when consolidating them into one requires no change in behavior and has the potential to eliminate a substantial number of wrapper calls I think we can set aside concerns about returning interfaces and about large interfaces requiring extension methods since no one is proposing those approaches at this time Thanks Here is what the API has become as of 0 17 0 to achieve the lift and Subscriber benefits More are likely coming to support continuations async await style java public final static T Observable T create OnSubscribe T f Invoked when Obserable subscribe is called public static interface OnSubscribe T extends Action1 Subscriber super T Operator function for lifting into an Observable public interface Operator R T extends Func1 Subscriber super R Subscriber super T public final Subscription subscribe Subscriber super T observer what is the benefit of keeping those two types in separate type hierarchies Even if Observable implemented OnSubscribe someone still needs to wrap OnSubscribe to become an Observable since Java doesn t support extension methods thus to get the behavior of Observable the inner function which we call OnSubscribe has to be put inside the Observable type Closing this so it no longer is on the pull request page but I m okay continuing the discussion Regarding those wrapper methods i e Observable create OnSubscribeFunc in master I have counted the calls in the version of master I last merged and in my branch My branch contains 292 calls master contains more than twice as many 664 These will almost all go away with the use of lift Thanks for your detailed thoughts in this discussion I think the 0 17 API has the capabilities it needs to be useful If I were writing it I probably wouldn t have decomposed those capabilities the same way e g the current API has even more places where user supplied code and library supplied code are blended into a single type that seems like a code smell to me However the distance from one point to the other is now greater than it was when I started this endeavor so I think my differences of opinion are largely moot at this point I will continue to use RxJava gladly and I look forward to contributing in other ways in the future',RxJava,true,false,false
25485388,'Fixed issue #737','Fixed issue #737 Moved the onCompleted logic under the condition latest id','RxJava pull requests #661 https netflixoss ci cloudbees com job RxJava pull requests 661 SUCCESS This pull request looks good RxJava pull requests #662 https netflixoss ci cloudbees com job RxJava pull requests 662 SUCCESS This pull request looks good Thanks @zsxwing',RxJava,true,false,false
25542375,'Proposal Bind Operator','Over the past couple months several sources of inspiration have trigged the idea of adding a bind operator to Observable I have played with an implementation and propose we adopt it for RxJava but want to get feedback on signatures and find out if there are any use cases I m completely missing that would negate the idea ### Benefits ##### 1 Synchronous Unsubscribe The primary benefit of this proposal is that synchronous Observables can be unsubscribed This means an infinite sequence of integers without a separate thread could now be used A large Iterable followed by take 20 would actually only emit the first 20 This is achieved by injecting Subscription into what we today call Observable OnSubscribeFunc instead of it being returned by the function An Observable of this nature would check the Subscription inside its loop such as this java Obsurvable Integer OBSERVABLE_OF_INFINITE_INTEGERS Obsurvable create new Action2 Observer Integer OperatorSubscription @Override public void call Observer Integer o OperatorSubscription s int i 1 while s isUnsubscribed o onNext i o onCompleted ##### 2 Custom Operator Chaining Because Java doesn t support extension methods the only approach to applying custom operators without getting them added to rx Observable is using static methods This has meant code like this java MyCustomerOperators operate observable map filter take 5 map subscribe In reality we want java observable map filter take 5 myCustomOperator map subscribe Using bind we can get quite close to this java observable map filter take 5 bind MyCustomOperator operate map subscribe Here is how the proposed bind method looks if all operators were applied with it java Obsurvable String os OBSERVABLE_OF_INFINITE_INTEGERS bind TAKE_5 bind MAP_INTEGER_TO_STRING ##### 3 Simpler Operator Implementations The bind operator injects the necessary Observer and Subscription instances and eliminates for most use cases the need for manual subscription management Because the Subscription is available in scope there are no awkward coding patterns needed for creating a Subscription closing over it and returning and taking into account synchronous vs asynchronous For example fromIterable is simply java public static T Obsurvable T from final Iterable T is return Obsurvable create new Action2 Observer T OperatorSubscription @Override public void call Observer T o OperatorSubscription s for T i is if s isUnsubscribed break o onNext i o onCompleted s unsubscribe The take operator is java public static class TakeOperator T implements Func2 Observer T OperatorSubscription Observer T final int limit TakeOperator int limit this limit limit @Override public Observer T call final Observer T o final OperatorSubscription s if limit 0 o onCompleted s unsubscribe return new Observer T int count 0 @Override public void onCompleted o onCompleted @Override public void onError Throwable e o onError e @Override public void onNext T i if s isUnsubscribed o onNext i if count limit o onCompleted s unsubscribe ##### 4 Eliminate Need for CurrentThreadScheduler A side effect of injecting the Subscription and handling synchronous execution is we can now use loops instead of trampolining for operators like repeat This means we should not need the CurrentThreadScheduler as far as I can tell and the ugliness it takes to make synchronous unsubscribes work Here is the repeat operator without need for scheduling java public static class RepeatOperator T implements Func2 Observer T OperatorSubscription Observer Obsurvable T RepeatOperator @Override public Observer Obsurvable T call final Observer T o final OperatorSubscription s return new Observer Obsurvable T @Override public void onCompleted o onCompleted @Override public void onError Throwable e o onError e @Override public void onNext Obsurvable T ot while s isUnsubscribed ot f call o s ##### 5 Recursion Loop Performance The fromIterable use case is 20x faster when implemented as a loop instead of recursive scheduler see https github com Netflix RxJava commit a18b8c1a572b7b9509b7a7fe1a5075ce93657771 Many places recursive scheduling were used to avoid stack overflow can be done as a loop instead ### Drawbacks ##### 1 Observable create Signature Change Currently the Observable create method is defined as java public static T Observable T create OnSubscribeFunc T func This is effectively the same as java public static T Observable T create Func1 Observer super T Subscription func To inject the Subscription we need it to instead be java public static T Obsurvable T create Action2 Observer super T Subscription f Note that there is not return type any longer the Subscription is injected instead of returned Then to support operators conditionally attaching themselves to the injected Subscription the signature is actually java public static T Obsurvable T create final Action2 Observer super T OperatorSubscription f The OperatorSubscription simply adds void add Subscription s so each operator can register with it as needed ### Prototype Code The prototype code can be found at https gist github com benjchristensen 8367765 The name of the class is Obsurvable and this code can be dropped into the rx package as Obsurvable java alongside Observable java for testing ### Design Decisions If we agree that this proposal make sense there are some design decisions to make ##### 1 Action2 Func2 or New Type Right now the prototype code has this java public static T Obsurvable T create final Action2 Observer super T OperatorSubscription f public R Obsurvable R bind final Func2 Observer R OperatorSubscription Observer T bind Should we create types that represent those I think the create one probably should for the same reason as before to simplify the pain of dealing with generics Thus it would be OnSubscribeFunc OnSubscribe or something similar For the bind method I m less opinionated though it may be cleaner to provide a type that represents the Func2 I did play with a variant of this that combined Observer and OperatorSubscription into a single type Operator to make the function simpler but it conflated things and was quite troublesome with composition as the Observer and Subscription had different lifecycles and intents ##### 2 Private Subscribe for Nested Observables If you look at the MergeOperator code you ll see inside the onNext Obsurvable T innerObservable that it has this code java innerObsurvable f call observer s This is reaching inside the Obsurvable to the private field f and invoking it This is equivalent to calling Obsurvable subscribe except that it inject the Subscription rather than returning it I still want the normal Subscription Observable subscribe Observer o signature for public consumption but am considering whether we should have a an alternate public signature for subscription that looks like void Observable otherSubscribe Observer o Subscription s b a private mechnism that operator implementations can somehow subscribe not sure yet how without these only being implemented inside Observable itself I tend to prefer b so we don t leak implementation details but a would allow anyone to create even the more complicated nested operators such as merge outside of Observable java ##### 3 OperatorSubscription Name Is this name okay Where should it live Is its signature correct ##### 4 Observable create Should we deprecate or keep the current signature If it exists alongside the new one and both have the create name accepting a single function it will break Groovy and Clojure and probably JRuby as they won t be able to distinguish between overloads Thus it likely is best to just do the breaking change cleanly and have a single create method with the new signature Is there any reason to have the old signature that returns Subscription instead of accepting it as an argument ### Operator Refactor If we adopt this pattern it will take some time to retrofit all operators to use bind In Observable java they would be coded something like this using bind java public R Obsurvable R flatMap Func1 T Obsurvable R f return bind new MapOperator T Obsurvable R f bind new MergeOperator R public Obsurvable T take int num return bind new TakeOperator T num Each operator would need to be changed to this new model I suggest we leverage this to do other cleanup such as eliminate unnecessary synchronization use of volatile Atomic Concurrent locking etc eliminate unnecessary object allocation such as Notification or use of materialize add a new src perf folder and add a performance test for each operator implementation similar to https github com Netflix RxJava blob master rxjava core src test java rx schedulers SchedulerPerformanceTests java and https github com Netflix RxJava blob master rxjava core src test java rx subjects SubjectPerformanceTests java rename each operator from Operation to Operator as a marker of which have been migrated and to read better and match the package name come up with standard approaches for concurrency when it is needed such as state machines recently applied to Schedulers and Subscriptions I d appreciate feedback and improvement Thanks','For feedback cc @headinthebox @abersnaze @samuelgruetter @jmhofer @mairbek @zsxwing @akarnokd @michaeldejong @johnhmarks @duarten @rickbw After the first look it definitely solves the take n problem as the downstream take can now access the cancellation token for the upstream btw loops should exit with return instead of break in case of isUnsubscribed However external users are still unable to cancel the long running operation as subscribe won t return the subscription until it has finished One would need to have an overload where the cancellation token is passed in from the outside as well or a binding which leaks the OperatorSubscription java OperatorSubscription os new OperatorSubscription Schedulers computation schedule os unsubscribe 1 TimeUnit SECONDS Obsurvable from 1 repeat subscribe os new Observer T void But it doesn t work at the moment as from 1 unsubscribes the os and repeat can t really repeat it it prints 1 and two onCompleted If I remove the unsubscribe and change repeat to not emit onCompleted it works as expected and honors the RxJava contract better see https gist github com akarnokd 8415495 and https gist github com akarnokd 8415517 After the modification it appears to me that we replace one problem with another now one would need to carefully isUnsubscribed almost everywhere and think twice when to call unsubscribe I like this approach It keeps the user facing behaviour the same while allowing for a simpler implementation After a first look it seems that upstream operators shouldn t be able to unsubscribe downstream operators So bind would change to java public R Obsurvable R bind final Func2 Observer R OperatorSubscription Observer T bind return new Obsurvable R new Action2 Observer R OperatorSubscription @Override public void call Observer R o OperatorSubscription s OperatorSubscription s2 new OperatorSubscription s add s2 f call bind call o s s2 Take can unsubscribe from all the upstream operators but these can unsubscribe Take which would be notified through onComplete We can write merge like so java @Override public void onNext Obsurvable T innerObsurvable Subscription innerSubscription innerObsurvable subscribe new Observer T outerSubscription add innerSubscription We already have to protect against onNext calls arriving after a call to onCompleted and unsubscribe so first subscribing to the inner observable and then adding the inner subscription to the composite won t introduce any new interleaving This seems to allow for option 2 b while also allowing people to create arbitrary nested observables or am I missing something We can write merge like so Each of the inner Observable instances can also be synchronous which would make the call to subscribe block and thus we would never receive the Subscription back I think we may just want to provide a subscribe overload or new name such as java public final void subscribe Observer super T observer OperatorSubscription s or public final void observe Observer super T observer OperatorSubscription s I think I d prefer the different name observe I m not super concerned with discoverability as it s incredibly rare that someone would need to be building an operator of this type and in that case they re reading the docs and complying with the create bind observe semantics external users are still unable to cancel the long running operation as subscribe won t return the subscription until it has finished I have yet to see actual use code where they use the Subscription received from subscribe It s more or less a sign they are doing it wrong if they need to as they should instead be using things like take and takeUntil particularly takeUntil for conditional cases for ending Observables The only time I m aware of a Subscription from subscribe being used for valid reasons is when building operators to combine Observables together and in that case we are saying to use bind instead See the previous comment for thoughts on exposing the private subscribe publicly for the rare case of building a new operator beyond merge concat zip switch etc for nested behavior After the modification it appears to me that we replace one problem with another now one would need to carefully isUnsubscribed almost everywhere and think twice when to call unsubscribe How is this any different than now We currently have to very carefully consider where to place a Subscription what to put within it and what manual cancellation tokens usually a boolean we have to check while in loops that will be set by that Subscription we return I see the consideration exactly the same I also don t see it as any more sensitive about when to call unsubscribe It has the same impact as our current approach does As soon as you call it everything is supposed to shut down So how do we have to think twice in one approach but not in the other On top of that with the current implementation we have to deal with the fact that the approach doesn t work for synchronous use cases and we have to keep answering questions from people as to why their code doesn t behave as they expect and we keep telling them use Schedulers which in effect means Rx is only useful if all data sources is async or small enough to not be a problem which kind of defeats the purpose However this is actually only half the answer as in Rx Net those synchronous cases work by putting everything on a recursive CurrentThreadScheduler and interweaving through the code base hacks to modify tokens similar or equal to ThreadLocal state that then stop the recursion See my benefits 4 and 5 for why this new approach to create bind seems far better than that Thus if we don t use this bind approach we have to accept slower behavior for all recursion and figure out how to make CurrentThreadScheduler work I spent time implementing it and it was basically whack a mole with hacks in multiple places in the codebase to capture an unsubscribe and set it on a ThreadLocal so CurrentThreadScheduler could see that it had been unsubscribed and stop recursion This is fairly straight forward when on a single thread It all becomes far more difficult when crossing over thread boundaries or when nesting Observables and different Schedulers in a single Observable sequence After a first look it seems that upstream operators shouldn t be able to unsubscribe downstream operators So bind would change to I need to play with this a bit to better understand and will then respond Each of the inner Observable instances can also be synchronous which would make the call to subscribe block and thus we would never receive the Subscription back Right I forgot about that case The overload taking a subscription factory seems like the better approach then The MergeOperator would end up like this java public void onNext Obsurvable T innerObsurvable innerObsurvable subscribe new Observer T @Override public void onCompleted synchronized o o onCompleted @Override public void onError Throwable e synchronized o o onError e @Override public void onNext T a synchronized o o onNext a new Func0 OperatorSubscription @Override public OperatorSubscription call OperatorSubscription innerSubscription new OperatorSubscription outerSubscription add innerSubscription return innerSubscription Using a subscribe method like this java public void subscribe Observer T o Func0 OperatorSubscription sf f call o sf call It s a little unnecessary for a private operator doing the right thing and involves closing over the outerSubscription but it does provide a safe public signature Updated prototype code with observe method https gist github com benjchristensen 8367765 This would make the create bind observe methods siblings for creating operators Thus an Observable is observed by an Observer and the OperatorSubscription is always injected The public signature of Observable subscribe is unchanged I ve implemented zip with this new paradigm and it felt a bit odd java public U R Obsurvable R zip Obsurvable U other Func2 T U R resultSelector Obsurvable T t this return Obsurvable create o s Object guard new Object Queue T leftQueue new LinkedList Queue U rightQueue new LinkedList AtomicBoolean leftDone new AtomicBoolean AtomicBoolean rightDone new AtomicBoolean OperatorSubscription tsub new OperatorSubscription OperatorSubscription usub new OperatorSubscription s add tsub s add usub Action0 stride boolean done false synchronized guard while leftQueue isEmpty rightQueue isEmpty s isUnsubscribed try o onNext resultSelector call leftQueue poll rightQueue poll catch Throwable e o onError e s unsubscribe return if s isUnsubscribed if leftQueue isEmpty leftDone get rightQueue isEmpty rightDone get done true o onCompleted if done s unsubscribe t observe new Observer T @Override public void onNext T args synchronized guard leftQueue offer args stride call @Override public void onError Throwable e synchronized guard o onError e s unsubscribe @Override public void onCompleted synchronized guard leftDone set true stride call tsub other observe new Observer U @Override public void onNext U args synchronized guard rightQueue offer args stride call @Override public void onError Throwable e synchronized guard o onError e @Override public void onCompleted synchronized guard rightDone set true stride call usub And a test method java Obsurvable from 1 repeat take 10000 zip Obsurvable from 2 repeat take 5 a b a b take 2 subscribe System out println Which again doesn t work with the reference repeat as it should not call onCompleted once its upstream calls it because it will continue with subscribing to it again Once fixed the above example works The oddity comes from where and what to call unsubscribe on is this okay java OperatorSubscription tsub new OperatorSubscription OperatorSubscription usub new OperatorSubscription s add tsub s add usub And should I call tsub unsubscribe in the first observer onCompleted or s unsubscribe It s probably unrealistic to assume that all of the operations can be rewritten in one pull request This method will allow existing operators that use OnSubscribeFunc to still work java public static X Obsurvable X create final OnSubscribeFunc X onSub return create new Action2 Observer X OperatorSubscription @Override public void call Observer X in OperatorSubscription s Subscription sub onSub onSubscribe in s add sub @akarnokd Here is another implementation of zip as comparison https gist github com benjchristensen 8367765#file obsurvable java L340 The only place an unsubscribe is invoked is here https gist github com benjchristensen 8367765#file obsurvable java L417 There are no places where it must be checked The most interesting unit test for this is testZipInfiniteAndFinite as it must unsubscribe the children https gist github com benjchristensen 8367765#file obsurvable java L491 The thing that makes this work is that whenever a subscription occurs via observe the Subscription is injected into it and applies to the entire lifecycle of that subscription This can be seen here java os i observe InnerObserver observers i new Func0 OperatorSubscription @Override public OperatorSubscription call return childSubscription This could be simplified to the following if we want to make a user have to do the right thing when using it java os i observe InnerObserver observers i childSubscription The same childSubscription is injected into all Obsurvables being zipped together so a single unsubscribe will cause them all to be unsubscribed as each of them will be looking at the same Subscription wherever applicable such as a ObsurvableFromIterable loop @akarnokd I think the root of your zip problems comes from the use of Observable create and not this bind For last couple days I ve been working on building on this to build a visual debugger of sorts for Rx Because of the OperatorSubscription add method it allows the association between inner and outer observers to be discovered aka merge Here is a sample the raw data that I was able to get with three hooks on create on bind and on add for the code from 1 3 5 flatMap i from i i 1 take 3 subscribe print it obsurdebug https f cloud github com assets 406038 1937976 59c177bc 7f38 11e3 9134 b209dd40a767 png In the current API the fundamental thing you do with an observable object is _subscribe_ to it by passing an observer and getting a subscription back You can invoke that behavior on Observable itself with subscribe Observer or you can inject that behavior _into_ Observable with Observable create and OnSubscribeFunc onSubscribe Observer Either way the signature and the contract are exactly the same In the proposed new API the fundamental thing you do is _observe_ by passing in both an observer and a subscription You can invoke that behavior with observe Observer T Func0 OperatorSubscription or inject it with Action2 Observer T OperatorSubscription call Except that you ve lost the symmetry of the current API I would either go with Action2 Observer T Func0 OperatorSubscription and observe Observer T Func0 OperatorSubscription or with Action2 Observer T OperatorSubscription and observe Observer T OperatorSubscription But don t mismatch the signatures Otherwise we ll find ourselves constantly writing closures to convert OperatorSubscription into Func0 OperatorSubscription I think you might be right about the Func0 being unnecessary My current workspace is too far removed from the base line its hard to say for sure but I was able to remove the Func0 implementations and it still work for my use case While implementing various operators I ran into groupBy which required a signature change on bind to compose the Subscriptions It s working though I m not convinced the signature is as elegant as it can be The prototype code is still here https gist github com benjchristensen 8367765 It has grown to include bind map flatMap merge take zip groupBy and repeat There are unit tests for these asserting behavior including handling infinite synchronous streams composed subscriptions and general functionality I have also split out a simpler example ObsurvableBind java with just the bind operator and a small number of unit tests for necessary functionality to simplify discussion of and iterating on the bind signature https gist github com benjchristensen 8486461 The essential parts of the code are currently java public static T ObsurvableBind T create final Action2 Observer T OperatorSubscription f return new ObsurvableBind T f public void observe Observer T o OperatorSubscription sf f call o sf public Subscription subscribe Observer T o final OperatorSubscription os new OperatorSubscription observe o os return os public static interface Operator T extends Observer T public OperatorSubscription getSubscription public R ObsurvableBind R bind final Func2 Observer R OperatorSubscription Operator T bind return new ObsurvableBind R new Action2 Observer R OperatorSubscription @Override public void call Observer R o final OperatorSubscription s Operator T ot bind call o s observe ot ot getSubscription This achieves the generally desired traits but I d like to see if we can come up with a better way of representing the Func definition of bind The public void testBindUnsubscribeNested unit test represents the groupBy type functionality that requires nested composition of Subscriptions Here is another possible variant of the signature https gist github com benjchristensen 8497234 Instead of Func2 Observer R OperatorSubscription Operator T it uses Func1 Operator R Operator T java public static T ObsurvableBind2 T create final Action1 Operator T f return new ObsurvableBind2 T f public R ObsurvableBind2 R bind final Func1 Operator R Operator T bind return new ObsurvableBind2 R new Action1 Operator R @Override public void call Operator R o observe bind call o public void observe Operator T o f call o public Subscription subscribe final Observer T o final OperatorSubscription os new OperatorSubscription observe createOperator o os return os public static interface Operator T extends Observer T Get the Subscription intended to pass up to the source being bound to p In other words the subscription from Operator Source public OperatorSubscription getSubscription Here is another variant https gist github com benjchristensen 8506432 This eliminates the OperatorSubscription and the Operator becomes an abstract class instead of interface java public static abstract class Operator T implements Observer T Subscription private final CompositeSubscription cs Operator CompositeSubscription cs this cs cs Operator this cs new CompositeSubscription Used to register an unsubscribe callback public final void add Subscription s cs add s @Override public final void unsubscribe cs unsubscribe public final boolean isUnsubscribed return cs isUnsubscribed The create bind observe signatures stay the same java public static T ObsurvableBind3 T create final Action1 Operator T f return new ObsurvableBind3 T f public R ObsurvableBind3 R bind final Func1 Operator R Operator T bind return new ObsurvableBind3 R new Action1 Operator R @Override public void call Operator R o observe bind call o public void observe Operator T o f call o @rickbw Are these different variants solving your concerns What improvements would you make to their signatures and which do you prefer @duarten I believe these new signatures address the problem you brought up regarding the passing of Subscription The unit tests combining groupBy and take assert the particular use case public static abstract class Operator T implements Observer T Subscription This I like On Sun Jan 19 2014 at 4 44 PM Ben Christensen notifications@github com wrote Here is another variant https gist github com benjchristensen 8506432 This eliminates the OperatorSubscription and the Operator becomes an abstract class instead of interface public static abstract class Operator T implements Observer T Subscription private final CompositeSubscription cs Operator CompositeSubscription cs this cs cs Operator this cs new CompositeSubscription Used to register an unsubscribe callback public final void add Subscription s cs add s @Override public final void unsubscribe cs unsubscribe public final boolean isUnsubscribed return cs isUnsubscribed The create bind observe signatures stay the same public static T ObsurvableBind3 T create final Action1 Operator T f return new ObsurvableBind3 T f public R ObsurvableBind3 R bind final Func1 Operator R Operator T bind return new ObsurvableBind3 R new Action1 Operator R @Override public void call Operator R o observe bind call o public void observe Operator T o f call o @rickbw https github com rickbw Are these different variants solving your concerns What improvements would you make to their signatures and which do you prefer @duarten https github com duarten I believe these new signatures address the problem you brought up regarding the passing of Subscription The unit tests combining groupBy and take assert the particular use case Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 746#issuecomment 32711145 This thread blessed me with the following insight If we look at the pull oriented Iterator java interface Iterator T boolean hasNext T next and try to find its push oriented dual we get something like java interface PushIterator T boolean wantsNext void onNext T void onError Throwable void onComplete which is basically the same as @benjchristensen s java public static abstract class Operator T implements Observer T Subscription where wantsNext isUnsubscribed That said I like the Operator idea but I think the naming can be improved Operator is not general enough I can also imagine use cases where I d use an Operator instead of an Observer without my Operator really being an operator in the sense that it transforms an Observable Moreover the name Subscription makes sense if it s returned by a call to subscribe but if I create a Subscription myself and pass it to the subscribe method this name is not very intuitive any more I ve not yet any good naming suggestion I do not think PushIterator is a good name but I m thinking Your dual is not correct interface PushIterator T boolean wantsNext void onNext T void onError Throwable void onComplete boolean Where onComplete would be called before onNext with false and ultimately with true Which means you can ignore the boolean and only call it when you d call it with true On Sun Jan 19 2014 at 7 08 PM samuelgruetter notifications@github com wrote This thread blessed me with the following insight If we look at the pull oriented Iterator interface Iterator T boolean hasNext T next and try to find its push oriented dual we get something like interface PushIterator T boolean wantsNext void onNext T void onError Throwable void onComplete which is basically the same as @benjchristensen https github com benjchristensen s public static abstract class Operator T implements Observer T Subscription where wantsNext isUnsubscribed That said I like the Operator idea but I think the naming can be improved Operator is not general enough I can also imagine use cases where I d use an Operator instead of an Observer without my Operatorreally being an operator in the sense that it transforms an Observable Moreover the name Subscription makes sense if it s returned by a call to subscribe but if I create a Subscription myself and pass it to the subscribe method this name is not very intuitive any more I ve not yet any good naming suggestion I do not think PushIterator is a good name but I m thinking Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 746#issuecomment 32714958 Samuel the subscription comes from the IDispoable which is not in the Java Iterable interface Yes it solves that problem I like it Anyone interested in this please take a look at the pull request I just submitted @headinthebox and @samuelgruetter I could use your help fixing the Scala module Thanks everyone for your discussion on this I have merged the implementation Next steps are 1 Nail down naming and signatures https github com Netflix RxJava issues 775 2 Document a README or Wiki page operator implementation standards guidelines and best practices 3 Update operator implementations over time Sorry for chiming in late I m a bit all over the place these days and some of the latest developments in the project slipped past me I ll comment here w r t #770 as well I read the proposal and I like the suggested changes Once concern I have is that observers now have to extend an abstract class In Java it s quite intrusive if a library or a framework forces super classes on you since it lacks multiple inheritance We had a few components in our app that would behave like observers but inherited from Android framework classes This was quite nice since they would provide the glue between the Android framework and our Rx based client code We now have to convert these to observers first by delegating to an inner class which makes their public API a bit awkward More problematic though is test friendliness Maybe I m missing something but a very common recipe that we adopted in dozens of unit tests is the following Observer mockObserver mock Observer class obj getObservable subscribe mockObserver ArgumentCaptor Observer onNextArgs ArgumentCaptor of verify mockObserver onNext onNextArgs capture do expecations against onNextArgs This is not possible anymore since SafeObserver into which all external observers get wrapped requires a valid subscription in a private final field something that a mock object cannot provide FWIW Mockito @Spy s work but it might not be wise to rely on spies Maybe this could at least be mitigated by providing a non final getter for the subscription which SafeObserver queries At least then we d be able to return a subscription for the mock that SafeObserver can accept Ben also pointed me to TestObserver which can be used as a wrapper to query arguments Neither solution strikes me as very elegant though Sorry I ll have to work more with the current code base to get a deeper impression just wanted to throw this as a first impression of sorts Thanks @mttkay for getting involved and providing feedback I too have similar concerns about Observer become abstract and I m still considering the pros and cons of the change but thus far have come to see abstract Observer implements Subscription as being the best of the proposed designs For unit tests your code would need to change like this java Observer mockObserver mock Observer class obj getObservable subscribe new TestObserver mockObserver ArgumentCaptor Observer onNextArgs ArgumentCaptor of verify mockObserver onNext onNextArgs capture do expecations against onNextArgs Going back to the discussion on signatures in https github com Netflix RxJava issues 775 the choice is basically to either a change Observer to an abstract class and have a single type b create a new type that combines Observer and Subscription and is used in the create OnSubscribe and lift signatures but not subscribe At this point the strongest argument has been to keep the public API clean and have a single Observer type that works in all cases The drawback of this approach though is the impact on multiple inheritance and unit testing The current signatures are java Observable create public final static T Observable T create OnSubscribe T f Observable OnSubscribe typed function interface public static interface OnSubscribe T extends Action1 Observer super T lift function public R Observable R lift final Func1 Observer super R Observer super T bind Observer public abstract class Observer T implements Subscription public abstract void onNext T t public abstract void onError Throwable e public abstract void onCompleted public final void add Subscription s public final void unsubscribe public final boolean isUnsubscribed Subject public abstract class Subject T R extends Observer T public abstract Observable R toObservable Anyone have a better design than this This code demonstrates what the new signatures allow java Observable create new OnSubscribe Integer @Override public void call Observer super Integer ob for int i 1 i 100000 i The Observer communicates whether it is unsubscribed so loops and seqential processing on the same thread can now unsubscribe if ob isUnsubscribed System out println Unsubscribed at i return ob onNext i ob onCompleted subscribe new Observer Integer @Override public void onCompleted System out println Completed @Override public void onError Throwable e e printStackTrace @Override public void onNext Integer i System out println Received i if i 10 an Observer can now unsubscribe unsubscribe This outputs Received 1 Received 2 Received 3 Received 4 Received 5 Received 6 Received 7 Received 8 Received 9 Received 10 Unsubscribed at 11 Note how the source Observable can check ob isUnsubscribed and the Observer can now unsubscribe all within a single threaded sequential call This is equally beneficial if the Observable is made async by running on a separate thread but still a sequential for loop instead of trampolining which is far slower than a loop and both less obvious and more complicated to implement java Observable create new OnSubscribe Integer @Override public void call Observer super Integer ob for int i 1 i 100000 i The Observer communicates whether it is unsubscribed so loops and seqential processing on the same thread can now unsubscribe if ob isUnsubscribed System out println Unsubscribed at i return ob onNext i ob onCompleted use subscribeOn so it is now async subscribeOn Schedulers newThread subscribe new Observer Integer @Override public void onCompleted System out println Completed @Override public void onError Throwable e e printStackTrace @Override public void onNext Integer i System out println Received i if i 10 an Observer can now unsubscribe unsubscribe This means we do want the Observer to be more intelligent and encapsulate the Subscription so we achieve these goals Unit testing is doable by using TestObserver and I m okay with that being slightly less elegant The remaining drawback is the inability to implement Observer since it is now abstract A relevant question is whether classes need to implement Observer so as to be an Observer We do not support this on Observable classes are not an Observable but generally have getters that return an Observable or a class has a toObservable method on it Similarly classes do not need to be an Observer but can encapsulate that logic That said there may still be value in having an interface that represents something that can be turned into an Observer Right now Observable has that with the Observable OnSubscribe interface Should we have something similar for Observer If so what should it be called Observer OnObserve We either need a new name for Observer Subscription the currently modified Observer and return Observer to just the 3 on methods and a mechanism for converting from it to the Observer Subscription Or we leave Observer as Observer Subscription and come up with a different name to represent the interface of the 3 on methods Thanks for the write up Ben I do agree this is very desirable So an Observer s role is an active one now it can unsubscribe rather than just a passive one it receives notifications That s fine and Observer is still a good name I m less happy with the fact that Observer is a Subscription now just in terms of naming but anyway I see how this makes sense implementation wise I usually name interfaces after the behavior they enable If we reintroduce an interface that resembles what Observer used to be I d vote for something along the lines of Notifiable or NotificationReceiver to reflect that the interface captures the behavior of being able to receive Rx notifications OnObserve sounds like a single callback to an observe function so that might be misleading Just my thoughts Can t we provide a default implementation of Observer like this Java public abstract class Observer T implements Subscription public abstract void onNext T t public abstract void onError Throwable e public abstract void onCompleted protected Subscription subscription default implementation for Subscription public final void add Subscription s subscription add s public final void unsubscribe subscription unsubscribe public final boolean isUnsubscribed return subscription isUnsubscribed Can t we provide a default implementation of Observer like this That is how it is implemented https github com Netflix RxJava blob master rxjava core src main java rx Observer java If we go this path an interface Notifiable could work since we already have the Notification type java public abstract class Observer T implements Subscription Notifiable Or we could leave Observer as the passive object that receives notifications and use Subscriber to represent the thing that calls subscribe and it would implement Observer and Subscription Note that if we went to having Subscriber and Observer we d then have the question of whether we allow Observable subscribe Observer o because if we did those implementations could not unsubscribe That is probably fine though as most Observer s don t need to unsubscribe Thus we could have methods like this in Observable java void subscribe Subscriber s Subscription subscribe Observer o I did an implementation using Subscriber to see if it makes sense Please provide feedback on issue https github com Netflix RxJava issues 792',RxJava,false,false,false
25553353,'Organize Format Alphabetize and Finalize','Code cleanup after the many new operators that have come in over the past 2 months 1 Organized imports 2 Formatted all code for standard whitespace code formatting etc 3 Sorted methods in Observable java alphabetically 4 Updated all license headers 5 Made Observable methods final as they are not intended to be overridden in the rare cases when inheritance makes sense for Observable This better communicates the inheritance intent of the class and prevents against accidental misuse such as overriding subscribe which breaks it Anyone have issues with any of these changes I figure 5 will be the most controversial','RxJava pull requests #663 https netflixoss ci cloudbees com job RxJava pull requests 663 SUCCESS This pull request looks good',RxJava,true,false,false
25555483,'StackOverflowError is swallowed','The following code should have thrown StackOverflowError java final PublishSubject Integer a PublishSubject create final PublishSubject Integer b PublishSubject create a subscribe new Observer Integer @Override public void onCompleted @Override public void onError Throwable e e printStackTrace @Override public void onNext Integer args System out println args b subscribe new Observer Integer @Override public void onCompleted @Override public void onError Throwable e e printStackTrace @Override public void onNext Integer args System out println args a subscribe new Observer Integer @Override public void onCompleted @Override public void onError Throwable e e printStackTrace @Override public void onNext Integer args b onNext args 1 b subscribe new Observer Integer @Override public void onCompleted @Override public void onError Throwable e e printStackTrace @Override public void onNext Integer args a onNext args 1 a onNext 1 However StackOverflowError is swallowed The problem is the following line in SafeObserver https github com Netflix RxJava blob 0b1b6e7a91d89ad63263b80747f0bd4683fe4ba2 rxjava core src main java rx operators SafeObserver java#L117 java RxJavaPlugins getInstance getErrorHandler handleError e When StackOverflowError is thrown there is few stack space However this line will generate too big stack frame and cause the thread crash If I comment out this line I can observe StackOverflowError Reported by Samuel at https groups google com forum # topic rxjava eraZ 32w1gQ','The proper fix seems to be to immediately re throw any VirtualMachineError by introducing a more specialized catch Not surprised we ended up with something like this happening after migrating from Exception to Throwable https github com Netflix RxJava issues 296 I agree @duarten that SafeObserver should catch and re throw at least the VirtualMachineError class of errors http docs oracle com javase 7 docs api java lang VirtualMachineError html Any others we should include ThreadDeath looks fun The LinkageError exceptions also seem like we should never catch them http docs oracle com javase 7 docs api java lang LinkageError html Maybe it s better not to catch any of the Error subclasses http docs oracle com javase 7 docs api java lang Error html Re throwing the Error still has a problem when Schedulers io is involved The Error will be swallowed by the ExecutorService In general not caching Error and Throwable is worse than catching them as in an async system that means they are being thrown on some random thread in the background won t call onError and thus can lock up a system since an Observable won t be terminated So it may only be the StackOverflow case that needs to be special cased since it is a unique case of an infinite loop that means we won t ever successfully exit But swallowing them is not good either and then that will put the onus on the users to re throw those exceptions because there s really no way to handle them If there are uncaught Errors won t the JVM shutdown if there are non daemon threads Interestingly Scala defines a NonFatal exception as scala object NonFatal def apply t Throwable Boolean t match case _ StackOverflowError true StackOverflowError ok even though it is a VirtualMachineError case _ VirtualMachineError _ ThreadDeath _ InterruptedException _ LinkageError _ ControlThrowable _ NotImplementedError false case _ true which they use in their Futures library to check if it should be handed to the user for handling It won t be swallowing them they are or should all be passed via onError to the user provided Observer StackOverflow is swallowed because of a recursive loop Sorry my point is that users may not be expecting to be handed such exception and may swallow them themselves by for example just logging them The correct behaviour IMHO would be to let them bring down the JVM asap Background on Throwable being caught and emitted via onError can be seen here https github com Netflix RxJava issues 296 The Scala definition seems good I think we should follow that same logic for defining something Fatal and immediately re throwing it as opposed to passing via onError That sounds good Just found the a potential problem in this method java protected void _onError Throwable e try RxJavaPlugins getInstance getErrorHandler handleError e actual onError e catch Throwable e2 e2 printStackTrace if e2 instanceof OnErrorNotImplementedException onError isn t implemented so throw https github com Netflix RxJava issues 198 Rx Design Guidelines 5 2 when calling the Subscribe method that only has an onNext argument the OnError behavior will be to rethrow the exception on the thread that the message comes out from the observable sequence The OnCompleted behavior in this case is to do nothing try subscription unsubscribe catch Throwable unsubscribeException RxJavaPlugins getInstance getErrorHandler handleError unsubscribeException throw new RuntimeException Observer onError not implemented and error while unsubscribing new CompositeException Arrays asList e unsubscribeException throw OnErrorNotImplementedException e2 else throw since the Rx contract is broken if onError failed https github com Netflix RxJava issues 198 RxJavaPlugins getInstance getErrorHandler handleError e2 try subscription unsubscribe catch Throwable unsubscribeException RxJavaPlugins getInstance getErrorHandler handleError unsubscribeException throw new RuntimeException Error occurred when trying to propagate error to Observer onError and during unsubscription new CompositeException Arrays asList e e2 unsubscribeException throw new RuntimeException Error occurred when trying to propagate error to Observer onError new CompositeException Arrays asList e e2 if we did not throw about we will unsubscribe here if onError failed then unsubscribe happens in the catch try subscription unsubscribe catch RuntimeException unsubscribeException RxJavaPlugins getInstance getErrorHandler handleError unsubscribeException throw unsubscribeException If RxJavaPlugins getInstance getErrorHandler handleError e throws a Throwable RxJavaPlugins getInstance getErrorHandler handleError e2 also may throw one So there may be a recursive loop Is it necessary to make a distinction between Throwables from RxJavaPlugins getInstance getErrorHandler handleError e and actual onError e A thought to solve the swallowed StackOverflowError can we call actual onError e before RxJavaPlugins getInstance getErrorHandler handleError e Just dig deeply and found StackOverflowError is swallowed by SafeObserver In this example there are 4 observers and wrapped by 4 SafeObservers Here I call them so1 so2 so3 so4 in order When the StackOverflowError is thrown the thread call stack is something like so1 onNext so4 onNext so3 onNext so4 onNext so3 onNext so4 onNext Next so1 onError throw a new StackOverflowError from RxJavaPlugins getInstance getErrorHandler handleError e2 so4 onNext so3 onNext so4 onNext so3 onNext so4 onNext Next so4 onNext so3 onNext so4 onNext so3 onNext so4 onNext Next so4 onError throw a new StackOverflowError from RxJavaPlugins getInstance getErrorHandler handleError e2 so3 onNext so4 onNext so3 onNext so4 onNext Next so3 onNext so4 isFinished true onNext so3 onNext so4 isFinished true onNext Next so3 onError throw a new StackOverflowError from RxJavaPlugins getInstance getErrorHandler handleError e2 so4 isFinished true onNext so3 isFinished true onNext so4 isFinished true onNext Next so4 isFinished true onError StackOverflowError is swallowed here so3 isFinished true onNext so4 isFinished true onNext Here StackOverflowError is sent to so4 onError again so4 will swallow it since isFinished is true So if RxJavaPlugins getInstance getErrorHandler handleError e always throw an error actual onError e will be skipped No matter what we do in the catch clause e g throw some special error it will be swallowed by SafeObserver Dealing with in pull request https github com Netflix RxJava pull 839 Should be fixed in https github com Netflix RxJava pull 839',RxJava,false,false,false
25558684,'Separated Android test code from source','Moved the nested test classes in the android contrib code into a separate test folder The unit test dependencies were making ProGuard sad causing it to complain about missing libraries','RxJava pull requests #664 https netflixoss ci cloudbees com job RxJava pull requests 664 SUCCESS This pull request looks good Thank you for contributing',RxJava,true,false,false
25578980,'Provide Observable timestamp Scheduler in scala','Currently it s possible to use Observable timestamp Scheduler in java but not in scala','This has been added https github com Netflix RxJava blob master language adaptors rxjava scala src main scala rx lang scala Observable scala#L361',RxJava,false,false,false
25579456,'Provide Observable timestamp Scheduler to be used in the tests','The test could ve used toBlockingObservable but this hangs even though timestamped observable is completed','RxJava pull requests #665 https netflixoss ci cloudbees com job RxJava pull requests 665 SUCCESS This pull request looks good @samuelgruetter please review I d also change 2 overloads to the one Observable timestamp s Option Scheduler None but I m not sure it s ok to break binary compatibility RxJava pull requests #671 https netflixoss ci cloudbees com job RxJava pull requests 671 SUCCESS This pull request looks good LGTM thanks for contributing Regarding The test could ve used toBlockingObservable but this hangs even though timestamped observable is completed That s not surprising You can t use toBlockingObservable and TestScheduler in a single threaded test because you would have to call advanceTimeTo while you re blocking on a method of BlockingObservable And regarding scala Observable timestamp s Option Scheduler None Don t do this we want to keep it the same way in all operators But I agree that the way overloads with schedulers are done currently is not good Scala offers much better ways with implicits We re still working on this and will change all operators at once @samuelgruetter Thanks for reviewing Actually my naive attempts at eliminating the overloads failed because of existential types causing troubles Maybe it would be possible to eliminate existentials as well in favor of abstract types Just saying though haven t thoroughly tried it myself From the Scala folks should this be updated and merged considered the changes that have happened in the past month @headinthebox @samuelgruetter This can be merged but once we decide on https github com Netflix RxJava issues 815 it will change again I would appreciate a way to have a timestamped stream unit tested If this is not with Scheduler parameter I m fine',RxJava,true,false,false
25630922,'Organize Format Alphabetize and Finalize','Code cleanup after the many new operators that have come in over the past 2 months 1 Organized imports 2 Formatted all code for standard whitespace code formatting etc 3 Sorted methods in Observable java alphabetically 4 Updated all license headers 5 Made Observable methods final as they are not intended to be overridden in the rare cases when inheritance makes sense for Observable This better communicates the inheritance intent of the class and prevents against accidental misuse such as overriding subscribe which breaks it','RxJava pull requests #667 https netflixoss ci cloudbees com job RxJava pull requests 667 SUCCESS This pull request looks good',RxJava,true,false,false
25631311,'modify ReplaySubject with specified capacity to comply with original reactive extensions behaviour','modify ReplaySubject with specified capacity to comply with original reactive extensions behaviour the capacity of ReplaySubject specifies maximum element count of the replay buffer code https rx codeplex com SourceControl latest#Rx NET Source System Reactive Linq Reactive Subjects ReplaySubject cs test https rx codeplex com SourceControl latest#Rx NET Source Tests System Reactive Tests Linq Subjects ReplaySubjectTest cs','RxJava pull requests #668 https netflixoss ci cloudbees com job RxJava pull requests 668 FAILURE Looks like there s a problem with this pull request RxJava pull requests #669 https netflixoss ci cloudbees com job RxJava pull requests 669 FAILURE Looks like there s a problem with this pull request RxJava pull requests #670 https netflixoss ci cloudbees com job RxJava pull requests 670 SUCCESS This pull request looks good Hi not really necessary as OperationReplay replayBuffered allows this but it is not in the public API area @benjchristensen could a rx subject Subjects utility class collect all subject factory methods from the other subjects I agree the initialCapacity isn t meant for bounded buffering This is where the confusion comes from I am writing the same application on both iOS ReactiveCocoa and Android RxJava The different behaviours of ReplaySubject with capacity is confusing ReplaySubject on ReactiveCocoa https github com ReactiveCocoa ReactiveCocoa blob master ReactiveCocoaFramework ReactiveCocoa RACReplaySubject m I think it is good to keep the behaviour consistent across different platforms following the original Net reactive extensions design ReplaySubject should behave the same as Rx Net Any different behavior is a mistake could a rx subject Subjects utility class collect all subject factory methods from the other subjects Are you referring to something like this java Subjects createAsync Subjects createBehavior Subjects createPublish Subjects createReplay Subjects createReplayBuffered size Subjects createReplayBuffered size time However in this case the following seems clearer java AsyncSubject create BehaviorSubject create PublishSubject create ReplaySubject create ReplaySubject createBuffered size ReplaySubject createBuffered size time In general I prefer the latter On Subscriptions it does not offer factory methods for each Subscription impl it is still each class that has it s own factory methods such as BooleanSubscription create The Subscriptions factories are generic all returning Subscription Are there generic things that belong on a Subjects class Thank you @wangsha for getting involved I believe we have all of the replay functionality available on Observable java ConnectableObservable T replay R Observable R replay Func1 super Observable T extends Observable R selector R Observable R replay Func1 super Observable T extends Observable R selector int bufferSize R Observable R replay Func1 super Observable T extends Observable R selector int bufferSize long time java util concurrent TimeUnit unit R Observable R replay Func1 super Observable T extends Observable R selector int bufferSize long time java util concurrent TimeUnit unit Scheduler scheduler R Observable R replay Func1 super Observable T extends Observable R selector int bufferSize Scheduler scheduler R Observable R replay Func1 super Observable T extends Observable R selector long time java util concurrent TimeUnit unit R Observable R replay Func1 super Observable T extends Observable R selector long time java util concurrent TimeUnit unit Scheduler scheduler R Observable R replay Func1 super Observable T extends Observable R selector Scheduler scheduler ConnectableObservable T replay int bufferSize ConnectableObservable T replay int bufferSize long time java util concurrent TimeUnit unit ConnectableObservable T replay int bufferSize long time java util concurrent TimeUnit unit Scheduler scheduler ConnectableObservable T replay int bufferSize Scheduler scheduler ConnectableObservable T replay long time java util concurrent TimeUnit unit ConnectableObservable T replay long time java util concurrent TimeUnit unit Scheduler scheduler ConnectableObservable T replay Scheduler scheduler Unfortunately though I don t think it s all been implemented using ReplaySubject but instead some other Subject implementations as internal implementation details of making Observable work and not ReplaySubject We need to fix this and make ReplaySubject be the backing implementation for all of these so it matches Rx Net with these signatures http msdn microsoft com en us library hh211810 v vs 103 aspx java ReplaySubject T Creates a replayable subject ReplaySubject T Integer Initializes a new instance of the ReplaySubject T class with the specified buffer size ReplaySubject T TimeSpan Initializes a new instance of the ReplaySubject T class with the specified window ReplaySubject T Scheduler Initializes a new instance of the ReplaySubject T class with the specified scheduler ReplaySubject T Integer Scheduler Initializes a new instance of the ReplaySubject T class with the specified buffer size and scheduler ReplaySubject T Integer TimeSpan Initializes a new instance of the ReplaySubject T class with the specified buffer size and window ReplaySubject T TimeSpan Scheduler Initializes a new instance of the ReplaySubject T class with the specified window and scheduler ReplaySubject T Integer TimeSpan Scheduler Initializes a new instance of the ReplaySubject T class with the specified buffer size window and scheduler @akarnokd Since you have implemented most of the replay overloads are you interested and do you have the time to migrate or re implement the functionality on ReplaySubject as discussed above from where it currently resides inside OperationReplay This should of course not lose the benefits we gained from the 0 16 0 work such as in https github com Netflix RxJava pull 651 A simple thing is to expose OperationReplay replayBuffered in ReplaySubject Rewriting CustomReplaySubject to use similar state machine is more complicated and I can t do it this week @akarnokd @benjchristensen cool Thanks for looking into this issue Looking forward to the update RxJava pull requests #683 https netflixoss ci cloudbees com job RxJava pull requests 683 SUCCESS This pull request looks good RxJava pull requests #709 https netflixoss ci cloudbees com job RxJava pull requests 709 FAILURE Looks like there s a problem with this pull request RxJava pull requests #710 https netflixoss ci cloudbees com job RxJava pull requests 710 FAILURE Looks like there s a problem with this pull request Keeping this open for now as I will merge this onto my branch when I work on ReplaySubject As is though I m not ready to merge Closing out This is referenced from https github com Netflix RxJava issues 865',RxJava,true,false,false
25631422,'AndroidObservable not work','private Subscription subscription @Override protected void onCreate Bundle savedInstanceState super onCreate savedInstanceState setContentView R layout activity_main worked subscription AndroidObservable fromActivity this getObservable subscribeOn Schedulers newThread subscribe this not work subscription AndroidObservable fromActivity this getObservable subscribeOn Schedulers newThread subscribe this worked subscription getObservable subscribeOn Schedulers newThread observeOn AndroidSchedulers mainThread subscribe this private Observable Integer getObservable return Observable create new OnSubscribeFunc Integer @Override public Subscription onSubscribe Observer super Integer obsever for int i 0 i 10 i obsever onNext i obsever onCompleted return Subscriptions empty @Override protected void onDestroy super onDestroy subscription unsubscribe @Override public void onCompleted Log d TAG finished @Override public void onError Throwable error @Override public void onNext Integer i Log i TAG i What I mean of not work is onNext and onCompleted not get called','I ll take this one The reason it s not working is we re doing a check for whether fromFragment is actually called from the main UI thread and terminate the Observable if not However this check happens in the OnSubscribeFunc so will fail if the wrapped Observable is scheduled to run elsewhere The check should be moved to the invocation side i e to the fromFragment helper I also got this issue When it ll be fixed I m waiting for 0 17 to land it contains major changes to the Observable API Will pick it up after Thank for reply You and your team made a bunch of great work thanks man @mttkay On this subject can you confirm that 0 17 master branch is working for you on Android In particular the Android Scheduler was changed by me and I m not setup to test on real devices I ll have a look ASAP Has the scheduler rewrite landed yet It was still in a PR last time I checked Yes it has been merged Thank you So I gave this some more thought and I m not sure we should actually fix this The reason is fromFragment schedules notifications on the main UI thread If you do not apply this to the final composition of your inner observables then the result might not be what you might expect If you have long running operations they will now be propagated on the main UI thread and this can congest the Android message queue For an activity since you unsubscribe in onDestroy and since onDestroy is triggered by finish and since finish will also post a message to the Android message queue you might defer releasing the references the operator holds to the activity After all these helpers are meant for just one use case to observe a fully constructed given sequence on the main thread while being able to unsubscribe such that no references to the activity or fragment will leak plus some additional sanity checks for fragments I guess that s why I put that guard in to begin with That being said I think one problem is the naming I would suggest the following rename OperationObserveFromAndroidComponent to OperationObserveOnAndroidComponent rename fromFragment and fromActivity to observeOnFragment and observeOnActivity remove the UI thread check from the operator and pull it up into these helpers that way your app will fail immediately with a sanity check rather than obscuring it and piping it through an Rx error handler which you might no even have supplied Thoughts on this @benjchristensen I did some quick testing in a sample app that I use as a sandbox for experiments and it looks good Unit tests also look good Would like to further test in our application but if there s pressure to release 0 17 earlier than later I d almost say go ahead I didn t see any smoke signals and smaller issues can still be addressed in a minor version bump Ship early ship often and so on @mttkay Thanks for doing that testing for me I agree that you ll want further testing before production deployment but the fact that it s good enough to pass right now means there are no major API signature or fatal issues I am trying to wrap up a few last things so we can release in the next week give or take Sounds good @mttkay This code sample below is is taken from your blog post Functional Reactive Programming on Android With RxJava http mttkay github io blog 2013 08 25 functional reactive programming on android with rxjava The code here seems to imply that the fromFragment and fromActivity methods can be used with subscribeOn Schedulers newThread but from the discussion above it sounds like that is not the intention So I m wondering if the blog post is just out of date Please let me know if I m misunderstanding something here class MyFragment extends Fragment implements Observer File private Subscription subscription @Override protected void onCreate Bundle savedInstanceState subscription AndroidObservables fromFragment this downloadFileObservable subscribeOn Schedulers newThread subscribe this private Observable File downloadFileObservable as above @Override protected void onDestroy subscription unsubscribe public void onNext File file Toast makeText getActivity Downloaded file getAbsolutePath Toast LENGTH_SHORT show public void onCompleted public void onError Throwable error Toast makeText getActivity Download failed error getMessage Toast LENGTH_SHORT show Yes that code snippet I wrote before adding the assertUiThread guard Like I said I ll revisit this soon but want to see 0 17 land first @mttkay Can you take a look at this PR #880 I m worried that deferring the unsubscribe action may cause some problems Maybe a better solution is if isUIThread do unsubscribe else AndroidSchedulers mainThread schedule do unsubscribe That PR already landed Can we maybe agree that a PR gets at least 2 1s before we merge it back I m not super happy with the changes in there see my comments in #880 This can be closed as it s fixed in bindActivity bindFragment which replace this',RxJava,false,false,false
25676342,'Add marble diagrams to new operators variants','Add javadoc @deprecated use where appropriate Some javadoc comment reformatting e g overlong lines','RxJava pull requests #673 https netflixoss ci cloudbees com job RxJava pull requests 673 SUCCESS This pull request looks good',RxJava,true,false,false
25676769,'Wrong behavior of buffer timespan count','According to the marble diagram in case the buffer is full all subsequent items are ignored till time interval has elapsed green item https github com Netflix RxJava wiki Transforming Observables#buffer But according to the description This version of buffer emits a new bundle of items for every count items emitted by the source Observable or if timespan has elapsed SINCE ITS LAST BUNDLE EMISSION it emits a bundle of however many items the source Observable has emitted in that span even if this is less than count imho the timespan timer as well as counter should be restarted immediately after buffer emission so none of the items are dropped Compare to Lee Campbell http www introtorx com Content v1 0 10621 0 13_TimeShiftedSequences html#Buffer Some systems may have a sweet spot for the size of a batch they can process but also have a time constraint to ensure that data is not stale In this case buffering by both time and count would be suitable We never get a buffer containing more than COUNT elements and we never wait more than TIMESPAN seconds The variants we have looked at so far do not overlap and have no gaps between buffers i e ALL VALUES FROM THE SOURCE ARE PROPAGATED THROUGH see also http msdn microsoft com en us library hh229200 aspx Indicates EACH element of an observable sequence into a buffer that s sent out when either it s full or a given amount of time has elapsed Bug or feature','seems to be fixed in 0 16 1 Ok the marble diagram was updated but it still does not work git SHA ID 10f172d3fe25e853142aa39ace4cda37a433faed public static void main final String args throws InterruptedException final int maxRounds 1000 final int maxCount 1000 final Scheduler scheduler Schedulers computation int round 0 boolean pass true final AtomicInteger count new AtomicInteger 0 do round count set 0 Observable List Integer observable Observable range 1 maxCount parallel o o Integer map val Integer parseInt val toString scheduler buffer 10 TimeUnit MILLISECONDS 42 scheduler filter list list isEmpty final CountDownLatch lock new CountDownLatch 1 observable subscribeOn Schedulers newThread subscribe val count addAndGet val size err System err println err getMessage lock countDown lock countDown lock await pass maxCount count get if pass System out println round round passed while pass round maxRounds System out println in maxCount out count get round round Output round 744 passed round 745 passed round 746 passed in 1000 out 999 round 747 Can you refactor that as a unit test with necessary assertions so it can go inside https github com Netflix RxJava blob master rxjava core src test java rx operators OperationBufferTest java Unit tests provided by @Acardiac in https github com Netflix RxJava pull 761 demonstrating the issue java @Test public void bufferTimeSpanEmitAllItems throws InterruptedException final int maxRounds 100 final int maxCount 1000 final int bufferTimeSpan 42 s int round 0 final AtomicInteger count new AtomicInteger 0 do round count set 0 Observable List Integer observable Observable range 1 maxCount buffer bufferTimeSpan TimeUnit MICROSECONDS final CountDownLatch lock new CountDownLatch 1 observable subscribe onNext new Action1 List Integer @Override public void call List Integer val count addAndGet val size onError new Action1 Throwable @Override public void call Throwable err lock countDown onComplete new Action0 @Override public void call lock countDown lock await while maxCount count get round maxRounds assertEquals maxCount count get assertEquals maxRounds round @Test public void bufferCountEmitAllItems throws InterruptedException final int maxRounds 100 final int maxCount 1000 final int bufferCount 42 int round 0 final AtomicInteger count new AtomicInteger 0 do round count set 0 Observable List Integer observable Observable range 1 maxCount buffer bufferCount final CountDownLatch lock new CountDownLatch 1 observable subscribe onNext new Action1 List Integer @Override public void call List Integer val count addAndGet val size onError new Action1 Throwable @Override public void call Throwable err lock countDown onComplete new Action0 @Override public void call lock countDown lock await while maxCount count get round maxRounds assertEquals maxCount count get assertEquals maxRounds round The rewritten exact buffer with count timespan creates a new buffer if either count or timespan is reached The inexact timed version emits the full buffer but does not start a new window until the timespan ellapses Do we need to ensure no values are left out Both of those unit tests are passing for me v0 18 3 now whereas at least 1 of them was failing still as of 0 17 6',RxJava,false,false,false
25689308,'Provide versioned Javadoc','The Javadoc for each version should be provided online Apologies if it is already I couldn t find it','Right now we only have the current latest at http netflix github io RxJava javadoc We could start storing historical as http netflix github io RxJava javadoc major minor patch such as http netflix github io RxJava javadoc 0 15 1 Right now this is not automated which is why it s somewhat adhoc http netflix github io RxJava javadoc 0 16 http netflix github io RxJava javadoc 0 17 http netflix github io RxJava javadoc 0 18',RxJava,false,false,false
25700170,'Recursive scheduler fails to unsubscribe from time to time RxJava 15 1','Subscription subscription Schedulers newThread schedule 0L new Func2 Scheduler Long Subscription @Override public Subscription call Scheduler inner Long t2 return inner schedule t2 this 1000 TimeUnit MILLISECONDS unsubscribe when app worked several hours subscription unsubscribe It seems that current implementation of recursive scheduler become unstable when it accumulates too much subscriptions May be subscriptions should not be accumulated and be substituted instead rx util CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed to unsubscribe to 1 or more subscriptions CompositeException Failed t','I believe this should be fixed as of 0 16 0 when Schedulers were more or less re implemented to fix the memory leaks they had when doing recursion See https github com Netflix RxJava pull 712 for the fix Recursion testing can be seen here https github com Netflix RxJava blob master rxjava core src test java rx schedulers TestRecursionMemoryUsage java @benjchristensen great I will try to do android specific load test this week Have tested with app that worked for 4 hours seems to work without crush After testing please let me know if the issue is resolved and close this out or whether you still see problems sure @benjchristensen sorry for delay but seems that with 16 1 problem is fixed Excellent thank you for the confirmation',RxJava,false,false,false
25717953,'rx operators OperationCombineLatest throw Null Point Exception','Null Point Excpeiton will be thrown in the following case 1 use OperationCombineLatest combineLatest Observable T0 w0 Observable T1 w1 Func2 T0 T1 R combineFunction 2 and when w0 or w1 emits a Null value The null value is a valid value The cause is that the member latestValue of OperationCombineLatest Aggregator is ConcurrentHashMap ConcurrentHashMap supports neither null key nor null value One solution is to user latestValue Collections synchronizedMap new HashMap CombineObserver extends R Object instead of latestValue new ConcurrentHashMap CombineObserver extends R Object','Or use a null sentinel like in the ZIP operator CombineLatest has been rewritten again Does this issue persist Looks to be working java public class CombineLatestWithNull public static void main String args Observable Integer o1 Observable from 1 2 null subscribeOn Schedulers computation Observable Integer o2 Observable from 4 5 subscribeOn Schedulers computation Observable Integer o3 Observable from null null 5 subscribeOn Schedulers computation Observable combineLatest o1 o2 o3 a b c return a b c toBlockingObservable forEach System out println Emits null 5 null null 5 null null 5 5',RxJava,false,false,false
25757182,'Performance Tests Source Folder','Create src perf for placing performance tests Start some operator tests and move existing perf tests into this folder Probably want to explore using https code google com p caliper','@abersnaze George when you have a chance can you look at what it would take to convert these to using Caliper I m also interested in knowing how we could compare the results between test runs',RxJava,true,false,false
25766944,'additional buffer tests','see Issue #756','RxJava pull requests #674 https netflixoss ci cloudbees com job RxJava pull requests 674 FAILURE Looks like there s a problem with this pull request Can t merge this until someone fixes the bugs these tests prove Code is linked to from https github com Netflix RxJava issues 756 so closing this out as we can t merge it here When that gets fixed these tests need to be merged into that branch By the way thank you for taking the time to create unit tests demonstrating the issue',RxJava,true,false,false
25776909,'adding javadoc marble diagram for the mergeMap next completed error variety','','RxJava pull requests #675 https netflixoss ci cloudbees com job RxJava pull requests 675 SUCCESS This pull request looks good',RxJava,true,false,false
25786953,'Added support for custom functions in combineLatest','','RxJava pull requests #676 https netflixoss ci cloudbees com job RxJava pull requests 676 SUCCESS This pull request looks good I think the same can be achieved by calling b map b over standard b combinLatest b no need for a special method To illustrate that s how I do it in my akka with rx monitoring project https github com vigdorchik rxmon blob master src main scala org matmexrhino rxmon Operations scala#L31 I agree with @chrisgrimm that this one should be there This one is not very handy and less performant since in 99 of the case you will immediately destruct the tuple by applying a function @benjchristensen can you merge this def combineLatest U that Observable U Observable T U @headinthebox @chrisgrimm yes the proposed one is more general and doesn t lose performance in 99 of the cases Maybe the existing one should be removed then I guess it is the idiomatic Scala way like Zip so I think we should keep it just for consistency My thinking was in line with @headinthebox The other issue I d like to see tackled with with the combineLatest function is the ability to zip many Observables together The current implementation can only zip two things together which makes it hairy to handle larger zippings You get this kind of recursive Tuple2 thing going on if you repeatedly zip things which can be resolved in Scala http stackoverflow com questions 21154639 higher order operations with flattened tuples in scala but it is annoying nonetheless You may want to look at the join patterns On Thu Jan 23 2014 at 11 30 PM Chris Grimm notifications@github com wrote My thinking was in line with @headinthebox https github com headinthebox The other issue I d like to see tackled with with the combineLatest function is the ability to zip many Observables together The current implementation can only zip two things together which makes it hairy to handle larger zippings You get this kind of recursive Tuple2 thing going on if you repeatedly zip things which can be resolved in Scala http stackoverflow com questions 21154639 higher order operations with flattened tuples in scala but it is annoying nonetheless Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 763#issuecomment 33176602 @headinthebox @chrisgrimm right I see you want to keep the API consistent though not minimal To do so however the current implementation of b combineLatest b should also be changed to delegate to the new one Correct Send a pull request On Fri Jan 24 2014 at 12 54 PM Eugene Vigdorchik notifications@github com wrote @headinthebox https github com headinthebox @chrisgrimm https github com chrisgrimm right I see you want to keep the API consistent though not minimal To do so however the current implementation of combineLatest should also be changed to delegate to the new one Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 763#issuecomment 33217020 @headinthebox sure if @chrisgrimm doesn t beat me to it @chrisgrimm Unfortunately I don t see your fork in the list of forks of Netflix RxJava so I can t send a PR to it',RxJava,true,false,false
25850959,'lazy append of Observables','I would like to define 2 combined mutually recursive stream of elements I managed to do it with Stream like that scala val data Stream Int Stream cons 1 for elt history s combine elt yield s val history Stream Int for s data elt combine2 s yield elt history take 20 foreach println def combine e Int e to e 1 def combine2 s Int s to s 2 How can I write equivalent code with Observables I would need an equivalent to Stream cons or Stream append which takes a by name function Observable T and evaluates it when the first Observable sent the completed event','This was missed and is about 5 months old now if you re still looking for help please reopen this or post to https groups google com forum # forum rxjava Well I did not find a solution so I kept using Streams This is a pity because I was really convinced after the coursera training Reactive Programming To build cycles you would use behavior subjects the cons 1 to represent the delay However loops like xs 1 map xs are much easier to express directly using scan so I deliberately did not talk about them in the course I have an unpublished blog post on my hard disk since 2009 on feedback loops in Rx @headinthebox thanks for answering but I understand very little of your post Do you have a sample of dependant Observables Writing mutually recursive loops easily lead to deadlocks For example in RxJava RxScala the following example prints 0 and then is dead scala val delay BehaviorSubject 0 val nats delay observeOn rx lang scala schedulers NewThreadScheduler doOnEach n delay onNext n 1 nats subscribe n println n Whereas in Rx NET the equivalent program works just fine C# var delay new BehaviorSubject int 0 var nats delay ObserveOn CurrentThreadScheduler Instance Do n delay OnNext n 1 nats Subscribe Console WriteLine For me the Java equivalent prints some numbers and terminates possibly because the main thread quits right after setting up the chain and the daemon thread of the NewThreadScheduler is terminated If I leave 1 second for it it prints a whole bunch of numbers Btw you used CurrentThreadScheduler in Rx NET which is a different kind of scheduler Using Schedulers trampoline creates an endless stream of increasing values Was experimenting with various schedulers none work from me This prints infinitely java public static void main String args BehaviorSubject Integer delay BehaviorSubject create 0 Observable Integer nats delay observeOn Schedulers trampoline doOnNext n delay onNext n 1 nats subscribe System out println @headinthebox and @benjchristensen I ve now got more experience with RxScala but I still don t see how to use your answers to fit the requirements I originally expressed in the issue 2 combined mutually recursive stream of elements',RxJava,false,false,false
25865277,'A variety of improvements to the javadoc text','','RxJava pull requests #677 https netflixoss ci cloudbees com job RxJava pull requests 677 SUCCESS This pull request looks good',RxJava,true,false,false
25877250,'Fixed the issue that zip calls onCompleted twice','Fixed the issue reported by Vadim Spivak at https groups google com forum # topic rxjava 79cWTv3TFp0 The original zip implementation may call onCompleted more than once but does not wrap the observer with a SafeObserver When the observer is an internal observer zip will break the Rx contract This PR wraps the internal observer with a SafeObserver','RxJava pull requests #678 https netflixoss ci cloudbees com job RxJava pull requests 678 SUCCESS This pull request looks good There is a shorter way L312 insert if done return L260 insert done true @akarnokd What if two Observable both executes the codes protected by rwLock writeLock tryLock observer onCompleted will be called twice java @Override public void onCompleted boolean c false rwLock readLock lock try done true c true finally rwLock readLock unlock if rwLock writeLock tryLock try for ItemObserver T io all if io queue isEmpty io done observer onCompleted cancel unsubscribe return finally rwLock writeLock unlock if c unsubscribe True It can get complicated I need to think about it Otherwise you could wrap the o2 observer with safe to ensure event semantics',RxJava,true,false,false
25901628,'Zip fix for multiple onCompleted and moved unsubscribe outside the lock','Also added the test case from the issue Instead of #766','RxJava pull requests #679 https netflixoss ci cloudbees com job RxJava pull requests 679 SUCCESS This pull request looks good',RxJava,true,false,false
25920725,'Idiomatic filtering of values','Is there a predicate to filter out null values or any values from a signal Currently a new function has to be created to do this but it would be easy to create a general function Filter out null values signal filter new Func1 Date Boolean @Override public Boolean call Date t1 return t1 null map','We do not have a collection of common predicates The closest to this idea we have currently is the rx util functions Not predicate that negates whatever predicate it is given Guava has lots of predicates http docs guava libraries googlecode com git history release javadoc com google common base Predicates html that could be reused here but that would be another dependency As a simplified solution ReactiveCocoa has the ignore https github com ReactiveCocoa ReactiveCocoa blob fc32fc06d398a99cd7c4c28e102d1ffb4a2e3cf9 ReactiveCocoaFramework ReactiveCocoa RACStream h#L161 operation that ignores elements equalling to the given parameter At the moment what I need is a simple method to ignore the default value of a BehaviorSubject Filtering out null s works in this case But without predicates the code will be ugly Obviously skip does not work as it would skip the stored value for all new subscribers instead of just the default one buffer with 1 is an alternative but that needs an additional map to flatten the one item lists Do you have a better idea for how this could be done That sounds you need PublishSubject instead of BehaviorSubject as the former doesn t have a default value But I need the 1 long buffer That s why publishsubject buffer map would solve the issue but it is just ugly and unnecessarily complex for a general purpose like this In other RX implementations there are operations that support this behavior 2014 1 21 akarnokd notifications@github com That sounds you need PublishSubject instead of BehaviorSubject as the former doesn t have a default value Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 768#issuecomment 32826352 So you need the latest value when someone subscribes but not an initial value This can be achieved via the replay int http netflix github io RxJava javadoc rx Observable html#replay int There is a fundamental difference between behavior subject and publish subject Behavior subject is a connected signal whenever a send happens that is stored Publish subject starts working only after it is subscribed to Error and Completed may be registered without a subscription I haven t tried those As a result an explicit subscription is needed to capture all events before a useful subscription is made Now the question is whether there is a connect method in the library that just sits at the end of the line and ignores every send Its only purpose is to keep the signal hot to record all events in the replay 2014 1 21 akarnokd notifications@github com So you need the latest value when someone subscribes but not an initial value This can be achieved via the replay int http netflix github io RxJava javadoc rx Observable html#replay int Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 768#issuecomment 32835556 Here is how filtering can be done java public class TestFilter public static void main String args Observable range 0 20 filter i i 2 0 subscribe System out println Observable range 0 20 filter TestFilter filterEven subscribe System out println public static boolean filterEven int i return i 2 0 If a library of common filters is desired that could be a good contrib module but does not belong in the core',RxJava,false,false,false
25931354,'Android Subject alternative to using CursorLoader','I m attempting to use RxJava to replace the CursorLoader approach in Android for retrieving and refreshing a Cursor I have https gist github com imminent 8511925 so far Curious if anyone else as tried this or sees ways to improve what I m doing','This was missed if still interested please post to https groups google com forum # forum rxjava',RxJava,false,false,false
25965439,'Bind Operator','Implementation of bind operator along with new create and subscribe methods and several reimplemented operators fromIterable toList toSortedList map cast timestamp merge flatMap mergeMap groupBy parallel The bind signature is java public R Observable R bind final Func1 Operator super R Operator super T bind The new Operator class signature is java public abstract class Operator T implements Observer T Subscription The create method now looks like java public final static T Observable T create final Action1 Operator super T f A new subscribe signature is java public final void subscribe Operator super T o The use of these three new methods allows for chaining operators together and supporting unsubscription on both synchronous and asynchronous sources ##### Status and Plan I have temporarily disabled Scala and Kotlin builds until they are fixed The Groovy module has been retrofitted with an extension module to intercept and disambiguate the new create method from the deprecated one I have not yet tested Clojure or JRuby I am pretty certain I have the generics wrong on OperatorMerge so am using it in non typesafe manner right now This design has been reviewed with several people on Github and in person Besides resolving the items listed above my intention is as follows invite feedback and review on this pull request in the next 12 24 hours merge into trunk if nothing major comes up work towards resolving issues with the language adaptors and polishing any rough edges of the new changes finalize bind signatures consider deprecating or eliminating CurrentThreadScheduler if it needs to exist at all perhaps rename to TrampolineScheduler to remove confusion between Immediate and CurrentThread release as 0 17 0 along with some unrelated Scheduler changes continue working in the future migrating operators to this new design See https github com Netflix RxJava issues 746 for background on the proposal reasons and design discussion','RxJava pull requests #680 https netflixoss ci cloudbees com job RxJava pull requests 680 FAILURE Looks like there s a problem with this pull request RxJava pull requests #681 https netflixoss ci cloudbees com job RxJava pull requests 681 FAILURE Looks like there s a problem with this pull request I ll try to take a look at the Clojure interop tomorrow Is OnSubscribeFunc now dead replace by just Action1 to create @daveray Yes OnSubscribeFunc is on its way out As of now it is just Action1 It is like this java new Action1 Operator super String @Override public void call Operator super String t1 I m open to giving an interface name for it if there is agreement For example java public static interface OnSubscribe T extends Action1 Operator super T java new OnSubscribe String @Override public void call Operator super String t1 This was done for OnSubscribeFunc to make it so people don t have to type in the full name including generics Action1 Operator super T and instead only have to type OnSubscribe String and let auto completion do the rest In other words it is currently this java Action1 Operator super String but could be this java OnSubscribe String Anyone have strong opinions on this RxJava pull requests #682 https netflixoss ci cloudbees com job RxJava pull requests 682 SUCCESS This pull request looks good Signature items for discussion #### 1 Operator There is a new class called rx Operator with this signature java public abstract class Operator T implements Observer T Subscription Can anyone else think of a better name Is there anything wrong with this signature It has two constructors java protected Operator Operator op protected Operator CompositeSubscription cs Any issues with these I m somewhat concerned the constructor taking an Operator will confuse people but it is very useful when implementing operators The reason I don t use the Operator create methods more heavily is because extending is far nicer for the implementations since generally someone wants to invoke unsubscribe or isUnsubscribed and that can t be done from within an Observer implementation passed into Operator create #### 2 OnSubscribe or Action1 Operator super String Should we leave the Observable constructor and create methods using the raw function Action1 Operator super String or should we give it a type such as OnSubscribe that simplifies what people need to type particularly the generics If we do give it a type a what name should it have b should it be an inner class of Observable like OnSubscribeFunc was it seems you don t need to close over the parentSubscription as it is accessible as the cs field no @duarten You are correct Thanks for the review I ll post an updated commit shortly It s clearer without closing over it RxJava pull requests #687 https netflixoss ci cloudbees com job RxJava pull requests 687 FAILURE Looks like there s a problem with this pull request RxJava pull requests #688 https netflixoss ci cloudbees com job RxJava pull requests 688 SUCCESS This pull request looks good If anyone has reasons for me not to merge this please let me know today Tuesday USA time I intend on merging it tonight about 10 hours from now so that other work can proceed without major merge conflicts happening After I merge it will still be a bit before 0 17 releases so we can continue discussing the questions about signatures that I posed above If anyone has reasons for me not to merge this please let me know today Tuesday USA time 2 phase commit I 100 support this change This will greatly simplify the implementation and make it much easier to maintain the code Wrt to names the name Operator is a bit generic and typically an operator is something that generates a result from its argument like the plus operator Perhaps a better term would be Acceptor http citeseerx ist psu edu viewdoc summary doi 10 1 1 225 7525 Or more radical not tried it to make Observer implement Subscription directly and have no separate type If that would be possible I d like that It is quite natural for an Observer to be disposed And if you don t care you can always use an empty subscription that does nothing Personally I rather have a synomym for Action1 Operator super T To many angle brackets in Scala it would be kind of OK Wrt to create methods vs extending the reason create was used in the NET implementation so heavily is that the a only anonymous object you have are lambdas and b if you want to intercept user supplied implementations inheritance is a bit awkward since users then have to overwrite different methods that are called by the regular ones This new approach feels a bit odd but perhaps after reimplementing ops I ll get a feel of it One last comment about stopping the upstream in the current setup could be achieved via custom exception or CancellationException thrown from onNext and specifically ignored in onError of the same observable It is similar to the case when one needs to stop a periodic action scheduled on the thread pool and doesn t have access to the Future One last comment about stopping the upstream in the current setup could be achieved via custom exception I actually often thought about using Exceptions as a quick way to rip up the stack like that but in NET exceptions are not quick That sounds a bit messy To cancel a chain of operators you would have to keep catching and re throwing the exception upstream Also an operator might redirect the execution of a call to onNext to another thread and there goes the callstack Here s http shipilev net pub blog 2014 exceptional performance a nice post on Java exception performance btw I actually often thought about using Exceptions as a quick way to rip up the stack like that but in NET exceptions are not quick Yes it is slow but one time cost you would have to keep catching and re throwing the exception Once thrown inside onNext it will propagate upwards to a catch where it will be sent downwards again in onError I don t think they are rethrown in an observable chain redirect the execution of a call to onNext to another thread and there goes the callstack this shouldn t be an issue as observeOn already takes care of this case regardless the intention of the exception If not using exceptions then one could have a more cooperative observer where onNext returns boolean to indicate continuation stop or returns an enumeration of continue complete terminate java interface Observer T boolean onNext T value void onError Throwable t void onCompleted Observable T from Iterable T source return create o for T t source if o onNext return Subscriptions empty o onCompleted this shouldn t be an issue as observeOn already takes care of this case regardless the intention of the exception Can you elaborate on this Unless I m missing something this would mean that there needs to be some other mechanism to actually propagate the unsubscription because the call stack is lost and so are the exception handlers The problem with returning with boolean is the same as propagating exceptions Because there is no constraint on where the onNext call is executed we can t assume we will be able to use the stack to communicate with the upstream operators I like the current approach of Subscriptions as cancellation tokens interface Observer T boolean onNext T value void onError Throwable t void onCompleted That does not sound right at all boolean onNext T value I meant if you use source observeOn cpu subscribe v throw ex it will unsubscribe from the source Otherwise you are right one would need to move the boolean return value into the heap so it basically becomes the subscription java class ObserveOn Observer Observer original CompositeSubscription csub boolean onNext T t csub add scheduler schedule if original onNext t csub unsubscribe return csub isUnsubscribed That does not sound right at all boolean onNext T value I would say it is the dualization of break and continue of the Iterator s usage pattern This new approach feels a bit odd @akarnokd It took me a bit to get used to the new mental model as well while implementing operators as the flow is inverted from before However the benefits are pretty convincing and I have come to prefer the model after implementing several operators One last comment about stopping the upstream in the current setup could be achieved via custom exception or CancellationException thrown from onNext and specifically ignored in onError of the same observable It is similar to the case when one needs to stop a periodic action scheduled on the thread pool and doesn t have access to the Future This should already be working due to how we catch errors and propagate via onError until they hit the last Observer wrapped in SafeObserver which will call unsubscribe That said what benefit does this give us as a programming model Using the composed Subscription and Observer onError is elegant and works well I consider throwing exceptions in this model to be exceptional as in it wasn t expected and is out of band and breaking the normal contract then one could have a more cooperative observer where onNext returns boolean to indicate continuation stop Similarly what does this give us that the Subscription composition does not already give us On both of these I m not quite understanding what problems you are seeking to solve Can you elaborate RxJava pull requests #690 https netflixoss ci cloudbees com job RxJava pull requests 690 FAILURE Looks like there s a problem with this pull request The same issue as this new model to stop from or repeat like producers in downstream operators like take or one s Observer at the end of the chain The benefit it gives is the lack of Subscription overhead when used solely as cancellation token By overhead are you referring to object allocation or memory To achieve composition do you envision some operators would need to try catch CancellationException around onNext and then conditionally re throw similar to how GroupBy must separate the subscriptions Generally though I don t like the idea of using exceptions for control flow Unsubscribe is not an uncommon event such as with take so using it for control flow seems very inappropriate and I don t know what the performance implications are The benefit it gives is the lack of Subscription overhead when used solely as cancellation token I meant the boolean onNext here For the exception case there is no need for extra try catch as exceptions will propagate back down on the onError wire breaking out of loops and triggering unsubscriptions along the way In terms of a TakeObserver onNext if count limit o onCompleted throw CancellationException o onNext v onError if e instanceof CancellationException return o onError e But Exceptions are quite expensive compared to a simple boolean return value indeed For the exception case there is no need for extra try catch as exceptions will propagate back down on the onError wire breaking out of loops and triggering unsubscriptions along the way The TakeObserver is a very simple use case I started with a single Subscription for the entire sequence in my bind prototyping but found it insufficient There are various use cases such as the one demonstrated by groupBy that require decoupling the subscriptions For this reason the CancellationException would have to be caught and not permitted to pass all the way boolean onNext I played with these types of return signatures for a while trying to see if I could compose the back pressure channel but found it didn t compose well in things like merge and zip I never considered it for replacing Subscription though The problem I see with using boolean onNext to replace Subscription is that it requires an onNext in order to be applied Thus it doesn t work on an Observable that never emits or is very slow to emit but should be shut down unsubscribed and resources cleaned up such as a network connection or operators like timeout that need to fire an unsubscribe that is not related to an onNext occurring Merging Discussion can continue here as the code will surely evolve on the master branch before we release I have opened issue https github com Netflix RxJava issues 775 for discussing the naming and type signatures Practically the signature boolean onNext T value is the same as void onNext T value boolean isUnsubscribed where the former s boolean return value is refactored into a separate method In both cases one needs a heap object to cross thread boundaries and complex operators boolean isUnsubscribed The difference is that Operator has more functionality than just isUnsubscribed notably the add Subscription method which allows registering callbacks to handle the use cases I mentioned If those use cases didn t exist then sure it would work Really it is a composite subscription Which is probably fine to have a the base class interface for subscriptions one of the side effects of this exercise is that I hope we can junk most of the subscription types Yes it is a CompositeSubscription without clear and remove Hence the reason why Observer implementing Subscription and expecting users to implement these methods is not correct Wouldn t we need the remove for example in groupByUntil to unsubscribe and remove groups I guess one could always have its on Composite and use add but how often do we need the ability to add multiple sub subscriptions in the first place I think Rx NET s Sink class the closest equivalent uses SingleAssignmentSubscription for it I m arguing for the fact that CompositeSubscription exists for good reason and the Observer Subscription use case the Operator solves is not the same I d say there are 4 scenarios for API users as opposed to API implementors a you pass in the individual methods and we create an observer for you b you call Observer create and we create one for you c you get an observer from somewhere else say a subject and you pass that on d you really want to implement one by hand then you can use ObserverBase or e You thin you are smart then shoot yourself in the foot SingleAssignmentSubscription is not a friendly type I bet you can replace SingleAssignmentDisposable with MultipleAssignmentDisposable in the whole Rx NET code base and it will still work caveat emptor Excuse my short memory but what problems do we want to solve with this new create bind subscribe approach https github com Netflix RxJava issues 746 1 Synchronous Unsubscribe 2 Custom Operator Chaining 3 Simpler Operator Implementations 4 Eliminate Need for CurrentThreadScheduler 5 Recursion Loop Performance Thanks I was looking at ways to implement repeat but I ve stumbled upon a problem java return from Arrays asList this bind u k new Observer Obsurvable T @Override public void onNext Obsurvable T args while k isUnsubscribed args subscribe new Observer T @Override public void onNext T args u onNext args @Override public void onError Throwable e u onError e @Override public void onCompleted k @Override public void onError Throwable e u onError e @Override public void onCompleted It works if the source is a synchronous from java from Arrays asList 1 repeat take 10 subscribe System out println But starts to spin rapidly if one uses subscribeOn which may lead to OOM and is just wasteful java from Arrays asList 1 subscribeOn Schedulers computation repeat take 10 subscribe System out println I did some implementation experiments https gist github com akarnokd 8570027 and it appears one would always need some queue to avoid recursion In addition I felt I don t need to combine Observer Subscription but to close over a CompositeSubscription where I can add remove dependent subscriptions at will I haven t spent the time to play with it but it seems to me that the repeat should not occur until onComplete is called',RxJava,true,false,false
25969618,'Exception rethrown inconsistently with without mapMany in 0 15','Sorry can t run with latest code Maybe I just don t understand JavaRX yet but this seems inconsistent Run this and then re run without the mapMany Note that the second run passes the unit test @Test expected RuntimeException class public void verifyExceptionIsThrownIfThereIsNoExceptionHandler Observable OnSubscribeFunc Object creator new Observable OnSubscribeFunc Object @Override public Subscription onSubscribe Observer super Object observer observer onNext a observer onNext b observer onNext c observer onCompleted return Subscriptions empty Func1 Object Observable Object manyMapper new Func1 Object Observable Object @Override public Observable Object call Object object return Observable just object Func1 Object Object mapper new Func1 Object Object private int count 0 @Override public Object call Object object count if count 2 throw new RuntimeException return object Action1 Object onNext new Action1 Object @Override public void call Object object System out println object toString Observable create creator mapMany manyMapper map mapper subscribe onNext','The problem here is that one of SafeObserver onError is called twice one is RuntimeException the other is OnErrorNotImplementedException A little to similar to #748 Not sure this is a bug If an Observer throws an Exception in onError what will happen I think Rx does not guarantee that it always calls onError when an exception is thrown It only guarantees that it at least calls onError once when an exception is thrown Do I misunderstand anything the behavior is inconsistent that s the bug Document that the throwables are silently swallowed or thrown if there is no onError Errors should probably always be thrown because I want my JVM to terminate before my JVM starts misbehaving and serving wrong data If an onError is not implemented it should always be thrown @benjchristensen Looks some operators do not handle OnErrorNotImplementedException correctly Could you propose a guild about how to handle exception in RxJava Now we have RuntimeException except OnErrorNotImplementedException Exception Error and OnErrorNotImplementedException Dealing with in pull request https github com Netflix RxJava pull 839 Should be fixed in https github com Netflix RxJava pull 839',RxJava,false,false,false
26001994,'Various buildscript cleanup','There s a lot of changes here but I tried to keep them small and incremental Let me know if there s anything you re unhappy with and I ll recraft this','RxJava pull requests #684 https netflixoss ci cloudbees com job RxJava pull requests 684 FAILURE Looks like there s a problem with this pull request RxJava pull requests #685 https netflixoss ci cloudbees com job RxJava pull requests 685 FAILURE Looks like there s a problem with this pull request I don t have an explanation for this latest failure It s passing locally The test needs to run something on an external thread and is time critical therefore if the build machine is bogged down for some reason it may fail Unfortunately I can t fix the test right now Is there anyway to retrigger the check here so we can verify the build passes with this PR RxJava pull requests #686 https netflixoss ci cloudbees com job RxJava pull requests 686 FAILURE Looks like there s a problem with this pull request @quidryan Justin since most of the gradle setup and config is from you I think you need to be involved in this review @alkemist Thank you for the submission We also need to validate this doesn t break the internal build process that builds and publishes the code to our internal repo and to Maven Central What is it that triggered these changes Were you having problems of some kind I just noticed that things were a bit disorderly and thought I could help No problems per se but there were issues around classpath management that probably would have reared eventually Secondary motivation is wanting to ensure that this project is a good example of Gradle usage Got it thanks @alkemist There s some history to the build We fork from a common repo called gradle template and then merge changes out to the 40 odd netflix projects It s not ideal and it s old but it works and is expected to be replaced soon Changes like whitespace and moving sections around makes it nearly impossible to merge so I d ask that the structural bits of the build files be left alone and taken out of the pull request E g the github pages needs to stay where it was I can see that there s lot of redundant definitions which is not in the gradle template have crept into this build and those can be consolidated like the javadoc Can you elaborate on what you consider structural changes Is this just where files are Or also things like getting the test dependencies off the compile classpath @alkemist Many of these changes in this PR would be better suited I think to fixing the parent at https github com Netflix gradle template If they are fixed there we will then pick them up The second group of changes for RxJava specific build files I would gladly accept cleanup if you can separate them from those that affect anything from gradle template Sure thing Will take a few days Thanks @alkemist I ll close this one out for now',RxJava,true,false,false
26047207,'rxjava contrib breaks on my machine','@akarnokd can you take a look at this Users netflix Development RxJavaFork rxjava contrib rxjava async util src main java rx util async Async java 1600 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators fromCallable png Users netflix Development RxJavaFork rxjava contrib rxjava async util src main java rx util async Async java 1620 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators fromRunnable png Users netflix Development RxJavaFork rxjava contrib rxjava async util src main java rx util async Async java 1639 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators fromAction s png Users netflix Development RxJavaFork rxjava contrib rxjava async util src main java rx util async Async java 1658 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators fromFunc0 s png Users netflix Development RxJavaFork rxjava contrib rxjava async util src main java rx util async Async java 1678 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators fromCallable s png Users netflix Development RxJavaFork rxjava contrib rxjava async util src main java rx util async Async java 1698 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators fromRunnable s png','@headinthebox What exactly is the problem The no alt attribute for image Did you try to build with Java 8 @DavidMGross could you help us Yes I do use Java 8 Weird that errors in doc comments break the build but hey None of the images have alt in them in Observable java not just in Async java Odd alt is a required img attribute in many modern flavors of HTML but browsers are forgiving about it and I ve never known javadoc to complain about it before On Tue Jan 21 2014 at 2 15 PM akarnokd notifications@github com wrote None of the images have alt in them in Observable java not just in Async java Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 773#issuecomment 32970115 David M Gross PLP Consulting Is this still a problem Java freaks out with Javadoc changes in every major release It s one of those things',RxJava,false,false,false
26048372,'Bind pre release','Fixed scala issue map with index was removed','RxJava pull requests #689 https netflixoss ci cloudbees com job RxJava pull requests 689 SUCCESS This pull request looks good Merged into https github com Netflix RxJava pull 770 Thanks @headinthebox',RxJava,true,false,false
26065543,'Naming of Create Bind Operator Functions and Types','Changes are being done in https github com Netflix RxJava pull 770 as a result of discussion in https github com Netflix RxJava issues 746 that add a new bind operator and change the create signature to inject a Subscription instead of returning it The reasons for this change can be seen at https github com Netflix RxJava issues 746 The names have thus far been left as is or as raw functions while achieving the right functionality Before releasing and becoming part of the published API I d like to finalize the names some of which have been disputed ### 1 source Function java Action1 Operator super T This is the single function that exists inside an Observable that is executed upon subscription when subscribe is invoked The previous function was called OnSubscribeFunc T We could just keep the Action1 signature but the generics are obnoxious to remember type and code complete Having a specific type is for ease of use This will be the most used of the types discussed in this issue as all Observable create usage will involve this type Most users of RxJava will use Observable create A possibility is java public static interface OnSubscribe T extends Action1 Operator super T or it could more explicitly and like OnSubscribeFunc be java public static interface OnSubscribe T extends Function public void onSubscribe Operator super T op What other names could this be ### 2 bind or lift Method The new method added to Observable has a name and signature like this java public R Observable R bind final Func1 Operator super R Operator super T bind The intent is to perform function composition and return a new Observable representing the composition Since my computer science lambda calculus etc is not the greatest I was calling this bind but after discussion with others it seems this is probably better called lift as per functional programming principles That said there is nothing requiring us to use names such as these The intent of this method is to chain together operators for transforming combining filtering and operating on data flowing through an Observable and each time it s chained it returns a new Observable For example java Observable U ou Observable T chain operatorA Observable V ov Observable U chain operatorB Observable W ow Observable V chain operatorC Typically this would be used like this java Observable W ow Observable T chain operatorA chain operatorB chain operatorC Here are possible names java public R Observable R bind Function T R f public R Observable R lift Function T R f public R Observable R compose Function T R f What is the correct name for this ### 3 bind or lift Function The function that the currently named bind takes is java Func1 Operator super R Operator super T This could be left as is and will generally only be used by people implementing operators Thus it is not in the common path for using Rx However it could benefit from the clearer communication of a specific type and name Possibilities include java OnBind R T OnLift R T BindFunction R T LiftFunction R T Composition R T Should we give this a specific type and name If so what should it be ### 4 Operator class As part of the new bind and create functionality that injects Subscriptions into the source function a new type Operator was created that combines Observer and Subscription java public abstract class Operator T implements Observer T Subscription Is Operator the correct name If not what should it be called ## Possible Outcomes java use OnSubscribe for the source function public final static T Observable T create final OnSubscribe T f use compose and Composition as user friendly representations for the bind lift functionality public R Observable R compose final Composition R T cf leave Operator as is public abstract class Operator T implements Observer T Subscription or java use OnSubscribe for the source function public final static T Observable T create final OnSubscribe T f use compose for the name but leave the function public R Observable R compose final Func1 Operator super R Operator super T cf leave Operator as is public abstract class Operator T implements Observer T Subscription or java use OnSubscribe for the source function public final static T Observable T create final OnSubscribe T f use lift public R Observable R lift final Func1 Operator super R Operator super T cf leave Operator as is public abstract class Operator T implements Observer T Subscription etc My intent is to solidify the naming before releasing 0 17 0 as these are not easy to change once released Please provide your suggestions and reasoning either to support one of the options above or for something new Thank you','How about java Observable T o Observable T with operatorA with operatorB with operatorC public R Observable R bind final Func1 Operator super R Operator super T bind This is actually an instance of map since it takes Operator T Operator S to Observable S Observable T so lift would be the geek name I like @akarnokd proposal to use leverage English to emphasize the fluent style Using with sounds OK Func1 Operator super R Operator super T For this one I actually like keeping Func1 otherwise I d have to unfold the synonym That is because I remember Operator S Operator T Observable T Observable T That is easier than XXX S T Observable Observable public static interface OnSubscribe T extends Action1 Operator super T I like this one With public static interface OnSubscribe T extends Function public void onSubscribe Operator super T op I need to mentally translate too much public abstract class Operator T implements Observer T Subscription Can t we just make Observer implement Subscription Less types is better This would be my choice As I said not sure the last one works use OnSubscribe for the source function public final static T Observable T create final OnSubscribe T f use with for the name but leave the function public R Observable R with final Func1 Observer super R Observer super T cf Modify Observer public abstract class Observer T implements Subscription Note that with is a keyword in Scala so in Scala we ll need a different name What would be a good word for before Since bind is contravariant it chains the transformations in reverse order In my younger days when Algol 68 was all the rage if then else fi while do od case esac I would propose neht but I am sure that this would not fly in 2014 I m not sure if I like having Observer implementing a Subscription Now you can have the same Observer instance subscribed to more than one Observable if you so wish and what you unsubscribe is the Observable Observer association I guess it would be okay if Observer were to become only an internal type Also there might be some strangeness with Subjects After playing with this last night I m beginning to like the idea of changing Observable to a abstract class that extends CompositeSubscription The two argument creators on Operator seem awkward Does it make sense to allow the same Subscription was used to create two different Operator s with different Observable s or vice versa If Observable was the Operator you wouldn t need any of that Changing from an interface to an abstract class would minimize the breakiness to just forcing everyone to switch from implements to extends for just named classes anonymous inner classes wouldn t need to change Come to think of it are there any other Subscription types Should we think of this as renaming CompositeSubscription to Observer and adding three abstract methods onNext onError onCompleted I too don t think making Observer extend Subscription is a good approach #### 1 Conflates Responsibility When using an Observable it is rare that someone needs to concern themselves with the Subscription unless they are implementing an operator By making Observer extend Subscription we would be forcing all users to always concern themselves with it What does implementing unsubscribe even mean when just providing an Observer to an Observable subscribe Observer when one just wants to subscribe to the data This is what we users would have to implement java new Observer String @Override public void onCompleted @Override public void onError Throwable e @Override public void onNext String args public final void unsubscribe what to do here In most cases I don t know what the unsubscribe method should do It certainly wouldn t be implemented correctly Contrast this with the current Observable subscribe which handles the subscription java public final Subscription subscribe Observer super T observer simplified Operator T op Operator create observer new CompositeSubscription subscribe op return op This is not logic that most users of Rx should ever have to worry about I feel that Observer and Subscription should be kept separate and that we have a type such as the current Operator that combines them when needed #### 2 Major Breaking Change This would be a massive breaking change to anyone using RxJava There is no mechanism for making it backwards compatible or providing a deprecation strategy I m not sure if you were replying directly to my statement What about making Observer and abstract class where unsubscribe in implemented for you In fact it should probably be final so that users would have to add Subscription to register a unsubscribe callback when needed I m not sure if you were replying directly to my statement I was replying to @headinthebox but it applies to yours as well we posted within minutes of each other What about making Observer and abstract class where unsubscribe in implemented for you Perhaps but it s still a pretty major breaking change I can see some limited benefit in an Observer being able to call unsubscribe but that is supported by the subscribe Operator interface and it s very rare that people are doing that in the final Observer since they generally should be using things like take and takeUntil for controlling when an Observable is unsubscribed The problem obviously is that we now have 2 ways of subscribing java public Subscription subscribe Observer super T observer and java public void subscribe Operator super T o So the real question is whether we are willing to have a massive breaking change where we eliminate all of the subscribe methods that return Subscription And if so why are they called subscribe anymore Perhaps just observe If we were starting from scratch I wouldn t have the Subscription subscribe Observer methods only void observe Observer Another problem I just considered Subject must extend from from Observable and implement Observer Java doesn t support multiple inheritance so we can t have Observer be an abstract class Thus if we make Observer extend Subscription it can only be an interface which means everyone must implement unsubscribe which we don t want What exactly is wrong with the name Operator since everyone casually calls them operator anyways and the package they all live in is rx operators Putting the MI part aside I a do not agree with What does implementing unsubscribe even mean when just providing an Observer to an Observable subscribe Observer when one just wants to subscribe to the data It just means don t do anything Just like now when you do an observable create and return a subscription by subscribing to another observable In NET enumerator inherits IDisposable and in most cases the IDisposable just does nothing I see absolutely nothing wrong with that Now most of the time people do not even pass observers directly but just the onNext onError or onCompleted functions to most of the time they won t even notice What exactly is wrong with the name Operator http en wikipedia org wiki Operator_ programming An operator is typically a Function3 I would say keep just one subscribe Subscription Subscribe Observer Instead of returning void there is no harm in returning the augmented subscription in both bases Now you can have the same Observer instance subscribed to more than one Observable That is not a smart idea anyway not sure if that would always guarantee that calls to OnNext are serialized if they get called from tow independ observables This is the signature that starts the Observable java void subscribe Observer Subscription o The Subscription specifically needs to be of type CompositeSubscription and is the seed for the entire sequence Also it must have the add and isUnsubscribed methods java private final CompositeSubscription cs public final void add Subscription s cs add s public final void unsubscribe cs unsubscribe public final boolean isUnsubscribed return cs isUnsubscribed Thus a user can not just pass in an empty unsubscribe They must pass in the exactly correct implementation which is not at all what a user should have to do This is why subscribe Observer does this internally java Operator op Operator create observer new CompositeSubscription subscribe op If Observer implements Subscription it would not change this as CompositeSubscription is more than the Subscription interface Thus we would now have users implementing an unsubscribe method with no hook to the thing it should unsubscribe from java subscribe new ObserverThatExtendsSubscription String @Override public void onCompleted @Override public void onError Throwable e @Override public void onNext String s receive data if s null unsubscribe public void unsubscribe what do I do here I want to do this parentSubscription unsubscribe but there is no hook to a parentSubscription The problem is that if I m implementing just an interface there is no parentSubscription passed in that I can do something with Thus what would someone do inside the unsubscribe method they implement in their Observer There is nothing they can do The only way I see to make this work is to replace the Observer interface with the abstract class Operator This would indeed work as then it is a legit Subscription backed by a CompositeSubscription But it won t work with Subject as Java doesn t support multiple inheritance and Subject needs to extend both Observable and Observer Using this abstract class would work exactly like the current Operator class does like this java subscribe new OperatorOrObserver String @Override public void onCompleted @Override public void onError Throwable e @Override public void onNext String s receive data if s null unsubscribe this will now work This would work great except for 1 it s a massive breaking change and 2 Subjects would all break That is not a smart idea anyway not sure if that would always guarantee that calls to OnNext are serialized if they get called from tow independ observables Agreed But it s additional flexibility that comes from separating those ideas And the Subscription Subscribe Observer signature would be misleading Another benefit is that now a subscription can be shared between a chain of observers whereas otherwise each operator would have to cancel the parent observer which in turn would cancel its parent and so forth But it won t work with Subject as Java doesn t support multiple inheritance and Subject needs to extend both Observable and Observer One way around that would be to make it have a toObservable method Talking with @headinthebox and @abersnaze we have discussed taking these changes all the way instead of part way as done so far and doing the following Change interface Observer T to an abstract class java Observer Subscription public abstract class Observer T implements Subscription public static create onNext public static create onNext onError public static create onNext onError onCompleted abstract void onNext T abstract void onError Throwable abstract void onCompleted final add Subscription final unsubscribe final boolean isUnsubscribed This would effectively be the same class as is currently Operator Then Subject would change to java Subject T extends Observer T public Observable T toObservable This would allow subscribe Operator and subscribe Observer to collapse into one The benefit of this is no new types just Observer it forces subscribing the right way where an Observer can unsubscribe even on synchronous data Regarding the naming of bind we decided that bind is not the correct name as it is not exactly a monadic bind It is in fact a lift or transform We feel it is likely better to stick to proper CS or mathematical names for this function Thus it will be java lift public R Observable R lift final Func1 Observer super R Observer super T cf or public R Observable R transform final Func1 Observer super R Observer super T cf This means version 0 17 will be a significant breaking release We will leverage this to do all of the breaking changes here including removing deprecated methods and changing Scheduler to explicitly have Inner Outer Would it make sense for Observer to extend from CompositeSubscription as it will have those semantics Being able to do Observer create add Observer create still feels a bit weird I wonder if this approach is just due to a limitation of Java s type system as we can t express Observer with Subscription without explicitly introducing a new type Would it make sense for Observer to extend from CompositeSubscription as it will have those semantics I don t think we want to expose the clear and remove methods that CompositeSubscription has Also I consider the use of CompositeSubscription inside Observer an implementation detail We could use something different if it makes sense so I don t want to commit long term to CompositeSubscription Observer create add Observer create It looks odd like that but there are actually use cases where I think that s more or less what we ll do zip groupBy merge albeit with a little more code involved and not directly chained like that There are always things we can do that shouldn t be done such as this infinite loop with a Subject java Subject String String s PublishSubject create s subscribe s This fits into the don t do that category Similar to anInfiniteObservable toList I wonder if this approach is just due to a limitation of Java s type system I don t know regarding this specific decision We are limited in our implementation design though due to things such as lack of extension methods which drives us to use abstract class instead of interface for Observable and now Observer and then that affects Subject since we can t have multiple inheritance Here is my branch working on this refactor as a preview of the changes https github com benjchristensen RxJava commits lift observer The biggest issue I now have is figuring out how to make the unit tests work since mock Observer class can no longer be used the abstract method constructor is not invoked and thus the subscription state is null Probably going to sleep on it enough carpal tunnel pain on tedious refactoring for one night I don t quite understand why Observer and Subscription needs to be merged this way I got pretty far with one of the previously suggested structures java private final Action2 Observer T CompositeSubscription onSubscribe private Obsurvable Action2 Observer T CompositeSubscription onSubscribe this onSubscribe onSubscribe public Subscription subscribe Observer T obsurver CompositeSubscription token new CompositeSubscription onSubscribe call obsurver token return token public Subscription subscribe Observer T obsurver CompositeSubscription token onSubscribe call obsurver token return token public static T Obsurvable T create Action2 Observer T CompositeSubscription onSubscribe return new Obsurvable onSubscribe public U Obsurvable U bind Func2 Observer U CompositeSubscription Observer T binder return new Obsurvable o t onSubscribe call binder call o t t This way both create u k and bind u k t offers a composite subscription k which can be naturally closed over with an Observer or that of the Operator if one really wants to reduce inner class clutter The when to unsubscribe remains largely the same It definitely works on the previous signatures I was arguing for leaving Observer as is but @headinthebox and @abersnaze convinced me to pursue changing Observer The argument was for 1 Having a signature that only dealt with Observer rather than Observer and some other Subscription implementation In other words specifically avoiding methods like you show java Observer T obsurver CompositeSubscription token Action2 Observer T CompositeSubscription Func2 Observer U CompositeSubscription Observer T That is where I started this journey at and it works just fine as you say Making Observer implement Subscription is taking it to the extreme possibly end state as I see it allowing the signatures to be simpler like this java Observer T obsurver Action1 Observer T Func1 Observer U Observer T 2 Elegance due to simpler signatures while it ends up doing the right thing in all cases rather than a user having to choose the right signature if they want unsubscribe support It s quite nice now that any subscribe Observer o can call unsubscribe from within an onNext method Any user of Rx can do that with this Observer implements Subscription design whereas the code on master right now requires them choosing a different subscribe overload The when to unsubscribe remains largely the same Yes This last set of changes is purely one of semantics and signature design The change in functionality is already what was merged into master that added the bind lift function It basically was the discussion with @headinthebox that if we were starting from scratch with this lift model we wouldn t have combined Observer and Subscription so how about let s try and get it all refactored to that model now before we hit 1 0 instead of keeping signatures of old and new Apparently I m too late to the party just seen the 0 17 release notes preview but I wanted to say it anyway the mathy sciency geeky lift thing sounds scary to me I m a programmer I don t want to care about category theory I want to chain method calls Give me chain or with and I m a happy guy I could understand andThen or compose but I get a little bit nervous with bind With lift I m just put off Thanks for listening to this complaint the mathy sciency geeky lift thing sounds scary to me I understand this sentiment I m torn on this one but there is a principle that pushed us towards using lift We try hard not to re invent new names for things when they already have names Arbitrarily putting plain english names on top of things does not really help our industry as then we have multiple synonyms for the same concept or functionality and moving across languages and libraries is made more difficult than it should be Part of the goal for Rx is to be consistent across platforms and languages which is why we work with @headinthebox and @mattpodwysocki to try and stay as close as we can As we have pursued this path with lift and Subscriber @headinthebox has mediated across languages Another aspiration is to not try and redefine what operators and functions mean If we are using capabilities from functional programming or math it is our perspective that it is better for us to learn and use the proper names for things so we can speak the same language Take the map function for example http en wikipedia org wiki Map_ higher order_function That has become common in imperative languages even though the name originates from functional programming and is not plain english like transform Last we have avoided adding new types as much as possible and let the functional interfaces stay as such in most places such as Func1 Subscriber super R Subscriber super T As seen in https github com Netflix RxJava issues 792 we tried very hard to not end up adding the new Subscriber type but the cost of not having it was worse than adding the type All that said With lift I m just put off what specifically puts you off about this Despite not liking the concept of alias methods I m not against having one if it is truly a blocker for users Nor is the name lift locked in stone yet as we have not yet released nor was there much feedback though @headinthebox has a very big say in this matter and I invite his input on this Ben first let me say that I very much appreciate your detailed explanation I beg to differ though With RxJava you are a bit in a special position as you are bringing Rx to masses of Java programmers which is a big deal itself and you are also innovating on Rx at the same time this Operator lift thing is new and doesn t exist in other Rx implementations AFAIK This requires careful API design of which naming things is an important part Of course it s a highly subjective matter and in the end it s your call I just wanted to present a different opinion What I ve seen is that APIs in mainstream ish languages tend to name things differently from the computer science upstreams map is a bit of an exception as it kinda makes sense as a synonym for transform transformation is a _mapping_ from source to target Though it s called transform somewhere and even select elsewhere in LINQ and Rx NET Rx JS where map is defined as an alias And looking at monadic bind that s called flatMap in Scala and most other mainstream ish languages libraries LINQ and Rx NET Rx JS call it selectMany Rx defines a flatMap alias and Dart uses expand which is IMHO almost perfect fold is often called reduce or like in Scala reduce is a special case of fold or even aggregate Et cetera So again I believe it s common to diverge from functional CS terminology in mainstream and I guess that the reason is understandability Regarding lift looking at http en wikipedia org wiki Lift_ mathematics it looks like for practical purposes lift is a function that is used in function composition Eh come on What we have here is a chain of method calls that creates a chain of operators which is a great name BTW And what we are looking for is a name of a method that adds a previously unknown operator to the chain To me lift doesn t come even close It s more abstract yes but more abstract doesn t necessarily mean more good For me part of Rx s awesomeness lies in its accessibility to masses Abstraction over abstraction is usually an opposite of that @Ladicek Your make a strong argument and I m willing to concede and make a change that benefits ease of adoption and comprehension I d like others to weigh in on this so cc @samuelgruetter @jmhofer @zsxwing @mairbek @mattrjacobs @abersnaze @akarnokd @michaeldejong @mttkay @JakeWharton @loganj @adriancole The proposal is to change from java public R Observable R lift final Func1 Subscriber super R Subscriber super T lift to java public R Observable R chain final Func1 Subscriber super R Subscriber super T chain The use is for custom operator chaining such as java Observable String os observable_of_integers chain TAKE_5 chain MAP_INTEGER_TO_STRING More information about the background on this can be found at https github com Netflix RxJava issues 802 in summary form @benjchristensen Thanks for asking For what it s worth I disagree with @Ladicek s reasoning if not the proposed change There are a number of good criteria for choosing a function name but whether or not it s scary because it has the whiff of math about it doesn t strike me as one of them lift has the advantage of actually being a well known name for that function People familiar with it will immediately know what it is and how to use it People who are not will have a body of knowledge to draw from if they go searching That said chain is also a perfectly fine name and you could always make lift an alias or just mention it in the javadoc Thanks for your input @loganj I appreciate you taking the time to weigh in and you make good points Thanks @loganj for your input I agree that it looks scary is a lousy argument However it looks scary enough to make me join this discussion Don t underestimate the power of fear Anyway let me rephrase an argument I m trying to make here I argue that it s common for mainstream to have a different terminology from the math computer science origins I hope you will agree with me on that we don t necessarily have to agree on whether it s a good thing or not And I argue that we shouldn t deviate from the common practice One other example of importance of good naming Dart s core library dart async has a class called Stream which is essentially Observable and they have these two methods called map and transform I like the name Stream I like their map it s the same as ours map but I hate their transform It s not an alias for map it s this exact bind lift chain thing TBH I d much rather have it called lift than transform I think this is settled yup',RxJava,false,false,false
26065736,'Performance Testing','I would like to integrate performance testing as a first class aspect of rxjava core in https github com Netflix RxJava tree master rxjava core src perf One option is Google Caliper https code google com p caliper Another is JMH http openjdk java net projects code tools jmh Of potential interest Netty uses JMH http netty io wiki microbench module html I have placed some very simple manual performance tests in the src perf folders for now but I d like to establish the tooling and a few solid examples so we have a pattern to follow','cc @abersnaze as you ve been involved in these discussions and you re researching Google Caliper I would very much recommend using JMH and not Caliper The latter has lots and lots of issues which are addressed in the former Here s a great presentation http shipilev net talks devoxx Nov2013 benchmarking pdf about it Thank you for weighing in and sharing that presentation just read through it very interesting Can you point to anything about the issues with Caliper @gvsmirnov JMH looks technically pretty impressive but seems not to integrate as nicely as Caliper in an IDE workflow I could only find some very brief comments about IntelliJ integration on the Web do you know more Also as @benjchristensen says the presentation is super interesting but does not answer the question why Caliper is not a good choice A side question about all his benchmarking stuff is how much it relates to performance in production i e when running the benchmarks you measure things in a very specific way but in production it runs in a completely different environment It sometimes feels to me like measuring calories using a http en wikipedia org wiki Calorimeter which does not really correspond to the actual digestion of food To try to state it more formally is benchmarking monotonic in other words does Benchmark A Benchmark B imply that InProduction A InProduction B @benjchristensen Unfortunately there is no article presentation whatever which explicitly points out all the pitfalls of Caliper that I know of But for most of the common problems outlined in the presentation Caliper has no built in means to work around the last time I checked at least The most broken thing about Caliper is that it falls victim to loop unrolling See here http hg openjdk java net code tools jmh file tip jmh samples src main java org openjdk jmh samples JMHSample_11_Loops java JMH is all about taking the trouble off our shoulders especially the trouble we do not even suspect exists Many things that are hard to implement in Caliper like this http hg openjdk java net code tools jmh file f2e982b7c51b jmh samples src main java org openjdk jmh samples JMHSample_15_Asymmetric java and that http hg openjdk java net code tools jmh file f2e982b7c51b jmh samples src main java org openjdk jmh samples JMHSample_09_Blackholes java and that http hg openjdk java net code tools jmh file f2e982b7c51b jmh samples src main java org openjdk jmh samples JMHSample_08_DeadCode java are easy to do in JMH Now regarding IDE support there is indeed next to no of it But I personally hardly ever use IDE for things like running tests or working with VCSs Command line utilities work fine for me And for JMH they are much better that your average CLI tool I have just started a mechanical sympathy thread https groups google com forum # topic mechanical sympathy m4opvy4xq3U that discusses this subject There will probably be a lot of info there in a couple of days Thank you @gvsmirnov for the information This is something I hope we ll make a first class aspect of RxJava in the near future and your information will really help Are you interested in helping us bootstrap RxJava with JMH The rxjava core src perf code is wide open right now to setup correctly @benjchristensen I most definitely am There are some spare time issues at the moment though so I don t think I will be able to contribute for a couple of weeks Afterwards I would be happy to I understand that problem Once you have some time I d appreciate your help to get us started down the right path Some observations on the difference now that I ve actually used both of them Caliper PROS It also measures object count memory usage as well as time Makes it clear that is monitoring JIT and GC events during the timing parameter annotations makes easier to test different configurations without having to generate a method for each combination manually CONS Warm up is a bit a black box I ve seen the warnings that it has detect JIT during measurement often enough that it makes me think that it isn t doing enough to warm up the code It uploads the results P S I m not an expert in either benchmarking tool @benjchristensen Sorry it took me so long but I m finally back I ve thrown together a sample gradle project with JMH support here https github com gvsmirnov jmh gradle sample Hoping to integrate it with RxJava real soon Oh finally I have sent a pull request https github com Netflix RxJava pull 963 with the updated jmh benchmarking It features changes both to the gradle setup and to the benchmark itself The gradle set up us explained in this blog post http gvsmirnov ru blog tech 2014 03 10 keeping your benchmarks separate html The benchmark is changed in such a way that prevents most of the caveats like DCE from happening while also ensuring that more accurate results are attained Please consult these samples http hg openjdk java net code tools jmh file tip jmh samples src main java org openjdk jmh samples to gain deeper insight into how benchmarking should be done with JMH Here are the results that I got on my Haswell 2 6 GHz 16 GB RAM laptop with Java 8 Benchmark size Mode Samples Mean Mean error Units r o ObservableBenchmark measureBaseline 1 avgt 10 0 003 0 000 us op r o ObservableBenchmark measureBaseline 1024 avgt 10 2 764 0 051 us op r o ObservableBenchmark measureBaseline 1048576 avgt 10 3104 088 49 586 us op r o ObservableBenchmark measureMap 1 avgt 10 0 100 0 003 us op r o ObservableBenchmark measureMap 1024 avgt 10 5 036 0 059 us op r o ObservableBenchmark measureMap 1048576 avgt 10 6693 271 277 604 us op What we see here is that doing nothing RxJava introduces about a 2x overhead in latency compared to simply doing nothing Pretty acceptable if you ask me This is great @gvsmirnov Thank you Is there a way to maintain historical snapshots over time for getting performance diffs @benjchristensen you re very welcome Uh I m not exactly sure if there is an established practice with that You can easily get JMH to output its results in csv scsv or json Should not be a long way from there What I m doing is before merging anything to master run the benchmarks on master and on the branch Works fine for me We have JMH integrated and being used so closing this Thank you @gvsmirnov for your help on this',RxJava,false,false,false
26073032,'Fixed testSingleSourceManyIterators','Converted to a single threaded test','RxJava pull requests #691 https netflixoss ci cloudbees com job RxJava pull requests 691 SUCCESS This pull request looks good Thanks @akarnokd Sorry I didn t get around to this sooner',RxJava,true,false,false
26112932,'Fix zip race condition','The ItemObserver collection logic needs to run in both the OnNext and OnCompleted handlers Otherwise you might have values waiting to be emitted and without seeing an OnCompleted I couldn t think of an easy unit test for this it actually took a while to narrow down the example The only way I could reproduce it on my machine was to use Hystrix and it happens somewhat sporadically 10 50 iterations java public class Test public static class DummyCommand extends HystrixCommand Integer protected DummyCommand super HystrixCommandGroupKey Factory asKey Dummy @Override protected Integer run throws Exception Thread sleep 1 return 1 public static void main String args throws InterruptedException while true Observable zip tap new DummyCommand observe tap new DummyCommand observe new Func2 Integer Integer Integer @Override public Integer call Integer a Integer b return a b toBlockingObservable single System out println n n n Thread sleep 5 public static Observable Integer tap Observable Integer observable return observable doOnEach new Action1 Notification super Integer @Override public void call Notification super Integer notification System out println notification notification','RxJava pull requests #692 https netflixoss ci cloudbees com job RxJava pull requests 692 FAILURE Looks like there s a problem with this pull request Not sure why it failed since it passes locally and zip is not used in that test case Is there a way to re trigger the build Nice catch Basically you need something like T1 onNext T1 onCompleted T2 onNext T2 onCompleted where T1 onCompleted wins the lock over T2 onNext then T2 onCompleted just doens t do anything as the queues aren t empty I confirm your fix solves this issue We have a few unreliable tests and rerunning might not produce success Closing and reopening the PR might trigger a run but I m not sure @benjchristensen any idea on how to re trigger CI build any idea on how to re trigger CI build Only way I know how is updating the PR such as with a new commit It s quite annoying that way Is it possible to demonstrate the race with a unit test perhaps using latches to cause the necessary race Reason is that the zip operator will be changing soon to use the new design changes and I want to make sure we have a test to prove correctness Unfortunately it s an internal race between acquiring the read lock and trying to acquire the write lock I don t have any good ideas on how to test it without coupling it to the specific implementation RxJava pull requests #693 https netflixoss ci cloudbees com job RxJava pull requests 693 FAILURE Looks like there s a problem with this pull request RxJava pull requests #694 https netflixoss ci cloudbees com job RxJava pull requests 694 SUCCESS This pull request looks good',RxJava,true,false,false
26135617,'Make operator writing a little less error prone','','RxJava pull requests #695 https netflixoss ci cloudbees com job RxJava pull requests 695 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
26179702,'Added join','Added support for join in the Scala bindings','RxJava pull requests #696 https netflixoss ci cloudbees com job RxJava pull requests 696 SUCCESS This pull request looks good I tried to use it but got the following error java lang ClassCastException rx lang scala examples RxScalaDemo anonfun joinExample 3 cannot be cast to rx util functions Func2 at rx lang scala Observable class join Observable scala 1388 at rx lang scala JavaConversions anon 1 join JavaConversions scala 46 at rx lang scala examples RxScalaDemo joinExample RxScalaDemo scala 459 That s not surprising because before casting no implicit conversions are applied Could you please add a usage example to RxScalaDemo that s what I did so far for all operators and it serves as a minimal testing documentation tutorial at the same time Ha ha Too much exposure to Haskell Can t trust any other language',RxJava,true,false,false
26198677,'Fixed buglet in join binding simplified types','Txs to @samuelgruetter for pointing out a small bug involving implicit conversions Simplified some of the types of empty buffer window groupBy until to leverage Scala s top and bottom type we could not do this in C#','RxJava pull requests #697 https netflixoss ci cloudbees com job RxJava pull requests 697 SUCCESS This pull request looks good',RxJava,true,false,false
26200497,'Scheduler schedulePeriodically obvious memory leak','Folks this is a pretty bad memory leak I didn t even had to see it in action because it s provable See the current code at https github com Netflix RxJava blob master rxjava core src main java rx Scheduler java#L93 The method in question is this java public T Subscription schedulePeriodically T state final Func2 super Scheduler super T extends Subscription action long initialDelay long period TimeUnit unit final long periodInNanos unit toNanos period final AtomicBoolean complete new AtomicBoolean final Func2 Scheduler T Subscription recursiveAction new Func2 Scheduler T Subscription @Override public Subscription call Scheduler scheduler T state0 if complete get long startedAt now final Subscription sub1 action call scheduler state0 long timeTakenByActionInNanos TimeUnit MILLISECONDS toNanos now startedAt final Subscription sub2 schedule state0 this periodInNanos timeTakenByActionInNanos TimeUnit NANOSECONDS return Subscriptions create new Action0 @Override public void call sub1 unsubscribe sub2 unsubscribe return Subscriptions empty final Subscription sub schedule state recursiveAction initialDelay unit return Subscriptions create new Action0 @Override public void call complete set true sub unsubscribe The problem is that each and every one periodic execution of the given action is creating a new Subscription reference that is capturing the reference of the previous subscription And no subscription reference will ever be garbage collected unless unsubscribe happens','I updated the issue multiple times hopefully it s helpful Thanks @benjchristensen are you working on this I ve just been hit by that while implementing a short period periodic task using an Action0 hence without explicitly adding new subscriptions to the party for cgeo http github com cgeo cgeo Yes I can as schedulers is on my list for 0 17 and I fixed memory leaks in schedulers already obviously missing this one I completely ignored the schedulePeriodically methods Hey I believe this can be closed no I saw that Schedulers changed the interface Yup it can be I need to do a pass through all of the issues I bet 1 3 of them are probably ready for me to close I think the current version doesn t leak but can t be cancelled either This program prints 1 through 6 java public static void main String args throws Exception Worker w Schedulers computation createWorker CompositeSubscription cs new CompositeSubscription AtomicInteger i new AtomicInteger cs add w schedulePeriodically int j i incrementAndGet if j 3 cs unsubscribe System out println j if j 6 w unsubscribe 200 200 TimeUnit MILLISECONDS TimeUnit SECONDS sleep 2 The reason this doesn t seem to be an issue because most operators don t mix schedule with schedulePeriodic Memory leak is fixed The cancellation issue is being solved elsewhere',RxJava,false,false,false
26256000,'Implement some Android UI related operators','1 OperatorViewClick 2 OperatorEditTextInput 3 OperatorCompoundButtonInput','RxJava pull requests #698 https netflixoss ci cloudbees com job RxJava pull requests 698 SUCCESS This pull request looks good RxJava pull requests #705 https netflixoss ci cloudbees com job RxJava pull requests 705 SUCCESS This pull request looks good',RxJava,true,false,false
26282155,'Lift and Observer Subscription','Make Observer implement Subscription and rename bind to lift as per decisions in https github com Netflix RxJava issues 775 Signatures are now java Observable create public final static T Observable T create OnSubscribe T f Observable OnSubscribe typed function interface public static interface OnSubscribe T extends Action1 Observer super T lift function public R Observable R lift final Func1 Observer super R Observer super T bind Observer public abstract class Observer T implements Subscription public abstract void onNext T t public abstract void onError Throwable e public abstract void onCompleted public final void add Subscription s public final void unsubscribe public final boolean isUnsubscribed Subject public abstract class Subject T R extends Observer T public abstract Observable R toObservable This is a major set of changes to the internals particularly the unit tests because Mockito has issues with abstract classes as opposed to Observer being an interface There are still some unit tests failing that I haven t yet figured out OperationJoinsTest whenComplicated in rxjava core OperationConditionalsTest testDoWhileManyTimes in rxjava computation expressions OperationConditionalsTest testWhileDoManyTimes in rxjava computation expressions I intend on merging this sooner rather than later so everyone can be working off the same codebase even though I do not consider this code ready for release even once those unit tests are fixed Interestingly these performance tests on my machine are much better java OperatorFromIterablePerformance timeTenLongs v0 16 Run 10 8 096 667 ops sec Run 11 8 382 131 ops sec Run 12 8 256 288 ops sec Run 13 8 139 703 ops sec Run 14 8 011 023 ops sec after v0 17 work Run 10 31 296 553 ops sec Run 11 30 080 435 ops sec Run 12 31 886 941 ops sec Run 13 32 281 807 ops sec Run 14 33 519 028 ops sec OperatorMapPerformance timeMapPlusOne v0 16 Run 10 11 375 632 ops sec Run 11 11 390 325 ops sec Run 12 11 655 527 ops sec Run 13 11 528 440 ops sec Run 14 11 321 181 ops sec after v0 17 work Run 10 17 674 464 ops sec Run 11 17 890 239 ops sec Run 12 17 919 155 ops sec Run 13 16 356 974 ops sec Run 14 16 723 414 ops sec OperatorMergePerformance timeRepetitionsEmissionSynchronous v0 16 Run 10 32 609 617 ops sec Run 11 33 511 839 ops sec Run 12 34 768 096 ops sec Run 13 32 376 499 ops sec Run 14 33 166 835 ops sec after v0 17 work Run 10 45 945 747 ops sec Run 11 46 342 209 ops sec Run 12 44 493 090 ops sec Run 13 44 999 640 ops sec Run 14 47 389 771 ops sec','cc @abersnaze @akarnokd @headinthebox RxJava pull requests #699 https netflixoss ci cloudbees com job RxJava pull requests 699 FAILURE Looks like there s a problem with this pull request If I factor out the subjects toObservable calls to be the same the test passes java Observable Integer xso xs toObservable Observable Integer yso ys toObservable Observable Integer zso zs toObservable Observable Integer m Observable when xso and yso then add2 1 4 5 2 5 7 3 6 9 xso and zso then mul2 1 7 7 2 8 16 3 9 27 yso and zso then sub2 4 7 3 5 8 3 6 9 3 Otherwise it seems you had like 6 different and operations and source numbers were replicated to all of them This way there were multiple queues per source and did independent matching As for the conditionals change the SerialSubscription to MultipleAssignmentSubscription in OperationConditionals#L235 and any dependent places @akarnokd Thanks for the pointer to the problem I have fixed the Subject toObservable implementations to correctly have only 1 Observable instance for the life of the Subject Looking at OperationConditionals RxJava pull requests #700 https netflixoss ci cloudbees com job RxJava pull requests 700 FAILURE Looks like there s a problem with this pull request For Observable join and Observable groupJoin you must draw a marble diagram at least I do otherwise your brain will melt RxJava pull requests #701 https netflixoss ci cloudbees com job RxJava pull requests 701 FAILURE Looks like there s a problem with this pull request RxJava pull requests #702 https netflixoss ci cloudbees com job RxJava pull requests 702 FAILURE Looks like there s a problem with this pull request As for the conditionals change the SerialSubscription to MultipleAssignmentSubscription in OperationConditionals#L235 and any dependent places That indeed fixes it though I have yet to track down why the unsubscribe on each pass causes things to fail now whereas it didn t before RxJava pull requests #703 https netflixoss ci cloudbees com job RxJava pull requests 703 SUCCESS This pull request looks good Merging so work can continue on master branch',RxJava,true,false,false
26308953,'Reimplement Zip Operator Using Lift Preview','A preview of a re implementation of the zip operator This re implements the zip operator but not yet the zipIterable so those unit tests are still failing I m submitting early to get a code review and will finish the zipIterable sometime early next week I have already had the concurrency model reviewed by two others and all unit tests are passing but further review is justified and welcome The performance of this implementation without doing any profiling has risen from 1 42m ops second on v0 16 to 1 67m ops second as measured on my machine for the simple test Observable zip from 1 from 1 a b a b and 31k ops second to 63k ops second for Observable zip range 0 100 range 100 200 a b a b','RxJava pull requests #704 https netflixoss ci cloudbees com job RxJava pull requests 704 ABORTED Other than the lack of null sentinel it looks okay Thank you both for the review Is it possible to lift n arity operator Is it possible to lift 2 n arity operator If you re referring to arguments passed into an Operator implementation yes they can take anything you want to pass in If you re referring to something like zip T1 T2 then it s a little different since a lift is performed on an Observable T so the T contains everything that can be done against it In this particular instance I m taking the types creating an Observable Observable out of them and then lift the OperatorZip into it The zip operator ignores the types internally for simplicity so we don t have N number of implementations and then re establish the types when it emits java return just new Observable o1 o2 o3 lift new OperatorZip R zipFunction If the specific types wanted to be retained then the T would need to become a type that contained everything I think of this somewhat like currying where an Observable represents only a single type so if I need to work on multiple types at once I need to compose them together first With zip implemented most other operators needing to combine types could first use zip to do the composition and then lift that Observable RxJava pull requests #716 https netflixoss ci cloudbees com job RxJava pull requests 716 ABORTED RxJava pull requests #732 https netflixoss ci cloudbees com job RxJava pull requests 732 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
26321491,'Careful With That Global Search And Replace Eugene','restoring the working URLs of RxJava wiki pages and marble diagrams in the javadocs http www youtube com watch v AYMyxTFwuz8','RxJava pull requests #706 https netflixoss ci cloudbees com job RxJava pull requests 706 SUCCESS This pull request looks good Whoops I thought I had fixed the bad search replace I did Obviously not Thanks for fixing those I did the same once when working on the Scala bindings',RxJava,true,false,false
26345942,'Fix problem with Observable create','Fix problem with Obserable create Avoid the use of deprecated methods','RxJava pull requests #707 https netflixoss ci cloudbees com job RxJava pull requests 707 SUCCESS This pull request looks good Thank you @MarioAriasC',RxJava,true,false,false
26380425,'Performance benchmark with caliper','Minimal changes to get a gradlew time task to accurately benchmark performance changes for #776 I m still looking into JHM but I m not sure how well it will integrate with Rx s gradle build','RxJava pull requests #708 https netflixoss ci cloudbees com job RxJava pull requests 708 FAILURE Looks like there s a problem with this pull request RxJava pull requests #713 https netflixoss ci cloudbees com job RxJava pull requests 713 SUCCESS This pull request looks good Example output http microbenchmarks appspot com runs 2bf85f2a a3cc 4612 afb7 99a556aebe93#r scenario benchmarkSpec methodName',RxJava,true,false,false
26436081,'Exception in subscribe s onNext is not rethrown','scala import rx lang scala Observable Observable items 1 2 3 subscribe next throw new RuntimeException Bang I m still trying to grasp all the nuances of the Rx Contract but according to various sources for one http social msdn microsoft com Forums en US 6ea06e08 6d26 49b4 a3fa 276d1efef780 what if an exception is thrown by the observer in onnext forum rx I d expect this code snippet to throw the Bang exception but it does as of Rx 0 16 1 not However such issue seems too basic to me to go unnoticed so I guess there is some reason for such behavior Can someone elaborate please Thank you Tom Dvo k','Your Bang exception should be sent to onError method But you do not pass the onError function So an OnErrorNotImplementedException should be thrown However as the issue #771 the OnErrorNotImplementedException will be swallowed Once the issue is fixed you will observe OnErrorNotImplementedException Dealing with in pull request https github com Netflix RxJava pull 839 Should be fixed in https github com Netflix RxJava pull 839',RxJava,false,false,false
26472378,'Convert to scan to use lift','I switched the scan to an operator and cleaned up what looked like a lot of unnecessary code from the summing operations','RxJava pull requests #711 https netflixoss ci cloudbees com job RxJava pull requests 711 FAILURE Looks like there s a problem with this pull request not sure what went wrong on cloud bees because it works locally from the command line and eclipse RxJava pull requests #714 https netflixoss ci cloudbees com job RxJava pull requests 714 FAILURE Looks like there s a problem with this pull request RxJava pull requests #786 https netflixoss ci cloudbees com job RxJava pull requests 786 FAILURE Looks like there s a problem with this pull request RxJava pull requests #794 https netflixoss ci cloudbees com job RxJava pull requests 794 SUCCESS This pull request looks good To answer @benjchristensen s question about the performance of sumInteger Float Long Double Originally half of the implementations were based on reduce R Func2 R T R and the other half were custom I just removed the custom code for reduce Func2 T T T which has the behavior of throwing an error when the Observable is empty I m having a hard time imagining a critical situation for sum together an Observable numbers to justify so much custom code',RxJava,true,false,false
26553404,'improve switchOnNext description in javadocs','also repair anchors in links to RxJava wiki in javadocs','RxJava pull requests #712 https netflixoss ci cloudbees com job RxJava pull requests 712 SUCCESS This pull request looks good',RxJava,true,false,false
26577009,'Observer and or Subscriber','A discussion in issue https github com Netflix RxJava issues 746#issuecomment 33637512 related to Observer having become an abstract class led to the idea of keeping Observer as an interface and introducing a new type Subscriber to represent Observer Subscription I have implemented this change on this branch for review https github com benjchristensen RxJava tree subscriber observer The signatures currently are java Observable create public final static T Observable T create OnSubscribe T f Observable OnSubscribe typed function interface public static interface OnSubscribe T extends Action1 Observer super T Observable subscribe public final Subscription subscribe Observer super T observer lift function public R Observable R lift final Func1 Observer super R Observer super T bind Observer public abstract class Observer T implements Subscription public abstract void onNext T t public abstract void onError Throwable e public abstract void onCompleted public final void add Subscription s public final void unsubscribe public final boolean isUnsubscribed Subject public abstract class Subject T R extends Observer T public abstract Observable R toObservable This branch changes them to java Observable create public final static T Observable T create OnSubscribe T f Observable OnSubscribe typed function interface public static interface OnSubscribe T extends Action1 Subscriber super T Observable subscribe public final Subscription subscribe Subscriber super T subscriber public final Subscription subscribe Observer super T observer lift function public R Observable R lift final Func1 Subscriber super R Subscriber super T bind Observer public interface Observer T public abstract void onNext T t public abstract void onError Throwable e public abstract void onCompleted Subscriber public abstract class Subscriber T implements Observer T Subscription public final void add Subscription s public final void unsubscribe public final boolean isUnsubscribed Subject this could probably be changed back to implementing Observer and extending Observable public abstract class Subject T R extends Subscriber T public abstract Observable R toObservable This allows an Observer to subscribe java Observable create new OnSubscribe Integer @Override public void call Subscriber super Integer ob for int i 1 i 100000 i The Observer communicates whether it is unsubscribed so loops and seqential processing on the same thread can now unsubscribe if ob isUnsubscribed System out println Unsubscribed at i return ob onNext i ob onCompleted subscribe new Observer Integer @Override public void onCompleted System out println Completed @Override public void onError Throwable e e printStackTrace @Override public void onNext Integer i System out println Received i if i 10 a Subscriber can unsubscribe but an Observer can not unsubscribe but notice that an Observer alone can not unsubscribe A Subscriber however can unsubscribe java package rx import rx Observable OnSubscribe public class Test public static void main String args Observable create new OnSubscribe Integer @Override public void call Subscriber super Integer ob for int i 1 i 100000 i The Observer communicates whether it is unsubscribed so loops and seqential processing on the same thread can now unsubscribe if ob isUnsubscribed System out println Unsubscribed at i return ob onNext i ob onCompleted subscribe new Subscriber Integer @Override public void onCompleted System out println Completed @Override public void onError Throwable e e printStackTrace @Override public void onNext Integer i System out println Received i if i 10 a Subscriber can unsubscribe but an Observer can not unsubscribe Pros of this change Observer remains an interface which allows classes to implement it and not run into multiple inheritance issues Unit tests are clean without need for wrapping a mock Observer in TestObserver Most use cases can just use subscribe Observer with the interface but it s just as easy with subscribe Subscriber unless you need multiple inheritance Cons of this change There is a new Subscriber type and users would need to understand the difference between Observer and Subscriber There are both subscribe Subscriber and subscribe Observer and if using subscribe Observer the Observer can not unsubscribe However it is quite rare that a user provided Observer actually needs the ability to unsubscribe and if they do they would use take takeUntil or now be able to use Subscriber Operator implementations would need to be sure to use Subscriber and not Observer whereas if we only have Observer they have no choice This should not be a problem for most users of RxJava however Please weigh in with opinions or better ideas cc @headinthebox @mttkay @akarnokd @zsxwing @abersnaze @samuelgruetter @jmhofer @mattrjacobs','I like this newer structure better As for the Subject I would go for extends Observable implements Observer Agree with @akarnokd on reverting Subject to the pre tectonic shift definition Generally I guess this is the design that the gravity of the Java type system is pulling us to On good thing I guess is that it minimizes the changes to the external API service and only puts the additional constraints on those who want to implement operators definitely 1 on this one I don t think it s too much to ask to familiarize yourself with the Subscriber type when writing your own operators and for the more likely case that you don t write your own the interfaces remain simple familiar and unit tests straight forward and clean Good compromise Thanks for the feedback I ll proceed down this path I prefer the purity of having only Observer but I agree that Subscriber Observer is the better solution of those we ve considered thus far for working within the constraints of Java 1 I would like to propose that we also have a remove Subscription on the Subscriber so that Operator implementations don t have to add there own CompositeSubscription instances to get that functionality Any intermediates separating the Subscriber s makes it impossible for the debug hook to build a fulling connected Observerable chain 2 Is there some way to alert prevent internal operators from using the Subscription subscribe Observer to direct the migration to void subscribe Subscriber as soon as possible Any use of the Subscription subscribe Observer method breaks synchronous Observerable unsubscribe support for the whole chain Just a little comment I don t if it s the good place here For beginers it would be easyer to understand pushNext pushCompleted pushError in the push model of Observable I would like to propose that we also have a remove Subscription on the Subscriber so that Operator implementations don t have to add there own CompositeSubscription instances to get that functionality Why What harm is it for Subscriber to compose CompositeSubscription And why should an Operator ever remove a Subscription Is there some way to alert prevent internal operators What do you suggest For beginners it would be easier to understand pushNext pushCompleted pushError in the push model of Observable It all depends on the perspective From the receiving side of an Observer it is not a push but a receipt Thus from the Observable create side it may look like pushNext but from the Observable subscribe side it looks like receiveNext The on prefix is a common listener or handler standard The two sides are not separated from each other as it just adds more type complexity such as java SendingObserver pushNext T pushError Throwable pushCompleted ReceivingObserver onNext T onError Throwable onCompleted In reality it would just end up like this java Observer final pushNext T t onNext t final pushError Throwable e onError e final pushCompleted onCompleted abstract onNext T abstract onError Throwable abstract onCompleted In which case why not just invoke onNext directly instead of pushNext which just calls onNext Also all implementations of Rx across languages use onNext onCompleted onError I think onNext is more intuitive since the name Observer suggests a passive role This is in line with the subject observer pattern which is widely known and adopted I use RxJava for several months now so I use onNext Co with no problem But when I explain Rx to beginers I often wrote Observable create new OnSubscribeFunction String public Subscription onSubscribe Observer String pusher pusher onNext On Jan 30 2014 at 12 21 PM Ben Christensen notifications@github com wrote I would like to propose that we also have a remove Subscription on the Subscriber so that Operator implementations don t have to add there own CompositeSubscription instances to get that functionality Why What harm is it for Subscriber to compose CompositeSubscription And why should an Operator ever remove a Subscription Any intermediates separating the Subscribers makes it impossible for a debug hook to build a fulling connected Observerable chain Ideally i would like to see CompositeSubscription renamed to Subscription so I could have a hook on add that would have to be used everywhere to allow me to build the Observable chains across all Operators Is there some way to alert prevent internal operators What do you suggest We could base when to do something by looking at the package like we do for wrapping with SafeObserverable As for what to do it would be easiest to throw an exception There currently isn t an option for nagging but still being functional CompositeSubscription renamed to Subscription Not all Subscriptions have the signature of a CompositeSubscription There is a reason for the various implementations Any intermediates separating the Subscribers A bad operator implementation could do this no matter what we do as operators must be capable of decoupling the chain otherwise operators like groupBy can not be implemented Ultimately it is required for operators to be implemented correctly otherwise it s not just the debug hook that will have problems but subscriptions won t unsubscribe correctly and resources won t be cleaned up throw an exception We can t throw an exception as nothing would work until every single operator was migrated It would also defeat the point of allowing the deprecated OnSubscribeFunc being used until some future version when it is removed I have merged these changes into master',RxJava,false,false,false
26658739,'Observer Subscriber','As per discussion in https github com Netflix RxJava issues 792 the abstract class Observer has been returned to interface Observer and there is now abstract class Subscriber implements Observer T Subscription to fill that role Signatures are now java Observable create public final static T Observable T create OnSubscribe T f Observable OnSubscribe typed function interface public static interface OnSubscribe T extends Action1 Subscriber super T Observable subscribe public final Subscription subscribe Subscriber super T subscriber public final Subscription subscribe Observer super T observer lift function public R Observable R lift final Func1 Subscriber super R Subscriber super T bind Observer public interface Observer T public abstract void onNext T t public abstract void onError Throwable e public abstract void onCompleted Subscriber public abstract class Subscriber T implements Observer T Subscription public final void add Subscription s public final void unsubscribe public final boolean isUnsubscribed Subject public abstract class Subject T R extends Observable R implements Observer T','RxJava pull requests #715 https netflixoss ci cloudbees com job RxJava pull requests 715 SUCCESS This pull request looks good',RxJava,true,false,false
26684314,'Creating two streams using zip from singe stream split','Having the following program java package org foo import java util Random import rx Observable import rx util functions Action1 import rx util functions Func1 import rx util functions Func2 import com opengamma lambdava tuple Pair com opengamma lambdava 0 3 from http maven opengamma com nexus content groups public public class Rx static class Position Position String security int qty this qty qty this security security public int qty public String security static double getMarketValueForSecurity String security Random r new Random System currentTimeMillis return r nextDouble static double calcValue double mktValue Position position Double coefficent return mktValue coefficent static Position portfolio new Position new Position AAPL 10 new Position OG 999 new Position AAPL 1000 new Position M 910 new Position HSBC 1910 public static void main String args compute portfolio public static void compute Position names Observable Position positions Observable from names only big positions Observable Position onlyBigPositions positions filter new Func1 Position Boolean @Override public Boolean call Position position return position qty 100 Observable Double marketValuesForPositions onlyBigPositions map new Func1 Position Double @Override public Double call Position position return getMarketValueForSecurity position security Observable Double fairValueCoefficient Observable from 1 2 repeat Observable Double skewedValueCoefficient Observable from 1 3 repeat Observable Pair Position Double positionsWithMarketValues onlyBigPositions cache zip marketValuesForPositions new ToPair Position Double cache Observable Pair Position Double positionsWithFairValues positionsWithMarketValues zip fairValueCoefficient new ToPair Pair Position Double Double map new Func1 Pair Pair Position Double Double Pair Position Double @Override public Pair Position Double call Pair Pair Position Double Double e Pair Position Double positionsWithMarketValue e getFirst Position position positionsWithMarketValue getFirst Double marketValue positionsWithMarketValue getSecond Double c e getSecond return Pair of position calcValue marketValue position c Observable Pair Position Double positionsWithFairValuesSkewed positionsWithMarketValues zip skewedValueCoefficient new ToPair Pair Position Double Double map new Func1 Pair Pair Position Double Double Pair Position Double @Override public Pair Position Double call Pair Pair Position Double Double e Pair Position Double positionsWithMarketValue e getFirst Position position positionsWithMarketValue getFirst Double marketValue positionsWithMarketValue getSecond Double c e getSecond return Pair of position calcValue marketValue position c positionsWithMarketValues subscribe new Action1 Pair Position Double @Override public void call Pair Position Double o System out println Market value for position o getFirst security is o getSecond positionsWithFairValues subscribe new Action1 Pair Position Double @Override public void call Pair Position Double o System out println Fair value for position o getFirst security is o getSecond positionsWithFairValuesSkewed subscribe new Action1 Pair Position Double @Override public void call Pair Position Double o System out println Skewed Fair value for position o getFirst security is o getSecond static class ToPair A B implements Func2 A B Pair A B @Override public Pair A B call A t B u return Pair of t u Why I get output Market value for position OG is 0 7260218088269859 Market value for position AAPL is 0 7260218088269859 Market value for position M is 0 7260218088269859 Market value for position HSBC is 0 7260218088269859 Fair value for position OG is 0 871226170592383 Fair value for position AAPL is 0 871226170592383 Fair value for position M is 0 871226170592383 Fair value for position HSBC is 0 871226170592383 instead of Market value for position OG is 0 7260218088269859 Market value for position AAPL is 0 7260218088269859 Market value for position M is 0 7260218088269859 Market value for position HSBC is 0 7260218088269859 Fair value for position OG is 0 871226170592383 Fair value for position AAPL is 0 871226170592383 Fair value for position M is 0 871226170592383 Fair value for position HSBC is 0 871226170592383 Skewed Fair value for position OG is 0 3744282129019022 Skewed Fair value for position AAPL is 0 3744282129019022 Skewed Fair value for position M is 0 3744282129019022 Skewed Fair value for position HSBC is 0 3744282129019022','Hi Could you try it without cache calls In addition using Observable from 1 2 repeat is kind of dangerous as it will push out a large number of values filling up the queue of the zip operator and may cause swallowed OutOfMemoryException Instead I sugest using the zip Iterable overload with Guava s Iterables cycle T instead This will ensure that zip only pulls the constant when the observable part produces a value 1 for @akarnokd without cache the behaviour is exactly the same I have produced minimal example showing the problem java import java util Arrays import java util Iterator import java util List import rx Observable import rx util functions Action1 import rx util functions Func1 import rx util functions Func2 public class Rx3 public static void main String args compute public static void compute Observable Integer inputData Observable from 1 2 3 4 5 Observable Double c1 Observable from constantIterable 1 2 Observable Double c2 Observable from constantIterable 1 3 THIS MAKES NO DIFFERENCE Observable Integer doubled inputData map new Func1 Integer Integer @Override public Integer call Integer integer return 2 integer cache Observable Integer doubled inputData map new Func1 Integer Integer @Override public Integer call Integer integer return 2 integer Observable List Double x doubled zip c1 new Func2 Integer Double List Double @Override public List Double call Integer integer Double aDouble return Arrays asList aDouble aDouble integer Observable List Double y doubled zip c2 new Func2 Integer Double List Double @Override public List Double call Integer integer Double aDouble return Arrays asList aDouble aDouble integer doubled subscribe new Action1 Integer @Override public void call Integer integer System out println doubled integer x subscribe new Action1 List Double @Override public void call List Double doubles System out println x doubles y subscribe new Action1 List Double @Override public void call List Double doubles System out println y doubles public static T Iterator T constantIterator final T v return new Iterator T @Override public boolean hasNext return true @Override public T next return v @Override public void remove nop public static T Iterable T constantIterable final T v return new Iterable T @Override public Iterator T iterator return constantIterator v Use your constantIterable directly with the zip I m not cerain but the overload is in 0 16 1 Is this still an issue Closing out at this is quite old Please reopen if needed',RxJava,false,false,false
26703395,'Cannot call subscribeOn or observeOn twice or it won t produce desired behavior','import rx Observable import rx Observable OnSubscribeFunc import rx Observer import rx Subscription import rx concurrency Schedulers import rx util functions Action1 public class Main public static void main String args System out println Start 1 getNumberedObservable 1 observeOn Schedulers immediate subscribeOn Schedulers immediate subscribe new Action1 Integer @Override public void call Integer value System out println value returned System out println Finish 1 System out println Start 2 getNumberedObservable 2 observeOn Schedulers immediate subscribeOn Schedulers immediate subscribe new Action1 Integer @Override public void call Integer value System out println value returned System out println Finish 2 System out println Start 3 getNumberedObservable 3 observeOn Schedulers immediate subscribeOn Schedulers immediate subscribe new Action1 Integer @Override public void call Integer value System out println value returned System out println Finish 3 try Thread sleep 1000 catch InterruptedException e public static Observable Integer getNumberedObservable final int value return Observable create new OnSubscribeFunc Integer @Override public Subscription onSubscribe Observer super Integer observer observer onNext value observer onCompleted return null subscribeOn Schedulers threadPoolForComputation observeOn Schedulers threadPoolForIO Based on the above program you would expect it to output Start 1 1 returned Finish 1 Start 2 2 returned Finish 2 Start 3 3 returned Finish 3 But instead it outputs Start 1 Finish 1 Start 2 Finish 2 Start 3 Finish 3 2 returned 3 returned 1 returned It can be fixed by removing the subscribeOn and observeOn setting from the getNumberedObservable function Since after that function returns I m setting them both to immediate you d think it would go back to normal behavior but it isn t it seems','This is the expected behavior Using subscribeOn observeOn with a thread pool will allow the caller thread in main to complete before the calculation can happen Using immediate scheduler afterwards is practically a no op If you need to wait for the completion of the observables specify the onCompleted handler and use CountDownLatch In addition returning null Subscription can lead to NPEs so instead return Subscriptions empty I think there is a misunderstanding If I set subscribeOn observeOn to Schedulers immediate I get output A If I make a new observable set subscribeOn observeOn to Schedulers io and then before subscribing set subscribeOn observeOn to Schedulers immediate I get output B I should be getting output A since I changed the observable back to immediate It doesn t work like that You are not setting the scheduler back but routing it again to a no op immediate scheduler Would there be a way to reset the observable back to the original behavior after a thread pool has been applied I realize this is an odd question No You need to keep a reference to the chain before the observeOn subscribeOn is applied',RxJava,false,false,false
26726852,'Add Subscription isUnsubscribed','With the new model of injecting Subscription into functions for synchronous loops to check isUnsubscribed it now makes sense for this to be on the interface of all Subscription implementations','RxJava pull requests #717 https netflixoss ci cloudbees com job RxJava pull requests 717 SUCCESS This pull request looks good Thanks Ben as you know I wanted this change for a long time On Sat Feb 1 2014 at 1 48 AM Ben Christensen notifications@github com wrote With the new model of injecting Subscription into functions for synchronous loops to check isUnsubscribed it now makes sense for this to be on the interface of all Subscription implementations You can merge this Pull Request by running git pull https github com benjchristensen RxJava subscription isunsubscribed Or view comment on or merge it at https github com Netflix RxJava pull 796 Commit Summary Add Subscription isUnsubscribed File Changes M language adaptors rxjava groovy src examples groovy rx lang groovy examples RxExamples groovy https github com Netflix RxJava pull 796 files#diff 0 7 M language adaptors rxjava groovy src test groovy rx lang groovy ObservableTests groovy https github com Netflix RxJava pull 796 files#diff 1 7 M language adaptors rxjava scala src main scala rx lang scala Subscription scala https github com Netflix RxJava pull 796 files#diff 2 2 M rxjava contrib rxjava android src main java rx operators OperationObserveFromAndroidComponent java https github com Netflix RxJava pull 796 files#diff 3 8 M rxjava core src main java rx Subscription java https github com Netflix RxJava pull 796 files#diff 4 2 M rxjava core src main java rx operators ChunkedOperation java https github com Netflix RxJava pull 796 files#diff 5 14 M rxjava core src main java rx operators OperationBuffer java https github com Netflix RxJava pull 796 files#diff 6 5 M rxjava core src main java rx operators OperationConcat java https github com Netflix RxJava pull 796 files#diff 7 8 M rxjava core src main java rx operators OperationGroupJoin java https github com Netflix RxJava pull 796 files#diff 8 6 M rxjava core src main java rx operators OperationMergeDelayError java https github com Netflix RxJava pull 796 files#diff 9 38 M rxjava core src main java rx operators OperationMulticast java https github com Netflix RxJava pull 796 files#diff 10 7 M rxjava core src main java rx operators OperationOnErrorResumeNextViaFunction java https github com Netflix RxJava pull 796 files#diff 11 8 M rxjava core src main java rx operators OperationOnErrorResumeNextViaObservable java https github com Netflix RxJava pull 796 files#diff 12 8 M rxjava core src main java rx operators OperationOnErrorReturn java https github com Netflix RxJava pull 796 files#diff 13 8 M rxjava core src main java rx operators OperationOnExceptionResumeNextViaObservable java https github com Netflix RxJava pull 796 files#diff 14 8 M rxjava core src main java rx operators OperationReplay java https github com Netflix RxJava pull 796 files#diff 15 5 M rxjava core src main java rx operators OperationSkipUntil java https github com Netflix RxJava pull 796 files#diff 16 6 M rxjava core src main java rx operators OperationSubscribeOn java https github com Netflix RxJava pull 796 files#diff 17 7 M rxjava core src main java rx operators OperationZip java https github com Netflix RxJava pull 796 files#diff 18 6 M rxjava core src main java rx operators SafeObservableSubscription java https github com Netflix RxJava pull 796 files#diff 19 5 M rxjava core src main java rx schedulers CurrentThreadScheduler java https github com Netflix RxJava pull 796 files#diff 20 5 M rxjava core src main java rx schedulers DiscardableAction java https github com Netflix RxJava pull 796 files#diff 21 5 M rxjava core src main java rx schedulers ExecutorScheduler java https github com Netflix RxJava pull 796 files#diff 22 5 M rxjava core src main java rx schedulers TestScheduler java https github com Netflix RxJava pull 796 files#diff 23 9 M rxjava core src main java rx subjects SubjectSubscriptionManager java https github com Netflix RxJava pull 796 files#diff 24 9 M rxjava core src main java rx subscriptions RefCountSubscription java https github com Netflix RxJava pull 796 files#diff 25 5 M rxjava core src main java rx subscriptions Subscriptions java https github com Netflix RxJava pull 796 files#diff 26 45 M rxjava core src test java rx operators OperationConcatTest java https github com Netflix RxJava pull 796 files#diff 27 23 M rxjava core src test java rx operators OperationMaterializeTest java https github com Netflix RxJava pull 796 files#diff 28 10 M rxjava core src test java rx operators OperationMergeDelayErrorTest java https github com Netflix RxJava pull 796 files#diff 29 51 M rxjava core src test java rx operators OperationSynchronizeTest java https github com Netflix RxJava pull 796 files#diff 30 5 M rxjava core src test java rx operators OperationUsingTest java https github com Netflix RxJava pull 796 files#diff 31 5 M rxjava core src test java rx operators OperatorMergeTest java https github com Netflix RxJava pull 796 files#diff 32 41 M rxjava core src test java rx operators OperatorTakeTest java https github com Netflix RxJava pull 796 files#diff 33 5 M rxjava core src test java rx subscriptions CompositeSubscriptionTest java https github com Netflix RxJava pull 796 files#diff 34 50 Patch Links https github com Netflix RxJava pull 796 patch https github com Netflix RxJava pull 796 diff Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 796',RxJava,true,false,false
26755315,'Scheduler Outer Inner Preview','Following are proposed changes to the Scheduler signature based on discussions between @headinthebox and I intended to simplify scheduling and make it easier to do the right thing This originates from three findings 1 It was very easy to cause memory leaks or inadvertent parallel execution since the distinction between outer and inner scheduling was not obvious To solve this the new design explicitly has the outer Scheduler and then Scheduler Inner for recursion 2 The passing of state is not useful since scheduling over network boundaries with this model does not work In this new design all state passing signatures have been removed This was determined while implementing a RemoteScheduler that attempted to use observeOn to transition execution from one machine to another This does not work because of the requirement for serializing deserializing the state of the entire execution stack Migration of work over the network has been bound to be better suited to explicit boundaries established by Subjects Thus the complications within the Schedulers are unnecessary 3 The number of overloads with different ways of doing the same things were confusing This new design removes all but the essential and simplest methods This is the new signature for Scheduler java public abstract class Scheduler the primary entry point it immediately schedulers work on a new thread and executes it the return subscription will shut down the Inner scheduler when unsubscribed public abstract T Subscription schedule Action1 Scheduler Inner action public T Subscription schedule final Action1 Scheduler Inner action final long delayTime final TimeUnit unit public int degreeOfParallelism public long now public abstract class Inner implements Subscription public abstract void schedule Action1 Scheduler Inner action public abstract void schedule Action1 Scheduler Inner action long delayTime TimeUnit unit public void schedulePeriodically final Action1 Scheduler Inner action long initialDelay long period TimeUnit unit I question having schedulePeriodically here since recursion allow the same behavior and with conditional logic public void schedule Action1 Scheduler Inner action Date dueTime The simplest execution of a single task is java Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner doWork Recursion is easily invoked java Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner doWork recurse until unsubscribed the schedule will do nothing if unsubscribed inner schedule this The use of Action1 Inner on both the outer and inner levels makes it so recursion that refer to this and it works easily Similar to the new lift create pattern with Subscriber the Inner is also a Subscription so it allows efficient loops with unsubscribe support java Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner while inner isUnsubscribed doWork An action can now unsubscribe the Scheduler Inner java Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner while inner isUnsubscribed int i doOtherWork if i 100 an Action can cause the Scheduler to unsubscribe and stop inner unsubscribe Typically just stopping is sufficient java Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner int i doOtherWork if i 10 recurse until done 10 inner schedule this but if other work in other tasks is being done and you want to unsubscribe conditionally you could java Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner int i doOtherWork if i 10 recurse until done 10 inner schedule this else inner unsubscribe and the recursion can be delayed java Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner doWork recurse until unsubscribed but delay the recursion inner schedule this 500 TimeUnit MILLISECONDS The methods on the Inner never return a Subscription because they are always a single thread event loop actor etc and controlled by the Subscription returned by the initial Scheduler schedule method This is part of clarifying the contract Thus an unsubscribe controlled from the outside would be done like this java Subscription s Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner while inner isUnsubscribed doWork unsubscribe from outside s unsubscribe I d appreciate feedback on this design direction NOTE This pull request is not yet complete I have not modified the language adaptors or other modules and there are 3 unit tests in core failing related to buffer and window','RxJava pull requests #718 https netflixoss ci cloudbees com job RxJava pull requests 718 FAILURE Looks like there s a problem with this pull request Love this new design it fixes a lot of the issues that the previous design inherited from the old Rx NET Win 1 The explicit C funcptr style of passing the state separately from the function pointer did not pan out and made everyones brain hurt Those using the Scala bindings know that there the schedulers where exposed without the separate state parameters already Win 2a The old design as Ben says deeply confused inner and outer schedulers In NET it is even worse since there the extension methods for scheduling using async await also show up on IScheduler If there is a good reason to leverage static typing it is this Win 2b The conceptual model is now much clearer and closer to Java s executors The additional feature is that you can schedule iteratively Win 3 One of the big mistakes in hindsight in NET IScheduler was to use DateTimeOffset Now get instead of long as here In true virtual time you just think about ticks Remark A I think it would be better to move Now to become a property of Inner or at least of both so you don t need to close over outer to get access to Now Anywhere you have time related operators you will want to access Now Remark B This design seems to have lost the distinction between scheduling relative versus absolute That is in principle OK but then you really need Now Remark C The semantic difference is subtle but I think we can remove public T Subscription schedule final Action1 Scheduler Inner action final long delayTime final TimeUnit unit from Scheduler The subtlety is when is a new thread allocated when calling this overload of Schedule on outer At the moment you call Schedule or after delayTime Since in the latter case outer must maintain some additional administration my guess is that typically this overload is implemented by calling the first overload of Schedule and then using schedule with delay on Inner The only price is that when you want to delay schedule you need to write a bit more code but I think smaller interface trumps that Remark D Wrt to keeping or dropping SchedulePeriodically there is an epic blogpost about the rationale here http blogs msdn com b rxteam archive 2012 06 20 reactive extensions v2 0 release candidate available now aspx The post goes down into all the gory details about how hard it is to deal with time in computing The short story is that a lot of the complication in the current Rx schedulers implementation and the reason for having SchedulePeriodically is to deal with time drift If I were to do the NET thing again which is really what we are doing with RxJava grin I would not let that pollute the whole implementation and design of schedulers Instead for the unlikely event that people want to do ultra precise and super long scheduling I would build a completely seperate implementation of a special high precision scheduler like TestScheduler that has all the bells and whistles just for that purpose Thanks @headinthebox for the feedback Good point regarding public void schedule Action1 Scheduler Inner action Date dueTime I will remove that since it breaks the model of relying on now Remark A I think it would be better to move Now to become a property of Inner or at least of both so you don t need to close over outer to get access to Now Anywhere you have time related operators you will want to access Now I found it became very awkward on some operators to have to schedule something before getting access to now So having it on both is perhaps better An example is timestamp which only needs Scheduler now It shouldn t need to schedule something just to get now Remark B Remark C on outer delayed scheduling It does greatly simplify usage of the API keeping this It also leaves a nice symmetry between outer and inner java public abstract class Scheduler public abstract T Subscription schedule Action1 Scheduler Inner action public T Subscription schedule Action1 Scheduler Inner action long delayTime final TimeUnit unit public abstract class Inner implements Subscription public abstract void schedule Action1 Scheduler Inner action public abstract void schedule Action1 Scheduler Inner action long delayTime TimeUnit unit For example this schedules the first execution 100ms in the future then 500ms each time thereafter and uses this for recursion java Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner doWork recurse until unsubscribed but delay the recursion inner schedule this 500 TimeUnit MILLISECONDS 100 TimeUnit MILLISECONDS Remark D Wrt to keeping or dropping SchedulePeriodically I ll read that post to better understand We already support the implementation and it works fairly well It takes into account the time taken by the task being executed periodically and schedules in the future for the diff of periodic time time taken for task I m open for keeping or removing it Of note we do have a handful of operators in rxjava core that use schedulePeriodically so I plan on leaving it as is RxJava pull requests #719 https netflixoss ci cloudbees com job RxJava pull requests 719 FAILURE Looks like there s a problem with this pull request So having it Now on both is perhaps better Works for me It does greatly simplify usage of the API keeping this No issues with that but in that case we should also add absolute time We already support the implementation and it works fairly well No real opinion about this the implementation indeed does useful work and since other operators rely on it so let s keep it No issues with that but in that case we should also add absolute time Why do you want to add absolute time I thought we wanted to eliminate absolute time so it was always based off of now These are the only signatures currently java public abstract class Scheduler public T Subscription schedule Action1 Scheduler Inner action public T Subscription schedule Action1 Scheduler Inner action long delayTime final TimeUnit unit public long now public int degreeOfParallelism public abstract class Inner implements Subscription public void schedule Action1 Scheduler Inner action public void schedule Action1 Scheduler Inner action long delayTime TimeUnit unit public void schedulePeriodically final Action1 Scheduler Inner action long initialDelay long period TimeUnit unit public long now I was assuming the absolute time one would look like public void schedule Action1 Scheduler Inner action long dueTime I was assuming the absolute time one would look like public void schedule Action1 Scheduler Inner action long dueTime In Java the time value is always paired with TimeUnit hence the signature like this long delayTime TimeUnit unit All of these are absolute times that are then scheduled relative to now which always returns timeInMilliseconds As of commit 4bdf08d I now have all rxjava core unit tests passing and tests in most other modules The Scala bindings are currently broken I ll try looking at them this evening but if anyone else has time and interest to submit a PR to my branch fixing them that would help as Scala is not my strength RxJava pull requests #724 https netflixoss ci cloudbees com job RxJava pull requests 724 FAILURE Looks like there s a problem with this pull request Yup fixing the Scala bindings is complex enough with traits inner classes traits Java interop etc that I m not going to learn Scala fast enough tonight to fix that I would appreciate someone submitting a PR to me with the Scala changes cc @headinthebox @samuelgruetter @mattrjacobs @jmhofer Is there a reason only Inner has the schedulePeriodically and the outer doesn t I left it out for simplicity as it seems to only make sense calling it on the outer The point is to start it and let it run The inner is used for manual recursion All use cases for schedulePeriodically I refactored or considered only made sense on the outer Since it s easy to add and hard to remove I left it out until a use case is shown Do you have one Yup fixing the Scala bindings is complex enough with traits inner classes traits Java interop etc that I m not going to learn Scala fast enough tonight to fix that I would appreciate someone submitting a PR to me with the Scala changes No worries working on it One day I hope to convince you to switch from Groovy to Scala @akarnokd We should be careful with that before you know it outer is as complex as it was before Erik s razor is actually still a bit eager to cut out the delay one from outer Wrt to now should we let now return http docs oracle com javase 7 docs api java lang System html#nanoTime instead of milliSeconds i e Now should reflect the most accurate time you can measure In any case since now has an implicit unit then absolute time scheduling would not need a time unit but always be the same as that of now The latter is not a big deal but I do think we should seriously look at nanoTime Interestingly if you read the description it has the same goal as now in a scheduler to provide local time that is only relevant in a closed context @benjchristensen I don t have any use case for that but moving the schedulePeriodically to the outer is okay I guess the reduced surface again means that there won t be any Action0 overloads right @headinthebox The delayed version is necessary for most timed operators take skip delay etc Nanotime would be great at least for the time windowed replay @akarnokd My proposal is to always go via Action0 on outer That is what delay must do anyway so it feel purer to make that explicit @headinthebox but that way you can t use the same action in the outer and inner as the inner has to get the Inner scheduler While we are at it some operators use Timestamped T and compare against now If now changes unit and origin we need to rethink redocument Timestamped usage as well but that way you can t use the same action in the outer and inner That s fine with me the outer just dispatches to inner Agree with Timestamped It already has an implicit unit milliseconds but in Java duration always goes with TimeUnit and is hen used to convert to whatever is desired In any case since now has an implicit unit then absolute time scheduling would not need a time unit but always be the same as that of now The latter is not a big deal but I do think we should seriously look at nanoTime Interestingly if you read the description it has the same goal as now in a scheduler to provide local time that is only relevant in a closed context We didn t go with nanos originally because a you can only get relative time since the JVM started not real time b no scheduler I m aware of can schedule at that speed My understanding is the OS ticks at 1ms some slower than that I ve seen them tick at 10ms If we change from millis to nanos it will break any code assuming millis Issue a is the one I m most concerned with as you could no longer take Scheduler now and turn it into a real date This also means historical schedulers would be useless because the values from Scheduler now would not be meaningful on a Calendar I guess the reduced surface again means that there won t be any Action0 overloads right Correct I m keeping it as simple as can be Without all of the Func2 and state overloads it is very simple now Also this Scheduler interface doesn t have type erasure issues so the methods can be targeted with lambdas Overloads with Action0 Action1 conflict More importantly though we want the Action1 Inner interface common on all of them for two reasons 1 make it very difficult to not correctly use a inner for recursion 2 use the same type on outer and inner so recursion is as simple as inner schedule this This also means historical schedulers would be useless because the values from Scheduler now would not be meaningful on a Calendar That should be no problem if you try that you are going against the spirit of now historical schedulers implement now themselves either by explicitly advancing test schedulers or by using timestamps in the input Time is virtual especially in historical schedulers I really like the changes I m seeing The scheduling code was quite difficult to follow and it s a lot cleaner now One thing I d still like to see but might be well outside the scope of this PR is a way to skip to first wrap around for recursive scheduling when going through observeOn Maybe I just don t understand why it s implemented the way it is What s happening is that for the first notification that arrives instead of processing that notification directly using the given scheduler it s deferred into a function which is then piped through that scheduler again That means it s not the notification that will get processed during the first call to schedule but instead another call to schedule which then again schedules the actual notification For schedulers like the one we use for Android this means an extra unnecessary round through the message loop thus prolonging the RTT for the first notification Any idea why it is implemented the way it is I fail to see the point I guess either by explicitly advancing test schedulers or by using timestamps in the input Time is virtual especially in historical schedulers Agreed that the passage of time is virtual not sure we want the value to be virtual though What should the timestamp operator use It currently uses Scheduler now to create timestamps If converted to nanoTime it could no longer do this Here is a broader use case on the timestamp and nanoTime subject Say I have multiple machines all processing events and writing an event log They use timestamp when generating that log A historical scheduler is then used to pull in multiple event logs from multiple machines and combine them in further offline processing If the timestamps are real all of the events can be merged together and time in meaningful If each machine has its own relative representation then the timestamps in the event logs are meaningless when compared against each other We could make timestamp not use Scheduler now but that seems contrary to the entire purpose of Scheduler now and would mean that timestamps generated when using virtual time such as TestScheduler or a HistoricalScheduler would have nothing to do with the virtual time and would incorrectly represent actual time In short if we re not going to use actual time then I think we would need to eliminate timestamp and anything else representing actual time values and user code would have to decide what time means if they want to do something like write out timestamped event logs @mttkay Glad you like the changes a way to skip to first wrap around for recursive scheduling when going through observeOn Interesting point I hadn t paid attention to that before I m pretty sure we can eliminate that It s more about the code organization for invoking processQueue than a reason for re scheduling on the first pass We can pursue fixing this in a separate PR Thanks for pointing that out I m proceeding with the merge as this is a major change that will conflict with almost all other pull requests The Scala fixes and any others needed can be done against master',RxJava,true,false,false
26802252,'How to create an ObservableList','This is of course easy when you do it like this Observable List T oMap Observable create But this gives you no informations about added or removed entries In effect it forces you to iterate through all entries each time the map was changed Additionally if the List T contains Observables itself you have no way to unsubscribe from removed elements or react on their removal My approach is something like this List T wrapped new ArrayList public void onInit List Action1 T addedEntryObservers new ArrayList Observer T addedEntries Observable create observer observer add t observer onNext t public void add T t wrapped add t addedEntryObservers forEach o o call t But this requires me to write some strange combinators if I just want to get all entries currently in the list Is there a canonical way to do this yet','Hi Could you elaborate what you try to achieve in the first place I have a dynamic collection of streams and want to migrate them to use Observable s While it is easy to model the streams as Observable T s I struggle to find a nice way to get the stream added and stream removed notifications into the concept I could of course use Observable Map StreamID Observable but as I wrote above there is no way to react to individual changes This could be done by delay ing the Map and comparing the results but this will probably quite ineffective Sending out notification and observing them can be achieved via Subjects You d need PublishSubject for both addedStreams and removedStreams java public class StreamManager T List Observable T streams new ArrayList public final PublishSubject Observable T streamAdded PublishSubject create public final PublishSubject Observable T streamRemoved PublishSubject create public final PublishSubject List Observable T streamChanged PublishSubject create public void add Observable T stream List Observable T current sychronized this streams new ArrayList streams streams add stream current streams streamChanged onNext current addedStreams onNext stream public void remove Observable T stream List Observable T current synchronized this streams new ArrayList streams streams remove stream current streams removedStreams onNext stream streamChanged onNext current Thanks I ll have to try that but it looks useful 2014 02 03 akarnokd notifications@github com Sending out notification and observing them can be achieved via Subjects You d need PublishSubject for both addedStreams and removedStreams public class StreamManager T List Observable T streams new ArrayList public final PublishSubject Observable T streamAdded PublishSubject create public final PublishSubject Observable T streamRemoved PublishSubject create public final PublishSubject List Observable T streamChanged PublishSubject create public void add Observable T stream List Observable T current sychronized this streams new ArrayList streams streams add stream current streams streamChanged onNext current addedStreams onNext stream public void remove Observable T stream List Observable T current synchronized this streams new ArrayList streams streams remove stream current streams removedStreams onNext stream streamChanged onNext current Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 798#issuecomment 33956998 Is there a canonical way to connect these StreamManager s Eg I might have a ReadManager and a WriteManager ReadManager will add streams as they appear and WriteManager will subscribe to streamAdded and every announced stream Currently I d just give WriteManager a reference to the ReadManager via its constructor and it will then subscribe to the necessary Observables General we implement dynamic collects of Obersvables as Obersvable Obersvable T The outer Observable emits with onNext any new Obersvables as they are created and removal is the achieved by having the inner Obersvable emit an onCompleted Could your problem be solved with that It would probably make it a lot easier to implement Check out the implementation of groupBy The problem is probably that I d have a Observable Observable where the type could be almost any basic or composite type This is not known until runtime While I get to know the type before the first events come in that information would be lost if I just use a Observable Observable Maybe this question is better How would you create composable blocks of functionality like the Read and WriteManager above using the RXJava framework Note that there are multiple streams of data that run in parallel and may be combined and or splitted in the individual blocks Closing out as this conversation went stale if you d like to followup on these questions please post to https groups google com forum # forum rxjava',RxJava,false,false,false
26845654,'Error reporting can enter infinite loop','Relevant thread dump java lang Thread State RUNNABLE at java lang Throwable getCause Throwable java 415 locked 0x00007f48cf6b4f20 a java lang NullPointerException at rx util CompositeException attachCallingThreadStack CompositeException java 87 at rx util CompositeException CompositeException java 42 at rx util CompositeException CompositeException java 51 This is an infinite loop caused by collapsing multiple throwables together In the presence of CompositeExceptions we need to break out of the while loop in CompositeException attachCallingThreadStack on Throwables that have self referential loops','I ve got a unit test that duplicates this behavior and a fix PR coming shortly After further review I still don t have a complete handle on this The above Pull Request successfully limits the symptom of calling attachCallingThreadStack on a malformed exception but the malformed exception is still getting created Since I can t eliminate the malformed exception yet I m submitting a Pull Request that does not call attachCallingThreadStack This should eliminate the source of the malformed exception with the loss of informative debugging of CompositeExceptions',RxJava,false,false,false
26847247,'issue 799','This PR is targeted at the 0 16 1 tag but can be applied cleanly to master as well I wanted to have the ability to launch a bugfix 0 16 2 release that s not gated on the large number of changes in master Fixes #799','RxJava pull requests #722 https netflixoss ci cloudbees com job RxJava pull requests 722 FAILURE Looks like there s a problem with this pull request RxJava pull requests #725 https netflixoss ci cloudbees com job RxJava pull requests 725 FAILURE Looks like there s a problem with this pull request RxJava pull requests #729 https netflixoss ci cloudbees com job RxJava pull requests 729 FAILURE Looks like there s a problem with this pull request RxJava pull requests #746 https netflixoss ci cloudbees com job RxJava pull requests 746 FAILURE Looks like there s a problem with this pull request RxJava pull requests #747 https netflixoss ci cloudbees com job RxJava pull requests 747 FAILURE Looks like there s a problem with this pull request RxJava pull requests #748 https netflixoss ci cloudbees com job RxJava pull requests 748 FAILURE Looks like there s a problem with this pull request RxJava pull requests #749 https netflixoss ci cloudbees com job RxJava pull requests 749 FAILURE Looks like there s a problem with this pull request RxJava pull requests #807 https netflixoss ci cloudbees com job RxJava pull requests 807 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
26859557,'Added more possible failure cases to CompositeExceptionTest','','RxJava pull requests #726 https netflixoss ci cloudbees com job RxJava pull requests 726 SUCCESS This pull request looks good',RxJava,true,false,false
26859752,'Version 0 17 0 Release Notes Preview','# 0 17 0 Release Notes Version 0 17 0 contains some significant signature changes that allow us to significantly improve handling of synchronous Observables and simplify Schedulers Many of the changes have backwards compatible deprecated methods to ease the migration while some are breaking The new signatures related to Observable in this release are java A new create method takes OnSubscribe instead of OnSubscribeFunc public final static T Observable T create OnSubscribe T f The new OnSubscribe type accepts a Subscriber instead of Observer and does not return a Subscription public static interface OnSubscribe T extends Action1 Subscriber super T Subscriber is an Observer Subscription public abstract class Subscriber T implements Observer T Subscription The main subscribe behavior receives a Subscriber instead of Observer public final Subscription subscribe Subscriber super T observer Subscribing with an Observer however is still appropriate and the Observer is automatically converted into a Subscriber public final Subscription subscribe Observer super T observer A new lift function allows composing Operator implementations together public R Observable R lift Func1 Subscriber super R Subscriber super T lift Also changed is the Scheduler interface which is much simpler java public abstract class Scheduler public Subscription schedule Action1 Scheduler Inner action public Subscription schedule Action1 Scheduler Inner action long delayTime TimeUnit unit public Subscription schedulePeriodically Action1 Scheduler Inner action long initialDelay long period TimeUnit unit public long now public int degreeOfParallelism public static class Inner implements Subscription public abstract void schedule Action1 Scheduler Inner action long delayTime TimeUnit unit public abstract void schedule Action1 Scheduler Inner action public long now This release applies many lessons learned over the past year and seeks to streamline the API before we hit 1 0 As shown in the code above the changes fall into 2 major sections #### 1 Lift OnSubscribe Subscriber Changes that allow unsubscribing from synchronous Observables without needing to add concurrency #### 2 Schedulers Simplification of the Scheduler interface and make clearer the concept of outer and inner Schedulers for recursion ## Lift OnSubscribe Subscriber New types Subscriber and OnSubscribe along with the new lift operator have been added The reasons and benefits are as follows ### 1 Synchronous Unsubscribe RxJava versions up until 0 16 x are unable to unsubscribe from a synchronous Observable such as this java Observable Integer oi Observable create new OnSubscribe Integer @Override public void call Observer super Integer Observer for int i 1 i 1000000 i subscriber onNext i subscriber onCompleted Subscribing to this Observable will always emit all 1 000 000 values even if unsubscribed such as via oi take 10 Version 0 17 0 fixes this issue by injecting the Subscription into the OnSubscribe function to allow code like this java Observable Integer oi Observable create new OnSubscribe Integer @Override public void call Subscriber super Integer subscriber we now receive a Subscriber instead of Observer for int i 1 i 1000000 i the OnSubscribe can now check for isUnsubscribed if subscriber isUnsubscribed return subscriber onNext i subscriber onCompleted Subscribing to this will now correctly only emit 10 onNext and unsubscribe java subscribe with an Observer oi take 10 subscribe new Observer Integer @Override public void onCompleted @Override public void onError Throwable e @Override public void onNext Integer t println Received t Or the new Subscriber type can be used and the Subscriber itself can unsubscribe java or subscribe with a Subscriber which supports unsubscribe oi subscribe new Subscriber Integer @Override public void onCompleted @Override public void onError Throwable e @Override public void onNext Integer t println Received t if t 10 a Subscriber can unsubscribe this unsubscribe ### 2 Custom Operator Chaining Because Java doesn t support extension methods the only approach to applying custom operators without getting them added to rx Observable is using static methods This has meant code like this java MyCustomerOperators operate observable map filter take 5 map subscribe In reality we want java observable map filter take 5 myCustomOperator map subscribe Using the newly added lift we can get quite close to this java observable map filter take 5 lift MyCustomOperator operate map subscribe Here is how the proposed lift method looks if all operators were applied with it java Observable String os OBSERVABLE_OF_INTEGERS lift TAKE_5 lift MAP_INTEGER_TO_STRING Along with the lift function comes a new Operator signature java public interface Operator R T extends Func1 Subscriber super R Subscriber super T All operator implementations in the rx operators package will over time be migrated to this new signature ### 3 Simpler Operator Implementations The lift operator injects the necessary Observer and Subscription instances via the new Subscriber type and eliminates for most use cases the need for manual subscription management Because the Subscription is available in scope there are no awkward coding patterns needed for creating a Subscription closing over it and returning and taking into account synchronous vs asynchronous For example the body of fromIterable is simply java public void call Subscriber super T o for T i is if o isUnsubscribed return o onNext i o onCompleted The take operator is java public final class OperatorTake T implements Operator T T final int limit public OperatorTake int limit this limit limit @Override public Subscriber super T call final Subscriber super T o CompositeSubscription parent new CompositeSubscription if limit 0 o onCompleted parent unsubscribe return new Subscriber T parent int count 0 boolean completed false @Override public void onCompleted if completed o onCompleted @Override public void onError Throwable e if completed o onError e @Override public void onNext T i if isUnsubscribed o onNext i if count limit completed true o onCompleted unsubscribe ### 4 Recursion Loop Performance The fromIterable use case is 20x faster when implemented as a loop instead of recursive scheduler see https github com Netflix RxJava commit a18b8c1a572b7b9509b7a7fe1a5075ce93657771 Several places we can remove recursive scheduling used originally for unsubscribe support and use a loop instead ## Schedulers Schedulers were greatly simplified to a design based around Action1 Inner java public abstract class Scheduler public Subscription schedule Action1 Scheduler Inner action public Subscription schedule Action1 Scheduler Inner action long delayTime TimeUnit unit public Subscription schedulePeriodically Action1 Scheduler Inner action long initialDelay long period TimeUnit unit public long now public int degreeOfParallelism public static class Inner implements Subscription public abstract void schedule Action1 Scheduler Inner action long delayTime TimeUnit unit public abstract void schedule Action1 Scheduler Inner action public long now This design change originated from three findings 1 It was very easy to cause memory leaks or inadvertent parallel execution since the distinction between outer and inner scheduling was not obvious To solve this the new design explicitly has the outer Scheduler and then Scheduler Inner for recursion 2 The passing of state is not useful since scheduling over network boundaries with this model does not work In this new design all state passing signatures have been removed This was determined while implementing a RemoteScheduler that attempted to use observeOn to transition execution from one machine to another This does not work because of the requirement for serializing deserializing the state of the entire execution stack Migration of work over the network has been bound to be better suited to explicit boundaries established by Subjects Thus the complications within the Schedulers are unnecessary 3 The number of overloads with different ways of doing the same things were confusing This new design removes all but the essential and simplest methods 4 A scheduled task could not do work in a loop and easily be unsubscribed which generally meant less efficient recursive scheduling This new design applies similar principles as done with lift create OnSubscribe Subscriber and injects the Subscription via the Inner interface so a running task can check isUnsubscribed WIth this new design the simplest execution of a single task is java Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner doWork Recursion is easily invoked java Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner doWork recurse until unsubscribed the schedule will do nothing if unsubscribed inner schedule this The use of Action1 Inner on both the outer and inner levels makes it so recursion that refer to this and it works easily Similar to the new lift create pattern with Subscriber the Inner is also a Subscription so it allows efficient loops with unsubscribe support java Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner while inner isUnsubscribed doWork An action can now unsubscribe the Scheduler Inner java Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner while inner isUnsubscribed int i doOtherWork if i 100 an Action can cause the Scheduler to unsubscribe and stop inner unsubscribe Typically just stopping is sufficient java Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner int i doOtherWork if i 10 recurse until done 10 inner schedule this but if other work in other tasks is being done and you want to unsubscribe conditionally you could java Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner int i doOtherWork if i 10 recurse until done 10 inner schedule this else inner unsubscribe and the recursion can be delayed java Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner doWork recurse until unsubscribed but delay the recursion inner schedule this 500 TimeUnit MILLISECONDS The methods on the Inner never return a Subscription because they are always a single thread event loop actor etc and controlled by the Subscription returned by the initial Scheduler schedule method This is part of clarifying the contract Thus an unsubscribe controlled from the outside would be done like this java Subscription s Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner while inner isUnsubscribed doWork unsubscribe from outside s unsubscribe ## Migration Path #### 1 Lift OnSubscribe Subscriber The lift function will not be used by most and is additive so will not affect backwards compatibility The Subscriber type is also additive and for most use cases does not need to be used directly the Observer interface can continue being used The previous create OnSubscribeFunc f signature has been deprecated so code will work but now have warnings Please begin migrating code as this will be deleted prior to the 1 0 release Code such as this java Observable create new OnSubscribeFunc Integer @Override public Subscription onSubscribe Observer super Integer o o onNext 1 o onNext 2 o onCompleted return Subscriptions empty should change to this java Observable create new OnSubscribe Integer @Override public void call Subscriber super Integer subscriber subscriber onNext 1 subscriber onNext 2 subscriber onCompleted If concurrency was being injected java Observable create new OnSubscribeFunc Integer @Override public Subscription onSubscribe final Observer super Integer o final BooleanSubscription s new BooleanSubscription Thread t new Thread new Runnable @Override public void run int i 0 while s isUnsubscribed o onNext i t start return s you may no longer need it and can implement like this instead java Observable create new OnSubscribe Integer @Override public void call Subscriber super Integer subscriber int i 0 while subscriber isUnsubscribed subscriber onNext i or can just simplify the Subscription management java Observable create new OnSubscribe Integer @Override public void call final Subscriber super Integer subscriber Thread t new Thread new Runnable @Override public void run int i 0 while subscriber isUnsubscribed subscriber onNext i t start or use a Scheduler java Observable create new OnSubscribe Integer @Override public void call final Subscriber super Integer subscriber Schedulers io schedule new Action1 Inner @Override public void call Inner inner int i 0 while subscriber isUnsubscribed subscriber onNext i or use subscribeOn which now works to make synchronous Observables async while supporting unsubscribe this didn t work before java Observable create new OnSubscribe Integer @Override public void call Subscriber super Integer subscriber int i 0 while subscriber isUnsubscribed subscriber onNext i subscribeOn Schedulers newThread #### 2 Schedulers Custom Scheduler implementations will need to be re implemented and any direct use of the Scheduler interface will also need to be updated ##### 3 Subscription If you have custom Subscription implementations you will see they now need an isUnsubscribed method You can either add this method or wrap your function using Subscriptions create and it will handle the isUnsubscribed behavior and execute your function when unsubscribe is called # The Future This is hopefully the last of the major refactors to rxjava core and we re approaching version 1 0 We have most if not all operators from Rx Net that we want or intend to port We think we have got the create subscribe signatures as we want and the Subscription and Scheduler interfaces are now clean We need to improve on some of the Subject implementations still particularly ReplaySubject We are beginning to focus after this release on cleaning up all of the operator implementations stabilizing fixing bugs and performance tuning We appreciate your usage feedback and contributions and hope the library is creating value for you','Sometime this or next week I hope to release 0 17 These release notes try to communicate what changed why and how to migrate code that is impacted by the changes Please let me know what you feel needs to be added changed for it to be clearer or more useful Also now is the time for any final feedback on the changes in 0 17 before they are released and become the published API The major changes in this release are https github com Netflix RxJava issues 746 lift and create OnSubscribe https github com Netflix RxJava issues 792 Subscriber https github com Netflix RxJava pull 797 Scheduler Redesign I have a question about Operator Now Operator is only a Func1 Subscriber super R Subscriber super T Observable can not be touched in Operator So if some Operator s like repeat need to subscribe the original Observable more than once how to do it Of course the Operator can get the Observable through the constructor But lift will not be able to chain it with other operators For example we need to break the chain java o observable map filter take 5 o lift new MyCustomOperator o map subscribe Just because it can t be written in a single line of code doesn t mean that it isn t chained like the others So if some Operator s like repeat need to subscribe the original Observable more than once how to do it By converting to Observable Observable so lift has access to the inner Observable See a prototype example here https gist github com benjchristensen 8367765#file obsurvable java L132 java public Obsurvable T repeat return from this bind new RepeatOperator T Here is a pull request implementing zip using lift https github com benjchristensen RxJava blob 100983d29b5890fa604ae76f2c3dd29114936621 rxjava core src main java rx Observable java#L3126 java public final static T1 T2 R Observable R zip Observable extends T1 o1 Observable extends T2 o2 final Func2 super T1 super T2 extends R zipFunction return just new Observable o1 o2 lift new OperatorZip R zipFunction Just because it can t be written in a single line of code doesn t mean that it isn t chained like the others It wouldn t take much to allow it being written in a single line All we need is a simple function operator that goes Observable T Observable Observable T For example if we called it toNestedObservable we could then do this java o observable map filter take 5 toNestedObservable lift new MyCustomOperator map subscribe The implementation of the function would simply be java public Observable Observable T toNestedObservable return from this Thanks for your clarification I feel Observable Observable T is not very intuitive but I think it s the best solution in current design We deal with Observable Observable T on any combinatorial operator such as zip merge concat and others like groupBy switch etc thus it is a very common type to deal with What about it do you feel is not intuitive Also it should be very rare that someone will need to use lift directly and worry about this for nested behavior as generally the existing operators would be leveraged to groupBy merge concat zip etc and then custom operators applied to the Observable T or Observable Observable T that comes out of those I feel it s not intuitive because for example repeat is repeating the values in Observable T but lift it on Observable Observable T looks like emitting Observable T s But I m convinced by Operator is rarely used by the users If you consider what lift is doing then I see it as intuitive The function being lifted is acting on T thus when T is an Observable T it is acting on the Observable T that is emitted That s the elegance of lift The operators always act on type T and emit type R and are statically typed to whatever type T they accept In the case of repeat it accepts an Observable T so that means it can be lifted against an Observable Observable T since that will emit an Observable T to it Thanks for your explanation Really cleared my confusion Glad it was helpful and thank you for your involvement and being willing to ask and share your opinion I m trying to implement the OperatorSubscribeOn to fix #813 Here is the prototype code java public class OperatorSubscribeOn T implements Operator T Observable T private final Scheduler scheduler public OperatorSubscribeOn Scheduler scheduler this scheduler scheduler @Override public Subscriber super Observable T call final Subscriber super T subscriber return new Subscriber Observable T @Override public void onCompleted @Override public void onError Throwable e @Override public void onNext final Observable T o scheduler schedule new Action1 Inner @Override public void call final Inner inner if inner isUnsubscribed o subscribe subscriber However I encounter a problem I can not dispatch the unsubscribe action to the scheduler One way to implement it is overriding Subscriber unsubscribe but it is final Is there any way that an Operator can change the unsubscribe behavior Just find I can create a Subscriber with a CompositeSubscription to change the unsubscribe behavior Like all of the ideas in this release Really powerful Yes a Subscriber allows passing in a CompositeSubscription or Subscriber to get its Subscription or you can add any other Subscription to a Subscriber to create the chains in whatever way is needed Outstanding items I want resolved or completed before releasing include x GroupBy functional bugs Some of the unit tests are actually asserting incorrect behavior for example unsubscribing of all current children should not cause the parent to unsubscribe ObserveOn performance Will work on in 0 17 x Despite using a ring buffer in the current implementation something seems wrong that the performance was hit as hard during the recent changes Despite the changes being necessary to provide correct behavior for back pressure it should be possible to improve behavior in that case and regain full performance if someone chooses to allow buffering x Parallel operator It appears there is some non determism in when the onComplete unsubscribe occurs and that it is related to groupBy The parallel operator uses both groupBy and observeOn so it is impacted by changes in 0 17 Zip with back pressure Not Doing in 0 17 0 The zip operator is typically the biggest issue other than observeOn for back pressure and we want a solution I want it in 0 17 as it will likely be a big enough change to warrant a 0 x version change Removing the buffers in zip fix back pressure but result in deadlocks when zipping synchronous Observables thus the obvious change can not be done Likely it is appropriate in this case to inject concurrency so that each stream can synchronously push data while the zip operator itself can subscribe to multiple streams We may be able to conditionally not inject extra concurrency if we find a source already on a different thread x Scheduler periodicDelay Change signature from java public Subscription schedulePeriodically final Action1 Scheduler Inner action long initialDelay long period TimeUnit unit to java public Subscription schedulePeriodically final Action1 Scheduler Inner action long initialDelay TimeUnit unit long period TimeUnit unit x Debug plugin functional all hooks proven Make sure that the execution hook plugin supports the desired debug capabilities along with the new lift Subscriber and OnSubscribe behavior See https github com Netflix RxJava pull 836 for first attempts Production canary testing I intend on running 0 17 on Netflix production canaries before releasing I can do a release candidate if there is interest but a final release needs to be proven to work at scale This does not mean all operators get equally battle tested as Netflix code does not use all of them but it does prove out the core operators and main code flows such as lift OnSubscribe Subscriber etc Please let me know if you have things you feel are needed before 0 17 are released I d also appreciate insight or help on achieving the above goals @abersnaze After the merge of #836 are you comfortable with Debug plugin functional all hooks proven Marked Debug plugin functional all hooks proven as completed as the changes from @abersnaze are merged and we reviewed together and they look good They resulted in https github com Netflix RxJava pull 857 changing the signature to public R Observable R lift final Operator R T bind Scheduler periodicDelay is done in https github com Netflix RxJava pull 856 open for debate on whether it should be merged or not GroupBy functional bugs is more or less done I believe except for determining whether the subscribeOn time gap https github com Netflix RxJava issues 844 issue needs a solution I m leaving it unfinished until that is figured out Other than the final things being worked on does anyone else have things you feel are needed in 0 17 or that have happened in 0 17 that you disagree with for objective reasons Can we have an issue for Zip with back pressure with all the requirements so discussions won t detract this issue Here you go Zip Back pressure https github com Netflix RxJava issues 867 I m not going to hold up 0 17 0 for zip It s massive enough as it is I want to get a release candidate out I d like to just wrap up the groupBy subscribeOn stuff and start doing canary testing The groupBy and parallel operators are working well enough to move forward I believe https github com Netflix RxJava pull 869 My only remaining concern is performance for observeOn but that can be worked on going forward Once I confirm a test https github com Netflix RxJava pull 869#issuecomment 35052669 I will merge this last pull request and release a candidate 0 17 0 RC1 for testing and if that goes well release the real thing 0 17 0 Released 0 17 0 RC1 for testing https github com Netflix RxJava releases tag 0 17 0 RC1 Starting the canary testing on our end Once we have proven we can serve our production traffic on this code I will release 0 17 0 I am only merging bug fixes for now before tackling new features and design improvements Verison 0 17 0 RC2 has been released for testing https github com Netflix RxJava releases tag 0 17 0 RC2 cc @samuelgruetter @jmhofer @mttkay @daveray for feedback on whether all is well with language adaptors Android and Swing modules Testing at Netflix is continuing I d appreciate your feedback before calling this version ready for production release due to it s massive changes in subscription and scheduling behavior Of interest while hunting down the observeOn performance issue it actually seems to be related to the NewThreadScheduler and not observeOn itself As of now I am not aware of any further changes needed for 0 17 0 so I m looking for bug reports and fixes I see the Clojure interop was updated for the util purge I started the work to open source our internal Clojure bindings and all tests pass with the move to master from 0 14 1 So all s good there Thanks @daveray for the confirmation 0 17 0 RC6 was just released Testing in dev is going well though I have not yet been able to canary it in our production environment as we have some yak shaving to do to get it into our production codebase due to the signature changes They are a side effect of a hack we did over a year ago when we moved from internal to open source version and that hack has caught up to us with the lift Subscriber changes so we have a few days more of work before I can validate this release That is why I have not yet released 0 17 0 as I can t assert it is production worthy Is anyone else doing testing to validate this release is working for you I would particularly be interested in experience from Android developers Ben I set a day aside today to focus on this We haven t yet moved to 0 17 due to other priorities but will work on it today Looking good so far Would like to put out a beta with these changes in place to be sure One thing I had issues with Observables are not mockable anymore using Mockito since the f field that holds the OnSubscribe function is always null and it s final to can t be overridden I realize observables aren t great candidates to be mocked out to begin with since you can quickly end up in train wreck mocks but it can be convenient at times for instance to test whether subscribe was called with a specific observer type verify is quite useful I had to build a custom mock class now which traces all subscribers so that I can keep verifying that observables returned by peer objects are actually being subscribed to as opposed to just calling the method that created the sequence More feedback soon Forgot to mention this might be an IntelliJ issue but whenever I subscribe a Subscriber to an observable IntelliJ now complains Ambiguous method call both subscribe Observer and subscribe Subscriber in Observable match However it builds fine on the command line Anyone else getting this I think the problem is that a Subscriber is an Observer too Don t remember exactly how Java handles this I guess one would assume it picks the most specific signature match at runtime Anyone else getting this warning It s a bit annoying because I actually configured my IDE to display warnings as errors so the RxJava code is bleeding all over the place Thank you for taking the time to play with it IntelliJ issue That seems very wrong for IntelliJ to do that Eclipse doesn t have the issue I m not sure what we would change since it seems fairly normal to have method overloads such as this Observables are not mockable anymore They were never very good at being mocked anyways There is a new TestSubscriber that I find very useful for unit tests Can you look at it and suggest improvements that would allow the assertions you re trying to do We could eliminate this method java public final Subscription subscribe Subscriber super T observer and do an instanceof check on Observer and then treat it accordingly but that feels just wrong and doesn t correctly communicate via the API that Subscriber is intended for use with the subscribe method And I don t want to delete the subscribe Observer super T observer method as it s fine to subscribe with an Observer if the added functionality of Subscriber is not needed If I had to choose between them I d rather kill subscribe Observer super T observer I d really rather just make IntelliJ not be broken @mttkay Which version of IntelliJ is that I had similar trouble with the 12 x series http youtrack jetbrains com issue IDEA 116359 unrelated to RxJava I think it is still caused by the incomplete and or bogus Java 8 support @akarnokd Do you not see this issue Are you on 13 x I m curious because RxJava or Android doesn t involve Java 8 and thus shouldn t be affected by that bug I get the same but it really does not matter since it compiles fine I would not change anything for that @Override public void onNext Observable extends T innerObservable runningCount incrementAndGet Subscriber T i new InnerObserver childrenSubscriptions add i innerObservable subscribe i This is on 13 0 2 It s just a warning not an error but still I actually did install Java 8 recently let me check whether that s the issue @mttkay This compiler issue was the reason I turned away from IJ to NetBeans I m working on a lambda intensive code and got tired IJ complaining about most of it We have a solid proposal from @abersnaze that provides pause functionality on Subscription to allow natural back pressure on things like reading files or Iterables and since it involves signature changes to Subscription I m holding off on releasing 0 17 a little longer and the fact that we still haven t confirmed the release in our production environment I d rather have 0 17 with all of those changes since we already have changed Subscription The prototype he demonstrated to @headinthebox and I today works with zip take map and conceptually with merge and thus flatMap More to come in the next few days Does everyone want to wait for Netflix to finish testing this release in prod before officially releasing or are enough of you content with RC 6 that I should release it and let further improvements come in 0 17 x Any takers on giving a yes no on whether you feel 0 17 0 RC6 is ready for your production use My production use currently consists of PublishSubject only so it is a go for me However we should consider reimplementing the most used operations as operators before releasing I ve used it in development builds for about a week now and didn t have any problems either We do not use any operators beyond map mergeMap cache publish and replay however 1 I ve been using it on Android since RC2 for the cgeo https github com cgeo cgeo development branch and nightly releases We use AndroidObservable a lot and operators merge flatMap parallel reduce toBlockingObservable single onErrorResumeNext from filter publish refcount lastOrDefault as well as PublishSubject and BehaviourSubject Also schedulePeriodically and schedule on Scheduler instances So far everything seems to be working well Great thank you for your feedback we should consider reimplementing the most used operations as operators before releasing @akarnokd I feel that will take far too long and introduce more risk of delaying for another month The full benefits of the lift changes won t occur until we do this but I d rather do them in 0 17 x incremental releases Are you okay with that We tried to use it no good so far since there are problems when working with iterables we need to observe queues and Kafka topics What makes it worse is that it looks like everything works observer gets data that seems right until you start digging Of course I prefer it to be fixed there are problems when working with iterables Are you referring to back pressure buffer bloat or something that was working in 0 16 and no longer works in 0 17 @benjchristensen Yes I guess the top 10 operators with overloads would take a few weeks Regardless I would like to start working on the reimplementations en masse Regardless I would like to start working on the reimplementations en masse Yes it will be happening soon Let s not quite start until we get 0 17 0 out the door and agree upon the coding patterns I also want to nail down our answer for back pressure Despite not being able to fully validate in our prod environment for severe yak shaving reasons I don t want to hold this up any further and believe we have validate enough to move forward Bugs which will surely be found will be fixed in 0 17 x releases along with re implementaitons of the many operators that are still on the old OnSubscribeFunc mechanism I ll revise the release notes and release this soon RxJava 0 17 0 RC7 is released Some small issues arose with debug hooks I want to validate before making this 0 17 0 Release @benjchristensen in the new release notes can you fix the while s isUnsubscribed to while s isUnsubscribed among the examples Ha good catch just fixed I wrote the code in an IDE to make sure it compiled but didn t test that part',RxJava,false,false,false
26861382,'Add testMultipleWithSameCause UnitTest','Also make tests capable of failing with timeouts Before the constructor would immediately go into an infinite loop and hang the tests','RxJava pull requests #727 https netflixoss ci cloudbees com job RxJava pull requests 727 SUCCESS This pull request looks good',RxJava,true,false,false
26899310,'Operator repeat','I ve reimplemented repeat with the new lift subscriber semantics but run into a few problems The previous observeOn implementation didn t work for some reason with some of the repeat tests Haven t really looked into them but instead reimplemented observeOn with the new semantics and with queue drain method which brought up some further issues Changed the TestScheduler a bit as I ve run into cases where the internal queue s order was not of the order of the schedule typically when using 0 as delay which caused tests to get rearranged events Adding a monotonic id helps distinguish between tasks scheduled for the same time GroupBy had some problem where it duplicated childObserver onCompleted when run with staggered groups It broke merge I ve added a once check to it to make it work Might need to utilize the same completeInner logic than the groups Broke OperationParallelMergeTest I m not sure why they don t work Maybe it gets 3 parallelism but the thread Ids keep changing underneath I never understood the expectations in those tests','RxJava pull requests #728 https netflixoss ci cloudbees com job RxJava pull requests 728 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
26899875,'Fix CompositeException','This fixes possible issues where infinite loops could be created if the right combination of Exceptions and causal chains were composed together','RxJava pull requests #730 https netflixoss ci cloudbees com job RxJava pull requests 730 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
26900717,'Operator repeat','I ve reimplemented repeat with the new lift subscriber semantics but run into a few problems The previous observeOn implementation didn t work for some reason with some of the repeat tests Haven t really looked into them but instead reimplemented observeOn with the new semantics and with queue drain method which brought up some further issues Changed the TestScheduler a bit as I ve run into cases where the internal queue s order was not of the order of the schedule typically when using 0 as delay which caused tests to get rearranged events Adding a monotonic id helps distinguish between tasks scheduled for the same time GroupBy had some problem where it duplicated childObserver onCompleted when run with staggered groups It broke merge I ve added a once check to it to make it work Might need to utilize the same completeInner logic than the groups Broke OperationParallelMergeTest I m not sure why they don t work Maybe it gets 3 parallelism but the thread Ids keep changing underneath I never understood the expectations in those tests','RxJava pull requests #731 https netflixoss ci cloudbees com job RxJava pull requests 731 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
26946038,'Operator Repeat and other operator fixes','Reimplemented repeat which exposed some other problems Added QueueDrain based on this http twistedoakstudios com blog Post8424_deadlocks in practice dont hold locks while notifying Added overload of repeat long n to repeat a source n times which is not the same as repeat take n generally Note that Ben s prototype was not working correctly because it run the re subscription code in a loop if subscribeOn was used it was constantly resubscribing before the old even finished For some reason observeOn take didn t work as expected causing repeat tests to fail as well I couldn t determine the cause I ve noticed that take was unable to unsubscribe the upstream as there was nothing in its cs To fix the problem above I ve reimplemented observeOn as well It does not use recursive scheduling but the QueueDrain This exposed another problem with GroupBy in some cases childObserver onCompleted was sent out twice breaking merge flatMap I ve added a once check but I m not 100 certain there isn t anything else wrong with the GroupBy s staggered behavior Unfortunately OperationParallelMergeTest is broken with this PR I don t quite understand why it doesn t work nor have a clue how to fix it or the new observeOn Maybe the parallel tests relied on thread timing and not expiring too fast so they could continue one them Performance from repeat 3 8MOps s from repeat observeOn 1 5MOps s range 31 8MOps s from observeOn repeat 15 kOps s','RxJava pull requests #733 https netflixoss ci cloudbees com job RxJava pull requests 733 FAILURE Looks like there s a problem with this pull request I ve noticed that take was unable to unsubscribe the upstream as there was nothing in its cs What is the unit test for this scenario Unfortunately OperationParallelMergeTest is broken with this PR It breaks because observeOn is now hopping threads as it always schedulers on the outer Scheduler The fix I pasted above resolves the OperationParallelMergeTest tests The test case with take that caused problems was something like this java Observable range 1 20000000 observeOn Schedulers newThread take 10 subscribe System out println It prints 1 10 but then it doesn t stop and spins up a lot of threads Basically the OperationRepeatTest failed for me with timeouts I merged repeat based on the discussion above I ll await your work on observeOn then it doesn t stop and spins up a lot of threads Isn t that because we haven t re implemented observeOn yet This works java Observable range 1 20000000 take 10 toBlockingObservable forEach new Action1 Integer @Override public void call Integer t1 System out println t1 Do you intend on submitting updated code soon or should I merge the observeOn changes as discussed above I skip on this one Okay thanks @akarnokd The test case with take that caused problems was something like this Is the take issue resolved for you now based on https github com Netflix RxJava pull 833 The issue was with observeOn take together This fixes take but observeOn in its current form doesn t work This spins java Observable range 1 20000000 observeOn Schedulers newThread take 10 toBlockingObservable forEach System out println I guess I need to revisit the issue once ObserveOn has been updated That code works on the new observeOn implementation I just submitted https github com Netflix RxJava pull 835 Excellent I m looking at the new observeOn right now for speedup options Thanks @akarnokd I would appreciate that My brain is done for the night',RxJava,true,false,false
26954310,'Doc comments Inner scheduler tracking','Schedules a cancelable action to be executed in delayTime public abstract void schedule Action1 Scheduler Inner action The doc comments for schedulers are out of sync','I ve looked through the public APIs and they seem okay now fixed one place The referenced text no longer exists in code',RxJava,false,false,false
26955031,Schedulers,'public Subscription schedulePeriodically final Action1 Scheduler Inner action long initialDelay long period TimeUnit unit Wouldn t it be nicer to have public Subscription schedulePeriodically final Action1 Scheduler Inner action long initialDelay TimeUnit initialDelayUnit long period TimeUnit periodUnit','I guess we could in the event someone really wants to use different units It came up in the Scala bindings where you use Duration as in 60 seconds I think everywhere we take a time it should have its own unit This was debated elsewhere a bunch we settled on the Scheduler API as of v0 18',RxJava,false,false,false
26956129,Scheduler,'Any reason public class Schedulers has no static TestScheduler factory','No significant reason Probably because all other schedulers just return the interface but that one you want the concrete instance It feels a bit inconsistent nothing prevents this one to return a value of type TestScheduler instead of Scheduler This now exists java public static TestScheduler test',RxJava,false,false,false
26956561,'IntelliJ support','@alkemist Loading the current project in IntelliJ is totally broken not that it ever really worked for me but at least IntelliJ recognized that the Scala bindings were in Scala no I might as well use textedit Can you take a look','@headinthebox this works for me Are you running gradlew idea and then opening the project in IDEA the right way or trying to import it in IDEA Ok I did not try gradlew idea didn t even know that existed Will try that out and just for my education how could I have discovered the right way The docs http www gradle org docs current userguide idea_plugin html',RxJava,false,false,false
26964769,'Fixed OperationSubscribeOn so OperationConditionalsTest works again','Commenting out the inner makes the OperationConditionalsTest pass Unfortunately I m not sure whether this change affects non Trampolined schedulers in any way or why was there a need to unsubscribe an inner scheduler It is possible the actual bug is in TrampolineScheduler','RxJava pull requests #734 https netflixoss ci cloudbees com job RxJava pull requests 734 SUCCESS This pull request looks good Interesting thanks for catching that I m sure we ll find a few more of these types of things after my touching basically every class in the codebase',RxJava,true,false,false
26969328,'Subscriber isUnsubscribed always returns false for synchronous methods','The following program produces unexpected at least for me output public static void main String args throws Exception final Subscription subscription Observable create new Observable OnSubscribe Integer @Override public void call final Subscriber super Integer subscriber try for int i 0 subscriber isUnsubscribed i System out println Observable i subscriber onNext i Thread sleep 2000 catch Exception exception subscriber onError exception subscribeOn NewThreadScheduler getInstance observeOn NewThreadScheduler getInstance subscribe new Action1 Integer @Override public void call final Integer value System out println Observer value Thread sleep 3000 subscription unsubscribe The output is Observable 0 Observer 0 Observable 1 Observer 1 Observable 2 Observable 3 Observable 4 Observable 5 Observable 6 Observable 7 And I m expecting to get the following output Observable 0 Observer 0 Observable 1 Observer 1 Am I wrong or it s a bug','Hi Generally unsubscribe is best effort so some values might slip through The question is does Observable X stop at all If not that is a bug @akarnokd no it never stops As OperationSubscribeOn has not been rewritten yet subscriber isUnsubscribed does not work on the subscribeOn method @mironov nsk You are correct in your impression that it should work that is the purpose of 0 17 However as @zsxwing said we don t yet have subscribeOn and observeOn updated to the new model which I want before we release 0 17 as they are important Right now if you avoid those and use a Scheduler with the synchronous code inside it demonstrates the theory of how it would work while still unsubscribing from the outside java final Subscription subscription Observable create new Observable OnSubscribe Integer @Override public void call final Subscriber super Integer subscriber subscriber add NewThreadScheduler getInstance schedule new Action1 Inner @Override public void call Inner inner try for int i 0 inner isUnsubscribed i System out println Observable i subscriber onNext i Thread sleep 2000 catch Exception exception subscriber onError exception subscribe new Action1 Integer @Override public void call final Integer value System out println Observer value Thread sleep 3000 subscription unsubscribe Note how the inner allows checking on the unsubscribe and I register the schedulers Subscription with Subscriber That said we definitely want to have your code functional before releasing @benjchristensen thank you for clarifying that Provided workaround works in this particular case but doesn t work in a real case that I have My Observable is a bit more complicated java Observable create new Observable OnSubscribe String @Override public void call final Subscriber super String subscriber try final Socket socket new Socket 127 0 0 1 12345 final BufferedReader reader new BufferedReader new InputStreamReader socket getInputStream subscriber add Subscriptions create new Action0 @Override public void call IOUtils closeQuietly socket while subscriber isUnsubscribed subscriber onNext reader readLine catch Exception exception subscriber onError exception Server sends a new string very rarely and even if I unsubscribe from the Subscription Observable won t know about this for a very long time because it s blocked on reader readLine The only way to cancel the Observable properly is to provide an unsubscribe callback via subscriber add and close a socket here it will cause reader readLine to fail with exception Unfortunately I couldn t find a way to add an unsubscribe callback using Scheduler Inner You can add multiple Subscription s to subscriber For example java Observable create new Observable OnSubscribe String @Override public void call final Subscriber super String subscriber try final Socket socket new Socket 127 0 0 1 12345 subscriber add Subscriptions create new Action0 @Override public void call IOUtils closeQuietly socket subscriber add NewThreadScheduler getInstance schedule new Action1 Inner @Override public void call Inner inner try final BufferedReader reader new BufferedReader new InputStreamReader socket getInputStream while inner isUnsubscribed subscriber onNext reader readLine catch Exception exception subscriber onError exception catch Exception exception subscriber onError exception @benjchristensen @zsxwing thank you for your help With your hints I managed to solve my problem but the code became a bit more complicated than it has been before Looking forward to the subscribeOn fix Agreed I hope to get subscribeOn and observeOn in soon @zsxwing has submitted a PR for subscribeOn and I m reviewing it shortly This issue seems to be fixed in the 0 17 0 RC2 Excellent thank you for confirming Is there another way to do this on newer versions I m using 0 19 2 and Action1 Inner is not available to call inner isUnsubscribed return Observable create new Observable OnSubscribe List Cab @Override public void call Subscriber super List Cab subscriber try while subscriber isUnsubscribed cabs from network subscriber onNext cabs Thread sleep 5000 catch Exception e subscriber onError e Thank you for your help',RxJava,false,false,false
26971489,'RunAsync method for outputting multiple values','Added runAsync method to allow producing multiple values while running an action on a scheduler The drawback is that the action is run immediately and observers might not get any or all of the produced values An overload lets the client specify a subject such as ReplaySubject to reliably capture all values and replay them to Observers Otherwise it just acts as a cold observable with the additional option to cancel the schedule and or the action','RxJava pull requests #735 https netflixoss ci cloudbees com job RxJava pull requests 735 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
26971765,'Implicit Schedulers','This is a proposal to use Scala s implicits to improve the Schedulers part of the RxScala API by @vjovanov and myself ### Current situtation There are many methods depending on a Scheduler Since we do not want to always pass the Scheduler argument explicitly there s a second version of each method which chooses a reasonable default Scheduler for instance scala def window timespan Duration Observable Observable T def window timespan Duration scheduler Scheduler Observable Observable T ### Advantages of this proposal Compared to the current situation this proposal brings the following adavantages For method calls without an explicitly provided Scheduler it s possible to override the chosen default Scheduler in a per scope and per method way All methods which existed in a version with Scheduler and one without can be replaced by one so the API size decreases by almost 50 ### Usage examples There are three ways of using Schedulers 1 With default implicits For each method the framework chooses a reasonable default scheduler It can be a different Scheduler for each method For instance for buffer ThreadPoolForComputation is chosen and for from ImmediateScheduler is chosen scala import rx lang scala schedulers DefaultImplicits _ Observable interval 200 millis take 10 buffer 300 millis Observable interval 200 millis take 10 window 300 millis flatMap obs obs sum Observable from List 1 2 3 2 With explicitly specified Schedulers scala Observable interval 200 millis NewThreadScheduler take 10 buffer 300 millis NewThreadScheduler Observable interval 200 millis NewThreadScheduler take 10 window 300 millis NewThreadScheduler flatMap obs obs sum Observable from List 1 2 3 ThreadPoolForIOScheduler 3 With custom default Schedulers This feature is the whole point of this proposal scala val testScheduler TestScheduler specify which default scheduler to use for which method implicit val myImplicitScheduler1 new Scheduler testScheduler with DefaultBufferScheduler with DefaultWindowScheduler with DefaultIntervalScheduler implicit val myImplicitScheduler2 new Scheduler ImmediateScheduler with DefaultFromScheduler Observable interval 200 millis take 10 buffer 300 millis Observable interval 200 millis take 10 window 300 millis flatMap obs obs sum Observable from List 1 2 3 for t 0 to 2500 testScheduler advanceTimeBy 1 millis ### How it works There s one marker trait without any members for each method in Observable which takes a Scheduler scala trait DefaultBufferScheduler trait DefaultWindowScheduler trait DefaultFromScheduler trait DefaultIntervalScheduler All method pairs of a method with Scheduler and its corresponding method without Scheduler are replaced by one single method with an implicit Scheduler parameter of type Scheduler with DefaultXxxScheduler for instance scala def window timespan Duration Observable Observable T def window timespan Duration scheduler Scheduler Observable Observable T is replaced by scala def window timespan Duration implicit scheduler Scheduler with DefaultWindowScheduler Observable Observable T Further the original scala trait Scheduler private scala val asJavaScheduler rx Scheduler is replaced by scala class Scheduler s rx Scheduler def this s Scheduler this s asJavaScheduler alternative constructor private scala val asJavaScheduler rx Scheduler s because we need to create new Schedulers using the new keyword such that we can specify with DefaultXxxScheduler with DefaultYyyScheduler The three ways of using Schedulers work as follows 1 Default implicits There s scala object DefaultImplicits implicit val computationScheduler new Scheduler ThreadPoolForComputationScheduler with DefaultBufferScheduler with DefaultWindowScheduler with DefaultIntervalScheduler implicit val immediateScheduler new Scheduler ImmediateScheduler with DefaultFromScheduler which has to be imported by all users who don t want to customize scala import rx lang scala schedulers DefaultImplicits _ This is similar to Futures requiring all users to scala import scala concurrent ExecutionContext Implicits global so users should not get too upset about it 2 With explicitly specified Schedulers There are implicit conversions to convert a regular Scheduler to a Scheduler with DefaultXxxScheduler scala one implicit conversion for each DefaultXxxScheduler implicit def toDefaultBufferScheduler s Scheduler new Scheduler s with DefaultBufferScheduler implicit def toDefaultWindowScheduler s Scheduler new Scheduler s with DefaultWindowScheduler implicit def toDefaultFromScheduler s Scheduler new Scheduler s with DefaultFromScheduler implicit def toDefaultIntervalScheduler s Scheduler new Scheduler s with DefaultIntervalScheduler These implicits just unwrap the underlying Java Scheduler and wrap it again in a differently labeled Scala Scheduler 3 With custom default Schedulers Whenever a method xxx is called without giving a Scheduler the Scala compiler will look for an implicit value of type DefaultXxxScheduler issue a could not find implicit value error if none was found or an ambiguous implicit values error if multiple implicit values matched ### Advanced usage By defining new Scheduler marker traits users can define their own method groups which should use the same Scheduler and new groups can also be defined in terms of smaller groups scala trait SchedulerForMethodsGroup1 extends DefaultIntervalScheduler with DefaultWindowScheduler trait SchedulerForMethodsGroup2 extends DefaultBufferScheduler with DefaultFromScheduler trait SchedulerForBothGroups extends SchedulerForMethodsGroup1 with SchedulerForMethodsGroup2 These could then be used as follows scala implicit val group1Scheduler new Scheduler ThreadPoolForComputationScheduler with SchedulerForMethodsGroup1 implicit val group2Scheduler new Scheduler NewThreadScheduler with SchedulerForMethodsGroup2 but also as like this scala implicit val theScheduler new Scheduler ThreadPoolForComputationScheduler with SchedulerForBothGroups ### Preview An incomplete preview can be found in this branch https github com samuelgruetter RxJava tree implicit schedulers','@headinthebox and RxScala users your opinion and comments are welcome Need some time to digest this Considering the Scala bindings are broken right now after the recent Scheduler changes 0 17 is waiting until Scala either fixes to the current design or moves forward on this 0 17 is a good time for changing design since the Scheduler redesign broke everything already I must be missing something but given the possibility to explicitly specify the required scheduler I don t see why per method type of the scheduler is needed Brings too much complexity for no obvious win Also implicit defs repacking schedulers with creating new instances brings runtime overhead right And if ImmediateScheduler is the default for all overloads without Scheduler parameter now why not include implicit val in Observable companion object In the current version the defaults for overloads without Scheduler parameter are already different per method For instance the default for repeat is Schedulers currentThread but the default for buffer is Schedulers computation And yes rewrapping Schedulers brings some runtime overhead but it s during the setup phase where the operator chain is created and during the performance critical push data phase there is no overhead As for the complexity I think that 50 of less methods in Observable justifies a bit of complexity in the implicit parameters Furthermore the Scala community is used to passing ExecutionContexts in the same manner The additional marker trait with quite a descriptive name should not make much confusion Ok but why is the proposed change superior to just supplying default arguments for schedulers for all methods @vigdorchik look at the Usage examples I posted above Just supplying default arguments for schedulers for all methods would only allow case 1 and 2 to work but not 3 I did some analysis on Observable java and found that most methods which take a Scheduler have Schedulers computation as default Scheduler buffer debounce delay delaySubscription parallel repeat replay sample skip skipLast take takeLast takeLastBuffer throttleFirst throttleLast throttleWithTimeout timeout window interval timer timer However there are also methods with a different default Scheduler repeat Schedulers currentThread startWith no scheduler timeInterval Schedulers immediate timestamp Schedulers immediate empty no scheduler error no scheduler from no scheduler just no scheduler merge no scheduler parallelMerge Schedulers currentThread range no scheduler As we can see the default is always either Schedulers computation or don t introduce additional concurrency So maybe there s a much simpler solution For the methods in the first list have an implicit parameter of type Scheduler and leave the methods of the second list unchanged Like the simplified variant very much How about also including Schedulers computation as implicit val in object Observable @headinthebox how s your digestion going Your opinion would be appreciated Actually I am not so much convinced that schedulers should be implicit anymore since the typical scenario is that you have several different schedulers in the same query xs subscribeOn s0 groupBy flatMap g g obServerOn s2 observerOn s3 How would that work out If there is a default scheduler you don t have to pass one My 2 cents as a user Specifying a default scheduler would be amazing We ve implemented our own scheduler which is essentially an I O scheduler with an upper limit We ve had to add a load of calls of subscribeOn to all our observables It would be nice to just configure it once on init and everything just uses that scheduler Something I ve been wanting for a while is the ability to use the RxJavaPlugins mechanism to assign the default Scheduler factories for Schedulers computation Schedulers io and Schedulers newThread so that a system wanting to change this behavior can do so in one place without needing to use the overloads everywhere This could be useful to use lightweight threads for example https github com puniverse pulsar instead of normal threads everywhere in the system It could allow specific customization of thread behavior when an app knows a better way to do things Here is some code I wrote but have not yet tested that would allow this behavior https github com Netflix RxJava pull 905 Obviously if someone is using a specific implementation directly it would not help but generally the Schedulers factory methods should be used and if they are then this plugin can help Perhaps we can deprecate the actual Scheduler implementation constructors so only Schedulers factory methods can be used for built in schedulers @headinthebox when I wrote this proposal I thought that observeOn and subscribeOn would still have an explicit Scheduler argument but all the other operators would get implicit Schedulers This would make rx consistent with futures and actors in scala akka which accept an implicit execution context And that seems to have worked out ok for them The Schedulers Plugin exists now https github com Netflix RxJava blob master rxjava core src main java rx plugins RxJavaDefaultSchedulers java @headinthebox @samuelgruetter Anything to do here I d love to discuss this in person this summer when I am at EPFL Can we leave it open for now Yup it s fine leaving open Assigned it to you for tracking purposes @headinthebox that sounds great',RxJava,false,false,false
26977054,'One global onCompleted object','issue https github com Netflix RxJava issues 662','RxJava pull requests #736 https netflixoss ci cloudbees com job RxJava pull requests 736 FAILURE Looks like there s a problem with this pull request The failing tests are rx operators OperationConditionalsTest testDoWhileManyTimes rx operators OperationConditionalsTest testWhileDoManyTimes and they already failed on my machine before I made any changes Curious what performance memory gains does this represent OnCompleted by definition happens only once per Observable so it s negligible compared with the cost of wrapping T with Notification Yes I think the performance memory gains are very small but 0 Maybe if someone uses Observables which emit 0 elements and just an OnCompleted to represent durations e g for join and many of these Observables are materialized the gains could be somewhat bigger Okay',RxJava,true,false,false
26990450,'Scala Scheduler Bindings Fix','Updated schedulers to reflect 0 17 changes Add timer bindings','RxJava pull requests #737 https netflixoss ci cloudbees com job RxJava pull requests 737 SUCCESS This pull request looks good',RxJava,true,false,false
26996442,'CompositeSubscription memory reduction','Since CompositeSubscription is now used everywhere with Subscriber I looked at the code again and tried to reduce memory consumption I ve added CLEAR_STATE_UNSUBSCRIBED singleton to transition into when unsubscribed Note that the previous version kept the subscription array after the unsubscription keeping references to other subscriptions alive although unsubscribed I m not certain why unsubscription didn t simply discard the array before I ve played with changing the add and remove methods not included in this PR to do more direct array manipulation with about 10 40 speed increase for tests like add directly followed by remove The speed increase comes from using arraycopy to avoid dynamic array creation in copyOf handling case where CS contains a single item to be removed and transitions into CLEAR_STATE instead of creating a new empty state Similar memory reduction could be implemented in MAS and SAS','RxJava pull requests #738 https netflixoss ci cloudbees com job RxJava pull requests 738 SUCCESS This pull request looks good This is great stuff thank you I ve been considering spending time on this myself so thanks for taking it on The changes involving arrayCopy sound great as well',RxJava,true,false,false
27006911,'CompositeSubscription performance increase','Optimized the case when the composite holds only a single element Replaced Arrays copyOf with regular arraycopy to avoid the cost of reflective array creation Included perf test where I got 32 increase on my i7 4770K','RxJava pull requests #739 https netflixoss ci cloudbees com job RxJava pull requests 739 SUCCESS This pull request looks good The things we do for performance Very nice changes Old code on my machine Run 10 14 477 981 ops sec Run 11 14 028 905 ops sec Run 12 14 738 523 ops sec Run 13 14 296 743 ops sec Run 14 14 643 646 ops sec New code Run 10 20 500 289 ops sec Run 11 19 725 110 ops sec Run 12 20 433 601 ops sec Run 13 19 659 111 ops sec Run 14 20 011 446 ops sec Like',RxJava,true,false,false
27016863,'Git keeps modifying this file so committing it how it wants it','','RxJava pull requests #740 https netflixoss ci cloudbees com job RxJava pull requests 740 SUCCESS This pull request looks good',RxJava,true,false,false
27018294,'Update to use Subscriber Subscriptions create','Master had changed since the pull request','RxJava pull requests #741 https netflixoss ci cloudbees com job RxJava pull requests 741 SUCCESS This pull request looks good',RxJava,true,false,false
27031420,'Reimplement subscribeOn using lift','hi this PR reimplemented the subscribeOn using lift However both the original and current implementation can not guarantee that unsubscribe is always called in the scheduler An extreme example is java public static void main String args throws InterruptedException Observable create new OnSubscribe Integer @Override public void call final Subscriber super Integer t1 final Subscription s Subscriptions create new Action0 @Override public void call System out println Thread currentThread getName t1 add s new Thread new Runnable @Override public void run t1 unsubscribe test start try Thread sleep 10000 catch InterruptedException e e printStackTrace t1 onCompleted subscribeOn Schedulers newThread subscribe Thread sleep 10000 will output test','RxJava pull requests #742 https netflixoss ci cloudbees com job RxJava pull requests 742 FAILURE Looks like there s a problem with this pull request RxJava pull requests #743 https netflixoss ci cloudbees com job RxJava pull requests 743 SUCCESS This pull request looks good I ve played around with this and couldn t get the scheduled unsubscription to run because when the subscription is scheduled it exposes the Inner MAS which then gets unsubscribed and prevents further scheduling on Inner completely Could you provide an example The return value of scheduler schedule isn t used This example doesn t print unsub and doesn t terminate after 100ms as it should I know it isn t your subscribeOn but this would ensure the unsubscription happens on the same newThread thread java public class SubscribeOnTest static T Observable T subscribeOn1 Observable T source Scheduler scheduler return Observable create Subscriber super T s Subscriber T s0 new Subscriber T @Override public void onCompleted s onCompleted @Override public void onError Throwable e s onError e @Override public void onNext T t s onNext t MultipleAssignmentSubscription mas new MultipleAssignmentSubscription s add mas mas set scheduler schedule i s add Subscriptions create i schedule j System out println Unsub Thread currentThread getName s0 unsubscribe System out println Sub Thread currentThread getName source subscribe s0 public static void main String args throws Exception Subscription s subscribeOn1 Observable interval 10 TimeUnit MILLISECONDS Schedulers computation subscribe v System out printf s s n Thread currentThread getName v Thread sleep 105 s unsubscribe Thread sleep 100 The problem is that the first schedule call once run should be gently removed to preserve the Inner s isUnsubscribed false status I had to modify MultipleAssignmentSubscription to allow setting and unsubscribing without calling unsubscribe in the inner subscription https gist github com akarnokd 8843694 https gist github com akarnokd 8843709 With the latter it correctly subscribes and unsubscribes If the Subscription of scheduler schedule is not added to the subscriber or the mas so the unsubscribe can be always called although there is a little performance cost RxJava pull requests #745 https netflixoss ci cloudbees com job RxJava pull requests 745 SUCCESS This pull request looks good Thanks @zsxwing for this and @akarnokd for the review',RxJava,true,false,false
27048148,'Why do Multiple and SerialSubscriptions keep the inner reference after unsubscription','I m looking into performance enhancement options with subscriptions at the moment and I m wondering why MultipleAssignmentSubscription and SerialSubscription keep the inner subscription value after unsubscribing instead of swapping it out with empty If done so I could use a static final unsubscribed state instead of a per instance unsubscribed state In addition I d rather use getAndSet DONE instead of the state loop I couldn t measure any significant performance change in swapping out an if check with an empty method call','Closing this for now',RxJava,false,false,false
27048635,'Set setDaemon on NewThreadScheduler','First noticed by @zsxwing','RxJava pull requests #744 https netflixoss ci cloudbees com job RxJava pull requests 744 FAILURE Looks like there s a problem with this pull request Passes locally Thank you for catching this',RxJava,true,false,false
27067240,'Issue #799 Commenting out the call to attachCallingThreadStack when co','nstructing a CompositeException','Should I merge this manually into 0 17',RxJava,true,false,false
27077588,'Return wrapped Subscription','make sure the SafeSubscriber is included in what is returned then return as Subscription not Subscriber so it can t be cast back to a Subscriber','',RxJava,true,false,false
27080192,'Fixed cut paster error in io scheduler','Thanks @samuelgruetter for pointing this out','RxJava pull requests #750 https netflixoss ci cloudbees com job RxJava pull requests 750 FAILURE Looks like there s a problem with this pull request Builds on my machine obviously GitHub pull request #827 to Netflix RxJava EnvInject Loading node environment variables Building remotely on 6880a4f9 in workspace scratch jenkins workspace RxJava pull requests sudo opt jenkins sbin mount webdav https repository netflixoss forge cloudbees com private netflixoss alert private netflixoss is not a mountpoint webdav mount try 1 private netflixoss is not a mountpoint p11 kit couldn t read config file etc pkcs11 modules private netflixoss is a mountpoint Fetching changes from the remote Git repository Fetching upstream changes from git github com Netflix RxJava git FATAL Could not checkout master with start point origin master',RxJava,true,false,false
27080788,'Repeat Operator','Based on code and discussion in https github com Netflix RxJava pull 807 files','',RxJava,true,false,false
27085775,'adding marble diagrams see also links to javadocs of new repeat variants','','RxJava pull requests #751 https netflixoss ci cloudbees com job RxJava pull requests 751 SUCCESS This pull request looks good RxJava pull requests #752 https netflixoss ci cloudbees com job RxJava pull requests 752 SUCCESS This pull request looks good',RxJava,true,false,false
27096483,'Subscriber linking up for unsubscriptions','If I understand correctly a Subscriber should send unsubscriptions only upwards but never downwards So whenever lift is used one would need to chain up Subscribers like this Subscriber U call Subscriber T o Subscriber U u o add u return u Here o comes from the client Calling o unsubscribe will propagate to u unsubscribe and up on the chain However if u unsubscribe is called It won t affect o s subscriptions i e u should send out onCompleted event to affect downstream However the OperatorMap doesn t do this but basically shares the same CompositeSubscription between o and u therefore unsubscription will affect both upstream and downstream OperatorTake completely ignores unsubscription coming from o as well letting the following example spin trough the 1G values in the background java Observable range 0 1_000_000_000 take 1_000_000_000 take 1 toBlockingObservable last Thread sleep 5000','Yep it was certainly broken Fixed in https github com Netflix RxJava pull 833 Thanks for the report This unit test proved the issue and is now passing java public void testMultiTake final AtomicInteger count new AtomicInteger Observable create new OnSubscribe Integer @Override public void call Subscriber super Integer s for int i 0 s isUnsubscribed i System out println Emit i count incrementAndGet s onNext i take 100 take 1 toBlockingObservable forEach new Action1 Integer @Override public void call Integer t1 System out println Receive t1 assertEquals 1 count get What about OperatorMap What about map It doesn t decouple the subscription chain but just passes it through java public Subscriber super T call final Subscriber super R o return new Subscriber T o Consider this java public static void main String args throws Exception AtomicInteger count new AtomicInteger Observable from 1 2 map v v 2 take 1 subscribe new Subscriber Integer @Override public void onCompleted @Override public void onError Throwable e @Override public void onNext Integer t add Schedulers newThread schedule i count incrementAndGet 500 TimeUnit MILLISECONDS Thread sleep 1000 System out println count It prints 0 for me because once take unsubscribes from map map or take propagates that unsubscription downwards as well disrupting the delayed schedule Yes that s how it behaves but not because take unsubscribes It s because onComplete happens which then triggers unsubscribe from the bottom up to do cleanup inside the SafeSubscriber That is by design Rx Design Guideline 4 3 Assume resources are cleaned up after an OnError or OnCompleted message Paragraph 4 1 states that no more messages should arrive after an OnError or OnCompleted message This makes it possible to cleanup any resource used by the subscription the moment an OnError or OnCompleted arrives Cleaning up resources immediately will make sure that any side effect occurs in a predictable fashion It also makes sure that the runtime can reclaim these resources Thus adding the Scheduler Subscription to the Subscriber but wanting it to be run after onCompleted won t work You would need to remove the add so the scheduling 500ms in the future happens regardless of onComplete happening FYI that I won t be responding to this further tonight It s past midnight and my brain is done Surprisingly this works java Observable from 1 take 1 delay v Observable timer 500 TimeUnit MILLISECONDS subscribe s even if delay clearly violates the guideline above as take will call unsubscribe before delay even emits its value It seems delay works only because its CompositeSubscription is disconnected from upstream so SafeSubscriber can t unsubscribe it before the actions were taken So if I rewrite delay pending onNexts won t get run because SafeSubscriber between the two will cancel the schedule subscriptions I think SafeSubscriber shouldn t force its actual subscriber which is downstream to unsubscribe even if delay clearly violates the guideline above It doesn t violate the guideline delay is also delaying the onComplete thus the unsubscribe of SafeSubscriber is not triggered until after delay completes Surprisingly this works It s not surprising since delay is an intermediate operator and thus does not have SafeSubscriber applied to it This is yet another reason why lift is actually a clearer representation of what is happening the intermediate operations are not subscribing their functions are lifted into the Observable and executed in sequence when the Observable is subscribed to by the final subscribe Subscriber The only remaining oddity now that we have lift that doesn t cleanly match are nested Observable use cases where an Operator must subscribe to them such as groupBy merge zip repeat We still rely on the isInternalImplementation check to prevent SafeSubscriber from wrapping those That is the intent of this discussion https github com Netflix RxJava issues 676 During the lift prototyping I had considered a private or different method than subscribe for operators to use but it makes the public API awkward to do so Likely we will end up with an rx operators Subscriber TrustedSubscriber OperatorSubscriber marker interface I think SafeSubscriber shouldn t force its actual subscriber which is downstream to unsubscribe If this were to be changed that would mean our current interpretation and implementation of guideline 4 3 is wrong As per the current interpretation the actual subscriber is not downstream The SafeSubscriber is the absolute last thing in the sequence and this is because the subscribe step is the final in the chain it s the exit point java Observable from 1 take 1 delay v Observable timer 500 TimeUnit MILLISECONDS subscribe s The final subscribe s there is the end That s why it returns Subscription or could equally return Void now Thus once the onComplete onError is invoked it is terminated and the full sequence is unsubscribed If SafeSubscriber did not unsubscribe the actual Subscriber what would it unsubscribe The intent is to cleanup all resources and the injected Subscriber is one of the resources that is now terminated and being cleaned up Considering this interpretation of guideline 4 3 what code changes would you make @headinthebox Your input would be valuable to correct any misunderstandings or wrong implementations of the guidelines we have The particular line of the guideline that influenced this implementation is The Rx contract for cleanup ensures that unsubscription will be called automatically once an OnError or OnCompleted message is sent Specifically we have interpreted that to mean when onCompleted onError happens at the very end not to intermediate steps since that didn t make sense nor does it work Thanks From implementation perspective I have two concerns As an internal implementation the Subscriber returned by my lifter method will be unsubscribed from upstream depending on what other operator is there the case where basically there is a single CompositeSubscription shared between various lifting Subscribers As an external implementation I can t use the Subscriber s add method because SafeSubscriber will unsubscribe it even if I want different behavior or do something after onCompleted arrived from upstream i e subscribe to another source Most likely both situation can be bypassed via nest will be unsubscribed from upstream If an operator needs to decouple from this such as groupBy then it passes a different Subscription up the chain The map operator for example doesn t care It just transforms data it receives As an external implementation I can t use the Subscriber s add method Sure you can within the lifecycle of that Subscriber If you don t want to work within the lifecycle then you must decouple just like groupBy does If you want to do something after onComplete you are by definition working outside the lifecycle of that Subscriber Since you re at the end of the chain you would not have another Subscription to attach to and thus just fire and forget as in the example given above with a Scheduler inside onNext In short the subscribe method is not the place to build a chaining operator implementing the lift function is and then you decouple the Subscription as necessary If you use subscribe Subscriber s then it is the end of the chain',RxJava,false,false,false
27098689,'Race condition in rx operators OperationJoin','I just picked up RxJava for the first time and was experimenting with Observable join I discovered a race condition when both sides of the join are publishing in parallel they will both emit each other s item e g 1 2 3 4 a b c d Could result in 1 a 2 a 1 b 2 b 3 a 3 b 3 c 1 c 2 c 3 c 1 d 2 d 3 d 4 a 4 b 4 c 4 d I have a patch for this on my fork I ll submit a pull request','I really appreciate you finding the fix for this',RxJava,false,false,false
27099559,'Issue #831 Fix for OperationJoin race condition','This is to fix the race condition outlined in issue #831 The join now grabs a copy of the other side s id in the first critical section then won t go higher than that in the iteration of the other side s values now using entrySet','RxJava pull requests #753 https netflixoss ci cloudbees com job RxJava pull requests 753 FAILURE Looks like there s a problem with this pull request Looks like a problem with the build server s local repo rather than the pull request Caused by hudson plugins git GitException Command git checkout b master origin master returned status code 1 stdout rxjava core src test java rx util CompositeExceptionTest java needs merge RxJava pull requests #754 https netflixoss ci cloudbees com job RxJava pull requests 754 FAILURE Looks like there s a problem with this pull request Looks to be passing when I run it on my machine Thank you for hunting this down and submitting a fix',RxJava,true,false,false
27107807,'Take operator was breaking the unsubscribe chain','Fixes issue https github com Netflix RxJava issues 830','',RxJava,true,false,false
27111781,'Update clojure for 0 17','Updated interop for OnSubscribe interface Updated readme and examples','RxJava pull requests #755 https netflixoss ci cloudbees com job RxJava pull requests 755 FAILURE Looks like there s a problem with this pull request Thanks Dave np more to come hopefully you guys are mostly done tearing things up At the surface yes I believe so I m not aware of any more signature changes Now it s on to cleaning up the guts to make it take advantage of the new Subscription injection capabilities so all operators connect the chain correctly But that won t hold up releasing 0 17 nor will that necessitate API changes',RxJava,true,false,false
27118530,'ObserveOn Operator with Backpressure','This is a re implementation of ObserveOn done for 3 purposes 1 Migrate to new lift style so the Subscription flows through correctly 2 Eliminate the wasted first schedule step reported by @mttkay https github com Netflix RxJava pull 797#issuecomment 34044956 3 Eliminate buffering so it naturally provides back pressure Unit tests are passing on my machine for a full build but I m interested in user experience particularly from Android users where observeOn behavior is mission critical This WILL change behavior and possibly cause problems if observeOn was being used to make something async which is not the purpose of observeOn The subscribeOn operator is the one to use for making something async This is a complete re write so I may very well have created nasty bugs that we don t yet have unit tests for so I d appreciate a thorough review and testing One possible concern is performance In the case of a synchronous firehose not the normal use case but a use case nonetheless this is far slower because now each onNext is sent one at a time across thread boundaries whereas before it would put everything into a queue on one side then read it all from the queue on the other side Thus for this code that synchronously firehoses 100000 values it is about 7 times faster on the current code without back pressure java long last Observable range 0 100000 observeOn Schedulers newThread toBlockingObservable last However this code is the same performance java long last Observable interval 1 TimeUnit MILLISECONDS take 1000 observeOn Schedulers newThread toBlockingObservable last The difference being that we re not just filling up the queue in the second one as it has latency I believe this is okay as the intent of observeOn is moving across thread boundaries such as for UI events and eliminating the bad behavior of buffer bloat is the right thing I m sure we can find some performance improvements in this code but it s worth pointing out how the change in behavior can affect it','@headinthebox This relates to discussions you and I have had about eliminating implicit buffers to enable natural back pressure unless operators such as buffer and window are explicitly requested I d appreciate your review of the change in behavior RxJava pull requests #756 https netflixoss ci cloudbees com job RxJava pull requests 756 FAILURE Looks like there s a problem with this pull request @benjchristensen Will do We might consider to add an explicit buffer operator to decouple producer and consumers such that is people want they can get the old behavior of observon whith all caveats about buffer bloat of course In NET you can that by ToEnumerable ToObservable but that is quite a hack and maybe not giving you exactly what you want RxJava pull requests #756 FAILURE That test is non deterministic and needs to get fixed We might consider to add an explicit buffer operator to decouple producer and consumers I m open to that Are you thinking just an overload of buffer or an overload of observeOn that accepts buffer options I think a buffer overload makes sense You are thinking of buffer that takes a scheduler then You are thinking of buffer that takes a scheduler then I was thinking so but looking at the buffer signature again I think it may be confusing java Observable List T buffer int count That would not line up well with java Observable T buffer Scheduler s Otherwise we could have observeOn Scheduler s Queue impl or observeOn Scheduler s int bufferSize it defaults to 1 I don t think we have enough use case to warrant the Queue type though Yes plus that buffer has many overloads for overlapping ones Also agreed on queue Having observeOn with size and what about time like replay i e buffer n ticks seems like a good start I did some testing speed testing with 1M range observed on newThread Original 473 828 612 ops s 444 320 052 ops s 411 198 937 ops s 416 063 006 ops s 420 909 267 ops s This PR 108 350 741 ops s 92 500 636 ops s 104 746 970 ops s 112 972 259 ops s 135 964 434 ops s With LinkedTransferQueue from Java 7 https gist github com akarnokd 8860735 Note that I m not sure the interrupt works in this example properly 953 053 010 ops s 858 773 229 ops s 975 575 822 ops s 783 006 554 ops s 1 146 638 663 ops s Using Doug Lea s TransferQueue backport http gee cs oswego edu cgi bin viewcvs cgi jsr166 src jsr166y 993 209 341 ops s 932 095 132 ops s 805 127 562 ops s 814 611 245 ops s 855 212 910 ops s The two latter TransferQueue based implementations fluctuate quite a bit between 600k 1200k for some reason Tested on i7 920 @ 2 66GHz Win7x64 6GB DDR3 1333MHz Java 7 u51 x64 Generally the benefit of using TQ transfer is that if there is a consumer party running it won t effectively block but if there isn t one it will wait until the consumer spins up I must admit I m not 100 certain it actually behaves like a queue 1 in terms of memory However profiling memory doesn t indicate any excess memory usage I did some testing speed testing with 1M range observed on newThread Original 473 828 612 ops s 444 320 052 ops s 411 198 937 ops s 416 063 006 ops s 420 909 267 ops s This PR 108 350 741 ops s 92 500 636 ops s 104 746 970 ops s 112 972 259 ops s 135 964 434 ops s Semaphore queue with permits observeOn code is here https gist github com akarnokd 8860735 1 100 000 ops s tests pass 2 350 000 ops s backpressure tests fail 4 1 300 000 ops s backpressure tests fail testParallel fails 8 1 900 000 ops s backpressure tests fail testParallel fails 16 2 500 000 ops s backpressure tests fail testParallel fails 32 2 300 000 ops s backpressure tests fail testParallel fails 64 2 200 000 ops s backpressure tests fail testParallel fails The testParallel seems to fail because the scheduling is interrupted before the last values in the queue could be processed If I remove the interrupt check from poll any sized testParallel passes Semaphore queue with permits and batch drain of the queue code https gist github com akarnokd 8863449 1 95 000 ops s 2 272 000 ops s 4 900 000 ops s 8 1 900 000 ops s 16 3 074 000 ops s 32 5 400 000 ops s 64 8 700 000 ops s 128 7 700 000 ops s 256 7 600 000 ops s 512 11 086 000 ops s Using batch drain appears to be more efficient when the queue size 16 on my machine I think the reason for this is that permits are released in larger numbers and producers less frequently need to wait for a 0 1 permit transition Going above 512 resulted in significant fluctuations between 8M 13M The two latter TransferQueue based implementations fluctuate quite a bit between 600k 1200k for some reason Tested on i7 920 @ 2 66GHz Win7x64 6GB DDR3 1333MHz Java 7 u51 x64 I tried to improve performance of the 1 permit case via TransferQueue but I couldn t get reliable data exchange nor could I implement proper interruption I have updated the code to support observeOn Scheduler s int bufferSize and it uses a ring buffer in the implementation The buffer allows getting async behavior and increased throughput version 0 17 1 with queue size 1 Run 10 115 033 ops sec Run 11 118 155 ops sec Run 12 120 526 ops sec Run 13 115 035 ops sec Run 14 116 102 ops sec version 0 17 1 with queue size 16 Run 10 850 412 ops sec Run 11 711 642 ops sec Run 12 788 332 ops sec Run 13 1 064 056 ops sec Run 14 656 857 ops sec version 0 17 1 with queue size 1000000 Run 10 5 162 622 ops sec Run 11 5 271 481 ops sec Run 12 4 442 470 ops sec Run 13 5 149 330 ops sec Run 14 5 146 680 ops sec However it s still slower than the previous implementation with an unbounded queue version 0 16 1 Run 10 27 098 802 ops sec Run 11 24 204 284 ops sec Run 12 27 208 663 ops sec Run 13 26 879 552 ops sec Run 14 26 658 846 ops sec I m going to proceed with the merge as this gets the functionality and API to what is wanted and the performance is adequate for the use case I d be interested if anyone else wants to look at how to further improve the performance I ve been playing with this over the weekend with 0 17 0 RC1 and think we need to revert the default back pressure behavior I think it is relevant as an option to be applied but it s too risky as the default behavior if the source Observable is being emitted from an event loop such as an NIO selector thread I m going to submit a change today that splits out OperatorObserveOn and OperatorObserveOnBounded and leaves the default observeOn Scheduler s using the unbounded version Further discussion of providing tools for back pressure will be picked up in the 0 18 dev cycle',RxJava,true,false,false
27119966,'Setting up the new subproject for debugging observable chains','By creating and registering this plugin you get a complete log of all the events subscribe onNext onError onCompleted and unsubscribe that happen in all observables observers and subscribers The debug hook also takes a Func1 for transforming data before they are sent to actual onNext functions This pull request is for the raw data There isn t any persistence or visualization of the data generated yet Here is an example of a simple observable chain from 1 3 flatMap it from it it 1 take 3 subscribe And the stream of notifications sent nano 1391761208271225000 thread 1 observer rx Observable 27@3290a11e type Subscribe source rx Observable 2@3541d281 nano 1391761208272832000 thread 1 observer rx operators OperatorTake 1@f81c4a1 type Subscribe source rx Observable 2@10942dfb to rx operators OperatorTake@7056c23d nano 1391761208275469000 thread 1 observer rx operators OperatorMerge 1@49c5146e type Subscribe source rx Observable 2@29c06798 to rx operators OperatorMerge@16d14192 nano 1391761208275644000 thread 1 observer rx operators OperatorMap 1@427e3f2 type Subscribe source rx operators OperatorFromIterable@56e626ff to rx operators OperatorMap@200a5beb nano 1391761208276707000 thread 1 observer rx operators OperatorMap 1@427e3f2 type OnNext value 1 to rx operators OperatorMap@200a5beb nano 1391761208276839000 thread 1 observer rx operators OperatorMerge 1@49c5146e type OnNext value rx Observable@299b78d4 from rx operators OperatorMap@200a5beb to rx operators OperatorMerge@16d14192 nano 1391761208277012000 thread 1 observer rx operators OperatorMerge 1 InnerObserver@2b6dd9c5 type Subscribe source rx operators OperatorFromIterable@38f42ac9 nano 1391761208277075000 thread 1 observer rx operators OperatorMerge 1 InnerObserver@2b6dd9c5 type OnNext value 1 nano 1391761208277166000 thread 1 observer rx operators OperatorTake 1@f81c4a1 type OnNext value 1 from rx operators OperatorMerge@16d14192 to rx operators OperatorTake@7056c23d nano 1391761208277243000 thread 1 observer rx Observable 27@3290a11e type OnNext value 1 from rx operators OperatorTake@7056c23d nano 1391761208277338000 thread 1 observer rx operators OperatorMerge 1 InnerObserver@2b6dd9c5 type OnNext value 2 nano 1391761208277397000 thread 1 observer rx operators OperatorTake 1@f81c4a1 type OnNext value 2 from rx operators OperatorMerge@16d14192 to rx operators OperatorTake@7056c23d nano 1391761208277471000 thread 1 observer rx Observable 27@3290a11e type OnNext value 2 from rx operators OperatorTake@7056c23d nano 1391761208277557000 thread 1 observer rx operators OperatorMerge 1 InnerObserver@2b6dd9c5 type OnCompleted nano 1391761208279076000 thread 1 observer rx operators OperatorMap 1@427e3f2 type OnNext value 3 to rx operators OperatorMap@200a5beb nano 1391761208279154000 thread 1 observer rx operators OperatorMerge 1@49c5146e type OnNext value rx Observable@24d8116d from rx operators OperatorMap@200a5beb to rx operators OperatorMerge@16d14192 nano 1391761208279252000 thread 1 observer rx operators OperatorMerge 1 InnerObserver@65601e00 type Subscribe source rx operators OperatorFromIterable@951c5ff nano 1391761208279322000 thread 1 observer rx operators OperatorMerge 1 InnerObserver@65601e00 type OnNext value 3 nano 1391761208279409000 thread 1 observer rx operators OperatorTake 1@f81c4a1 type OnNext value 3 from rx operators OperatorMerge@16d14192 to rx operators OperatorTake@7056c23d nano 1391761208279483000 thread 1 observer rx Observable 27@3290a11e type OnNext value 3 from rx operators OperatorTake@7056c23d nano 1391761208279562000 thread 1 observer rx Observable 27@3290a11e type OnCompleted from rx operators OperatorTake@7056c23d nano 1391761208279692000 thread 1 observer rx Observable 27@3290a11e type Unsubscribe from rx operators OperatorTake@7056c23d nano 1391761208279756000 thread 1 observer rx operators OperatorTake 1@f81c4a1 type Unsubscribe from rx operators OperatorMerge@16d14192 to rx operators OperatorTake@7056c23d nano 1391761208279830000 thread 1 observer rx operators OperatorMerge 1@49c5146e type Unsubscribe from rx operators OperatorMap@200a5beb to rx operators OperatorMerge@16d14192 nano 1391761208279880000 thread 1 observer rx operators OperatorMap 1@427e3f2 type Unsubscribe to rx operators OperatorMap@200a5beb nano 1391761208279946000 thread 1 observer rx operators OperatorMerge 1 InnerObserver@2b6dd9c5 type Unsubscribe nano 1391761208280018000 thread 1 observer rx operators OperatorMerge 1 InnerObserver@65601e00 type Unsubscribe nano 1391761208280085000 thread 1 observer rx operators OperatorMap 1@427e3f2 type OnCompleted to rx operators OperatorMap@200a5beb nano 1391761208280150000 thread 1 observer rx operators OperatorMerge 1@49c5146e type OnCompleted from rx operators OperatorMap@200a5beb to rx operators OperatorMerge@16d14192','RxJava pull requests #757 https netflixoss ci cloudbees com job RxJava pull requests 757 FAILURE Looks like there s a problem with this pull request Something is conflicted so it needs to be rebased before I can merge Sorry forgot to push it up to the fork RxJava pull requests #763 https netflixoss ci cloudbees com job RxJava pull requests 763 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
27121381,'Perf with JMH','#776 This is a small change on top of perf with Caliper to performance benchmarking with JMH','Example output of the same timings done in #788 Benchmark Mode Thr Count Sec Mean Mean error Units r o ObservableBenchmark timeBaseline thrpt 1 20 1 557 493 12 025 ops ms r o ObservableBenchmark timeMap thrpt 1 20 1 374 152 3 968 ops ms r o ObservableBenchmark timeMapIterate thrpt 1 20 1 2389 195 42 686 ops ms BUILD SUCCESSFUL Total time 2 mins 5 172 secs RxJava pull requests #758 https netflixoss ci cloudbees com job RxJava pull requests 758 FAILURE Looks like there s a problem with this pull request Thanks I look forward to seeing our perf testing mature in this project Related to https github com Netflix RxJava issues 776',RxJava,true,false,false
27183892,'Make Scala OnCompleted Notification an object','This should solve issue https github com Netflix RxJava issues 662 and https github com Netflix RxJava pull 584','RxJava pull requests #759 https netflixoss ci cloudbees com job RxJava pull requests 759 SUCCESS This pull request looks good',RxJava,true,false,false
27185371,'Error Handling OnErrorNotImplemented and java lang Error','Special Handling of java lang Error and OnErrorNotImplemented https github com Netflix RxJava issues 748#issuecomment 32471495 https github com Netflix RxJava issues 771 https github com Netflix RxJava issues 789','This represents a possible approach to handling OnErrorNotImplementedException and java lang Error I m not convinced it s the right approach for all java lang Error to be caught For OnErrorNotImplementedException and StackOverflow I think they must be thrown from wherever they are caught The reason for it not being obvious to throw is that by throwing on a background thread instead of sending via onError the terminal states of an Observable will never be triggered and thus will deadlock Many java lang Error should result in the system shutting down but probably not all It could possibly be limited to these https github com Netflix RxJava issues 748#issuecomment 32471495 Any advice or insight on what is considered to be the right approach for everything else RxJava pull requests #760 https netflixoss ci cloudbees com job RxJava pull requests 760 FAILURE Looks like there s a problem with this pull request After thinking about it further I decided I didn t like my previous approach and have replaced it with this one that is more generic and doesn t make any specific operators do anything special I found the issue was the SynchronizedObserver was taking on more responsibility than it should have been and was capturing errors and then ignoring everything after a terminal state occurred which became a problem when onError was called resulted in an exception of its own which invoked onError again This resulted in me doing 3 specific changes 1 SafeSubscriber manages safety and error handling SynchronizedObserver only does synchronization 2 New method Exceptions throwIfFatal e checks for special handling java public static void throwIfFatal Throwable t if t instanceof OnErrorNotImplementedException throw OnErrorNotImplementedException t values here derived from https github com Netflix RxJava issues 748#issuecomment 32471495 else if t instanceof StackOverflowError throw StackOverflowError t else if t instanceof VirtualMachineError throw VirtualMachineError t else if t instanceof ThreadDeath throw ThreadDeath t else if t instanceof LinkageError throw LinkageError t 3 The throwIfFatal call is invoked before the terminal state check so even if onError was already invoked and throws only to end up again passed to onError the throwIfFatal will catch it on the outside of the isFinished check so it will still throw java public void onError Throwable e we handle here instead of another method so we don t add stacks to the frame which can prevent it from being able to handle StackOverflow Exceptions throwIfFatal e if isFinished compareAndSet false true _onError e These changes appear to have resolved the OnErrorNotImplemented and StackOverflow issues reported in https github com Netflix RxJava issues 771 and https github com Netflix RxJava issues 748 Local build is passing merging BUILD SUCCESSFUL Total time 2 mins 36 851 secs RxJava pull requests #761 https netflixoss ci cloudbees com job RxJava pull requests 761 SUCCESS This pull request looks good',RxJava,true,false,false
27203980,'Example of creating Observable from an I O source','I d like to see an example of something simple like reading lines from a File in Scala It would then be incredibly useful to see applying filters e g users only receive non comment lines potentially with the Observable itself knowing it can skip processing if nobody is subscribed I m not sure if this is even possible but could allow some optimisations parallel calculations in the subscribers but with throttling on the observable imagine a 10GB CSV file being read by the observable Subscribers doing expensive processing in parallel per row but no more than 100 rows are ever actually alive in the system thereby controlling the memory usage','parallel calculations Is it okay for the parallel execution to be unordered or do you need the output to remain in the same order as coming from the file The difference is significant in how the problem is tackled skip processing if nobody is subscribed If nobody subscribes then the Observable is not running unless you have turned it into a hot Observable behind a Subject but that doesn t really make sense for file processing Thus a filter operator would drop all comment lines and emit only the unfiltered lines and you d only process what you re interested in unordered is fine For working with large infinite streams of text I recommend you look at the rxjava string contrib module There are a few basic operators working with strings and byte arrays I just submitted a pull request #843 to add a from Reader method to make the example below work Translation to Scala is left to the reader import static rx observables StringObservable split from new FileReader foo txt n filter new Func1 String Boolean public Boolean call String line return line startsWith subscribe I not actually interested in string files I ve just used that as a simple example without having to explain the binary format of the file we re parsing The from code is a good starting place though thanks Take a look at the parallel operator for doing processing work on multiple threads @abersnaze should onCompleted be called when it gets to the end of the file I m seeing infinite hanging here https github com fommil rx playground blob master src main scala com github fommil rx scratch scala#L154 @benjchristensen how am I supposed to use parallel It takes two parameters I was hoping to just add parallel similarly to the way Scala collections can be par d Yes If oncompleted is not called things tend to hang forever On Feb 16 2014 at 11 50 AM Sam Halliday notifications@github com wrote @abersnaze should onCompleted be called when it gets to the end of the file I m seeing infinite hanging here https github com fommil rx playground blob master src main scala com github fommil rx scratch scala#L154 @benjchristensen how am I supposed to use parallel It takes two parameters I was hoping to just add in similarly to the way Scala collections can be par d Reply to this email directly or view it on GitHub @abersnaze is that a bug you ll be fixing soon @benjchristensen I added the parallel flag here is this the correct way to do it It feel clunky having to pass the identity and mixing the Java Scala APIs to use the StringObservables https github com fommil rx playground blob master src main scala com github fommil rx scratch scala#L150 but this results in an OutOfMemoryException when run with 10mb heap I m trying to simulate parsing a large input source that cannot be retained in memory This is very representative of problems I face on an recurring basis and it appears that the current Observable parallel setup is to do the same thing as creating lots of Future s I am aware that you ve said on the mailing list that this is a work in progress and there are plans to allow customisation of the parallel strategy For me it would be ideal if the producer and consumer were seen as pots of atomic work e g readNext onNext and I could write a parallelisation strategy on that basis e g always call readNext if I have less than 10 buffered outstanding readNext otherwise always call onNext and the differentiator from the rest if there are no elements in my buffer then give the Thread back to the pool and don t make any more decisions until one of the readNext s returns Could you write a unit test in Java without the various dependencies of that code that demonstrates the OOM issue @benjchristensen if it helps absolutely I might drop the StringObservables too and just use an infinite stream of integers or something Thank you it definitely would I d like to use the unit test to track down the issue resolve it and put in the codebase If you submit it as a PR I ll merge it in as I work on fixing it @benjchristensen I m struggling with gradle A problem occurred configuring root project rxjava Could not resolve all dependencies for configuration classpath Could not download artifact com jcraft jsch 0 1 44 1@jar Artifact com jcraft jsch 0 1 44 1@jar not found I might just do this as a unit test in my repo and then copy it over when I can compile and open in IntelliJ actually writing this might have to run as part of a separate low heap size test package It ll obviously pass if the default jvm flags are used @benjchristensen please find test you ll need to run it with a really small heap like 5m to see the problem My gradle foo is not strong enough to help you set that up I think I d actually struggle under sbt or maven as well to be honest Thank you I ll play with this to avoid the need to change the memory settings the test could be easily changed to return arrays of 10 to 100MB That outta cause OOMs with your default test settings what is your default @benjchristensen see trivial update that OOMs with default JVM settings @benjchristensen I should like to draw your attention to my experiment at https github com fommil rx playground commit 26d39e030dc10e9c7c99be638537b55473be8537 This is horrendously inefficient at the moment and ugly but the principles are there In a nutshell I have defined an interface BlockingProducer and a means to turn it into an Observable with the ability to throttle the number of threads in consumers I use consumer subscriber synonymously here whilst minimising blocking The algorithm is pretty simple effectively produce if the buffer is getting low and we re not already blocking on the producer in another thread otherwise consume if there is anything to consume otherwise rest by giving the thread back to the pool There is a pool of Futures so this typically results in 1 producer and N consumer threads at any given moment Mosts importantly memory use is kept under control The performance could be greatly improved by reducing or eliminating the need to use locks and the code could be cleaned up dramatically by a few simple refactors However a simple test in the hack scala of reading a 50 000 CSV file with 1ms processing time per line does result in running N times faster Contrast this with Observable parallel which is prone to OutOfMemoryException as I showed above Next steps could be support other types of producers e g non blocking but with a back off and retry strategy possibly moot because this is most effective when a tight loop over production creates too much data producers that can provide in parallel or producers that require regular polling heartbeats abstract the produce consume decision so that it is more pluggable by users of the API updates https github com fommil rx playground blob master src main scala com github fommil rx producers scala The backpressure concerns of this issue are being tracked in #1000 and worked on as part of the Reactive Streams https github com reactive streams reactive streams project If there is anything out of this discussion that you d like to contribute back please submit it as part of one of the existing contrib modules or as a new one',RxJava,false,false,false
27215284,'Range OnSubscribe','Reimplemented as a simple loop instead of Iterable Simpler code gives a performance bump 0 17 Run 10 271 147 198 ops sec Run 11 274 821 481 ops sec Run 12 271 632 295 ops sec Run 13 277 876 014 ops sec Run 14 274 821 763 ops sec 0 16 1 Run 10 222 104 280 ops sec Run 11 224 311 761 ops sec Run 12 222 999 339 ops sec Run 13 222 344 174 ops sec Run 14 225 247 983 ops sec','',RxJava,true,false,false
27215355,'Test Unsubscribe','also cleaned up some stuff I remembered after merging last commits','',RxJava,true,false,false
27304968,'Updating StringObservable','Updating StringObservable to use lift And added from InputStream and from Reader','RxJava pull requests #764 https netflixoss ci cloudbees com job RxJava pull requests 764 FAILURE Looks like there s a problem with this pull request RxJava pull requests #765 https netflixoss ci cloudbees com job RxJava pull requests 765 FAILURE Looks like there s a problem with this pull request This is failing to merge and can the debug stuff be separated out from StringObservable Nevermind I manually merged it in is this in a SNAPSHOT release yet yes 0 17 0 RC1 it was released yesterday',RxJava,true,false,false
27307316,'GroupBy time gap Issue','The groupBy operator has a time gap issue when used with subscribeOn and observeOn This exists in Rx Net as well and was written about at http blogs msdn com b rxteam archive 2012 06 14 testing rx queries using virtual time scheduling aspx However if you introduce asynchrony in the pipeline e g by adding an ObserveOn operator to the mix you re effectively introducing a time gap during which we ve handed out the sequence to you control has been released on the OnNext channel but subscription happens at a later point in time causing you to miss elements We can t do any caching of elements because we don t know when if ever someone will subscribe to the inner sequence so the cache could grow in an unbounded fashion In discussion with @headinthebox I have decided to alter the behavior to remove this time gap issue so that non deterministic data loss does not happen for the common use cases of using observeOn and subscribeOn with GroupedObservables from groupBy Why It is common to want to use observeOn or subscribeOn with GroupedObservable do process different groups in parallel It comes with a trade off though all GroupedObservable instances emitted by groupBy must be subscribed to otherwise it will block The reason for this is that to solve the time gap one of two things must be done a use unbounded buffering such as ReplaySubject b block the onNext calls until GroupedObservable is subscribed to and receiving the data We can not choose a for the reasons given in the Rx Net blog post because it breaks backpressure and could buffer bloat until the system fails In general it is an appropriate thing to expect people to subscribe to all groups except in one case where it will be expected to work using filter In this case we can solve the common case by special casing filter to be aware of GroupedObservable It s not decoupled or elegant but it solves the common problem Thus the trade offs are 1 Allow for non deterministic data loss if observeOn subscribeOn are used and expect people to learn about this by reading docs 2 Behave deterministically when observeOn subscribeOn are used but block if groups are manually skipped Option 2 seems to be easier for developers to run into during dev and solve than option 1 which could often show up randomly in prod and be difficult to figure out and solve','How about 1 and present a new operator to cover the parallel processing case directly That doesn t prevent people from using observeOn on GroupedObservable such as for rendering to a UI It s a tough trade off non determinism when using things that should not inject non determism or risk of blocking Another possible solution is we could special case observeOn and subscribeOn instead to not return from onNext until they have subscribed This would mean I need a hook inside the Subscriber type that tells me once a subscription is registered I ve looked at that as well not sure which is better yet Actually modifying observeOn and subscribeOn may not result in the deadlock risks so I m going to test that implementation I ve submitted an attempt at a solution The issue appears to be resolved but I don t completely like the solution nor do I trust it 100 yet I need to sleep and think about it again tomorrow but I d appreciate a review and feedback or a better solution from someone There are trade offs to solving this solution that probably are not worth it I d like people s opinion on whether we should figure out how to make these unit tests pass or if it s acceptable for them not to java @Test public void testGroupsWithNestedSubscribeOn throws InterruptedException final ArrayList String results new ArrayList String Observable create new OnSubscribe Integer @Override public void call Subscriber super Integer sub sub onNext 1 sub onNext 2 sub onNext 1 sub onNext 2 sub onCompleted groupBy new Func1 Integer Integer @Override public Integer call Integer t return t flatMap new Func1 GroupedObservable Integer Integer Observable String @Override public Observable String call final GroupedObservable Integer Integer group return group subscribeOn Schedulers newThread map new Func1 Integer String @Override public String call Integer t1 System out println Received t1 on group group getKey return first groups t1 toBlockingObservable forEach new Action1 String @Override public void call String s results add s System out println Results results assertEquals 4 results size @Test public void testFirstGroupsCompleteAndParentSlowToThenEmitFinalGroupsWhichThenSubscribesOnAndDelaysAndThenCompletes throws InterruptedException final CountDownLatch first new CountDownLatch 2 there are two groups to first complete final ArrayList String results new ArrayList String Observable create new OnSubscribe Integer @Override public void call Subscriber super Integer sub sub onNext 1 sub onNext 2 sub onNext 1 sub onNext 2 try first await catch InterruptedException e sub onError e return sub onNext 3 sub onNext 3 sub onCompleted groupBy new Func1 Integer Integer @Override public Integer call Integer t return t flatMap new Func1 GroupedObservable Integer Integer Observable String @Override public Observable String call final GroupedObservable Integer Integer group if group getKey 3 return group map new Func1 Integer String @Override public String call Integer t1 return first groups t1 must take 2 so an onCompleted unsubscribe happens on these first 2 groups take 2 doOnCompleted new Action0 @Override public void call first countDown else return group subscribeOn Schedulers newThread delay 400 TimeUnit MILLISECONDS map new Func1 Integer String @Override public String call Integer t1 return last group t1 toBlockingObservable forEach new Action1 String @Override public void call String s results add s System out println Results results assertEquals 6 results size Here is a subscribeOn unit test that fails when PublishSubject is used if the Scheduler is slower than the time to emit onNext java @Test public void testSubscribeOnPublishSubjectWithSlowScheduler PublishSubject Integer ps PublishSubject create TestSubscriber Integer ts new TestSubscriber Integer ps subscribeOn new SlowScheduler subscribe ts ps onNext 1 ps onNext 2 ps onCompleted ts awaitTerminalEvent ts assertReceivedOnNext Arrays asList 1 2 Maybe subscribeOn has to be smarter about its source and not everyone else I e if subscribeOn detects that the source is PublishSubject It enters a buffering mode and once the time of the actual subscription has come replay the buffered values and resume as a regular Observer would This is is different from my previous hack where only the first observer would get the values Here everyone who is on a delayed subscription would eventually get the values from the time gap That s an interesting idea especially since PublishSubject is definitely the culprit What do you think about the lack of back pressure during that buffering period The reason is the same as observeOn being changed not allowing buffer bloat unless someone consciously chooses to do buffering or windowing Bounded buffering like in observeOn seems to be a workable solution since the source needs to be blocked until the replay catches up anyway I m not sure however that my idea is deadlock free or not I ll do some experiments tomorrow Thanks I look forward to seeing your idea I appreciate your back and forth on this with me Is this settled I believe so Hi Ben I found your post after worrying that I could run into this situation in my own code It is implied in your post but I wanted to be entirely sure Can this problem arise if you call subscribe on the _same_ scheduler i e if I do grpdObs subscribe keyAndObs val key obs keyAndObs obs subscribe someObserver is it guaranteed that the notification that evokes the first outer subscribe will also be pushed to someObserver in other words that the notification on the inner subscription won t be skipped on someObserver Now the issue discussed here only applies when the inner subscription is done on another scheduler correct As of 0 18 this problem shouldn t exist any longer as it will buffer until the subscriber arrives If the subscribe is occurring synchronously then it is never a problem only when the subscribe happens asynchronously such as using subscribeOn Now the choice of same or different scheduler is nuanced if using subscribeOn Even if it s the same scheduler it could schedule it to be done later so the question is not about what scheduler it is it is about whether there is a delay async queueing scheduling of the subscribe occurring which typically is going to happen when using a scheduler Your example code would be fine because the obs subscribe is happening synchronously If however you changed it to the following it would be vulnerable grpdObs subscribe keyAndObs val key obs keyAndObs obs subscribeOn aScheduler subscribe someObserver The reason it becomes vulnerable is that the function returns and groupBy continues forward while the obs subscribe then happens sometime later We put a solution in place for this in https github com Netflix RxJava pull 975 The downside is it makes it possible to have a memory leak if groups are skipped purposefully not subscribed to and we don t have a solution for that yet We decided that we d rather avoid the non deterministic data loss and risk a memory leak as that s easier to explain to people At some point we ll need to solve the memory leak issue as well such as emit an error auto unsubscribe or something similar if a group is emitted and not subscribed to I opened https github com Netflix RxJava issues 1280 to cover the side effect of this solution',RxJava,false,false,false
27308472,'Fix problem with Subscription','Fix problem with anonymous implementation of Subscription Enable Kotlin module','RxJava pull requests #766 https netflixoss ci cloudbees com job RxJava pull requests 766 FAILURE Looks like there s a problem with this pull request The tests failing aren t relatad to Kotlin Thank you',RxJava,true,false,false
27327062,'Added overloaded createRequest method that takes an HttpContext instance','An HttpContext is needed when doing for example preemptive digest authentication with HTTP Client','RxJava pull requests #767 https netflixoss ci cloudbees com job RxJava pull requests 767 FAILURE Looks like there s a problem with this pull request I don t think I ve caused the test failures since they failed even before I started working on the pull request I have a fix for it in #777 but has been ignored so far Thank you for contributing',RxJava,true,false,false
27330241,'Various Changes While Fixing GroupBy','','RxJava pull requests #768 https netflixoss ci cloudbees com job RxJava pull requests 768 SUCCESS This pull request looks good',RxJava,true,false,false
27330319,'Attempt at SubscribeOn Time Gap Issue Preview','This is an attempt at solving the subscribeOn time gap issue that I found to be affecting unit tests and use cases such as parallel More information and discussion is at https github com Netflix RxJava issues 844 Currently I have made this work by having a trigger on Subscriber onSubscribe that I m not thrilled with but want to show this for discussion','RxJava pull requests #770 https netflixoss ci cloudbees com job RxJava pull requests 770 FAILURE Looks like there s a problem with this pull request I m aware of the rx subjects ReplaySubjectTest testNewSubscriberDoesntBlockExisting failure and have not yet dug into it RxJava pull requests #771 https netflixoss ci cloudbees com job RxJava pull requests 771 FAILURE Looks like there s a problem with this pull request Pulled in changes from https github com Netflix RxJava pull 850 and rebased on top of the many merges to master done this morning RxJava pull requests #777 https netflixoss ci cloudbees com job RxJava pull requests 777 ABORTED Closing out as I m not happy with the direction this is taking Discussion over at https github com Netflix RxJava issues 844',RxJava,true,false,false
27341102,'Add Fragment Host to rxjava contrib modules for OSGi','avoid split packages http wiki osgi org wiki Split_Packages see also discussion #154','RxJava pull requests #772 https netflixoss ci cloudbees com job RxJava pull requests 772 SUCCESS This pull request looks good Thank you this isn t something I have any experience with',RxJava,true,false,false
27342938,'Subscribe on gap','Changed @benjchristensen code a bit to allow cancelling a delayed async subscription Fixed up the testNewSubscriberDoesntBlockExisting test the original deadlocked due the synchronous changes to the subscription model In order to let the async subscription work non disruptively I had to add a delete method to CompositeSubscription which removes a subscription without unsubscribing it This is necessary to not cancel an inner scheduler Unfortunately some Async tests fail due to deadlock now This PR is not really meant for merge but only for demonstration purposes','Thank you @akarnokd I have merged into my branch on https github com Netflix RxJava pull 848 and am reviewing things While exploring this problem I created a BlockUntilSubscribePublishSubject that seemed to solve the groupBy use case Do you think it s better to pursue a one off solution for that problem and not attempt the overall time gap issue of subscribeOn I thought about introducing a PublishSubject variant which acts as a ReplaySubject until the first subscriber arrives Or simply allow the user to decide about the groups subject type Other than this I don t have any ideas maybe we need a 4th dimension like a meta scheduler or meta observable level to solve this I thought about introducing a PublishSubject variant which acts as a ReplaySubject until the first subscriber arrives That would work well as long as everything gets subscribed to which then brings up the hacks such as filter that needs to be aware of subscribe to and unsubscribe from GroupedObservable instances that are filtered out Same problem as the blocking onNext Do you think that s a satisfactory hack to solve the problem The specific use cases that concern me are now listed in https github com Netflix RxJava issues 844#issuecomment 34815955 Closing out for further discussions at #844',RxJava,true,false,false
27347966,'Reimplement the timeout operator and fix timeout bugs','This PR reimplemented the timeout operator I also fixed the following bugs of timeout The timeout can not work on a synchronized Observable Unit test https github com zsxwing RxJava commit 356a6902a6e96e4d1a131d71521b62d26596fd6c#diff f181dce6b07869d0daacb404a292ce0cR231 The selector variant of Timeout should throw TimeoutException when a timeout event happens without an other Observable Unit test https github com zsxwing RxJava commit 356a6902a6e96e4d1a131d71521b62d26596fd6c#diff 836fc7028db94329e793dcc6075a258dR259 and https github com zsxwing RxJava commit 356a6902a6e96e4d1a131d71521b62d26596fd6c#diff 836fc7028db94329e793dcc6075a258dR289 The selector variant of Timeout has a race condition between onNext and timeout methods Unit test https github com zsxwing RxJava commit 356a6902a6e96e4d1a131d71521b62d26596fd6c#diff 836fc7028db94329e793dcc6075a258dR321 The method signatures of some selector variants of Timeout are wrong','Sorry that I have no time to update the java docs tonight I ll finish it tomorrow RxJava pull requests #774 https netflixoss ci cloudbees com job RxJava pull requests 774 SUCCESS This pull request looks good I haven t had time to go through line by line and fully understand but it looks clean and the tests suggest it s good Thank you this looks like it took some work',RxJava,true,false,false
27383137,'rxjava debug','Manual merge of https github com Netflix RxJava pull 836','',RxJava,true,false,false
27383303,'StringObservable Update','Manual merge of https github com Netflix RxJava pull 843','RxJava pull requests #776 https netflixoss ci cloudbees com job RxJava pull requests 776 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
27395030,'The onCreate hook disappeared','I think in the merging this hook disappeared from the original pull request for the debug hooks','RxJava pull requests #778 https netflixoss ci cloudbees com job RxJava pull requests 778 SUCCESS This pull request looks good',RxJava,true,false,false
27395087,'Move InterruptibleBlockingQueue Inside ObserveOn','I decided I m not ready to commit to this in the public API so am leaving it an implementation detail of ObserveOn While working on groupBy parallel and subscribeOn this queue was not the right solution','RxJava pull requests #779 https netflixoss ci cloudbees com job RxJava pull requests 779 SUCCESS This pull request looks good',RxJava,true,false,false
27396423,'SchedulePeriodically Signature','This pull requests adds TimeUnit delayUnit to the signature java public Subscription schedulePeriodically final Action1 Scheduler Inner action long initialDelay TimeUnit delayUnit long period TimeUnit periodUnit This was derived from feedback from @headinthebox while writing the Scala APIs Reason for it better matches languages that have a single object that represent both together such as Scala Java 8 adds Duration http download java net jdk8 docs api java time Duration html Reason against Java 7 and earlier doesn t do it this way on their Executor Java 8 despite adding Duration still doesn t use it on their ScheduledExecutorService Thoughts concerns opinions','RxJava pull requests #780 https netflixoss ci cloudbees com job RxJava pull requests 780 SUCCESS This pull request looks good I don t know that this change is worth pursuing and being different than Executor It s easy enough to use as is and convert from languages like Scala as it s wrapper already does Some day maybe v2 0 when we support Java 8 as the minimum we could then use Duration initial Duration period Agreement Disagreement Evidently I m not strongly opinionated either way on this one so feedback would be helpful @headinthebox Since you are a proponent for this change please weigh in Why not have two overloads That should work just fine I find it a bit extremely distasteful to have one unit for two totally unrelated durations Using overload is a safe way but we need to add overloads to operators which take 2 durations such as Timer Buffer and Window but we need to add overloads to operators which take 2 durations such as Timer Buffer and Window Yes I mentioned that earlier Only because we have been trying to eliminate overloads An overload of this one feels like it means we can t decide In that case my preference is clear @akarnokd Should we merge this change and adopt the new signature or stick with the Java ScheduledExecutorService signature The other schedule methods don t match it so it s not a strong reason to stay matching @abersnaze I believe you are in favor of merging this change correct My preference would be to stick with the Java convention Ideal thing would be to have a single object encapsulating the delay unit and time but that is not an option currently Isn t there a scala wrapper anymore where this could be shifted over I would support the new split syntax only if the current overload is kept with deprecated annotation until the time of the major purge Isn t there a scala wrapper anymore where this could be shifted over Yes the Scala wrapper already does it this way I m closing this out the reasoning for doing it is not strong enough as languages like Scala can already deal with it whereas in Java the way it is currently is idiomatic',RxJava,true,false,false
27400595,'Change Lift to use rx Observable Operator','The generics insanity has to stop This pull request is a result of @abersnaze and I continuing to fail to make generics work with this signature java Func1 Subscriber super R Subscriber super T It all fell apart while trying to do things that needed the equivalent of java Func1 Subscriber super R Subscriber super super T and other such variants With this change I can also finally get the OperatorMerge generics to work Thus the Operator type exists inside Observable just like OnSubscribe like this java Operator function for lifting into an Observable public interface Operator R T extends Func1 Subscriber super R Subscriber super T cover for generics insanity This gives us imports like this java import rx Observable import rx Observable OnSubscribe import rx Observable Operator I know it s not as pure as having lift Func1 but this is far more usable java public R Observable R lift final Operator R T bind If anyone has a different suggestion that still solves the generics issue please let me know','If you doubt the insanity here s an error message for the merge operator The method lift Func1 Subscriber super R Subscriber super capture#210 of extends Observable extends T in the type Observable capture#210 of extends Observable extends T is not applicable for the arguments OperatorMerge T Apparently only the IDE likes merge now curse generics Users bechristensen development github RxJavaFork rxjava core src main java rx Observable java 1780 error method lift in class Observable T#1 cannot be applied to given types return source lift new OperatorMerge T required Operator R CAP#1 found OperatorMerge T#2 reason no instance s of type variable s R exist so that argument type OperatorMerge T#2 conforms to formal parameter type Operator R CAP#1 where R T#1 T#2 are type variables R extends Object declared in method R lift Operator R T#1 T#1 extends Object declared in class Observable T#2 extends Object declared in method T#2 merge Observable extends Observable extends T#2 where CAP#1 is a fresh type variable CAP#1 extends Observable extends T#2 from capture of extends Observable extends T#2 RxJava pull requests #782 https netflixoss ci cloudbees com job RxJava pull requests 782 SUCCESS This pull request looks good After fixing generics it actually would be java public R Observable R lift final Func1 extends Subscriber super R super Subscriber super T bind Using the Operator type it is instead java public R Observable R lift final Operator extends R super T bind as the type gives cover for java public interface Operator R T extends Func1 Subscriber super R Subscriber super T',RxJava,true,false,false
27404113,'Generics Help Please','Generics have me stumped on the merge operator The functionality is fine but only if I leave it untyped All other operators I m using lift with are okay but I can t get this one java this doesn t compile public final static T Observable T merge Observable extends Observable extends T source return source lift new OperatorMerge T this compiles with untyped warnings no generic and functions public final static T Observable T merge Observable extends Observable extends T source return source lift new OperatorMerge this compiles but is only merging itself so not very helpful public Observable T mergeSelf return from this lift new OperatorMerge T this doesn t compile public Observable T mergeSelfWithAnother Observable extends T other return from this other lift new OperatorMerge T Here is the compilation error Users bechristensen development github RxJavaFork rxjava core src main java rx Observable java 1780 error method lift in class Observable T#1 cannot be applied to given types return source lift new OperatorMerge T required Operator R CAP#1 found OperatorMerge T#2 reason no instance s of type variable s R exist so that argument type OperatorMerge T#2 conforms to formal parameter type Operator R CAP#1 where R T#1 T#2 are type variables R extends Object declared in method R lift Operator R T#1 T#1 extends Object declared in class Observable T#2 extends Object declared in method T#2 merge Observable extends Observable extends T#2 where CAP#1 is a fresh type variable CAP#1 extends Observable extends T#2 from capture of extends Observable extends T#2','Thank you to @abersnaze for fixing the generics',RxJava,false,false,false
27407729,'Add Fragment Host to rxjava contrib debug module for OSGi','see #849','RxJava pull requests #783 https netflixoss ci cloudbees com job RxJava pull requests 783 SUCCESS This pull request looks good',RxJava,true,false,false
27421975,'Fixing the generics for merge and lift','I ve tracked down to two problems #858 The first is that lift wasn t quite right I changed the lift argument from Operator R T to Operator extends R super T Unfortunately Java won t let us hide that away in the Operator class so we have to redeclare that everywhere in the debug hooks but it s still better than the alternative of having to use the full Func1 extends Subscriber super R super Subscriber super T everywhere The second problem was in the return type of merge Observable T Because of operators like merge Observable extends T t1 Observable extends T t2 the only thing that can be said for the return type is that it is also Observable extends T but at the moment it is returning Observable T This pull request changes all of them and leads to some silly return values like Observable String a b Observable extends String x merge a b','RxJava pull requests #784 https netflixoss ci cloudbees com job RxJava pull requests 784 FAILURE Looks like there s a problem with this pull request We should avoid return types such as A extends B RxJava pull requests #787 https netflixoss ci cloudbees com job RxJava pull requests 787 FAILURE Looks like there s a problem with this pull request RxJava pull requests #788 https netflixoss ci cloudbees com job RxJava pull requests 788 SUCCESS This pull request looks good @akarnokd you were right the return type change wasn t necessary I ve reverted and rebased the branch to clean out all the mistakes RxJava pull requests #789 https netflixoss ci cloudbees com job RxJava pull requests 789 SUCCESS This pull request looks good I almost did a PR on this when I saw you now did the same thing as I But was it necessary to change the debugs as well Yes There is a plugin hook inside lift that the debug plugin implements and spreads from there',RxJava,true,false,false
27423250,'Proposed solution to the time gap using unbounded buffering','This is a solution to the time gap problem for #844 Currently it uses an unbounded buffer I ll think about a bounded approach later on I ve added an subscribeOn overload where the user can explicitly request a buffering behavior In addition SubscribeOn checks the type of the Observable and enters buffering mode for GroupedObservable and PublishSubject I think these code options should be mutually exclusive 1 either we only check for Observable type but then new kinds of observables or hidden observables won t work 2 or ask the programmer in the documentation tutorial to explicitly request buffering in certain operator compositions I personally favor option 2','RxJava pull requests #785 https netflixoss ci cloudbees com job RxJava pull requests 785 SUCCESS This pull request looks good',RxJava,true,false,false
27427822,'Update the timeout docs','Updated the timeout docs','RxJava pull requests #790 https netflixoss ci cloudbees com job RxJava pull requests 790 SUCCESS This pull request looks good',RxJava,true,false,false
27431017,'Optimize SwingMouseEventSource fromRelativeMouseMotion','do it more functional way see the trick here http www introtorx com Content v1 0 10621 0 12_CombiningSequences html#Zip','RxJava pull requests #791 https netflixoss ci cloudbees com job RxJava pull requests 791 SUCCESS This pull request looks good',RxJava,true,false,false
27432703,'Blocking buffer until experiment','This is a solution to the time gap problem for #844 I ve added an subscribeOn overload where the user can explicitly request a buffering behavior In addition SubscribeOn checks the type of the Observable and enters buffering mode for GroupedObservable and PublishSubject I think these code options should be mutually exclusive 1 either we only check for Observable type but then new kinds of observables or hidden observables won t work 2 or ask the programmer in the documentation tutorial to explicitly request buffering in certain operator compositions I personally favor option 2','RxJava pull requests #792 https netflixoss ci cloudbees com job RxJava pull requests 792 FAILURE Looks like there s a problem with this pull request RxJava pull requests #793 https netflixoss ci cloudbees com job RxJava pull requests 793 SUCCESS This pull request looks good Test testRepeatTakeWithSubscribeOn passed locally I guess there is a race issue with repeat as it schedules a new repeat after take unsubscribes I guess adding a child isUnsubscribed test before L85 should do the trick Reviewing code considering the drawbacks what do you think is worse possibility of deterministic deadlock with this solution or possibility of non deterministic data loss when using subscribeOn on hot Observables Is the deadlock deterministic it would always happen in dev so it gets found or could it happen if a Scheduler becomes saturated or the buffer size is higher than available threads Non deterministic data loss is definitely worse Deadlock due to the computation scheduler being single threaded is worrying but might affect other concurrent operators as well regardless I think the documentation could mention that if pushback or blocking behavior is expected one should use NewThread or IO scheduler for the unblocking operation Non deterministic data loss is definitely worse I agree so let s continue down this path I ll review through your code in a bit First pass through reading this code it seems good and mature enough to handle the different scenarios we could throw against it I m going to spend some more time playing but nothing right now suggests that this should not be the path we take I added some things on top of this at https github com Netflix RxJava pull 869 Work on this is picked up in https github com Netflix RxJava pull 869',RxJava,true,false,false
27467572,'ReplaySubject Time and Capacity','The various replay overloads ended up getting implemented in a private Subject implementation inside OperationReplay https github com Netflix RxJava blob master rxjava core src main java rx operators OperationReplay java source c#L699 This functionality needs to live on ReplaySubject itself This was brought up with some of the functionality added in https github com Netflix RxJava pull 753 Issues related to this are https github com Netflix RxJava issues 71 Operator Replay https github com Netflix RxJava pull 612 Pull Request Replay additional overloads','Hi guys I ll begin working on this Does it need to solve issue #658 as well Yes it does thanks for reminding me of that one This item is open to be worked on as @katzseth22202 has been pulled away to something else This is being done as part of https github com Netflix RxJava pull 1211 Merged in https github com Netflix RxJava pull 1223',RxJava,false,false,false
27471372,'Update OperationScan to OperatorScan','Migrate to use updated conventions of Operator classes that implement rx Observable Operator','',RxJava,true,false,false
27482049,'Zip Back pressure','Currently the zip operator has an unbounded queue for each Observable it is combining together This makes it async and susceptible to buffer bloat when fast producer slow consumer issues occur but even worse with zip it can occur when it has fast producer slow producer Consider you can have n producers all it takes is one producer to cause all the rest to buffer Similar to recent changes to observeOn https github com Netflix RxJava pull 835 we want zip to default to blocking onNext non blocking on the outside blocking on the inside so that each Observable can only onNext when the previous onNext was consumed Overloads should exist to allow buffering if desired The goal is for normal use of Rx to provide natural back pressure that only gets lost when consciously choosing to do so or using explicit operators that do queueing such as buffer and window On the current zip implementation making the internal queues block at size 1 will not work as it deadlocks anytime 2 synchronous Observable s are zipped together common An alternative approach is to start treating zip as an operator that requires concurrency to behave correctly similar to window buffer interval With concurrency it can subscribe to each Observable and block them as needed The problem with this is that it could result in many blocking threads This could potentially be reduced by conditionally removing the concurrency if it is seen that the Observable is already running on another thread The other problem is likely performance impact Yet another proposal unknown if it would work is a scheme that would require changes to Subscriber highly unwanted to allow pausing resuming of Observable s that zip could control It may not be possible to achieve the goal of zip with back pressure with reasonable trade offs but we d like to pursue it','Closing as this is encompassed by #1000',RxJava,false,false,false
27492380,'Zip Bug UnitTest Never Completes When Zero Observables','Hey guys I discovered this issue today in Rx I m not sure if it s a bug or as designed I ve added the test Can you let me know if it is in fact a bug then I ll correct the issue','RxJava pull requests #795 https netflixoss ci cloudbees com job RxJava pull requests 795 FAILURE Looks like there s a problem with this pull request That failure is expected my test currently fails to prove the issue RxJava pull requests #796 https netflixoss ci cloudbees com job RxJava pull requests 796 FAILURE Looks like there s a problem with this pull request Yup that s a bug The OperatorZip code assumes it will always receive Observables to zip The line in question is here https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorZip java source c#L110 See #917 for PR I had to move this fix on master to it s own branch so I can continue to track the main master #917 Supersedes this PR RxJava pull requests #855 https netflixoss ci cloudbees com job RxJava pull requests 855 SUCCESS This pull request looks good',RxJava,true,false,false
27495258,'subscribeOn groupBy','Some changes on top of https github com Netflix RxJava pull 864 as part of work on https github com Netflix RxJava issues 844 Primarily I did two things here get unsubscribe working again via subscribeOn for synchronous Observable s leverage new subscribeOn behavior to make the groupBy unit tests work','@akarnokd Thanks for the excellent work in #864 Even though this doesn t solve it for all cases it at least gives us the ability to solve the time gap problem in specific uses Any reason not to proceed with merging this into the codebase @zsxwing Can you take a look at this unit test I m not sure if it s a legit problem or not When timeout happens it calls unsubscribe which can result in the work being interrupted This in turn causes it to not pass this test but the test may just need to account for work possibly being interrupted when a timeout occurs I d appreciate your review rx operators OperatorTimeoutWithSelectorTest testTimeoutSelectorWithTimeoutAndOnNextRaceCondition FAILED org mockito exceptions verification VerificationInOrderFailure at OperatorTimeoutWithSelectorTest java 421 See changes I did here to not block but it sometimes still fails https github com benjchristensen RxJava commit 54b19be072be8b25393c80faee61eed4d18da06e#diff 381ec8d12950bcd8ddf7e4751875d74fR349 @benjchristensen Where is the InterruptedException from When I was writing this test I assume that there is no InterruptedException So I don t handle the InterruptedException RxJava pull requests #803 https netflixoss ci cloudbees com job RxJava pull requests 803 ABORTED It s from the line https github com benjchristensen RxJava commit 43437fe931ac131085eb29eaa08d9e9a8b37ac7b#diff a726afb863d72e4bd1938fcc01f443b3R101 The scheduler is unsubscribed which will cancel a future when bread based that interrupts the thread I don t know what is causing the tests to abort Other than this timeout one being discussed all others pass on my machine The following codes which try to dispatch the unsubscribe to the scheduler have been removed https github com benjchristensen RxJava commit a394a7d8e91a4adc05642a2d54b5b2f97402be28#diff a726afb863d72e4bd1938fcc01f443b3L106 I m curious why I sent a PR to fix this test https github com benjchristensen RxJava pull 7 The following codes which try to dispatch the unsubscribe Because no one can give me a good reason for why the unsubscribe should be scheduled on the scheduler rather than execute directly The unsubscribe is coming from the opposite direction and scheduling doesn t work going backwards For example someone could write code like this not necessarily for good reason 1 Observable create emits on Thread RxNewThreadScheduler 1 5 main receives unsubscribe from Thread RxNewThreadScheduler 2 5 main 2 map Thread RxNewThreadScheduler 1 5 main 3 subscribeOn newThread A 4 observeOn newThread B 5 take unsubscribes on Thread RxNewThreadScheduler 2 5 main 6 flatMap Thread RxNewThreadScheduler 2 5 main 7 subscribe receives on Thread RxNewThreadScheduler 2 5 main Note how the unsubscribe is received on a different thread than is used to emit data We can t schedule back on to that other thread because scheduling goes down not up Thus I see no point in scheduling an unsubscribe on the thread going down when the event is being passed up and there could be any number of subscribeOn or observeOn in a sequence Considering this why should we schedule the unsubscribe on the thread meant for emitting onNext onError and onCompleted java public static void main String args TestSubscriber String ts new TestSubscriber String new Observer String @Override public void onCompleted System out println OnCompleted @Override public void onError Throwable e e printStackTrace @Override public void onNext String t System out println Received t on thread Thread currentThread Observable create new OnSubscribe Integer @Override public void call Subscriber super Integer s System out println OnSubscribed on thread Thread currentThread s add Subscriptions create new Action0 @Override public void call System out println Unsubscribe received on thread Thread currentThread for int i 0 s isUnsubscribed i s onNext i map new Func1 Integer String @Override public String call Integer i System out println Map function on thread Thread currentThread return value i subscribeOn Schedulers newThread observeOn Schedulers newThread take 10 flatMap new Func1 String Observable String @Override public Observable String call String s System out println FlatMap function on thread Thread currentThread return Observable from network result s subscribe ts ts awaitTerminalEvent Output is OnSubscribed on thread Thread RxNewThreadScheduler 1 5 main Map function on thread Thread RxNewThreadScheduler 1 5 main Map function on thread Thread RxNewThreadScheduler 1 5 main Map function on thread Thread RxNewThreadScheduler 1 5 main FlatMap function on thread Thread RxNewThreadScheduler 2 5 main Received network result value 0 on thread Thread RxNewThreadScheduler 2 5 main Map function on thread Thread RxNewThreadScheduler 1 5 main FlatMap function on thread Thread RxNewThreadScheduler 2 5 main Received network result value 1 on thread Thread RxNewThreadScheduler 2 5 main FlatMap function on thread Thread RxNewThreadScheduler 2 5 main Map function on thread Thread RxNewThreadScheduler 1 5 main Received network result value 2 on thread Thread RxNewThreadScheduler 2 5 main FlatMap function on thread Thread RxNewThreadScheduler 2 5 main Map function on thread Thread RxNewThreadScheduler 1 5 main Received network result value 3 on thread Thread RxNewThreadScheduler 2 5 main FlatMap function on thread Thread RxNewThreadScheduler 2 5 main Map function on thread Thread RxNewThreadScheduler 1 5 main Received network result value 4 on thread Thread RxNewThreadScheduler 2 5 main FlatMap function on thread Thread RxNewThreadScheduler 2 5 main Map function on thread Thread RxNewThreadScheduler 1 5 main Received network result value 5 on thread Thread RxNewThreadScheduler 2 5 main FlatMap function on thread Thread RxNewThreadScheduler 2 5 main Map function on thread Thread RxNewThreadScheduler 1 5 main Received network result value 6 on thread Thread RxNewThreadScheduler 2 5 main FlatMap function on thread Thread RxNewThreadScheduler 2 5 main Map function on thread Thread RxNewThreadScheduler 1 5 main Received network result value 7 on thread Thread RxNewThreadScheduler 2 5 main FlatMap function on thread Thread RxNewThreadScheduler 2 5 main Map function on thread Thread RxNewThreadScheduler 1 5 main Received network result value 8 on thread Thread RxNewThreadScheduler 2 5 main FlatMap function on thread Thread RxNewThreadScheduler 2 5 main Map function on thread Thread RxNewThreadScheduler 1 5 main Received network result value 9 on thread Thread RxNewThreadScheduler 2 5 main OnCompleted Unsubscribe received on thread Thread RxNewThreadScheduler 2 5 main I actually wonder if the issue is more related to observeOn I thought about this This might be an artifact of the NET s threads pools etc The closest example I could come up was the Swing scheduler where subscription should happen on the EDT and unsubscription as well but Swing s addlistener removelistener methods are generally thread safe Here is an example without subscribeOn or observeOn and I m curious how it should behave java public static void main String args TestSubscriber Integer ts new TestSubscriber Integer new Observer Integer @Override public void onCompleted System out println OnCompleted @Override public void onError Throwable e e printStackTrace @Override public void onNext Integer t System out println Received t on thread Thread currentThread Subscription s Observable create new OnSubscribe Integer @Override public void call final Subscriber super Integer s Schedulers newThread schedule new Action1 Inner @Override public void call Inner t1 System out println OnSubscribed on thread Thread currentThread s add Subscriptions create new Action0 @Override public void call System out println Unsubscribe received on thread Thread currentThread for int i 0 s isUnsubscribed i s onNext i subscribe ts s unsubscribe ts awaitTerminalEvent It receives the unsubscribe from the main thread OnSubscribed on thread Thread RxNewThreadScheduler 1 5 main Unsubscribe received on thread Thread main 5 main Received 0 on thread Thread RxNewThreadScheduler 1 5 main If someone is using the Rx provided Subscribers then everything is thread safe If they are implementing their own and modifying a mutable variable when they receive the unsubscribe then it could be an issue RxJava pull requests #805 https netflixoss ci cloudbees com job RxJava pull requests 805 SUCCESS This pull request looks good It does come from NET and binding events You must do button clickHandler and button clickHandler on the UI thread or things will blow up I guess that might be true in Swing JavaFx as well The only reason NET Rx has subscribeOn is to ensure that subscribe and unsubscribe happen on the specified scheduler From the codes of javax swing event EventListenerList which is used by Swing components here http www grepcode com file repository grepcode com java root jdk openjdk 7u40 b43 javax swing event EventListenerList java only add and remove are protected by synchronized I feel there may be some concurrent issues if calling add and remove out of EDT According to the doc here http docs oracle com javase tutorial uiswing concurrency dispatch html Swing event handling code runs on a special thread known as the event dispatch thread Most code that invokes Swing methods also runs on this thread This is necessary because most Swing object methods are not thread safe invoking them from multiple threads risks thread interference or memory consistency errors Some Swing component methods are labelled thread safe in the API specification these can be safely invoked from any thread All other Swing component methods must be invoked from the event dispatch thread Programs that ignore this rule may function correctly most of the time but are subject to unpredictable errors that are difficult to reproduce and the Swing s Threading Policy here http docs oracle com javase 7 docs api javax swing package summary html In general Swing is not thread safe All Swing components and related classes unless otherwise documented must be accessed on the event dispatching thread I think addXXXlistener removeXXXlistener is not thread safe out of the EDT I think addXXXlistener removeXXXlistener is not thread safe out of the EDT Same in NET See https github com Netflix RxJava pull 890 for work done with @headinthebox that resulted in simplification of subscribeOn and a new operator unsubscribeOn',RxJava,true,false,false
27516687,'Add the selector variants of timeout in RxScala','This PR added the selector variants of the timeout operator in the Scala and also added two examples','RxJava pull requests #798 https netflixoss ci cloudbees com job RxJava pull requests 798 SUCCESS This pull request looks good',RxJava,true,false,false
27522419,'Blocking zip operator','Proposed solution to #867 Added overloads to zip many and zip 2 only If my approach is favorable other overloads can be added Javadoc might need some rephrasing Contains fix for #868 but no test Overloads take a bufferSize 0 indicating the queue size bufferSize 0 behaves as the original zip Due to the internals of zip a bufferSize of 0 does not work i e everyone blocks on add and noone can call tick For that zip would need different internals with CyclicBarrier and other magic Should I work on this case as well Source completion is blocking as well right now for example an empty producer with a slow partner will complete only if the slow partner fires its first event Should it terminate as soon as possible Update Added 0 length buffering mode bufferSize 0 now indicates unlimited buffering Changed buffered mode to finish as soon as possible','RxJava pull requests #799 https netflixoss ci cloudbees com job RxJava pull requests 799 SUCCESS This pull request looks good Source completion is blocking as well right now for example an empty producer with a slow partner will complete only if the slow partner fires its first event Should it terminate as soon as possible Definitively empty T zip never S s t s t empty S T Thought so started working on the question points anyway Hey guys IMHO throwing an IllegalArgumentException when Observable zip empty zip is invoked seems like a valid solution to me I m not sure that zip should allow zipping nothing By definition there s nothing to observe I just think it should validate input I only discovered this problem due to a bug in our code RxJava pull requests #800 https netflixoss ci cloudbees com job RxJava pull requests 800 FAILURE Looks like there s a problem with this pull request signArchives failure again Let s try again RxJava pull requests #801 https netflixoss ci cloudbees com job RxJava pull requests 801 SUCCESS This pull request looks good I am not sure where the main discussion is happening so I am placing this response here I looked at this because I am experimenting with rxcpp improvements and have been applying some of the choices made in RxJava I was interested to see how this would map to C as well My understanding is that that pause is called from onnext when the queue is filled to bufferSize pause will block the stack that called onnext until resume is called I saw some discussion about using SubscribeOn to prevent deadlocks I was doing thought experiments of my own and wondered how that would be applied to Hot Observables It seems like many Hot Observables have stacks rooted in threads that are dedicated to that source UI thread Sensor thread IO thread and that blocking those threads have consequences for the system A UI thread would hang the app when blocked momentarily or deadlock if two UI events are being zipped A Sensor thread might drop or queue readings for all the sensors being monitored or deadlock if two sensors readings are being zipped Using SubscribeOn will not fix this and using ObserveOn only moves the infinite queue from zip to ObserveOn I would suggest that a Hot Observable needs to be unsubscribed when the buffer is full This sounds like ConnectableObservable is the surface that supports backpressure for HotObservables I futher think that ColdObservables can be implemented using ConnectableObservable as well speculation I also think that the buffering method and depth and the backpressure algorithm should be unique to each source Observable Thus I am wondering if back pressure can instead be implemented as overloads of a BackPressure operator that returns a ConnectableObservable and then all the operators that combine multiple observables have backpressure capable overloads that take only ConnectableObservable Zip from N ConnectableObservables will have a fixed buffer depth of for example 1 and would thus start by calling Connect on each source then unsubscribe the connect in the first onnext call from each source When the onnext call is received from the last source the output onnext is called and then Connect is called on each source etc two examples of potential backpressure operators A BlockingBackPressure operator would take Cold observables It would block the source when it is disconnected and would take the Scheduler to use in SubscribeOn No buffer needed A LossyBackPressure operator would take hot observables and unsubscribe when the buffer is full and re subscribe when the buffer has room Critiques and explanations welcome Thanks Kirk I would suggest that a Hot Observable needs to be unsubscribed when the buffer is full This sounds like ConnectableObservable is the surface that supports backpressure for HotObservables I futher think that ColdObservables can be implemented using ConnectableObservable as well This doesn t work If you unsubscribe from range then resubscribe later range starts over again If you unsubscribe from PublishSubject you lose events Ben reported about a new approach in #802 but no details Of course but some implementations of ConnectableObservable can block while others do not You might not have read my whole comment near the end you will find two examples of potential backpressure operators A BlockingBackPressure operator would take Cold observables It would block the source when it is disconnected and would take the Scheduler to use in SubscribeOn No buffer needed A LossyBackPressure operator would take hot observables and unsubscribe when the buffer is full and re subscribe when the buffer has room This seems like as good as any other place to try out the proposal Here are the basics Add three methods to Subscription void pause boolean isPaused and void resumeWith Action0 onResume Pause isPause behave the same as unsubscribe isUnsubscribe but non destructive not reading vs closing the socket When the source first detects that a Subscriber isPaused it is obliged to call resumeWith Action0 with a function that closed over the current state of the stream and then return from the OnSubscribe function as soon as possible The action passed should resume calling of onNext onComplete onError does not get paused I have an experimentally pause branch on my fork with an implementation of zip with an internal buffer size of 1 that can apply back pressure I ve also implemented a few new operators on Observable to allow users to enforce the desired pause behavior on a stream called whilePausedBlock whilePausedDrop whilePausedBuffer and whilePausedUnsubscribe All of this will be coming in a day or two once cherry pick the changes from the prototype Cool can t wait to see the code I like the four operators they make sense I feel like one operation is missing from subscriber How does Zip resume the subscribers Additionally one of the ways in which pause isPaused are not like unsubscribe isUnsubscribed is that pause will flip back and forth over time while unsubscribe is one shot This seems to introduce a few additional conditions that would need to be addressed I am interested in the full semantics of a paused Subscriber What happens when resumeWith is called twice during the same pause What happens when pause is called while paused What is the policy for multithread access to pause resumeWith and resume This appears to force backpressure support in every source This has tradeoffs between adoption and uniformity Is there some pattern here that would allow opt in Thanks Kirk Zip resumes the inner subscribers internally when other subscriber has caught up by clearing the internal state that makes isPaused return true and then it invokes the actions passed in to resumeWith while it was paused All actions passed in resumeWith are invoked when the subscriber is ready for more data The second pause is treated the same as a second unsubscribe probably ignored Also actions passed in to resumeWith while not paused are immediately invoked There is a lot of logic in the CompositeSubscription for handling all of this These changes makes implementing Subscription directly very tricky I m inclined to try and make Subscription a final class and not an interface That makes me wonder if there isn t something to the relationship between Subject Observer Observable and Subscriber Observer Subscription I like the idea that Subscriber is a concrete type like Subject and is a composition of Observer and Subscription Thanks for the explanation However given those properties why would pause be on the interface Zip has to use private access to the Subscriber in order to resume why not pause Is there any case where a pause would be invoked outside Zip I am also thinking that it would be a good idea to pass the scheduler that should be used to schedule the action to resumeWith The Action supplied could have a call to schedule but I think it is important to be explicit it allows the scheduler to be known and optionally overridden Going with the Subject Subscriber theme perhaps resumeWith actually takes a Resumer that is a Scheduler and Action Resumer may be a functor or have a named resume function that schedules the action Add three methods to Subscription void pause boolean isPaused and void resumeWith Action0 onResume @abersnaze I m curious that how do you handle resumeWith with subscribeOn Look forward to your PR After experimenting with these approaches on observeOn subscribeOn and zip we can t pursue this route Any form of blocking becomes a liability in systems using event loops and breaks the mental model of what people expect from Rx For example even merge as currently implemented and following the Rx Net pattern is a problem since it synchronizes multiple streams into one This means it can block threads which can be event loops I ll post another issue soon to pull the conversation together After experimenting with these approaches on observeOn subscribeOn and zip we can t pursue this route Any form of blocking becomes a liability in systems using event loops and breaks the mental model of what people expect from Rx For example even merge as currently implemented and following the Rx Net pattern is a problem since it synchronizes multiple streams into one This means it can block threads which can be event loops I ll post another issue soon to pull the conversation together',RxJava,true,false,false
27538441,'SynchronizedObserverTest testMultiThreadedWithNPEinMiddle fails','If I run just the test file it succeeds If I run a complete build it fails due to receiving 9 onNext calls most of the time Shouldn t SynchronizedObserver also ensure event semantics as well as synchronization Tested on i7 4770K @ 3 5GHz 4 8 cores','It s a good safety net to keep but it shouldn t do any of the error handling or unsubscribe logic of SafeSubscriber Thanks for pointing it out',RxJava,false,false,false
27560396,'BehaviorSubject doesn t emit onNext','I made simple test that is here https gist github com novemberox 8985583 it s output is Service onSubscribe Next 0 Obs 0 next 0 Obs 1 next 0 Service onSubscribe Obs 2 next 0 Next 1 Obs 3 next 0 Obs 0 next 1 Obs 1 next 1 Obs 2 next 1 It s using threading so sometimes it s correct The issue with that result is that I m emitting onNext to BehaviorSubject but i ts not propagated to Obs 3 What I m doing in this test I make two Observables and subscribe to them that subscription should give me 0 After one second I tell that result has changed and I make another two Observables and subscribe to them Now I expect that all four Observer will receive 1 value I want to achieve singe call to service should return the same result until it s invalidated I was trying to find way to avoid multiply call to service In my application I call many times service for same data and then I map it to different data depending on what is important at that screen Maybe there is better way to merge multiple method calls into one','It is possible your Thread sleep 1000 is sometimes not enough the let the last onNext propagate It works for me with 0 17 dev I was using 0 16 1 I made that sleep longer but it doesn t change anything Now I just downloaded 0 17 from here https netflixoss ci cloudbees com job RxJava master ws rxjava core build libs and it s still failing but quite rely 1 of 15 times It might vary on machine used for that test In one of runs I ve got Service onSubscribe Next 0 Obs 0 next 0 Obs 1 next 0 Service onSubscribe Obs 2 next 0 Next 1 Obs 0 next 1 Obs 3 next 1 Obs 1 next 1 Obs 2 next 1 so Obs 3 didn t get 0 value It s probably very good it would mind that that Subject propagated fresh result After running your code in a loop 100 times I see the output you listed Due to subscribeOn there is a race between the new source of value 1 and the subscription to the subject by dump 3 Sometimes subject subscription happens before the new value 1 is emitted therefore dump 3 sees only the value 0 However this case should still see value 1 but we have a lost event bug with subjects Issue #658 during dump 3 s subscription the last value is emitted the source produces value 1 concurrenty but since dump 3 is not in the internal list of registered observers at the time value is only delivered to the first 2 3 only If you put a sleep after longiesChanger the race is resolved and dump 3 sees value 1 I changed BehaviorSubject to ReplaySubject and after few runs I ve got Service onSubscribe Next 0 Obs 0 next 0 Obs 1 next 0 Service onSubscribe Obs 2 next 0 Next 1 Obs 0 next 1 Obs 3 next 0 Obs 1 next 1 Obs 3 next 1 Obs 2 value is missing So maybe it is an issue with SubjectSubscriptionManager I ve edited gist with simple asserts https gist github com novemberox 8985583 now it runs 100 times using ReplaySubject It fails about 20 times We have recently resolved a few SubjectSubscriptionManager issues which affected ReplaySubject Does it work for you now It seems to be working',RxJava,false,false,false
27589618,'Update CompositeSubscriptionTest java','Fix apparent typo unsubscription of s2 was not checked and should have been','RxJava pull requests #804 https netflixoss ci cloudbees com job RxJava pull requests 804 SUCCESS This pull request looks good Thanks for the fix I won t even ask what had you looking that detailed at the test code No worries I was looking at the interaction of CompositeSubscription and OperatorRetry in 0 16 1 for an issue I was having and was perusing the CompositeSubscriptionTest looking at unsubscribe behaviour I see that you ve changed RetryOperator significantly in master so I ll retest my issue with master next week and raise a github issue with a failing unit test if I still have a problem I suspect Schedulers trampoline will have me sorted Thanks for the great library',RxJava,true,false,false
27616440,'Bounded replay subject proposal','Proposal for #865 Not really for merging Subscription and unsubscription is serialized with the regular events so this implementation should solve #658 as well A property of this implementation due to queue drain approach is that a new subscriber s thread might steal the processing loop To mitigate this scheduler overloads are provided to capture the processing loop Unfortunately the performance is 2 3 times worse in unbounded mode compared against current ReplaySubject implementation when run with a simple 1M onNext calls The replay after completion is about 10 slower I would guess the enqueue dequeue operation adds quite a substantial overhead','RxJava pull requests #806 https netflixoss ci cloudbees com job RxJava pull requests 806 SUCCESS This pull request looks good Closing out We can t block threads thus to achieve bounding we need a continuation async await style solution An experiment to that end is happening at https github com benjchristensen RxBackpressure if you re interested in getting involved',RxJava,true,false,false
27621566,'Manual Merge of #750','Manual merge of https github com Netflix RxJava pull 751','RxJava pull requests #808 https netflixoss ci cloudbees com job RxJava pull requests 808 SUCCESS This pull request looks good',RxJava,true,false,false
27622357,'Correct synchronization guard in groupByUntil','Can t see how synchronized key could have been correct here key will hardly ever be the same instance for different invocations of keySelector and the comment on line 73 clearly states gate to be the guard for map','Nice catch RxJava pull requests #809 https netflixoss ci cloudbees com job RxJava pull requests 809 SUCCESS This pull request looks good',RxJava,true,false,false
27623503,'Scheduler scheduleRecursive','Make recursive scheduling a first class citizen without needing to refer to this which doesn t work inside lambdas Java8 Scala etc java Schedulers newThread scheduleRecursive new Action1 Recurse @Override public void call Recurse r System out println do stuff on thread Thread currentThread Time System nanoTime r schedule 100 TimeUnit MILLISECONDS','RxJava pull requests #810 https netflixoss ci cloudbees com job RxJava pull requests 810 SUCCESS This pull request looks good',RxJava,true,false,false
27640561,'Cannot subscribe to a Retry observable once all subscribers unsubscribed','For version 0 16 1 and master of rx java core Once all subscribers have unsubscribed from a retry observable it is not possible to subscribe again to it Unit test below that would belong in OperatorRetryTest java if its valid The same test once changed slightly to conform to code in master fails also but earlier Code for both 0 16 1 and master is below version 0 16 1 java @Test public void testRetryAllowsSubscriptionAfterAllSubscriptionsUnsubsribed final AtomicInteger subsCount new AtomicInteger 0 OnSubscribeFunc String onSubscribe new OnSubscribeFunc String @Override public Subscription onSubscribe Observer super String observer subsCount incrementAndGet return new Subscription @Override public void unsubscribe subsCount decrementAndGet Observable String stream Observable create onSubscribe Observable String streamWithRetry stream retry Subscription sub streamWithRetry subscribe assertEquals 1 subsCount get sub unsubscribe assertEquals 0 subsCount get streamWithRetry subscribe assertEquals 1 subsCount get version master java @Test public void testRetryAllowsSubscriptionAfterAllSubscriptionsUnsubsribed throws InterruptedException final AtomicInteger subsCount new AtomicInteger 0 OnSubscribeFunc String onSubscribe new OnSubscribeFunc String @Override public Subscription onSubscribe Observer super String observer subsCount incrementAndGet return new Subscription boolean unsubscribed false @Override public void unsubscribe subsCount decrementAndGet unsubscribed true @Override public boolean isUnsubscribed return unsubscribed Observable String stream Observable create onSubscribe Observable String streamWithRetry stream retry Subscription sub streamWithRetry subscribe assertEquals 1 subsCount get sub unsubscribe assertEquals 0 subsCount get streamWithRetry subscribe assertEquals 1 subsCount get','An issue is in OperationRetry L60 where the attempts is not per observer but per source But I m not sure if this is the root cause I believe that in the 0 16 1 code base the issue is with the use of a Composite subscription that in a certain case calls unsubscribe when you try to add another sub to it The code in master is a rework of operation retry and handles things with schedulers trampoline Fixed in master branch Unit test merged to demonstrate https github com Netflix RxJava pull 960',RxJava,false,false,false
27650213,'Force ViewObservable be subscribed and unsubscribed in the UI thread','According to #869 unsubscribe can run in any thread However that will cause some concurrent issues in rxjava android This PR schedules the unsubscribe action to run in the UI thread to solve the problem','RxJava pull requests #811 https netflixoss ci cloudbees com job RxJava pull requests 811 SUCCESS This pull request looks good RxJava pull requests #812 https netflixoss ci cloudbees com job RxJava pull requests 812 SUCCESS This pull request looks good Seems like a good change Do you agree with the assessment in #869 that we can t guarantee a Subscription is called from the correct thread Yes I agree with it Since we can not give the guarantee it s better to require users write a thread safe Subscription Cool then yes I also agree that Subscription implementations need to be thread safe since they don t have the same guarantees as onNext onError and onCompleted @zsxwing Take a look at https github com Netflix RxJava pull 890 to see if it would change anything you did in this pull request I was wondering can we simply make the component refs volatile instead I mean you control the subscription so scheduling on the UI thread just to maintain correctness w r t visibility seems wasteful can we simply make the component refs volatile instead Yes I think this is better and we can remove the assertUiThread for OperationObserveFromAndroidComponent @mttkay I feel uncomfortable that the Observable s from OperationObserveFromAndroidComponent can not be subscribed more than once Any thoughts I had a local branch where I did all the changes but I had to drop it like 2 times due to all the things that happened on master to the core APIs that s why I suggested to hold off with changes to this Looking at master it seems things have stabilized and the release will go out soon My suggestion again is declare all refs that need to be cleared volatile we merely need to ensure visibility when unsubscribing remove the UI thread assertion from the operator and either leave it out altogether or I guess make it a static call in AndroidObservable fromFragment and AndroidObservable fromActivity so that we fail instantly if we re attempting to bind a UI object from a background thread Does that make sense w r t subscribing more than once what would you expect instead I haven t thought about this to be honest e g Observable o AndroidObservable fromFragment s o subscribe s unsubscribe s1 o subscribe not work what doesn t work exactly remove the UI thread assertion from the operator and either leave it out altogether or I guess make it a static call in AndroidObservable fromFragment and AndroidObservable fromActivity so that we fail instantly if we re attempting to bind a UI object from a background thread So the following will fail if it runs in a background thread ViewObservable clicks subscribeOn AndroidSchedulers mainThread subscribe Observable o AndroidObservable fromFragment s o subscribe s unsubscribe componentRef will be set to null s1 o subscribe not work as componentRef is null Another case is Observable o AndroidObservable fromFragment s o subscribe observer1 s1 o subscribe observer2 observer1 will not receive any further message I see what you mean because componentRef is bound at time of construction I agree in general it should behave in the same way as the underlying sequence so if the underlying sequence is re subscribable not all are depending on the subscription I guess we should probably reflect that I m not sure how you would solve that though Any ideas',RxJava,true,false,false
27654221,'Lift Performance','Using f lift directly instead of subscribe improves ops second on the included test from 5 907 721 ops sec to 10 145 486 ops sec','RxJava pull requests #813 https netflixoss ci cloudbees com job RxJava pull requests 813 FAILURE Looks like there s a problem with this pull request @abersnaze What about the debug hooks depends on subscribe vs f call behavior I like it as it reduces the call stack depth and I don t need to step though the hooks and internal implementation checks all the time But isn t this lack of safeguards dangerous I had always intended it to call f call directly as in the prototypes I think it was inadvertent that it became subscribe As for safety we never have wrapped internal operators see https github com Netflix RxJava blob master rxjava core src main java rx Observable java#L7024 so we are not losing safety The only place the SafeSubscriber wrapper should happen is at the end when a user provides an Observer or Subscriber This is actually important we don t do this otherwise any onError onCompleted in the middle of a sequence would invoke unsubscribe and we don t want that Since lift is now public for placing operators in the chain perhaps we want to conditionally wrap them but I tend to think that if someone is adding an operator it should be a considered an unsafe thing and that operators need to comply with the Rx contract If we do choose to wrap it would be a conditional check similar to the link I posted above I don t think it s worth the cost though The code would become this java public R Observable R lift final Operator extends R super T lift return new Observable R new OnSubscribe R @Override public void call Subscriber super R o if isInternalImplementation o o new SafeSubscriber R o f call hook onLift lift call o And the perf drops from 10m ops second to 9m With conditional check Run 10 9 113 444 ops sec Run 11 8 603 038 ops sec Run 12 8 891 892 ops sec Run 13 8 548 031 ops sec Run 14 8 928 571 ops sec Without Run 10 10 167 354 ops sec Run 11 10 169 422 ops sec Run 12 10 065 222 ops sec Run 13 10 705 950 ops sec Run 14 10 996 019 ops sec I personally refer to f as unsafeSubscribe and agree with Ben it should do nothing except chaining lift Only at the end you insert checks If you add an operator you are responsible to make sure it does not mess things up RxJava pull requests #822 https netflixoss ci cloudbees com job RxJava pull requests 822 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
27686903,'rewrite OperationRetry and add unit test to address issue #879','I rewrote the OperationRetry class from first principles if you like Pretty clear to my eyes and doesn t use a single CompositeSubscription method add for the lifetime of the retry which was the cause of bug #879 in the first place Unit tests pass though I ll be glad of some peer review Cheers Dave','RxJava pull requests #814 https netflixoss ci cloudbees com job RxJava pull requests 814 SUCCESS This pull request looks good RxJava pull requests #816 https netflixoss ci cloudbees com job RxJava pull requests 816 SUCCESS This pull request looks good RxJava pull requests #818 https netflixoss ci cloudbees com job RxJava pull requests 818 SUCCESS This pull request looks good Fixed in master https github com Netflix RxJava pull 960 This was fixed as part of https github com Netflix RxJava pull 944 and https github com Netflix RxJava issues 943',RxJava,true,false,false
27692252,'Make Subscriptions of SwingObservable thread safe','Updated rxjava swing according to the discussion in #869 Is it necessary to move the unit tests to src test java folder','RxJava pull requests #815 https netflixoss ci cloudbees com job RxJava pull requests 815 SUCCESS This pull request looks good Does https github com Netflix RxJava pull 890 with the new operator unsubscribeOn change your approach for this at all Also can you rebase it for merge I missed merging it before conflicts happened I prefer my current approach as it can unsubscribe at once if it s in the event dispatch thread RxJava pull requests #826 https netflixoss ci cloudbees com job RxJava pull requests 826 FAILURE Looks like there s a problem with this pull request This failure is because #885 imports a Java 7 api java util Objects RxJava pull requests #830 https netflixoss ci cloudbees com job RxJava pull requests 830 SUCCESS This pull request looks good I prefer my current approach as it can unsubscribe at once if it s in the event dispatch thread Agreed',RxJava,true,false,false
27698638,OperatorRetry,'Rewritten retry operator for 0 17 and changed the per source retry counter to per subscriber retry counter so each subscriber can retry independently','RxJava pull requests #817 https netflixoss ci cloudbees com job RxJava pull requests 817 SUCCESS This pull request looks good OperatorRetry ended up being done in another pull request at some point OperatorRetry ended up being done in another pull request at some point',RxJava,true,false,false
27700486,'Fixed an issue with the from Reader added a bunch of unit tests','fixed a problem @fommil noticed in #840','RxJava pull requests #819 https netflixoss ci cloudbees com job RxJava pull requests 819 FAILURE Looks like there s a problem with this pull request @abersnaze please let me know when this is available as a SNAPSHOT release as I d like to play around with it I ll release 0 17 0 RC2 later today after a few more fixes are merged in',RxJava,true,false,false
27736290,'Internal exception seems to propagate to subscriber in 0 17 0 RC1','I updated c geo the most used geocaching application for Android to RxJava 0 17 0 RC1 in order to test it before the 0 17 0 release It looks like in a call to onCompleted an InterruptedException gets propagated to the subscriber Since the subscriber has no onError handling since the observable never calls onError this exception cannot be delivered I think that it should be caught internally and not propagated shouldn t it E AndroidRuntime 20140 rx util OnErrorNotImplementedException E AndroidRuntime 20140 at rx Observable 24 onError Observable java 6754 E AndroidRuntime 20140 at rx observers SafeSubscriber _onError SafeSubscriber java 120 E AndroidRuntime 20140 at rx observers SafeSubscriber onError SafeSubscriber java 93 E AndroidRuntime 20140 at rx operators OperationObserveFromAndroidComponent OnSubscribeBase 1 onError OperationObserveFromAndroidComponent java 84 E AndroidRuntime 20140 at rx Observable 27 onError Observable java 6961 E AndroidRuntime 20140 at rx observers SafeSubscriber _onError SafeSubscriber java 120 E AndroidRuntime 20140 at rx observers SafeSubscriber onError SafeSubscriber java 93 E AndroidRuntime 20140 at rx operators OperatorObserveOn ObserveOnSubscriber pollQueue OperatorObserveOn java 214 E AndroidRuntime 20140 at rx operators OperatorObserveOn ObserveOnSubscriber access 500 OperatorObserveOn java 112 E AndroidRuntime 20140 at rx operators OperatorObserveOn ObserveOnSubscriber 2 call OperatorObserveOn java 187 E AndroidRuntime 20140 at rx operators OperatorObserveOn ObserveOnSubscriber 2 call OperatorObserveOn java 182 E AndroidRuntime 20140 at rx android schedulers HandlerThreadScheduler InnerHandlerThreadScheduler 2 run HandlerThreadScheduler java 117 E AndroidRuntime 20140 at android os Handler handleCallback Handler java 733 E AndroidRuntime 20140 at android os Handler dispatchMessage Handler java 95 E AndroidRuntime 20140 at android os Looper loop Looper java 136 E AndroidRuntime 20140 at android app ActivityThread main ActivityThread java 5081 E AndroidRuntime 20140 at java lang reflect Method invokeNative Native Method E AndroidRuntime 20140 at java lang reflect Method invoke Method java 515 E AndroidRuntime 20140 at com android internal os ZygoteInit MethodAndArgsCaller run ZygoteInit java 781 E AndroidRuntime 20140 at com android internal os ZygoteInit main ZygoteInit java 597 E AndroidRuntime 20140 at dalvik system NativeStart main Native Method E AndroidRuntime 20140 Caused by java lang InterruptedException E AndroidRuntime 20140 at java util concurrent locks AbstractQueuedSynchronizer acquireSharedInterruptibly AbstractQueuedSynchronizer java 1279 E AndroidRuntime 20140 at java util concurrent Semaphore acquire Semaphore java 283 E AndroidRuntime 20140 at rx operators OperatorObserveOn InterruptibleBlockingQueue addBlocking OperatorObserveOn java 264 E AndroidRuntime 20140 at rx operators OperatorObserveOn ObserveOnSubscriber onCompleted OperatorObserveOn java 147 E AndroidRuntime 20140 at rx operators OperationSwitch SwitchObserver 1 onCompleted OperationSwitch java 134 E AndroidRuntime 20140 at rx Observable 27 onCompleted Observable java 6956 E AndroidRuntime 20140 at rx observers SafeSubscriber onCompleted SafeSubscriber java 73 E AndroidRuntime 20140 at rx operators OperatorMap 1 onCompleted OperatorMap java 42 E AndroidRuntime 20140 at cgeo geocaching network HtmlImage 2 call HtmlImage java 142 As a side note here is the code that triggers it java final Observable Pair BitmapDrawable Boolean loadFromDisk Observable create new OnSubscribe Pair BitmapDrawable Boolean @Override public void call final Subscriber super Pair BitmapDrawable Boolean subscriber final Pair Bitmap Boolean loadResult loadImageFromStorage url pseudoGeocode shared final Bitmap bitmap loadResult getLeft subscriber onNext new ImmutablePair BitmapDrawable Boolean bitmap null ImageUtils scaleBitmapToFitDisplay bitmap null loadResult getRight subscriber onCompleted subscribeOn Schedulers computation','can t build a simple example but it has to do with switchMap returning observables scheduledOn different schedulers',RxJava,false,false,false
27740177,'Remove Bad Filter Logic','This code was accidentally committed during exploration of groupBy subscribeOn','',RxJava,true,false,false
27741946,'Revert Bounded ObserveOn','Reverting to only having unbounded observeOn in public API as per comment at https github com Netflix RxJava pull 835#issuecomment 35299824 Leaving the bounded implementation as an internal operator implementation for now to be discussed further in v0 18 dev cycle','While performance testing this it was found that NewThreadScheduler appears to be the source of performance degradation not observeOn itself Using ImmediateScheduler 0 16 and 0 17 were very similar The code for observeOn in 0 17 is now basically the same as 0 16 except using lift and avoiding the use of materialize to reduce object creation Unit tests passing on local machine merging BUILD SUCCESSFUL Total time 1 mins 20 181 secs RxJava pull requests #821 https netflixoss ci cloudbees com job RxJava pull requests 821 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
27742790,'Observable toList shouldn t wait for onComplete','It s probably common use case when you display some list of items that are fetched from one source and you also need to apply to that list some additional info from other source I ve made simple test to demonstrate problem https gist github com novemberox 9056879 9d9ee0f8f9db868f600ac76fa8ae2490ef9b4c54 but observer is never called with any data I used subject that emits lists at begging because I want be able to update whole list in case something was deleted It also allows me apply there parallel latter if needed for operation on second source','I found solution updated gist https gist github com novemberox 9056879 58e9a3381c7373028ac1d3c4079645bce56896d4 I moved toList call to first flatMap and it helped I m not sure if it this still an issue If an Observable is infinite then toList can not be used If you want intermediate lists then buffer is what you want or just use scan to do the processing inline instead of emitting lists to then do processing The toList operator is doing what it s supposed to',RxJava,false,false,false
27747394,'Split SubscribeOn into SubscribeOn UnsubscribeOn','Working with @headinthebox based on discussions at https github com Netflix RxJava pull 869 and https github com Netflix RxJava pull 880#issuecomment 35163539 we determined that there are times when unsubscribeOn behavior is needed The subscribeOn operator can not mix subscribe and unsubscribe scheduling behavior without breaking the lift Subscriber behavior that allows unsubscribing synchronous sources The newly added unsubscribeOn operator will not work with synchronous unsubscribes but it will work for the targeted use cases such as UI event handlers','I think this still can not guarantee that unsubscribe is always called in the scheduler For example java public static void main String args throws InterruptedException Observable create new OnSubscribe Integer @Override public void call final Subscriber super Integer t1 final Subscription s Subscriptions create new Action0 @Override public void call System out println Thread currentThread getName t1 add s t1 onNext 1 t1 onNext 2 t1 onCompleted take 1 observeOn Schedulers io unsubscribeOn Schedulers newThread subscribe will output main in my PC As you said it can not work for synchronous unsubscribes so we still need to write a thread safe Subscription I just feel unsubscribeOn will confuse users that when to use unsubscribeOn and when it s necessary to write a thread safe Subscription',RxJava,true,false,false
27750839,'Eliminate rx util dumping grounds','Move all classes into proper homes rather than having rx util as the miscellaneous dumping grounds I have attempted to make rx util functions have deprecated proxies to ease the migration I m doing this in 0 17 instead of waiting since 0 17 already has breaking changes','',RxJava,true,false,false
27756738,'onErrorFlatMap OnErrorThrowable','I am working on solving a production error handling use case that needs the ability to handle errors on an Observable acting like a message bus This requires it to ignore errors if they occur With @headinthebox the idea of onErrorFlatMap evolved but we now have a decision to make about the implementation It s pretty easy to solve the first half and allow onErrorFlatMap to return Observables that are injected into the output Observable but don t onComplete and thus allow the stream to continue However we re looking at whether we can also capture the T value that caused the exception to be thrown so we can achieve use cases like this java @Test public void spliceAndContinueEmitting TestSubscriber String ts new TestSubscriber String Observable from 1 2 3 4 5 6 map new Func1 Integer String @Override public String call Integer v if v 2 v 5 return Value v throw new RuntimeException error in map function v onErrorFlatMap new Func1 OnErrorThrowable Observable String @Override public Observable String call OnErrorThrowable t return Observable from Error t getValue subscribe ts ts assertTerminalEvent System out println ts getOnErrorEvents assertEquals 0 ts getOnErrorEvents size System out println ts getOnNextEvents ts assertReceivedOnNext Arrays asList Value 1 Error 2 Error 3 Error 4 Error 5 Value 6 This outputs Value 1 Error 2 Error 3 Error 4 Error 5 Value 6 To accomplish this however we must capture the value and wrap the Throwable in all operators that execute user provided functions This results in code like this java @Override public void onNext T t try o onNext transformer call t catch Throwable e onError new OnErrorThrowable e t instead of this java @Override public void onNext T t try o onNext transformer call t catch Throwable e onError e The drawback to this is that onError will now receive an OnErrorThrowable if the error comes from a user provided function The benefit is that the value associated with the failure is now accessible for debugging reporting feedback loops etc Operators affected by this are cast doOnEach filter groupBy map scan zip and surely others as these all take user provided functions Are there reasons we should not wrap these errors inside an OnErrorThrowable','RxJava pull requests #823 https netflixoss ci cloudbees com job RxJava pull requests 823 FAILURE Looks like there s a problem with this pull request RxJava pull requests #823 FAILURE These errors are known Waiting on decision before proceeding Seems like a fairly major breaking change at least for code that handles errors I could see the extra info being useful though at least for bug exceptions you re not expecting Intentional exceptions should hopefully already be conveying this info Anyway seems reasonable as long as this behavior s well documented in every affected operator Blocking operations that turn onError back into throw should also document that calling code may need to do something special to handle exceptions they may be expecting What s another layer of exception unwrapping This change will help address the exact use case mentioned above when an unexpected untrapped exception occurs in an observable sequence Rather than shutdown the sequence the change will allow the observable to remain open This is especially useful for system oriented use cases where the observable should not close even if an unexpected untrapped error occurs For example an observable sequence processing user requests for dispatching or an observable sequence accepting job requests for scheduling Just because a request within the observable sequence may fail for some unexpected reason the system oriented sequence should remain available for future requests Also for debugging and troubleshooting having the element item that caused the exception is critical I have committed a change that allows this to work without wrapping Instead if adds a final cause to the Throwable being emitted via onError and then if onErrorFlatMap is used it can derive the value from the causal chain A stack trace would end up with something like this at the end of it Caused by rx exceptions OnErrorThrowable OnNextValue OnError while emitting onNext value fail Any problems with this approach Is this preferred to wrapping RxJava pull requests #831 https netflixoss ci cloudbees com job RxJava pull requests 831 SUCCESS This pull request looks good No complains so moving forward with this Using the causal chain instead of wrapping should be low impact not intrude on normal uses of Throwables such as instanceof checks while still allowing this new behavior and improved stack traces for tracking down what caused the exceptions RxJava pull requests #832 https netflixoss ci cloudbees com job RxJava pull requests 832 SUCCESS This pull request looks good',RxJava,true,false,false
27757819,'Change Parallel to use Long instead of Int','','RxJava pull requests #824 https netflixoss ci cloudbees com job RxJava pull requests 824 SUCCESS This pull request looks good',RxJava,true,false,false
27760413,'Synchronized Operator Check for isTerminated','As per https github com Netflix RxJava issues 872 make Synchronized reject events after terminal state This class should not unsubscribe though That is only for SafeSubscriber at the end','RxJava pull requests #825 https netflixoss ci cloudbees com job RxJava pull requests 825 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
27768161,'Rewrite OperationObserveFromAndroidComponent to OperatorObserveFromAndro','This PR did the following things Rewrite OperationObserveFromAndroidComponent to OperatorObserveAndroidComponent Call unsubscribe at once if the current thread is the UI thread Remove itUnsubscribesFromTheSourceSequence since it s meaningless in the new design','RxJava pull requests #827 https netflixoss ci cloudbees com job RxJava pull requests 827 FAILURE Looks like there s a problem with this pull request RxJava pull requests #829 https netflixoss ci cloudbees com job RxJava pull requests 829 SUCCESS This pull request looks good',RxJava,true,false,false
27772115,'removing java 7 dep','','RxJava pull requests #828 https netflixoss ci cloudbees com job RxJava pull requests 828 SUCCESS This pull request looks good Thanks George',RxJava,true,false,false
27796910,'Automatic unsubscribing in OperatorMerge','It seems to me Observable merge doesn t unsubscribe its inputs one by one as they complete but only when unsubscribed manually or when all of the inputs have completed It seems counter intuitive Is that intentional','Generally the cleanup unsubscribe does not occur until the final subscribe not for intermediate operators There is precedent for eagerly unsubscribing such as in take so as to not delay unsubscribing until some point in the future and merge is a gray area for being an intermediate operator as it is the terminal state for the Observables it is merging We can look at doing so for merge assuming there is not some unconsidered edge case If we do merge we should look at the other combinatorial operators as well including zip and concat Curious what is the use case where the Observable emits onCompleted and at that point is not cleaned up and needs to wait until unsubscribe I m playing with long running hours not weeks streams not sure if RxJava is ready for that though I have a long running input stream Observable Observable A xs of short running input streams that I eventually want to flatten to Observable A However small their footprint may be I m concerned with the idea that when Observable merge xs is unsubscribed I can see as many calls to unsubscribe of the nested Observable A s as there were elements in xs Of course I can try to make sure that I free up everything I can in their onCompleted method but something is worse than nothing My understanding is as soon as an Observable completes it s of no use and thus should be unsubscribed by its subscriber I can t see an edge case where it would be otherwise FWIW zip concat and mergeMap flatMap should definitely follow the same guideline as soon as an input Observable completes its unsubscribe is called For a toy example xs map f should have the same effect as xs flatMap x observableWithJust x but with the current behavior the latter has an accumulating memory footprint whereas the former doesn t Good points If we re retaining subscriptions that s a bad thing I ll take a look and resolve this long running hours not weeks streams not sure if RxJava is ready for that This has not been the area where we Netflix have used it in production thus far so it is definitely not battle tested and I m not surprised there are bugs We are starting to and have found bugs and expect to find more as it gets the same level of use and testing for long running streams Thank you for the bug report Thanks I ll try to write a reproducing test when the hurry settles down a bit Can you take a look at this https github com Netflix RxJava pull 904 I have only spent a few minutes on this so not 100 certain it is done Both the implementation and the tests look alright on a first glance I ll try it out in a minute Thanks a lot for such a quick reaction This is released in RC4 Nice',RxJava,false,false,false
27805047,'Handle illegal errors thrown from plugin','','',RxJava,true,false,false
27809200,'OperatorObserveFromAndroidComponent to support Fragment isVisible','I have a use case on Android in which I would want a fragment to stop updating its data while it s hidden It would seem natural to add a support for this in OperatorObserveFromAndroidComponent Maybe there could be a switch for whether the observable should be inactive only when the fragment is not added or also when it s hidden','So basically a callback to indicate if the fragment is active can improve the API What s your opinion @mttkay public static T Observable T from Func0 Boolean isActive Observable T sourceObservable Here is my thought that will solve this issue and another issue I mentioned in https github com Netflix RxJava pull 880#issuecomment 35367394 Essentially we need some api to make an Observable become inactive and keep silent we can not use Subscription returned by subscribe At first we need the following OperatorAttach to attach an Observable with a Func1 Boolean java public final class OperatorAttach T implements Observable OnSubscribe T private final Observable T source private final Func1 Notification T Boolean isAttached public OperatorAttach Observable T source final Subscription detach this source new Func1 Notification T Boolean @Override public Boolean call Notification T t1 return detach isUnsubscribed Generate a new Observable that mirrors the source but will swallow messages once isAttached return false @param source @param isAttached public OperatorAttach Observable T source Func1 Notification T Boolean isAttached this source source this isAttached isAttached @Override public void call final Subscriber super T subscriber source materialize takeWhile isAttached subscribe new Subscriber Notification T subscriber @Override public void onCompleted ignore @Override public void onError Throwable e ignore @Override public void onNext Notification T notification if notification isOnNext subscriber onNext notification getValue else if notification isOnError subscriber onError notification getThrowable else subscriber onCompleted Then observeFromAndroidComponent is like this java public static T Observable T observeFromAndroidComponent Observable T source android app Fragment fragment final Func1 android app Fragment Boolean isAttached final WeakReference android app Fragment fragmentRef Object memoryBarrier new Object synchronized memoryBarrier force a memory barrier fragmentRef new WeakReference android app Fragment fragment return Observable create new OperatorAttach T source observeOn AndroidSchedulers mainThread new Func1 Notification T Boolean @Override public Boolean call Notification T t1 android app Fragment fragment fragmentRef get return fragment null isAttached call fragment public static T Observable T observeFromAndroidComponent Observable T source Subscription detach return Observable create new OperatorAttach T source observeOn AndroidSchedulers mainThread detach Use case Activity java public class TestActivity extends Activity private volatile Subscription detach private Observable Integer o @Override protected void onCreate Bundle savedInstanceState super onCreate savedInstanceState detach new BooleanSubscription o OperatorObserveFromAndroidComponent observeFromAndroidComponent Observable from Arrays asList 1 2 3 detach @Override protected void onDestroy detach unsubscribe super onDestroy Fragment java android app Fragment fragment OperatorObserveFromAndroidComponent observeFromAndroidComponent Observable from Arrays asList 1 2 3 fragment new Func1 android app Fragment Boolean @Override public Boolean call Fragment t1 return t1 isAdded or t1 isVisible @mttkay any idea @zsxwing my guess is that OperatorObserveFromAndroidComponent assumes that Fragment can become active and inactive more than once so takeWhile isn t appropriate here I like your implementation more though @mironov nsk I think creating two operator one use takeWhile one use filter is better That would meet your requirements @benjchristensen is it worth to put such OperatorAttach in the rxjava core Does anyone need this operator out of rxjava android @zsxwing I came to a similar conclusion with my initial forked implementation I actually ended up needing a slightly custom code isAttached code function My nested fragment checks if its parent is visible in addition to itself because code FragmentTransaction hide code does not cascade the hidden property code OperatorAttach code does indeed seem a lot more generic than just this code rxjava android code use case I would like seeing it in the core myself I just realized I did the same thing as dematerialize The following codes are simpler public static Observable T attach Observable T source Func1 Notification T Boolean isAttached return source materialize takeWhile isAttached dematerialize public static Observable T filter Observable T source Func1 Notification T Boolean isAttached return source materialize filter isAttached dematerialize I don t fully understand the use case as I don t work with UIs or Android so can t help very much but are you trying to unsubscribe from the event source when it is hidden or just ignore them until it becomes visible In other words must you keep listening to the events so as to know when it becomes visible again If I understand correctly if the visibility is not taken into account we receive events when hidden e touch event visible e touch event visible e hidden hidden e touch event hidden e touch event hidden e touch event hidden e visible visible e hidden hidden e touch event hidden e visible visible e touch event visible I imagine you want this e touch event visible e touch event visible e touch event visible e touch event visible e hidden hidden e visible visible e touch event visible e hidden hidden e visible visible e touch event visible e touch event visible e touch event visible java public static Observable FragmentEvent listenToFragment final Fragment fragment simulate registering with the listener for a fragment return Observable create new OnSubscribe FragmentEvent @Override public void call final Subscriber super FragmentEvent s s add Schedulers newThread scheduleRecursive new Action1 Recurse boolean hidden false @Override public void call Recurse r if Math random 0 2 hidden hidden if hidden s onNext new FragmentEvent fragment hidden else s onNext new FragmentEvent fragment visible else s onNext new FragmentEvent fragment touch event r schedule 500 TimeUnit MILLISECONDS public static void main String args listenToFragment new Fragment f1 toBlockingObservable forEach new Action1 FragmentEvent boolean visible true @Override public void call FragmentEvent e if e event equals hidden visible false else if e event equals visible visible true System out println e e event visible visible hidden I want to ignore the events of the observable while the fragment is hidden However as I mentioned actually whether or not it is hidden is not a property but a custom function Therefore as @zsxwing suggested there would need to be a boolean function code isAttached code to determine the state In the code OperatorObserveFromAndroidComponent code there is already such functionality for the fragment state code isAdded code Explicitly subscribing unsubscribing according to a temporary state of the fragment is inconvenient because it requires subclassing and overriding methods The usage of the code in question would end up something like this java Observable String src android app Fragment fragment Observable String filteredSource OperatorObserveFromAndroidComponent observeFromAndroidComponent src fragment new Func1 android app Fragment Boolean @Override public Boolean call Fragment t1 android app Fragment parent t1 getParentFragment return t1 isVisible parent null parent isVisible filteredSource subscribe new Action1 String @Override public void call String str Update the UI with the new data Should it actually subscribe unsubscribe or just ignore events If it keeps the subscription open here are two approaches one with filter and one with switchOnNext java public static Observable FragmentEvent fragmentWithVisibilityCheckUsingSwitch final Fragment fragment return Observable switchOnNext listenToFragment fragment map new Func1 FragmentEvent Observable FragmentEvent boolean visible true @Override public Observable FragmentEvent call FragmentEvent e if e event equals hidden visible false return Observable from e could be Observable never to ignore else if e event equals visible visible true return Observable from e could be Observable never to ignore else if visible return Observable from e else return Observable never public static Observable FragmentEvent fragmentWithVisibilityCheckUsingFilter final Fragment fragment return listenToFragment fragment filter new Func1 FragmentEvent Boolean boolean visible true @Override public Boolean call FragmentEvent e if e event equals hidden visible false return true could be false to ignore else if e event equals visible visible true return true could be false to ignore else if visible return true else return false Of course the function for determining whether it is visible can be injected as you state is it worth to put such OperatorAttach in the rxjava core What is different from the attach operator and using filter Maybe I m missing something but doesn t the operator already do that It will skip all notifications unless the fragment isAdded What is different from the attach operator and using filter Now I think we don t need to add this operator Here I think there are two use cases disable an Observable forever once the isAttached return false For example once an Activity is destroyed we should disable the Observable forever disable an Observable once the isAttached return false and enable an Observable once the isAttached return true For example according the visible property of the fragment to enable or disable the Observable Maybe I m missing something but doesn t the operator already do that It will skip all notifications unless the fragment isAdded I m trying to support that the Observable can always be subscribed by many Observers if the Activity is alive OK From the the initial discussion it sounded as if this was merely about not emitting notifications if a fragment is in the background As for the use cases you mentioned disable an Observable forever once the isAttached return false For example once an Activity is destroyed we should disable the Observable forever We can t do that going through a configuration change means the fragment will get re attached and the observable must continue emitting We use that pattern frequently with cache and replay disable an Observable once the isAttached return false and enable an Observable once the isAttached return true For example according the visible property of the fragment to enable or disable the Observable What do you mean by disable Could this also be solved by using cache and replay You just keep emitting items into the cached observable and once your fragment activity is back to life you re subscribe I m trying to support that the Observable can always be subscribed by many Observers if the Activity is alive That suggests use of a Subject cache and replay This sounds correct but what are the lifecycle implications as far as memory is concerned The cache operator is replay with no limits so if an app is alive for hours or days it will keep retaining memory Perhaps it is just the last x events or minutes of events Curious why would there be events when an activity is not alive or a fragment is not visible And if there are events while hidden or not alive should they be retained or just ignored completely Curious why would there be events when an activity is not alive or a fragment is not visible And if there are events while hidden or not alive should they be retained or just ignored completely Here the events are not the UI events It s some events emitted from a background thread For example a thread may read some information from a web server in a background thread and send it to the UI thread In the UI thread the UI elements will be updated according to the information In Android AndroidSchedulers mainThread is used to dispatch such events to the UI thread There is an event queue for the UI thread Sometimes when the UI thread fetches an event sent from a background thread from the queue maybe now the Activity is gone or a fragment is not visible So such events need to be dropped I think it s a common pattern that creating an Observable that has the same life cycle as the Activity In addition I don t want to store a strong reference to an Activity or a Fragment in the Observable or it will not be cleaned by GC So I use a WeakReference The operator already takes care of this If you unsubscribe in onDestroy it will drop all outstanding messages Android guarantees that no messages will be delivered between onDestroy and the next call to onCreate so there s only two cases the Activity doesn t come back to life because the user backed out for instance the Activity goes through onCreate again because it was a configuration change like change in rotation In that case use cache or replay and keep the Observable alive for instance using a fragment that retains instance state That said I m still not sure what the problem is we re trying to solve or how it s not accounted for already That said I m still not sure what the problem is we re trying to solve or how it s not accounted for already In current rxjava android I think the following behavior is wrong This is the first problem I want to fix java public class TestActivity extends Activity protected void onCreate Bundle savedInstanceState super onCreate savedInstanceState Observable Integer o OperatorObserveFromAndroidComponent observeFromAndroidComponent Observable from 1 this the following codes output 1 o subscribe new Observer Integer @Override public void onCompleted @Override public void onError Throwable e e printStackTrace @Override public void onNext Integer t System out println t the following codes output nothing this is a wrong behavior should output 1 o subscribe new Observer Integer @Override public void onCompleted @Override public void onError Throwable e e printStackTrace @Override public void onNext Integer t System out println t The second one is adding an API to let users can control when the Observable is active For example a Button or a TextView can also be removed like Fragment So some Observable may be bind to a Button or other UI component I want to provide an API to keep the Observable silence once the UI component is removed Since the use case may be very complex I want to add one function like isAttached to let users determine when to keep the Observable silence The operator already takes care of this If you unsubscribe in onDestroy it will drop all outstanding messages Here I m not sure which one is better using takeWhile or filter Maybe filter is better since Activity or Fragment can come back to live Just to summarize what we want to fix is this yes make observables wrapped by fromFragment fromActivity re subscribable pull out decision logic for when to silence the observable into a function that we pass in rather than having it internal subclasses Yes thanks for your summary Thanks @zsxwing for elaborating the use case @mttkay I agree with the summary it supports my need of having a more complex function to determine the state @benjchristensen as suggested the source observable I have is sending events whenever it receives them from a push network API Subscribing Unsubscribing is done in fragment onCreate onDestroy but in between there are moments when the UI is hidden or otherwise inactive and the events can be discarded The story of keeping the displayed data consistent over the application is of course a lot longer and we have an elaborate system for it but in this case each notification was only shown in the UI for a short moment Not sure anymore where this should be best discussed but will leave my comment here While working on the samples project for rxjava android I actually discovered a few other issues that I was unaware of previously Currently fromFragment has to be used with much care and in a very specific often non obvious way to actually prevent memory leaks from happening This is due to a combination of things resubscribing doesn t work as already pointed out so one cannot unsubscribe from a cached observable in onDestroyView before a config change and resubscribe in onViewCreated This means the fragment will leak The only fix to this right now is to always recreate the outer observable by calling fromFragment again immediately before subscribing because once the reference is cleared out the operator doesn t unsubscribe its inner observer so it will continue receiving messages even though they will all get discarded this is rather easy to fix but I m not sure if this has other repercussions so I m testing this right now because of the assertUiThread issue the sequence can fail silently if no onError handler is specified easy to fix too As said I have fixes for the latter two issues although they require more testing However I agree this operator demands rethinking on a bigger scale I guess Especially the eager and final binding to the observed UI component in the constructor is a culprit here that needs to be addressed So I gave this some deeper thought over the weekend and came to the conclusion that I would prefer to deprecate and completely rewrite the current operator Here is is what I came up with https gist github com mttkay 0590979394aec6144a2e Benefits does not leak context references even when they re implicit through an inner class subscriber no distinction anymore between fragments and activities everything is considered a weak binding to some UI component should therefore work with views too it s not necessary to unsubscribe anymore due to the use of weak references auto unsubscribes when subscriber or bound reference are gone can be used with lift since it s an Operator now Drawbacks expects to and requires the caller to manually observeOn mainThread cache since otherwise re subscribing would restart the sequence perhaps there are even use cases for this though I only tested this guy quickly in the samples project in both a fragment that retains instance state and an activity which retains the sequence by piping it through onRetainNonConfigurationInstance and I saw the activities being properly garbage collected What s missing What @tehmou suggested i e making bindings more controllable by passing in a function I was wondering though whether this should be its own operator or implemented on top of this using existing operators When I wrote the initial implementation of OperatorObserveFromAndroidComponent my goals were to make it simple to observe sequences on the main UI thread without having to manage context references That backfired a bit I guess so I see this new implementation to be a superior implementation for this particular use case not so much something that s more feature rich Could you guys test this review this and give me your thoughts Thanks I realized this can even be further simplified by providing new helpers through AndroidObservable similar to what fromFragment used to do public static T Observable T bindActivity final Activity activity Observable T cachedSequence return cachedSequence observeOn AndroidSchedulers mainThread lift new OperatorWeakBinding T Activity activity public static T Observable T bindFragment final Fragment fragment Observable T cachedSequence return cachedSequence observeOn AndroidSchedulers mainThread lift new OperatorWeakBinding T Fragment fragment In the Activity you can then simplify to @Override protected void onCreate Bundle savedInstanceState super onCreate savedInstanceState setContentView R layout activity_reactive o Observable String getLastNonConfigurationInstance if o null o SampleObservables numberStrings 1 100 200 cache s bindActivity this o subscribe new Observer and the Fragment even to @Override public void onCreate Bundle savedInstanceState super onCreate savedInstanceState strings bindFragment this SampleObservables numberStrings 1 100 200 cache So the only assumption that remains is that the source sequence must always be cache d otherwise going through an unsubscribe subscribe cycle during a rotation change would restart the sequence instead of continuing it Any ideas how we could solve this I guess the problem is that the underlying sequence must continue to receive notifications during the time the fragment activity is detached Just tested this in one of our apps core screens works nicely so far I ve prepared a branch against netflix master that deprecates ObserveFromAndroidComponent and introduces this one I ll push it and send a PR so that you guys can test it out more easily Maybe it s just getting late but while working on the RxJava Android samples project I made an observation it seems the very problem all the Android operator implementations so far try to address i e binding the sequence to the life time of a fragment or activity without leaking it seems only to actually be an issue when using cache or replay which unfortunately is a very common use case for us When using e g just publish to connect a fragment s inner observer which in turn holds a reference to the fragment then as long as I unsubscribe in onDestroyView no context will leak even for retained fragments Using publish is unfortunately not useful on Android since the UI component might miss out on an emitted item while being detached I ve opened an issue report here since I don t want to drive this issue further off topic but would be glad if someone could either verify or falsify it https github com Netflix RxJava issues 939 I m just wondering whether the whole issue we re trying to fix might simply be down to a bug in ReplaySubject in which case the whole discussion around OperatorWeakBinding would be null and void So I invested more time into this today and the result is in the PR mentioned before https github com Netflix RxJava pull 938 I have added support to bind a sequence via a predicate function that can be controlled from the outside bindActivity now by default adds a predicate that tests for isFinishing and bindFragment tests for isAdded but this behaviour can overridden now by lift ing the operator manually using a custom predicate source lift new OperatorWeakBinding this new Func1 Fragment T subscribe observer In summary bindActivity this sourceSequence subscribe s keeps a weak reference to both this and s schedules notifications on the main UI thread and drops notifications and unsubscribes whenever this the activity is finishing this is gone s is gone bindFragment this sourceSequence subscribe s same just that the predicate test is for isAdded @zsxwing @tehmou let me know whether this addresses all the problems we discussed cc @samueltardieu This looks nice indeed I suggest to close this and in case of follow up problems discussion to open a new issue',RxJava,false,false,false
27841963,'OperatorGroupBy does not accept multiple subscriptions when source async','The test below fails in 0 16 1 I have not tested against new versions but I suggest we should if the test is valid Please have a look thanks java import static org mockito Mockito mock import static org mockito Mockito never import static org mockito Mockito verify import java util concurrent TimeUnit import org junit Test import org mockito Matchers import rx Observable import rx Observer import rx observables GroupedObservable import rx util functions Func1 public class OperatorGroupByTest2 @Test public void testGroupByOnAsynchronousSourceAcceptsMultipleSubscriptions throws InterruptedException choose an asynchronous source Observable Long source Observable interval 10 TimeUnit MILLISECONDS take 1 apply groupBy to the source Observable GroupedObservable Boolean Long stream source groupBy IS_EVEN create two observers Observer GroupedObservable Boolean Long o1 mock Observer class Observer GroupedObservable Boolean Long o2 mock Observer class subscribe with the observers stream subscribe o1 stream subscribe o2 check that subscriptions were successful verify o1 never onError Matchers Throwable any verify o2 never onError Matchers Throwable any private static Func1 Long Boolean IS_EVEN new Func1 Long Boolean @Override public Boolean call Long n return n 2 0','I merged the unit test into master branch and it is passing Thank you by the way for submitting a unit test along with the report That makes it far easier',RxJava,false,false,false
27850024,'GroupBy Unit Test from #900','https github com Netflix RxJava issues 900','RxJava pull requests #833 https netflixoss ci cloudbees com job RxJava pull requests 833 SUCCESS This pull request looks good',RxJava,true,false,false
27874136,'Fixed NullPointerException that may happen on timeout','An unhandled NullPointerException is thrown in the releaseResources method in rx apache http consumers ResponseConsumerDelegate if a timeout occur If a timeout occur then onResponseReceived is never called and thus consumer is null','RxJava pull requests #834 https netflixoss ci cloudbees com job RxJava pull requests 834 SUCCESS This pull request looks good Thank you',RxJava,true,false,false
27893463,'Scheduler Recurse fields should be private','','RxJava pull requests #835 https netflixoss ci cloudbees com job RxJava pull requests 835 SUCCESS This pull request looks good',RxJava,true,false,false
27895634,'Merge Unsubscribe Completed Inner Observables','Fixing bug report from https github com Netflix RxJava issues 897','RxJava pull requests #836 https netflixoss ci cloudbees com job RxJava pull requests 836 SUCCESS This pull request looks good',RxJava,true,false,false
27905063,'RxJavaSchedulers Plugin','Allow setting different default schedulers for use by system','',RxJava,true,false,false
27912266,'Deprecate Direct Access to Scheduler Implementations','This enforces the convention of using Schedulers and then makes the RxJavaDefaultSchedulers plugin more reliable','RxJava pull requests #838 https netflixoss ci cloudbees com job RxJava pull requests 838 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
27912364,'Deprecate Direct Access to Scheduler Implementations','This enforces the convention of using Schedulers and then makes the RxJavaDefaultSchedulers plugin more reliable','RxJava pull requests #839 https netflixoss ci cloudbees com job RxJava pull requests 839 FAILURE Looks like there s a problem with this pull request No idea why this doesn t want to be merged other than that thoughts on this idea based on RxJavaDefaultSchedulers plugin added in https github com Netflix RxJava pull 905',RxJava,true,false,false
27920631,'Rxjava clojure bindings','PLEASE DON T MERGE THIS FOR REVIEW ONLY Here s a pull request for Clojure bindings to give people a place to provide feedback','RxJava pull requests #840 https netflixoss ci cloudbees com job RxJava pull requests 840 SUCCESS This pull request looks good RxJava pull requests #841 https netflixoss ci cloudbees com job RxJava pull requests 841 FAILURE Looks like there s a problem with this pull request RxJava pull requests #842 https netflixoss ci cloudbees com job RxJava pull requests 842 SUCCESS This pull request looks good RxJava pull requests #843 https netflixoss ci cloudbees com job RxJava pull requests 843 SUCCESS This pull request looks good RxJava pull requests #846 https netflixoss ci cloudbees com job RxJava pull requests 846 FAILURE Looks like there s a problem with this pull request RxJava pull requests #847 https netflixoss ci cloudbees com job RxJava pull requests 847 SUCCESS This pull request looks good RxJava pull requests #848 https netflixoss ci cloudbees com job RxJava pull requests 848 SUCCESS This pull request looks good RxJava pull requests #849 https netflixoss ci cloudbees com job RxJava pull requests 849 SUCCESS This pull request looks good RxJava pull requests #850 https netflixoss ci cloudbees com job RxJava pull requests 850 SUCCESS This pull request looks good RxJava pull requests #851 https netflixoss ci cloudbees com job RxJava pull requests 851 FAILURE Looks like there s a problem with this pull request RxJava pull requests #854 https netflixoss ci cloudbees com job RxJava pull requests 854 SUCCESS This pull request looks good RxJava pull requests #859 https netflixoss ci cloudbees com job RxJava pull requests 859 SUCCESS This pull request looks good RxJava pull requests #861 https netflixoss ci cloudbees com job RxJava pull requests 861 SUCCESS This pull request looks good Replaced by https github com Netflix RxJava pull 925 Replaced by https github com Netflix RxJava pull 925',RxJava,true,false,false
27979004,'Scheduler Plugin Refactor','1 Deprecate Direct Access to Scheduler Implementations This enforces the convention of using Schedulers and then makes the RxJavaDefaultSchedulers plugin more reliable 2 Scheduler instances should be or behave like singletons Remove the Func0 factory signature for Scheduler creation','RxJava pull requests #844 https netflixoss ci cloudbees com job RxJava pull requests 844 SUCCESS This pull request looks good',RxJava,true,false,false
27979114,'Remove groupBy with selector','I think we can use groupBy keySelector map elementSelector instead Is there any reason to keep this signature Related to https github com Netflix RxJava commit 02ccc4d727a9297f14219549208757c6e0efce2a#commitcomment 5430646','Well groupBy returns Observable Observable so you need one more level of map to apply elementSelector I m ambivalent Merging for now to remove the broken functionality can be re added before 0 17 0 release if we decide to Well groupBy returns Observable Observable so you need one more level of map to apply elementSelector I m ambivalent Yes sorry it s within the map or flatMap but we already have to do that anyways when using groupBy as that s what it does emit Observable GroupedObservable T I don t see the need for a special operator that emits Observable GroupedObservable R Thanks @daveray for the feedback Anyone else have a good reason for the existence of this overload The preference is allow composition of existing operators RxJava pull requests #845 https netflixoss ci cloudbees com job RxJava pull requests 845 SUCCESS This pull request looks good',RxJava,true,false,false
27982885,'Unexpected behavior for Observable map and other transforms','I noticed that map gets run N times where N is number of subscribers number of items emitted E g java PublishSubject Long p PublishSubject create Observable Long mapped p map mapped subscribe firstSub mapped subscribe secondSub p onNext 1 In the above example the map function will get run twice even though only a single value is published My intuition was that map would be run once and the resulting value forwarded on to all subscribers Is there a type of observable that only runs the transforms once for each item instead of for each item and subscriber What is the reasoning behind re running the transforms for every subscriber This became a problem for me when I had an observable of ByteBuffers that was mapped to a decoded type It worked fine when there was only one subscriber but once I added more then the buffers would be read from multiple times and thus throw buffer underflow exceptions Thanks','PublishSubject Long p PublishSubject create Observable Long mapped p map publish mapped subscribe firstSub mapped subscribe secondSub mapped connect p onNext 1 Interesting that java PublishSubject p PublishSubject create ConnectableObservable mapped p map publish mapped connect mapped subscribe firstSub mapped subscribe secondSub p onNext 1 produces the desired behavior as well not entirely sure why though Thanks for your help Of course Not surprising really As long as you call connect before p OnNext 1',RxJava,false,false,false
27984367,'SampleWithObservable broken','Hi all I d expect scala import rx lang scala Observable import scala concurrent duration _ import rx lang scala JavaConversions _ val o Observable items 1 Observable never val sampler Observable interval 100 milli take 3 toScalaObservable toJavaObservable o sample toJavaObservable sampler toBlockingObservable toList to return List 1 1 1 but it returns as of As of RxJava 0 16 1 only List 1 Furthermore it seems that there is no unit test in the source testing SampleWithObservable Thank you for any insights on this Best regards Tom Dvo k','I just found OperationSampleTest java so there are in fact unit tests sorry for not finding them earlier There is even a test sampleWithSamplerNoDuplicates so it seems that it is actually in the specification of sample to ignore the same value if sampled more than one times I was mislead by the marble diagram at http netflix github io RxJava javadoc rx Observable html#sample rx Observable which shows that the green circle gets emitted two times when sampled twice The marble diagram behavior is also the one I d prefer you can always filter the duplicate values via distinct but you can t do the reverse So is there any chance the behavior of sample could be changed or maybe could we get another operator that wouldn t discard the duplicate values Thank you regards Tom Dvo k Tom Did you get a definitive answer about this I m the fellah who put the diagram together based on my understanding of sample at the time If I ve got it wrong I d like to change it to match the actual behavior David On Fri Feb 21 2014 at 6 52 AM Tomas Dvorak notifications@github com wrote I just found OperationSampleTest java so there are in fact unit tests sorry for not finding them earlier There is even a test sampleWithSamplerNoDuplicates so it seems that it is actually in the specification of sample to ignore the same value if sampled more than one times I was mislead by the marble diagram at http netflix github io RxJava javadoc rx Observable html#sample rx Observable which shows that the green circle gets emitted two times when sampled twice The marble diagram behavior is also the one I d prefer you can always filter the duplicate values via distinct but you can t do the reverse So is there any chance the behavior of sample could be changed or maybe could we get another operator that wouldn t discard the duplicate values Thank you regards Tom Dvo k Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 912#issuecomment 35736613 David M Gross PLP Consulting No answer yet but I hope that it will be the behavior that will get changed to match the marble diagram We ll see Hi Both sample with time and sample with observable consume source values only once Do you still need a sampler which returns the last seen value from source I had to write a custom operator to do this always emit the last value when sampler fires so I d appreciate this functionality being in the library I m not in a position to contribute my implementation sorry So would this be an operator that emits the latest value on every tick If so it s not really sample so what would that be called Hi I m on a long vacation so I m not able to test anything or respond too often But I can t see how the behavior of emitting the last value on every tick is not sampling when you sample e g an AD signal with a sampling tick signal you still want to sample a value on every tick regardless of whether the source signal value has changed or not and that is how I percieve what sampling means If you don t want duplicate values you can always distinct it On Tue May 20 2014 at 9 03 AM Ben Christensen notifications@github com wrote So would this be an operator that emits the latest value on every tick If so it s not really sample so what would that be called Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 912#issuecomment 43592550 Unlike map filter etc that have a fimr formal categorical semantics what sampling means is purely subjective so as the API designer you have to pick a few behaviors among many possible ones with the risk there are scenarios where the built in ones don t work for some people Fortunately it is typically easy to roll your own especially with the new lift operator That s the power of compositionality Now in this particular case doing a distinctUntilChanged will not work since that does not distinguish between the real values in the stream and the repeated values i e if your stream is 1 1 1 1 1 1 1 1 you will always get 1 However if you want to repeat values or do something else you can always do that using xs map x repeat x at some interval of your choosing switchOnNext to fill the gaps and then use the regular sample Unlike map filter etc that have a fimr formal categorical semantics what sampling means is purely subjective so as the API designer you have to pick a few behaviors among many possible ones with the risk there are scenarios where the built in ones don t work for some people Fortunately it is typically easy to roll your own especially with the new lift operator That s the power of compositionality Now in this particular case doing a distinctUntilChanged will not work since that does not distinguish between the real values in the stream and the repeated values i e if your stream is 1 1 1 1 1 1 1 1 you will always get 1 However if you want to repeat values or do something else you can always do that using xs map x repeat x at some interval of your choosing switchOnNext to fill the gaps and then use the regular sample OK Just out of curiosity can you sketch some simple usage scenario for me where the current behavior of sample fits in naturally so that I better grok what s it intended for please Thank you best regards On Sat May 31 2014 at 7 54 PM headinthebox notifications@github com wrote Unlike map filter etc that have a fimr formal categorical semantics what sampling means is purely subjective so as the API designer you have to pick a few behaviors among many possible ones with the risk there are scenarios where the built in ones don t work for some people Fortunately it is typically easy to roll your own especially with the new lift operator That s the power of compositionality Now in this particular case doing a distinctUntilChanged will not work since that does not distinguish between the real values in the stream and the repeated values i e if your stream is 1 1 1 1 1 1 1 1 you will always get 1 However if you want to repeat values or do something else you can always do that using xs map x repeat x at some interval of your choosing switchOnNext to fill the gaps and then use the regular sample Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 912#issuecomment 44754914 The sample operator has been part of the standard Rx operators since late 2007 see here for samples http introtorx com Content v1 0 10621 0 13_TimeShiftedSequences html#Sample http community bartdesmet net blogs bart archive 2010 04 19 some introductory rx samples aspx http eprystupa wordpress com 2009 12 19 throttling high frequency data feed using reactive extensions for net Hmm I have checked all three examples but I m still not convinced that any of them requires precisely the behavior that is implemented by the current version of sample that is sample values don t emit the value on next sampler tick if it has not changed but do emit it if it has changed to some other value and back again between the two sampler ticks The first example doesn t have any specification the second one should be in my opinion better with my definition of sample followed by distinct and the same could arguably be said about the third example I have also noticed that the author of the the third example mentions that My intuition was that if underlying feed does not produce a value during the sampling interval Sample will repeat the most recent available value when sampling is due that is he was initially under the same impression as me @DylanSale has posted a comment to this discussion stating that he also had the need the behavior I was describing and had to implement it himself The whole issue #1045 seems to be dealing with this once again where independently of me @amazari also desires the behavior I have described And I still have not found any use case requiring sample to behave exactly the way it behaves now but my imagination may be limited by the domain of the problems I usually deal with in my job However after this many comments on the topic and no sign of having convinced anybody I feel like I m just nitpicking too much and I certainly don t want to do that I really do appreciate all the work you put into RxJava and the open and collaborative way of development @headinthebox has already posted a way to combine operators to achieve the desired behavior thank you and if sample as is now is going to stay I m fine with just using his solution and closing this issue Best regards Tom Dvo k @dvtomas the power of a library is not in how many special purpose operators it has that do exactly the job you want i e how long the autocomplete list is when you hit but how flexible it is to compose the solution you want using an orthogonal set of primitive operators i e how short the autocomplete list is when you hit i e when it is possible to combine operators to achieve the desired behavior then the bar to add that combination as a separate operator is super high It seems you are using Scala so there it is really easy to add this operator yourself as an extension method and it will look as if it is a built in operator Unfortunately for Java we don t have that choice so we need to be extra strict to keep the number of operators down and avoid to get an obese API',RxJava,false,false,false
27987379,'window buffers elements in inner sequences','Hi all In this sample I m fitting 100 millisecond samples into 400 millisecond long non overlapping windows I print the timestamped inner values scala import rx lang scala Observable import scala concurrent duration _ val o Observable interval 100 milli take 10 window Long Long Observable items 0L Observable interval 500 milli _ Observable interval 400 milli take 1 doOnEach _ timestamp subscribe next println next o toBlockingObservable toList Just wait till completion I get results like this 1392922815665 0 1392922815666 1 1392922815666 2 1392922816165 4 1392922816165 5 1392922816165 6 1392922816165 7 1392922816265 9 According to the timestamp the inner elements are all emitted at once at the time the window closes Is there any reason the elements can t start being emitted as soon as the window opens It would make more sense to me Thank you best regards Tom Dvo k','This behavior has been changed recently The current window observables now emit values as soon as they can Could you test this and see if the issue can be closed @dvtomas Please re open if this issue is still not addressed as expected',RxJava,false,false,false
28014040,'Any reason for rx lang scala subjects PublishSubject to be private','title explains it all','Fixed in https github com Netflix RxJava pull 1216',RxJava,false,false,false
28052673,'Merge pull request #1 from Netflix master','Merge with Netflix','RxJava pull requests #852 https netflixoss ci cloudbees com job RxJava pull requests 852 SUCCESS This pull request looks good',RxJava,true,false,false
28052973,'Merge pull request #1 from Netflix master','Merge with Netflix','RxJava pull requests #853 https netflixoss ci cloudbees com job RxJava pull requests 853 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
28074949,'Zip Bug UnitTest Never Completes When Zero Observables','Duplicate of #868 Accidentally submitted the PR from master not from a test branch','RxJava pull requests #856 https netflixoss ci cloudbees com job RxJava pull requests 856 FAILURE Looks like there s a problem with this pull request Merged and fixed in https github com Netflix RxJava pull 919',RxJava,true,false,false
28077004,'Operator doOnTerminate','Like finallyDo but before emitting the terminal state instead of after','',RxJava,true,false,false
28078347,'BugFix Zip Never Completes When Zero Observables','Fixes https github com Netflix RxJava pull 868 and https github com Netflix RxJava pull 917','RxJava pull requests #857 https netflixoss ci cloudbees com job RxJava pull requests 857 FAILURE Looks like there s a problem with this pull request RxJava pull requests #858 https netflixoss ci cloudbees com job RxJava pull requests 858 SUCCESS This pull request looks good',RxJava,true,false,false
28079295,'Delete Deprecated onSubscribeStart That Doesn t Work','It s messy to make this work so deleting it instead Better to move forward in the 0 17 release than try and make this work for the very small percentage probably only Netflix that uses it','RxJava pull requests #860 https netflixoss ci cloudbees com job RxJava pull requests 860 SUCCESS This pull request looks good',RxJava,true,false,false
28158929,'Possible incorrect Switch implimentation','I feel the switchOnNext implementation is wrong Reading and looking at the original Switch documentation and marble diagrams http www introtorx com Content v1 0 10621 0 12_CombiningSequences html#Switch Switch should work as follows text SV 1 2 3 S1 1 1 1 1 S2 2 2 2 2 S3 3 3 RS 1 1 2 23 3 So when S2 is initiated in SV S1 still continues to be listened to until S2 actually emits its onNext What I actually see happen is this text SV 1 2 3 S1 1 1 1 1 S2 2 2 2 2 S3 3 3 RS 1 2 3 3 Where S2 is started in the parent all of S1 is ignored even though S2 is yet to produce onNext Now this might be my understanding of the docs Can someone clarify which is _meant_ to happen Should it switch when the parent starts the inner observable or when the inner observable calls the first onNext','Looking at the code when calling onNext in the SwitchObservable increments the latest confirming my thoughts Meaning when onNext is called in the parent all previous inner Observables are ignored as latest id will fail So I m sure it should be the inner Observable that is assigned an id when called in the parent onNext then when the inner onNext is called it can check if its id is greater than the latest id and take over e g java if id latest latest id SwitchObserver this observer onNext args Or something similar As per discussion with @headinthebox I believe it is supposed to unsubscribe from the previous Observable whenever it receives a new Observable via the onNext It does not wait until the child emits anything @headinthebox can you please confirm expected behavior of switch switchOnNext in Java since switch is a reserved word Yup that is the intended behavior As soon as the outer observable fires a new inner observable you switch Oh that s a shame what could I call too do expected behaviour Thinking I might have to write my own extension On 26 Feb 2014 17 26 headinthebox notifications@github com wrote Yup that is the intended behavior As soon as the outer observable fires a new inner observable you switch Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 921#issuecomment 36151339 Why do you want the other behavior @headinthebox You have two sources of data one is 99 of the time quicker than the other disk vs network I call data from the disk cache and the API at the same time I get the disk result then the API comes back and takes over from the disk result as that would be fresher So if i fired both at the same time return disk result then return api result For the case where the API returns before the disk the latest subscriber blocks the previous ones So the fresher API result will not be poisoned by the disk result Hope that makes sense I ve drawn a marble diagrams below to try and explain Normal use case S1 returns then S2 returns bash SV 12 S1 1 S2 2 SR 1 2 Second case where S1 returns after S2 bash SV 12 S1 1 S2 2 SR 2 Perhaps you re looking for the amb operator https github com Netflix RxJava wiki Conditional and Boolean Operators#wiki amb @benjchristensen unfortunately not look at the first example if 1 returns before 2 then 2 still returns later if 2 returns before 1 1 is discarded amb just listens to the first emitted observable Your 1st example looks like merge to me S1 and S2 both emit and SR receives whatever S1 and S2 emit The 2nd looks like you have different conditions for whether S1 returns first or S2 returns first it seems you need conditional logic on each stream so that if S2 returns first you unsubscribe S1 otherwise if S1 responds you keep waiting for S2 Is that what you re saying is needed That sounds about right S1 should be unsubscribed when S2 emits S1 S2 emits when S3 emits etc On 27 February 2014 17 37 Ben Christensen notifications@github com wrote Your 1st example looks like merge to me S1 and S2 both emit and SR receives whatever S1 and S2 emit The 2nd looks like you have different conditions for whether S1 returns first or S2 returns first it seems you need conditional logic on each stream so that if S2 returns first you unsubscribe S1 otherwise if S1 responds you keep waiting for S2 Is that what you re saying is needed Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 921#issuecomment 36268541 I ll close this As you can do this with a Merge and TakeUntil methods slightly more involved but works none the less',RxJava,false,false,false
28186595,'Changes made while integrating it with our internal system','Added complete and error hooks to make the duration of events evident Changed the debug notification to removed the start nano and thread id to leave that up to the hook writer to decide if they want that added the source observerable to make linking operators together','RxJava pull requests #862 https netflixoss ci cloudbees com job RxJava pull requests 862 SUCCESS This pull request looks good',RxJava,true,false,false
28194192,'Observable creation from Subscriber T Unit for Scala','This PR adds the Subscriber type and Observable apply T Subscriber T Unit Additionally I made some tweaks in RxScalaDemo and I could remove all comments of the kind TODO something behaves weirdly here because now the weird behavior was gone Seems like there was some progress in RxJava core Sorry that this PR mixes several topics let me know if you want me to split it by topic cc @headinthebox @vjovanov','RxJava pull requests #863 https netflixoss ci cloudbees com job RxJava pull requests 863 SUCCESS This pull request looks good RxJava pull requests #864 https netflixoss ci cloudbees com job RxJava pull requests 864 SUCCESS This pull request looks good Seems like there was some progress in RxJava core Good to hear Is this intended as fixes for the 0 17 0 Release Candidate or for 0 17 1 Looking at this made me wonder why we deprecate public final static T Observable T create final OnSubscribeFunc T f Observable create observer subscription is a common case when you hook up to event based APIs Deprecating the above overload will force me to basically repeat public void call Subscriber super T observer Subscription s f onSubscribe observer if s null s observer observer add s What use case are you referring to Like this def mouseDrag Observable MouseEvent Observable create observer val handler EventHandler MouseEvent m observer onNext m target addEventHandler MouseEvent MOUSE_DRAGGED handler Subscription target removeEventHandler MouseEvent MOUSE_DRAGGED handler It would just be like this where the Subscription is registered instead of returned scala def mouseDrag Observable MouseEvent Observable create subscriber val handler EventHandler MouseEvent m subscriber onNext m target addEventHandler MouseEvent MOUSE_DRAGGED handler subscriber add target removeEventHandler MouseEvent MOUSE_DRAGGED handler If we do decide we want an overload it won t be the OnSubscribeFunc overload which is the wrong name It makes no sense to have OnSubscribe as the Subscriber Unit version and OnSubscribeFunc as the Observer Subscription one That looks so imperative to me Don t fully understand your comment about the overloads Java can handle overloading both Subscription Create Action Subscriber T and Subscription Create Func Observer T Subscription right Not sure what being imperative has to do with this difference scala subscriber add target removeEventHandler MouseEvent MOUSE_DRAGGED handler versus Subscription target removeEventHandler MouseEvent MOUSE_DRAGGED handler but I can understand a preference one direction versus the other This is the current signature java public final static T Observable T create OnSubscribe T f And OnSubscribe is defined as java public static interface OnSubscribe T extends Action1 Subscriber super T Thus with overloads you d end up with two things looking exactly the same java public final static T Observable T create OnSubscribe T f public final static T Observable T create OnOtherSubscribe T f Their types would be java public static interface OnSubscribe T extends Action1 Subscriber super T public static interface OnOtherSubscribe T extends Func1 Observer super T Subscription Isn t OnOtherSubscribe already OnSubscribeFunc Hence public final static T Observable T create OnSubscribeFunc T f Yes and we re killing it because the name is wrong and we intended on having only a single create method We named OnSubscribe what we did purposefully as OnSubscribeFunc was going away We re not going to have two methods with different signatures with basically the same name We re not going to have two methods with different signatures with basically the same name Isn t that the very definition of overloading Not when they are exactly the same Put these two next to each other without reading the docs which one should I use java public final static T Observable T create OnSubscribe T f public final static T Observable T create OnOtherSubscribe T f That does not bother me just as Add int int vs Add long long Of course it would be simpler if the aliases OnSubscribe and OnOtherSubscribe were not needed and we could just have public final static T Observable T create Action1 Subscriber super T f public final static T Observable T create Func1 Observer super T Subscription f The int and long examples are not good ones as those are primitive types that are clear in their types and all languages can disambiguate between them Having both an Action and a Function as overloads causes problems for dynamic languages The reason the OnSubscribeFunc behavior has those null checks is because to make Groovy work during the deprecation phase we had to write a plugin for Groovy that forces all executions against create to use the new one and then we look for a return value and if we got one behave one way or behave the other if we got null back https github com Netflix RxJava blob master language adaptors rxjava groovy src main java rx lang groovy RxGroovyExtensionModule java#L73 As for the aliases they are done because of the complexity of co contr variant generics that people must deal with every time they use create If we were to give up on ease of use for that problem and on the challenges of dynamic languages disambiguating between the overloads then yes the Action and Func overloads work well java public final static T Observable T create Action1 Subscriber super T f return new Observable T f public final static T Observable T create final Func1 Observer super T Subscription f return new Observable T new Action1 Subscriber super T @Override public void call Subscriber super T subscriber Subscription s f call subscriber if s null s subscriber subscriber add s Another consideration my understanding of the event listeners on Android and Swing are that they typically need to be far more involved that this example anyways due to thread scheduling logic For example take a look at this code https github com Netflix RxJava blob master rxjava contrib rxjava android src main java rx operators OperatorObserveFromAndroidComponent java#L68 Line 99 uses subscriber add https github com Netflix RxJava blob master rxjava contrib rxjava android src main java rx operators OperatorObserveFromAndroidComponent java#L99 Returning that Subscription instead of using add does not seem to significantly alter the fact that inside a function a lot of often imperative behavior happens Also common event listeners end up with cover libraries such as rxjava android and rxjava swing because they are non trivial and need to just be done correctly once Therefore I don t think the need of an overload is worth confusing the API by having two different ways of doing things with nuanced differences between them how they behave with synchronous sources For example in the version with Subscriber passed in a Subscription can be registered at the beginning so even if the rest of the function is synchronous and never returns the Subscription is registered and will still work I think it s better to have a single mechanism for create that pushes people to using the model in a way that works for both sync and async sources The side benefit is we don t have ambiguous methods or generics issues as we can stick with the OnSubscribe cover type we have Is this intended as fixes for the 0 17 0 Release Candidate or for 0 17 1 I d say 0 17 0 the earlier people can use it the better FYI this PR has no breaking changes',RxJava,true,false,false
28224241,'Localized Operator Error Handling','Do error handling in the lift function rather than try catch in subscribe since this catches at the operator level rather than for an entire sequence This then allows onErrorResumeNext and siblings to handle the error instead of it only being emitted to the final Subscriber I derived this fix while working on Hystrix 1 4','RxJava pull requests #865 https netflixoss ci cloudbees com job RxJava pull requests 865 FAILURE Looks like there s a problem with this pull request RxJava pull requests #866 https netflixoss ci cloudbees com job RxJava pull requests 866 SUCCESS This pull request looks good',RxJava,true,false,false
28226500,'Rxjava clojure bindings final','Clojure bindings for RxJava Rebased and cleaned up version of https github com Netflix RxJava pull 908 ready for merge Didn t really get any external feedback so I m assuming that means it s perfect','RxJava pull requests #867 https netflixoss ci cloudbees com job RxJava pull requests 867 FAILURE Looks like there s a problem with this pull request Very nice Looks like the build failure is a non deterministic signing issue with Scala so merging',RxJava,true,false,false
28289629,'TestSubscriber Default onError and Terminal Latch Behavior','','',RxJava,true,false,false
28292694,'TestSubscriber lastSeenThread','','',RxJava,true,false,false
28314029,'Fix deadlock in SubscribeOnBounded','Swap the subscription and the scheduling of pass through to allow progress of a bounded synchronous source','RxJava pull requests #868 https netflixoss ci cloudbees com job RxJava pull requests 868 SUCCESS This pull request looks good Merging but SubscribeOnBounded will likely be deleted as a result of work in https github com benjchristensen RxBackpressure',RxJava,true,false,false
28346570,'correct link to maven search','Fixes the link for the maven search now pointing to artifact id rxjava android','RxJava pull requests #869 https netflixoss ci cloudbees com job RxJava pull requests 869 SUCCESS This pull request looks good Thanks',RxJava,true,false,false
28353150,'Initial commit of the Android samples module','refs https github com soundcloud RxJava issues 3 I made it so that the samples project will automatically be pulled in as soon as it detects an Android SDK on the build machine otherwise it s ignore It also runs in a sub gradle so should not be affected by changes to the main project It does however automatically pull in and compile against the current project version Let me know what you think I kept the actual samples minimal for now I see this more as a tracer bullet for how the samples could fit into the current build setup','RxJava pull requests #870 https netflixoss ci cloudbees com job RxJava pull requests 870 FAILURE Looks like there s a problem with this pull request The test failure looks unrelated to this PR Sorry realized too late that the samples project wouldn t import into Android Studio when looked at in isolation i e outside the main project There was also a broken method reference Fixed that RxJava pull requests #875 https netflixoss ci cloudbees com job RxJava pull requests 875 FAILURE Looks like there s a problem with this pull request Okay this is actually a genuine failure It looks as if there s an Android SDK installed on the build server so it tried to compile the samples build The stack trace isn t very revealing though @gbenson nflx could you have a look at this Might involve digging around on the build machine to which I don t have access Do you guys have time to look into this Otherwise I d simply disable the sample app build for now even when a framework SDK is detected I haven t had a chance I m not familiar with the build machine Maybe try Ben I have no clue what to do with that nor do I know what the Android SDK is doing on a CloudBees build server Perhaps so Android apps can be built on their build slaves Ben how about I always exclude the samples build for the time being and enable it via an explicit task or build parameter Then it should not interfere with anything in the core build infrastructure On Mar 6 2014 7 04 AM Ben Christensen notifications@github com wrote I have no clue what to do with that nor do I know what the Android SDK is doing on a CloudBees build server Perhaps so Android apps can be built on their build slaves Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 930#issuecomment 36827758 Works for me RxJava pull requests #891 https netflixoss ci cloudbees com job RxJava pull requests 891 SUCCESS This pull request looks good RxJava pull requests #892 https netflixoss ci cloudbees com job RxJava pull requests 892 SUCCESS This pull request looks good RxJava pull requests #894 https netflixoss ci cloudbees com job RxJava pull requests 894 SUCCESS This pull request looks good RxJava pull requests #895 https netflixoss ci cloudbees com job RxJava pull requests 895 SUCCESS This pull request looks good @gbenson nflx @benjchristensen Feel free to merge this in any time Samples are of course a moving target but this project builds fine and is working and I already got a few samples in that cover the most useful use cases I could think of for now I was wondering do you see a way to make it easier to add code to the samples project in the future Opening a PR against the core project seems like process overhead for everyone involved unless you re fine with that I guess that s the downside of this living in the core project folder RxJava pull requests #896 https netflixoss ci cloudbees com job RxJava pull requests 896 SUCCESS This pull request looks good Matthias thanks for doing this Much appreciate it Not sure about the PRs against core project probably more on Ben I was wondering do you see a way to make it easier to add code to the samples project in the future The solution will be to split this out once we migrate away from the current home so RxAndroid has it s own place and have it managed and run by Android developers specifically such as yourself who manage the commits PRs releases etc @headinthebox and I are getting close to having that roadmap It should be in the timeframe of months In the meantime just keep sending the PRs and I ll merge them Thanks I forgot to mention @gbenson nflx you can trigger the samples build like so gradlew build PbuildAndroidSamples Without that property the build proceeds as usual and simply ignores the Android samples @mttkay If I execute gradlew build from the project root RxJava then things build without issue However when I run via gradlew build PbuildAndroidSamples from the root then I get Where Build file Users gbenson RxJava rxjava contrib rxjava android samples build wrapper build gradle line 5 What went wrong Execution failed for task rxjava contrib rxjava android samples build wrapper build g On Wed Mar 12 2014 at 10 23 AM Matthias K ppler notifications@github com wrote Thanks I forgot to mention @gbenson nflx https github com gbenson nflx you can trigger the samples build like so gradlew build PbuildAndroidSamples Without that property the build proceeds as usual and simply ignores the Android samples Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 930#issuecomment 37437231 Hi Greg Odd this works on my machine I wonder if I forgot to commit something or am relying on machine specific configuration Could you build with the i option to get the full error log It s difficult to say from over here why it s failing Also does it build if you enter the samples folder and invoke the samples build script directly i e without going through the build wrapper module Not a major issue Things are working on another machine I have If I see an issue again I ll try to fix For now happy to be playing with the samples g On Wed Mar 12 2014 at 2 13 PM Matthias K ppler notifications@github com wrote Hi Greg Odd this works on my machine I wonder if I forgot to commit something or am relying on machine specific configuration Could you build with the i option to get the full error log It s difficult to say from over here why it s failing Also does it build if you enter the samples folder and invoke the samples build script directly i e without going through the build wrapper module Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 930#issuecomment 37465995 Glad to hear',RxJava,true,false,false
28353302,'A number of improvements to OperatorObserveFromAndroidComponent','Could I get some eyes on this @tehmou @zsxwing @benjchristensen move the UI thread assert out of the operator and into the helpers this way we don t fail the observer anymore with an exception but the caller do not loop unsubscribe through the main thread anymore This unnecessarily defers releasing the references and might in fact be processed only after Android creates the component after a rotation change I had to make the references volatile for this to work immediately unsubscribe in case we detect the componentRef has become invalid This solves the problem that dangling observers would continue to listen to notifications with no observer alive anymore refs https github com Netflix RxJava issues 754 https github com Netflix RxJava issues 899','RxJava pull requests #871 https netflixoss ci cloudbees com job RxJava pull requests 871 SUCCESS This pull request looks good Looks good Is this ready to merge I would like to try and see if we can even get rid of the component binding and make this purely subscriber based Moreover I still need to find out why we even appear to need a weak binding whenever cache or replay are involved A filed a separate issue for that I have a hunch that ReplaySubject leaks observers in some cases even after unsubscribing Meanwhile did anyone else give this a whirl Ben can we hold on with landing this until next week I think I won t get to this before the weekend On Mar 6 2014 7 02 AM Ben Christensen notifications@github com wrote Is this ready to merge Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 931#issuecomment 36827668 @samueltardieu you mentioned you re using AndroidObservable a lot in one of your project Would appreciate your feedback on this PR and the discussions linked above since this PR deprecates OperatorObserveFromAndroidComponent due to the many issues it has and the small number of problems it actually solves A quick recap of those discussions fromActivity currently forces you to unsubscribe in onDestroy which can be a source of bugs context leaks fromFragment is not really useful for retained fragments since you don t really need to handle references to a retained fragment it s also not really useful for non retained fragments AFAICT unless you keep a strong reference to the attached activity in the subscriber the test for isAdded for fragments isn t actually required in those cases where you unsubscribe in onDestroyView and turned out to not be flexible extensible enough for some users see one of the two linked issues both fromFragment fromActivity return observables that cannot be subscribed to more than once which is a pretty big issue Man of these limitations are a direct result of me trying to find a one size fits all solution for observing long running sequences from activities and fragments but that turned out to be difficult to achieve In summary this leads me to believe that 1 we should nail down what the different use cases for subscriptions in Android UI components are and address them separately 1 start by solving the most pressing issue which is making it hard or impossible to accidentally leaking context refs through observers that are bound to a fragment or activity This addresses 2 OperatorWeakBinding transforms a sequence by binding the subscriber weakly and stops emitting items and unsubscribes from the sequence whenever it notices that the subscriber has been released This turned out to work very well with Activities no need to unsubscribe anymore and subscribing an activity or an inner observer through this operator makes sure we don t leak the activity For retained fragments a weak subscriber binding seems to only be required when using cache or replay on the source sequence and I haven t quite figured out yet why that is I also need to test a few edge cases with the many ways fragments can be used for instance in a fragment ViewPager the fragment life cycle is a little peculiar We have 8 occurrences of AndroidObservable fromActivity and one of AndroidObservable fromFragment used on a non retained fragment Long running or infinite or slow running observables are subscribed to in onResume and explicitly unsubscribed in onPause so we should have no leak there Short running and finite observables are not explicitly unsubscribed and we could on fromActivity for doing the right thing that is not calling onNext because it may use UI components that are no longer displayed I am conscious that the context is leaked as well as UI components through the subscriber but in our case there is never a long delay between two events so the references are freed soon enough not to be a problem As far as the fragment is concerned the subscription is created in onCreateView and unsubscribed from in onDestroy will change this for onDestroyView but since the fragment is not retained here this is not a concern so using AndroidObservable fromFragment is more a precaution here than anything else As in some activities the use of AndroidObservable fromXXX is more of a convenience in order to avoid writing observeOn AndroidSchedulers mainThread I had not realized that those observables could not be subscribed more than once While this is not a concern today it might certainly have bitten me in the future I agree this is problematic I have tried running the cgeo tests with the content of this PR and I could not notice anything wrong However I am puzzled when you talk about OperatorWeakBinding which is not in this PR right Does that mean that a reference to the subscriber has to be kept somewhere in the activity so that it does not get garbage collected prematurely Thanks for your input Sorry for the confusion I meant to reference this pull request https github com Netflix RxJava pull 938 It would obsolete any changes in here but for the time being they re still valuable @benjchristensen this is ready to merge then Let s assume that this operator will stick around until we ve found a satisfying solution whether that be #938 or something else Merging then Thanks',RxJava,true,false,false
28387191,'skip does not propagate unsubscribe','In the code below skip is commented out When run only generated 1 is printed since the subscriber unsubscribes upon receiving the first emit If skip 1 is uncommented the unsubscribe request is lost and all 10 values are generated skip needs to propagate the unsubscribe request from the downstream subscribers to the parent observable Observable Integer anObservable Observable create new OnSubscribe Integer @Override public void call Subscriber super Integer subscriber for int number Arrays asList 1 2 3 4 5 6 7 8 9 10 if subscriber isUnsubscribed return System out println generated number subscriber onNext number anObservable skip 1 subscribe new Subscriber Integer @Override public void onCompleted @Override public void onError Throwable throwable @Override public void onNext Integer number unsubscribe','The skip operator has not yet been migrated to the new lift Operator Subscriber pattern so does not yet correctly propagate Subscription on a synchronous Observable There are many operators not yet migrated it will take a while This one is pretty easy similar to take which is migrated so I could get to it soonish Testing a fix right now The skip operator is now rewritten and the test code above with skip 1 prints the expected two lines generated 1 generated 2',RxJava,false,false,false
28390107,'Implemented Skip using Lift in Observable and OperatorSkip','Deleted non time part from OperationSkip Moved tests to OperatorSkipTest','Following template of OperatorFilter RxJava pull requests #872 https netflixoss ci cloudbees com job RxJava pull requests 872 SUCCESS This pull request looks good And add unit tests to expose all the above as well as boundary conditions such as n 1 n 0 empty stream stream with exceptions',RxJava,true,false,false
28393113,'add Observable startWith Observable method and unit test','add Observable startWith Observable method and unit test I would like to avoid breaking method chaining when want to startWith an Observable rather than just an Iterator or specific values This is a very minor change as under the covers startWith uses concat anyway but it is significant in terms of code readability and is a natural completion of the startWith api','RxJava pull requests #873 https netflixoss ci cloudbees com job RxJava pull requests 873 FAILURE Looks like there s a problem with this pull request Looks like a regression that is unrelated to my pull request I suspect the involved test is non deterministic because it assumes that specific asynchronous work is done by the time the line latch await 1000 TimeUnit MILLISECONDS completes One second of lockup for the build machine and the test fails RxJava pull requests #874 https netflixoss ci cloudbees com job RxJava pull requests 874 SUCCESS This pull request looks good as suspected the failing test is non deterministic and nothing to do with this pull request I ll raise an issue Looks good Thanks',RxJava,true,false,false
28397874,'non deterministic test AbstractSchedulerConcurrencyTests testUnSubscribeForScheduler','CI reported a pull request build failure below that was unrelated to the pull request but rather from a non deterministic unit test AbstractSchedulerConcurrencyTests testUnSubscribeForScheduler CI report https netflixoss ci cloudbees com job RxJava pull requests 873 testReport junit rx schedulers NewThreadSchedulerTest testUnSubscribeForScheduler Suggest increasing the latch await timeout on line 88 or removing the timeout','I have seen similar failures many times in the cloudbee However it s hard to change them to be deterministic depends on the test I ve looked around the test codebase and latch await is used without a timeout in many places In theory dropping the timeout could mean that a test never finishes if a commit busts something but Jenkins can be configured to fail a build if it takes say 50 longer than normal I don t know if the netflix jenkins ci is configured this way for the pull requests job but might be worthwhile If it is configured in this way I wouldn t mind seeing the timeout dropped from tests that people are confident about Schedulers have been changed significantly and I haven t seen these failures in a while so closing out This is a non deterministic issue though so if it comes back we can re open or start a new issue',RxJava,false,false,false
28447427,'Skip fixed','Fixed state capture bug Added unit tests','RxJava pull requests #876 https netflixoss ci cloudbees com job RxJava pull requests 876 SUCCESS This pull request looks good',RxJava,true,false,false
28575247,'buffer continues buffering after error','Hi All I ve found a strange behavior when using buffer method My code looks like def buildSequence Observable Seq Int buildStream 10 toSeq toObservable map x Seq x buffer 100 millis 3 doOnEach x consume x buildSequence subscribe onNext x println s onNext x onError e println s ERROR e HELPER FUNCTIONS def threadId Thread currentThread getId def buildStream num Int Stream range 1 num map s println s threadId Taken s s def consume x Seq Int println s Thread currentThread getId consuming x if x contains 5 throw new Exception s threadId consume ha and the output of this simulation is 118 consuming Buffer 1 2 3 onNext Buffer 1 2 3 118 consuming Buffer 4 5 6 ERROR java lang Exception 118 consume ha 118 consuming Buffer 7 8 9 118 consuming Buffer res0 rx lang scala Subscription rx lang scala Subscription anon 2@60a976c6 consume Seq Int Unit Note that although onNext is not getting called after the exception doOnEach is called after the exception until all the sequence is consumed change buildStream 10 to buildStream 100 and you will see how all the buffers are created Note also that without buffer it doesn t happen uncomment map comment buffer a sequence stops being observed immediately after the exception happen Expected behavior Observing sequence must stop immediately after the exception happen doForEach should not be called','Hi I think this is the common issue with synchronous sources and pre 0 17 versions 0 17 is aimed at fixing such problems but not sure if buffer works or has to be retrofitted This was found in 0 17 0 RC6 Interestingly enough even without using buffer I still see Rx consuming a sequence after onError has been called for an item It is easy to see by adding map x println s emitted x x to the query Although these values are not propagated to the observer there are a number of them being consumed from the sequence after the process fails Which can be very bad and can lead to very unfortunate situations for example if you try to observe a sequence from a queue or a kafka topic Messages may simply get lost consumed behind the scene and no one will ever know about it Something is wrong around how errors are treated in 0 17 0 RC6 that is probably an artifact that not all of operators have been converted to using lift and few of observable sources aren t using OnSubscribe call Subscriber R There are also probably more than a few bugs Up to 0 16 all of our testing has been around the down stream behavior In 0 17 we can just now address the upstream behavior with synchronous streams Is there a way for me to workaround the issue calling lift manually etc You d need to rewrite the entire buffer operator for lift java public class BufferWithTime T implements Operator List T T final long time final TimeUnit unit final Scheduler scheduler public BufferWithTime int capacity long time TimeUnit unit Scheduler scheduler this time time this unit unit this scheduler scheduler @Override public Subscriber super T call Subscriber super List T t1 BufferSubscriber T src new BufferSubscriber T t1 t1 add src src add scheduler schedule src time unit return src static final class BufferSubscriber T extends Subscriber T implements Action1 Inner final Subscriber super List T observer final Object guard new Object List T buffer new ArrayList T BufferSubscriber Subscriber super List T observer this observer observer @Override public void call Inner t1 boolean uns false synchronized guard if buffer null List T b buffer buffer new ArrayList T try observer onNext b catch Throwable t buffer null observer onError t uns true if uns unsubscribe @Override public void onNext T t synchronized guard if buffer null buffer add t @Override public void onError Throwable e synchronized guard emitAndNull observer onError e @Override public void onCompleted synchronized guard emitAndNull observer onCompleted void emitAndNull List T b buffer buffer null observer onNext b We have retrofitted the buffer operators Could you check if they work for your case @AlexeyRaga Can you confirm with the latest releases whether this is now solved Closing due to inactivity please reopen if necessary',RxJava,false,false,false
28578395,'RFC First implementation of OperatorWeakBinding','Preview of the new Android operator that weakly binds to a fragment or activity see discussion in https github com Netflix RxJava issues 899 This is missing unit tests not sure how to unit test something based on weak references will investigate','RxJava pull requests #877 https netflixoss ci cloudbees com job RxJava pull requests 877 FAILURE Looks like there s a problem with this pull request Couldn t you in addition check Activity#isFinishing to prevent values from being delivered to a dying or already dead activity That should not be necessary and it is something that we only realized after writing the very first version of the current operator Android guarantees that it will not process messages entering the main looper while the current Activity is in the process of being recreated that is between calls to onDestroy of instance A and onCreate of instance B of the same class So as long as you use OperatorWeakBinding with the main thread scheduler any Rx notifications will be queued up until after onCreate should they arrive while the Activity is gone bindActivity in AndroidObservable combines the two to achieve this Does that make sense I am more concerned about what happens when the activity is gone replaced by another one but not yet reclaimed by the GC Won t items be delivered to the UI thread which is now unrelated to the previous activity No that s what I tried to say Android stops processing the main looper during a configuration change Since HandlerThreadScheduler posts notifications to a looper they will queue up until your activity exists again We obviously don t understand each other I ll try again I m not talking about the case where the activity is recreated but where it is destroyed and another unrelated activity is started The same thread can be reused for the UI of the new activity and AFAIK but I may be wrong the looper is tied to a thread not to the activity I understand that the looper will be suspended between the previous activity death and the new activity creation but won t queued messages then be delivered to the new activity which would use the same looper as the previous one I have had cases where messages were delivered through a Handler to a destroyed activity which manifested through an error while attempting to do UI operations on now not displayed components and I wonder whether this could be the case here Not if you unsubscribe from the Activity subscriber in onDestroy or let the weak binding do that for you Am I missing something On Mar 7 2014 9 42 AM Samuel Tardieu notifications@github com wrote We obviously don t understand each other I ll try again I m not talking about the case where the activity is recreated but where it is destroyed and another unrelated activity is started The same thread can be reused for the UI of the new activity and AFAIK but I may be wrong the looper is tied to a thread not to the activity I understand that the looper will be suspended between the previous activity death and the new activity creation but won t queued messages then be delivered to the new activity which would use the same looper as the previous one I have had cases where messages were delivered through a Handler to a destroyed activity which manifested through an error while attempting to do UI operations on now not displayed components and I wonder whether this could be the case here Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 938#issuecomment 36977549 The weak binding will unsubscribe when the activity is freed by the garbage collector This may happen a long time after the activity is destroyed This is not a synchronous process as it would be in Python where references are reference counted Here we have to wait until the garbage collector decides to collect unreferenced objects for the weak reference to become null of course when unsubscribing explicitly there is no problem FWIW I should add that the implementation you re now using does not check for isFinishing and I wasn t able to reproduce this scenario in the tests I ran with OperatorWeakBinding I will give it another closer look though Moreover if we find we do need this check after all I suggest we follow the advice from the first issue linked which is to pass a predicate to the operator that can perform such checks or alternatively call filter on the result of the weak binding @samueltardieu Sorry for the delay finally got time to work on this You were right there is a case in which this can still happen which is when exiting the activity via the back button I still couldn t reproduce it when going through a rotation change but that case is sufficient to warrant a change or extension to this My suggestion is then to extend this operator to also address what @tehmou asked for which is to be able to pass in a predicate that tests for validity of the bound component This could be isFinishing for an activity or isAdded for a fragment I would like to keep the operator itself to remain fairly generic where it would perform the following things weakly bind a reference of R weakly bind the subscriber accept a predicate in the constructor that performs tests on the R instance for every notification this test can then be customized but the bindActivity and bindFragment helpers could still pass a default predicate implementing above mentioned checks Does that make sense I ll implement this run some tests and then push it for you guys to reviews RxJava pull requests #898 https netflixoss ci cloudbees com job RxJava pull requests 898 FAILURE Looks like there s a problem with this pull request RxJava pull requests #899 https netflixoss ci cloudbees com job RxJava pull requests 899 SUCCESS This pull request looks good RxJava pull requests #900 https netflixoss ci cloudbees com job RxJava pull requests 900 SUCCESS This pull request looks good RxJava pull requests #901 https netflixoss ci cloudbees com job RxJava pull requests 901 SUCCESS This pull request looks good',RxJava,true,false,false
28588715,'ReplaySubject leaks subscribers even after unsubscribing','On Android a common use case is to cache or replay an observable to UI components that might get temporarily destroyed due to e g screen rotations The biggest challenge on Android when using RxJava is therefore to make sure that no resource leaks occur since subscribers however might be inner classes of an Android Activity or Fragment if you re unfamiliar think screen object those will leak if strong references held within an operator are not released when unsubscribing from the sequence I just noticed that when using e g cache on a long running sequence and subscribing and unsubscribing multiple times the observer I subscribe to the sequence never seems to get finalized Android s StrictMode indeed reports that the observer and hence the entire screen is being leaked E StrictMode 2791 class com netflix rxjava android samples RetainedCacheFragmentActivity instances 2 limit 1 E StrictMode 2791 android os StrictMode InstanceCountViolation class com netflix rxjava android samples RetainedCacheFragmentActivity instances 2 limit 1 E StrictMode 2791 class com netflix rxjava android samples RetainedCacheFragmentActivity instances 3 limit 1 E StrictMode 2791 android os StrictMode InstanceCountViolation class com netflix rxjava android samples RetainedCacheFragmentActivity instances 3 limit 1 E StrictMode 2791 class com netflix rxjava android samples RetainedCacheFragmentActivity instances 4 limit 1 E StrictMode 2791 android os StrictMode InstanceCountViolation class com netflix rxjava android samples RetainedCacheFragmentActivity instances 4 limit 1 E StrictMode 2791 class com netflix rxjava android samples RetainedCacheFragmentActivity instances 5 limit 1 E StrictMode 2791 android os StrictMode InstanceCountViolation class com netflix rxjava android samples RetainedCacheFragmentActivity instances 5 limit 1 E StrictMode 2791 class com netflix rxjava android samples RetainedCacheFragmentActivity instances 6 limit 1 E StrictMode 2791 android os StrictMode InstanceCountViolation class com netflix rxjava android samples RetainedCacheFragmentActivity instances 6 limit 1 I quickly glanced over the ReplaySubject subscription handling code and it looks as if on unsubscribe it removes the observer from the internal map maybe that s broken however','We re observing the leakage on replaying as well using version 0 17 0 RC7 It seems that ReplaySubject uses some replayState map within its ReplayState that keeps references to the subscribers We currently work around the issue by avoiding non static inner classes as subscribers and voiding references to activity fragment bound variables explicitly in onComplete This of course only minimizes the impact of the leakage Any better suggestions of how to handle that I think this issue and some related problems with ReplaySubject are now fixed Could you confirm close this issue I can confirm this is fixed for us Thanks @mttkay for the confirmation',RxJava,false,false,false
28645111,'refactor the debug hooks before they become a breaking change','The number of call backs started at one and grew to four and managing them all separately was cumbersome This will bring some sanity back to the debug hook API I ve made one to tiny change to OnSubscribeFromIterable It now checks if the subscriber is unsubscribed before calling onCompleted','RxJava pull requests #878 https netflixoss ci cloudbees com job RxJava pull requests 878 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
28685195,'Is there any way to get a Scheduler from OnSubscribe function','Hello My Observable is very simple and looks like java Observable create new Observable OnSubscribe Content @Override public void call final Subscriber super Content subscriber final ContentObserver observer new ContentObserver @Override public void onContentChanged subscriber onNext loadContent subscriber add Subscriptions create new Action0 @Override public void call unregisterContentObserver observer registerContentObserver observer subscriber onNext loadContent loadContent is a heavy operation and have to be executed on the background thread which is provided by the Scheduler that I pass to subscribeOn method PROBLEM onContentChanged is always invoked from the UI thread and this cannot be changed so I need to reschedule loadContent call to the background thread but I failed to find a way to get a current Scheduler What is the right way to do it','Is it possible to move loadContent to Subscriber Then you can use observeOn to dispatch the messages to a Scheduler so I need to reschedule loadContent call to the background thread but I failed to find a way to get a current Scheduler You said onContentChanged is always invoked from the UI thread so what do you mean of current Scheduler If you just want to reschedule loadContent call to a background thread you can use Schedulers io Schedulers computation or Schedulers newThread Is it possible to move loadContent to Subscriber Then you can use observeOn to dispatch the messages to a Scheduler Could you please elaborate what do you mean of current Scheduler By current Scheduler I mean the Scheduler I passed to the subscribeOn method I know that I can make the Observable know about the Scheduler and the code will be like java final Scheduler scheduler Schedulers executor Executors newFixedThreadPool 3 final Observable Content observable Observable create new Observable OnSubscribe Content @Override public void call final Subscriber super Content subscriber final ContentObserver observer new ContentObserver @Override public void onContentChanged scheduler schedule new Action1 Scheduler Inner @Override public void call Scheduler Inner inner subscriber onNext loadContent subscriber add Subscriptions create new Action0 @Override public void call unregisterContentObserver observer registerContentObserver observer subscriber onNext loadContent subscribeOn scheduler I m just interested if it s possible to make this knowledge about the Scheduler more implicit Could you please elaborate I m not sure if the following example is what you want java Observable create new Observable OnSubscribe Content @Override public void call final Subscriber super Content subscriber final ContentObserver observer new ContentObserver @Override public void onContentChanged subscriber onNext null subscriber add Subscriptions create new Action0 @Override public void call unregisterContentObserver observer registerContentObserver observer subscriber onNext null observeOn scheduler map new Func1 Void Content @Override public Content call Void ignored return loadContent @zsxwing Don t like the solution but it does what I need Thank for the help @mironov nsk Are you suggesting some kind of ThreadLocal that would allow retrieving the current Scheduler if running within one If so that s an interesting idea It could be something like Schedulers current which could return null if not inside one or Immediate perhaps which is a no op so as to not worry about null or the real Scheduler I m not 100 certain it would work but it would be interesting to explore It could be useful for trampolining and recursive scheduling particularly when subscribeOn is used I don t have time to pursue this right now but if you or anyone else wants to play with it and propose something for review I d be interested @benjchristensen yes something like Schedulers current is really what I want Was too curious to not try here s a simple experiment with NewThreadScheduler https github com Netflix RxJava pull 946 files Here it is working with subscribeOn java Observable create new OnSubscribe Integer @Override public void call final Subscriber super Integer s c incrementAndGet Schedulers current schedule new Action1 Inner @Override public void call Inner t1 c incrementAndGet s onCompleted subscribeOn Schedulers newThread subscribe ts This would be great I literally needed something like this 2 days ago I ended up injecting the scheduler instead Dylan Sale On 6 Mar 2014 17 10 Ben Christensen notifications@github com wrote Here it is working with subscribeOn Observable create new OnSubscribe Integer @Override public void call final Subscriber super Integer s c incrementAndGet Schedulers current schedule new Action1 Inner @Override public void call Inner t1 c incrementAndGet s onCompleted subscribeOn Schedulers newThread subscribe ts Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 941#issuecomment 36829181',RxJava,false,false,false
28768322,MathObservable,'Moving the average sum min max functionality to the MathObservable similar to StringObservable Similar to the rxjava string module this is seeking to achieve the goal of keeping rxjava core focused on core functionality','RxJava pull requests #879 https netflixoss ci cloudbees com job RxJava pull requests 879 SUCCESS This pull request looks good Hi being a fan of method chaining I d like to see more Operator implementations of for example the math operations and many more Moreover I d like to have an idiom tested and confirmed by you experts to do this easily for my own stuff To that end do you think it would be of value to include in the library something like the class below One possibility would be to add the toOperator static method to the Observable class java import rx Observable import rx Observable Operator import rx Subscriber import rx functions Func1 import rx subjects PublishSubject Converts an Operation a function converting one Observable into another into an @link Operator @param R to type @param T from type public class OperatorFromOperation R T implements Operator R T public static R T Operator R T toOperator Func1 Observable T Observable R operation return new OperatorFromOperation R T operation The operation to convert private final Func1 Observable T Observable R operation Constructor @param operation to be converted into @link Operator public OperatorFromOperation Func1 Observable T Observable R operation this operation operation @Override public Subscriber super T call Subscriber super R subscriber final PublishSubject T subject PublishSubject create Subscriber T result createSubscriber subject subscriber add result operation call subject subscribe subscriber return result Creates a subscriber that passes all events on to the subject @param subject receives all events @return private static T Subscriber T createSubscriber final PublishSubject T subject return new Subscriber T @Override public void onCompleted subject onCompleted @Override public void onError Throwable e subject onError e @Override public void onNext T t subject onNext t What could you do with operation that couldn t be done with map Func1 T R or flatMap Func1 T Observable R An operation acts upon the observable as a whole not on the individual items like map and flatMap do For example map and flatMap themselves could be considered as operations operators On 9 Mar 2014 04 41 George Campbell notifications@github com wrote What could you do with operation that couldn t be done with map Func1 T R or flatMap Func1 T Observable R Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 942#issuecomment 37103999 I don t understand what use cases are trying to be solved by that code can you provide some examples please So for instance if I want to use sumInteger in the middle of a chain of method calls I need to use lift so I need an operator form of it I make an operator form of it by implementing a call to sumInteger in a Func1 Observable Integer Observable Integer and then call toOperator func as described in my example to give me an operator I would prefer if there were operator forms of all the static observable methods I suppose but it least this conversion was part of the codebase that would make life easier I should mention that method chained calls are important to me because the functional attractiveness of rxjava is weakened significantly every time I have to break the chain with some wrapper call In communicating the elegance of rxjava to my colleagues my case is weakened by those breaks in the chain I m a big fan of lift for this reason I m still new to rxjava so let me know if I m missing something obvious here Cheers Dave On 11 March 2014 03 26 Ben Christensen notifications@github com wrote I don t understand what use cases are trying to be solved by that code can you provide some examples please Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 942#issuecomment 37202146 To add an explicit example I ve found the method RxUtil toOperator as described above useful when I want to use an operation like sumInteger in an operator form with lift To use it I write private final Operator Integer Integer SUM_INTEGER RxUtil toOperator new Func1 Observable Integer Observable Integer @Override public Observable Integer call Observable Integer source return MathObservable sumInteger source Then I can write Observable from asList 1 2 3 lift SUM_INTEGER On 11 March 2014 08 07 Dave Moten davidmoten@gmail com wrote So for instance if I want to use sumInteger in the middle of a chain of method calls I need to use lift so I need an operator form of it I make an operator form of it by implementing a call to sumInteger in a Func1 Observable Integer Observable Integer and then call toOperator func as described in my example to give me an operator I would prefer if there were operator forms of all the static observable methods I suppose but it least this conversion was part of the codebase that would make life easier I should mention that method chained calls are important to me because the functional attractiveness of rxjava is weakened significantly every time I have to break the chain with some wrapper call In communicating the elegance of rxjava to my colleagues my case is weakened by those breaks in the chain I m a big fan of lift for this reason I m still new to rxjava so let me know if I m missing something obvious here Cheers Dave On 11 March 2014 03 26 Ben Christensen notifications@github com wrote I don t understand what use cases are trying to be solved by that code can you provide some examples please Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 942#issuecomment 37202146 I think perhaps I should simplify my original question Suppose I have a static function like public static R T Observable T something Observable R source anything here of course return source map someTransform retry take 100 What is the simplest way to make an Operator out of it so that I can use it with lift If the answer is longer than the toOperator method usage that I m proposing then I d be interested in having toOperator in the library On 12 March 2014 11 35 Dave Moten davidmoten@gmail com wrote To add an explicit example I ve found the method RxUtil toOperator as described above useful when I want to use an operation like sumInteger in an operator form with lift To use it I write private final Operator Integer Integer SUM_INTEGER RxUtil toOperator new Func1 Observable Integer Observable Integer @Override public Observable Integer call Observable Integer source return MathObservable sumInteger source Then I can write Observable from asList 1 2 3 lift SUM_INTEGER On 11 March 2014 08 07 Dave Moten davidmoten@gmail com wrote So for instance if I want to use sumInteger in the middle of a chain of method calls I need to use lift so I need an operator form of it I make an operator form of it by implementing a call to sumInteger in a Func1 Observable Integer Observable Integer and then call toOperator func as described in my example to give me an operator I would prefer if there were operator forms of all the static observable methods I suppose but it least this conversion was part of the codebase that would make life easier I should mention that method chained calls are important to me because the functional attractiveness of rxjava is weakened significantly every time I have to break the chain with some wrapper call In communicating the elegance of rxjava to my colleagues my case is weakened by those breaks in the chain I m a big fan of lift for this reason I m still new to rxjava so let me know if I m missing something obvious here Cheers Dave On 11 March 2014 03 26 Ben Christensen notifications@github com wrote I don t understand what use cases are trying to be solved by that code can you provide some examples please Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 942#issuecomment 37202146 We should add an overload for lift that takes an Observable Observable function Very much like http msdn microsoft com en us library hh229147 v vs 103 aspx This is on the TODO list or you can try to build it yourself and submit a pull request Note it should allow subscribing more than once in the lambda hence publish in NET We should add an overload for lift that takes an Observable Observable function 1 I ll make a pull request with the lift method overload as suggested Dave On 13 March 2014 13 41 Shixiong Zhu notifications@github com wrote We should add an overload for lift that takes an Observable Observable function 1 Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 942#issuecomment 37494316 I think we already have that publish method https github com akarnokd RxJava blob master rxjava core src main java rx Observable java#L5428 which relies on OperationMulticast If you could reimplement it to OperatorMulticast we would gain a lot of operators I m a bit lost about the reference to publish method that started with headinthebox s comment I am not talking about adding a publish method I am talking about adding a toOperator method or overload on lift method that does the same thing Dave @benjchristensen what do you think about the addition of an overload for lift that takes a Func1 Observable T Observable R Should I go ahead with a pull request',RxJava,true,false,false
28850594,'Observable retry does not unsubscribe from source','This unit test fails against 0 17 0 RC6 java import static org junit Assert assertEquals import java util concurrent atomic AtomicInteger import org junit Test import rx Subscription import rx functions Action1 import rx subjects PublishSubject public class OperationRetryTest2 @Test public void testUnsubscribeFromRetry PublishSubject Integer subject PublishSubject create final AtomicInteger count new AtomicInteger 0 Subscription sub subject retry subscribe new Action1 Integer @Override public void call Integer n count incrementAndGet subject onNext 1 sub unsubscribe subject onNext 2 assertEquals 1 count get','I believe this requires migrating OperationRetry to OperatorRetry using the new lift approach so the synchronous unsubscribe is propagated Thanks Ben I look forward to trying out the next RC release Dave',RxJava,false,false,false
28851962,'OperationRetry OperatorRetry','Updated to use lift and Subscriber Fixes https github com Netflix RxJava issues 943 Observable retry does not unsubscribe from source','',RxJava,true,false,false
28852107,'Manual Merge 940','Fixes https github com Netflix RxJava pull 940 via manual merge','RxJava pull requests #880 https netflixoss ci cloudbees com job RxJava pull requests 880 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
28853387,'Experimenting with Schedulers currentScheduler','Experimenting based on conversation at https github com Netflix RxJava issues 941#issuecomment 36827374','RxJava pull requests #881 https netflixoss ci cloudbees com job RxJava pull requests 881 FAILURE Looks like there s a problem with this pull request The things this would need to solve before being production worth are 1 Preferably hook into some abstract class so that each Scheduler doesn t need to correctly hook up the notifications 2 What do we do when not in a Scheduler Use the trampoline 3 Handle nested Schedulers similar to how Hystrix does it https github com Netflix Hystrix blob master hystrix core src main java com netflix hystrix Hystrix java#L90 Closing out as not ready to pursue this',RxJava,true,false,false
29023354,'Weird behavior of groupby','The following code java public static void main String args BlockingObservable GroupedObservable Integer Integer grouped Observable from Arrays asList 1 2 1 groupBy new Func1 Integer Integer @Override public Integer call Integer t1 return t1 toBlockingObservable for GroupedObservable Integer Integer o grouped toIterable System out println key o getKey for int i o toBlockingObservable toIterable System out println value i will output key 1 key 2 But I think it should have outputted key 1 value 1 value 1 key 2 value 2 It s because OperatorGroupBy uses PublishSubject So if GroupedObservable is not subscribed in time GroupedObservable will only send onCompleted In this example GroupedObservable is used after 1 2 1 is emitted so 1 2 1 are all dropped by PublishSubject Changing PublishSubject to ReplaySubject can get the result that I want This example is inspired by Joakim at https groups google com forum # topic rxjava KP0kW1MkT2c','It s a time gap issue See here https github com Netflix RxJava issues 844 Ben Christensen Netflix Edge Engineering 1 310 782 5511 @benjchristensen On March 8 2014 at 7 19 05 AM Shixiong Zhu notifications@github com wrote The following code public static void main String args BlockingObservable GroupedObservable Integer Integer grouped Observable from Arrays asList 1 2 1 groupBy new Func1 Integer Integer @Override public Integer call Integer t1 return t1 toBlockingObservable for GroupedObservable Integer Integer o grouped toIterable System out println key o getKey for int i o toBlockingObservable toIterable System out println value i will output key 1 key 2 But I think it should have outputted key 1 value 1 value 1 key 2 value 2 It s because OperatorGroupBy uses PublishSubject So if GroupedObservable is not subscribed in time GroupedObservable will only send onCompleted In this example GroupedObservable is used after 1 2 1 is emitted so 1 2 1 are all dropped by PublishSubject Changing PublishSubject to ReplaySubject can get the result that I want This example is inspired by Joakim at https groups google com forum # topic rxjava KP0kW1MkT2c Reply to this email directly or view it on GitHub Sorry that I didn t read it carefully Closed it We can t use ReplaySubject without causing other problems so this is still an unsolved issue These issues exist in Rx Net as well so it s not a trivial fix for something that has already been figured out I forgot to mention that I used 0 17 RC6 to get the output mentioned in the email I sent I read the discussions in https github com Netflix RxJava issues 844 and linked issues after I d sent my email and got the impression that some work had been done in the 0 17 branch to mitigate some of these time gap issues If those mitigations won t work for the very real example from my rxjava using project what is the suggested workaround to minimize or avoid the time gap issue when using group by suggested workaround Right now the only way I m aware of is using something like replay to buffer during the time gap But it needs to be done with a limit obviously otherwise it s a memory leak This is not an ideal solution but is a workaround To be clear this issue exists on a hot observable such as comes out of groupBy combined with PublishSubject and subscribeOn which introduces the time gap A proper solution is still being considered',RxJava,false,false,false
29030585,'OperationAll to OperatorAll','Replaced the OperationAll to an OperatorAll Caveat I am a newbie here hoping to learn so please do not spare me I saw a remark on performancetests but noticed they were not applied everywhere so I left them out I saw no issue yet asking for this work this is on invitation from Erik Meijer at QCON yesterday If you want me to I can tackle some other operations as well','RxJava pull requests #882 https netflixoss ci cloudbees com job RxJava pull requests 882 SUCCESS This pull request looks good',RxJava,true,false,false
29038590,'HandlerThreadScheduler fix','It s a best practice in android to check the current thread before using Handler post and Handler postDelayed because it can help to avoid unwanted UI blinks','RxJava pull requests #883 https netflixoss ci cloudbees com job RxJava pull requests 883 FAILURE Looks like there s a problem with this pull request RxJava pull requests #884 https netflixoss ci cloudbees com job RxJava pull requests 884 FAILURE Looks like there s a problem with this pull request I don t see any build problems on my machine Thank you @mironov nsk Can anyone else working on Android review this please cc @mttkay @zsxwing @mironov nsk There is a potential problem in your approach For the recursive schedule it may throw StackOverflowError E g java @Test public void testRecursiveSchedule Observable from 1 repeat 100000 AndroidSchedulers mainThread subscribe new Subscriber Integer @Override public void onCompleted @Override public void onError Throwable e e printStackTrace @Override public void onNext Integer t System out println t @zsxwing indeed but I m not sure how to fix it properly Is it ok to use TrampolineScheduler here Then InnerHandlerThreadScheduler will be like java private static class InnerHandlerThreadScheduler extends Inner private final CompositeSubscription subscription new CompositeSubscription private final Handler handler public InnerHandlerThreadScheduler final Handler handler this handler handler @Override public void unsubscribe subscription unsubscribe @Override public boolean isUnsubscribed return subscription isUnsubscribed @Override public void schedule final Action1 Inner action final long delayTime final TimeUnit unit final long millis unit toMillis delayTime if millis 0 handler getLooper Looper myLooper subscription add Schedulers trampoline schedule action return handler postDelayed new Runnable @Override public void run if isUnsubscribed subscription add Schedulers trampoline schedule action millis @Override public void schedule final Action1 Inner action schedule action 0 TimeUnit MILLISECONDS I was wondering have we actually measured what the performance gain is here I wanna make sure we re not prematurely optimizing since reasoning about correctness of the scheduler apparently got harder One reason I ask is because I used to have the same hunch before and experimented with a similar change to one of the earlier implementations of this scheduler but when I put theory to practice and measured the gain from this it was essentially zero so I discarded it again Might be because Android already optimizes for these cases internally In any even I totally see where you re coming from with this change but I wouldn t want to land it unless we have some hard numbers to back this up as in improves time to notification in cases of scheduling from the target thread by x percent @mttkay performance is not a goal here This simple change fixed 2 bugs in my app If you are interested I can describe them in more details Oh I see Yeah sure I think it s important everyone understands why changes are being made since changes here will affect all Android apps using RxJava Just found another problem Even using TrampolineScheduler to avoid StackOverflowError it may cause Application Not Responding as the UI thread may be occupied too long In my opinion keeping HandlerThreadScheduler consistent with Handler is better Android developers have already been familiar with it @mttkay ok I have a Fragment that shows list of items provided by the web service The progress bar is shown while the data is being loaded So may onViewCreated method looks like java @Override public void onViewCreated View view Bundle savedInstanceState super onViewCreated view savedInstanceState progress setVisibility View VISIBLE getWebServiceRequestAsObservable subscribeOn Schedulers io observeOn AndroidSchedulers mainThread subscribe new SimpleObserver @Override public void onNext List String values progress setVisibility View GONE adapter swap values getWebServiceRequestAsObservable caches the result so onNext can be executed immediately First bug In case the result is already cached I would prefer not to see a ProgressBar at all AndroidSchedulers mainThread delays onNext execution for a few milliseconds so ProgressBar is still visible for a very short period of time which is not very good for user experience Second bug Android can automatically save views state like ListView scroll position selected item etc and then restore it during fragment recreation In order to get it work in my case I have to populate the adapter during onViewCreated call But onNext execution is delayed by HandlerThreadScheduler so view state isn t properly restored This pull request fixes both issues @mironov nsk from subscribeOn Schedulers io onNext will be emitted in the Schedulers io then be sent to AndroidSchedulers mainThread So there is always a delay Why this PR can fix this problem Can you change getWebServiceRequestAsObservable to something like the following example java Observable List String getWebServiceRequestAsObservable if cachedValue null return Observable create send the web request and fetch the value subscribeOn Schedulers io observeOn AndroidSchedulers mainThread else return Observable from cachedValue This should solve your problem FWIW in our app we do what Shixiong suggested i e emit a cached result directly without going through the main looper again If we can solve this in the operator in a straight forward way that d be great but not convinced the complexity introduced e g by TrampolineScheduler warrants that from subscribeOn Schedulers io onNext will be emitted in the Schedulers io then be sent to AndroidSchedulers mainThread So there is always a delay Ooops my bad It s just a poorly chosen example the real Observable is a bit different Anyway I got your idea how it can be fixed without changing HandlerThreadScheduler Should I close this PR then Should I close this PR then Yes if you agree that this PR is not necessary',RxJava,true,false,false
29040412,'Add support for Eclipse PDE','Add support for Eclipse PDE handling OSGi fragments http help eclipse org kepler index jsp topic 2Forg eclipse platform doc isv 2Freference 2Fmisc 2Fbundle_manifest html see also #849','RxJava pull requests #885 https netflixoss ci cloudbees com job RxJava pull requests 885 SUCCESS This pull request looks good',RxJava,true,false,false
29057202,'OperatorTimeoutBase unsubscribe from source','If no other observable is supplied to the OperatorTimeout public final Observable T timeout long timeout java util concurrent TimeUnit timeUnit then it does not unsubscribe from the source in the event of a timeout','RxJava pull requests #886 https netflixoss ci cloudbees com job RxJava pull requests 886 FAILURE Looks like there s a problem with this pull request @rbramw Can you please provide a unit test to demonstrate the issue this is fixing Here are 3 tests which can be added to OperatorTimeoutTests java demonstrating the issue I see when using the timeout method As @zsxwing pointed out I don t think my fix is providing anything extra so please ignore it @Test public void shouldUnsubscribeFromUnderlyingSubscriptionOnTimeout final Subscription s mock Subscription class an observable which never emits anything Observable String never Observable create new OnSubscribe String public void call Subscriber super String subscriber System out println Never Observable subscribed to subscriber add s when wrapped in a timeout observable Observable String observableWithTimeout never timeout 1 TimeUnit MILLISECONDS try observableWithTimeout toBlockingObservable forEach new Action1 String public void call String t1 fail Never Observable should not have emited an item t1 fail Never Observable should not have completed catch Throwable ex System out println observableWithTimeout emitted error ex getMessage should unsubscribe verify s times 1 unsubscribe @Test public void shouldUnsubscribeFromUnderlyingSubscriptionOnImmediatelyComplete final Subscription s mock Subscription class Observable String immediatelyComplete Observable create new OnSubscribe String public void call Subscriber super String subscriber System out println ImmediatelyComplete Observable subscribed to subscriber add s subscriber onCompleted Observable String observableWithTimeout immediatelyComplete timeout 1 TimeUnit SECONDS try observableWithTimeout toBlockingObservable forEach new Action1 String public void call String t1 fail ImmediatelyComplete Observable should not have emited an item t1 System out println ImmediatelyComplete completed verify s times 1 unsubscribe catch Throwable ex fail ImmediatelyComplete Observable should not emited an error ex getMessage @Test public void shouldUnsubscribeFromUnderlyingSubscriptionOnImmediatelyErrored final Subscription s mock Subscription class Observable String immediatelyError Observable create new OnSubscribe String public void call Subscriber super String subscriber System out println immediatelyErrored Observable subscribed to subscriber add s subscriber onError new RuntimeException Error Observable String observableWithTimeout immediatelyError timeout 1 TimeUnit SECONDS try observableWithTimeout toBlockingObservable forEach new Action1 String public void call String t1 fail immediatelyErrored Observable should not have emited an item t1 fail immediatelyErrored Observable should not have completed catch Throwable ex System out println observableWithTimeout emitted error ex getMessage verify s times 1 unsubscribe Here are 3 tests which can be added to OperatorTimeoutTests java demonstrating the issue I see when using the timeout method As @zsxwing pointed out I don t think my fix is providing anything extra so please ignore it @Test public void shouldUnsubscribeFromUnderlyingSubscriptionOnTimeout final Subscription s mock Subscription class an observable which never emits anything Observable String never Observable create new OnSubscribe String public void call Subscriber super String subscriber System out println Never Observable subscribed to subscriber add s when wrapped in a timeout observable Observable String observableWithTimeout never timeout 1 TimeUnit MILLISECONDS try observableWithTimeout toBlockingObservable forEach new Action1 String public void call String t1 fail Never Observable should not have emited an item t1 fail Never Observable should not have completed catch Throwable ex System out println observableWithTimeout emitted error ex getMessage should unsubscribe verify s times 1 unsubscribe @Test public void shouldUnsubscribeFromUnderlyingSubscriptionOnImmediatelyComplete final Subscription s mock Subscription class Observable String immediatelyComplete Observable create new OnSubscribe String public void call Subscriber super String subscriber System out println ImmediatelyComplete Observable subscribed to subscriber add s subscriber onCompleted Observable String observableWithTimeout immediatelyComplete timeout 1 TimeUnit SECONDS try observableWithTimeout toBlockingObservable forEach new Action1 String public void call String t1 fail ImmediatelyComplete Observable should not have emited an item t1 System out println ImmediatelyComplete completed verify s times 1 unsubscribe catch Throwable ex fail ImmediatelyComplete Observable should not emited an error ex getMessage @Test public void shouldUnsubscribeFromUnderlyingSubscriptionOnImmediatelyErrored final Subscription s mock Subscription class Observable String immediatelyError Observable create new OnSubscribe String public void call Subscriber super String subscriber System out println immediatelyErrored Observable subscribed to subscriber add s subscriber onError new RuntimeException Error Observable String observableWithTimeout immediatelyError timeout 1 TimeUnit SECONDS try observableWithTimeout toBlockingObservable forEach new Action1 String public void call String t1 fail immediatelyErrored Observable should not have emited an item t1 fail immediatelyErrored Observable should not have completed catch Throwable ex System out println observableWithTimeout emitted error ex getMessage verify s times 1 unsubscribe I sent a PR #965 to fix the issue Thanks for your unit tests @rbramw',RxJava,true,false,false
29100106,'rxjava scala improvements and reimplemented the amb operator','This PR did the following improvements Added amb delay delaySubscription in rxjava scala Reimplemented the amb operator','RxJava pull requests #887 https netflixoss ci cloudbees com job RxJava pull requests 887 SUCCESS This pull request looks good RxJava pull requests #888 https netflixoss ci cloudbees com job RxJava pull requests 888 SUCCESS This pull request looks good',RxJava,true,false,false
29142892,'Make ObserveOnTest testNonBlockingOuterWhileBlockingOnNext deterministic','reported at https twitter com jaceklaskowski status 443153927069249536','',RxJava,true,false,false
29176561,'Subject doesn t fire filter map et al','Pretty serious bug if true I can t get it to work either way OSX Mavericks Java 1 8_b129 Java java PublishSubject String subject PublishSubject create subject subscribe value System out println Subscribe value subject filter new Func1 String Boolean @Override public Boolean call String value System out println Filter value return value null subject onNext Hello subject onNext World subject onCompleted doesn t fire regardless Java 8 java PublishSubject String subject PublishSubject create subject subscribe value System out println Subscribe value subject filter value System out println Filter value return value null subject onNext Hello subject onNext World subject onCompleted doesn t fire regardless bash Subscribe Hello Subscribe World That s all I get Am I doing something wrong Regards Daryl','Gah okay so you need to subscribe first before you get anything Noted Sorry Yup everything is lazy and doesn t run until subscribed to',RxJava,false,false,false
29178640,'Fixed ReplaySubject leak','Fix for issue #939','RxJava pull requests #889 https netflixoss ci cloudbees com job RxJava pull requests 889 SUCCESS This pull request looks good I can confirm this fixes #939 for me thanks @akarnokd This might in fact be the final nail in the coffin for any workarounds we used on Android to prevent Activities from leaking this is great @benjchristensen do you think we could get this in for 0 17 1 that would be fantastic It would simplify reasoning about requirements for Android operators a lot since the use of cache and replay is quite common on Android and some design decisions for OperatorObserveFromAndroidComponent were made purely due to the existence of this bug no one actually thought to question the correctness of the underlying operator back then hah',RxJava,true,false,false
29178928,'Fixed byLine test to use line separator system property instead of n','byLine uses the line separator but the test used n','RxJava pull requests #890 https netflixoss ci cloudbees com job RxJava pull requests 890 SUCCESS This pull request looks good',RxJava,true,false,false
29259646,'0 16 x Unable to subscribe several times to a GroupedObservable produced by groupBy','It seems impossible to subscribe several Observers to the same GroupedObservable as demonstrated in the following snipet Observable range 1 100 groupBy new Func1 Integer String public String call final Integer integer return integer 50 big small subscribe new Action1 GroupedObservable String Integer public void call final GroupedObservable String Integer objectIntegerGroupedObservable First subscription if left alone works flawlessly objectIntegerGroupedObservable subscribe new Action1 Integer public void call final Integer integer System out println first subscriber integer Second subscription fails and break the first one too objectIntegerGroupedObservable subscribe new Observer Integer public void onCompleted public void onError final Throwable e System out println e public void onNext final Integer args When providing an onError implementation to the second subscription we can see a java lang IllegalStateException Can not set subscription more than once This seems unique to GroupedObservable as other Observables direct or resulting of transformation can be subscribed to multiples times Is this a bug or a desired behavior In the latter case I am interested in the rationals and alternatives I am currently using publish and or replay on the resulting GroupedObservables before any further processing but it clutters the code with implemetation detailsm imho Thanks for your time and energy','Hi Yes it is the common single subscription bug If you can upgrade to most recent version 0 17 A few of the older operators have this issue For a workaround I would suggest using groupByUntil with a Observable never duration selector However this operator has a synchronization bug which makes is not suitable with any other duration selector Thanks for your answer I am gonna look into the alternatives you suggest',RxJava,false,false,false
29265307,OperatorSkipWhile,'Reimplemented OperatorSkipWhile the OperationSkipWhile has a state sharing bug with skipping and index 1 test for many subscribers','RxJava pull requests #893 https netflixoss ci cloudbees com job RxJava pull requests 893 SUCCESS This pull request looks good',RxJava,true,false,false
29278430,'OperationToFuture must throw CancellationException on get if cancelled','The JDK documentation for Future get and its overload requires these methods to throw CancellationException if the Future was cancelled before the task completed The Futures returned by OperationToFuture toFuture did not respect this contract Now they do','RxJava pull requests #897 https netflixoss ci cloudbees com job RxJava pull requests 897 SUCCESS This pull request looks good',RxJava,true,false,false
29366547,'Retry Unit Test from #879','From https github com Netflix RxJava issues 879','',RxJava,true,false,false
29370618,'Subject subscribeOn not persisted','This might be intentional change from 0 16 0 17 But I have noticed a change in how subjects onSubscribe react I had the following setup Init java mPaymentCodeSubject BehaviorSubject create String null mPaymentCodeSubject subscribeOn Schedulers io Then I would refresh via this means java mPaymentCodeSubject first flatMap new rx functions Func1 String Observable PaymentCode @Override public Observable PaymentCode call final String currentPaymentCode Lg w Thread s Thread currentThread getName return mCodeRequester getPaymentCode currentPaymentCode subscribe new rx functions Action1 PaymentCode @Override public void call final PaymentCode paymentCode Lg w Thread s Thread currentThread getName updatePaymentCode paymentCode getCode So what I expect to happen is that all subsequent subscriptions are on the io pool But first and all operators after are executed on the thread that called this method In this case on Android the Main thread So when first does not return anything it blocks and waits locking up the main thread I fixed it with the following change java mPaymentCodeSubject subscribeOn Schedulers io explicitly define Scheduler first flatMap new rx functions Func1 String Observable PaymentCode Not sure if its the Subject implementation or first which has changed I m going to roll back to dig around a bit more','mPaymentCodeSubject BehaviorSubject create String null mPaymentCodeSubject subscribeOn Schedulers io What this does and always did unless I m missing something about subjects is create the subject in line one then invoke a method which returns a new subject scheduled on the IO scheduler just to then discard it All operators and subscribeOn simply applies an operator do not mutate the sequence but transform it into a new one That said I m surprised this ever worked since it shouldn t have ever even executed on that scheduler to begin with Can t say if this is really causing the problem you re seeing just something I noticed @mttkay Yeah your right Rolled back to 0 16 the scheduler was never applied Seems that some implementation of first has changed As removing that resolves the problem I updated the OP The first operator would have been impacted by take changing in 0 17 0 I have not yet spent the time to understand this code So when first does not return anything it blocks and waits locking up the main thread That is exactly what is expected for take first In your full code example are you trying to then call mPaymentCodeSubject onNext something on the same thread as the subscription is occurring on @benjchristensen Yeah I would expect that too for take first but if i roll back to 0 16 it still blocks but other Observables that call observeOn MainThread still return even tho that call is blocked mPaymentCodeSubject onNext would eventually get called inside the subscription But thats not the issue I saw A whole different observable called later in execution e g java mSessionProvider isLoggedInAndPinSet true subscribeOn Schedulers io observeOn AndroidSchedulers mainThread subscribe new Observer Void @Override public void onCompleted mNavigationController next HomeActivity createIntent StartActivity this finish @Override public void onError Throwable e No login token Lg w No user session pin mNavigationController next OnboardingActivity createIntent StartActivity this finish @Override public void onNext Void token This will never make it back to the Subscriber I can only think that the changes to the Subscribers somewhere along the line have affected other observables using the same Thread I may just however be a coincidence that this hasn t broken before and actually as 0 17 simplifies Subscribers it may not have been working correctly before Hi Could you do a thread dump to see where it blocks I don t see any operators that would block the current thread Previously operations such as from and range combined with take would not properly return until all elements were produced What kind of Observable does mCodeRequester getPaymentCode return TraceView file Android Specific hopefully will help https docs google com file d 0B1IgMJoZaONSX09FUzBZWUtYeEk edit @akarnokd also at first look of the trace it seems to be going around in circles as it doesn t just block it recursively calls Very odd things going on Thanks This code demonstrates the issue on normal Java java BehaviorSubject String src BehaviorSubject create String null for int i 0 i 10 i src onNext i System out printf Turn d n i src first flatMap new Func1 String Observable String @Override public Observable String call String t1 return Observable from t1 t1 subscribe new Observer String @Override public void onNext String t System out println t @Override public void onError Throwable e e printStackTrace @Override public void onCompleted It seems the code above ends up in an infinite loop within the SubjectSubscriptionManager L60 L99 L89 fights against L99 all the time I ll post a PR to fix this Cool nice find Glad the trace helped On 13 Mar 2014 21 31 akarnokd notifications@github com wrote Thanks This code demonstrates the issue on normal Java BehaviorSubject String src BehaviorSubject create String null for int i 0 i 10 i src onNext i System out printf Turn d n i src first flatMap new Func1 String Observable String @Override public Observable String call String t1 return Observable from t1 t1 subscribe new Observer String @Override public void onNext String t System out println t @Override public void onError Throwable e e printStackTrace @Override public void onCompleted It seems the code above ends up in an infinite loop within the SubjectSubscriptionManager L60 L99 L89 fights against L99 all the time I ll post a PR to fix this Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 961#issuecomment 37589426 I think this issue has been resolved and can be closed Yes your right',RxJava,false,false,false
29374457,'Migrate from SynchronizedObserver to SerializedObserver','This pull request replaces use of SynchronizedObserver with SerializedObserver ### Why #### 1 Deadlocks Holding a lock while emitting notifications onNext onCompleted onError allows for deadlocks if the event results in a cycle back to the parent While testing RxJava 0 17 0 in Netflix production we ran into one of these The vulnerability has existed all along but we finally hit it This issue has also been reported before such as http twistedoakstudios com blog Post8424_deadlocks in practice dont hold locks while notifying #### 2 Blocking Threads The use of synchronized can block threads If it s used in areas such as modifying a data structure this can be okay When emitting a notification however it is a problem as the result of an onNext can take a non deterministically long time to complete This means any other thread trying to emit will be blocked If the source threads are event loops such as Vert x or Netty this will block the event loops For example if two network calls off two Netty event loops are being merged such as via flatMap and one of them does further slow processing that causes onNext to be slow it will block the other onNext which blocks the event loop and prevents any further IO on that thread This is a significant problem for system scale and breaks the promise of Rx being a non blocking reactive library ### Solution The synchronize SynchronizedObserver and SynchronizedSubscriber operator and classes have been deprecated They are replaced by serialize SerializedObserver and SerializedSubscriber The SerializedObserver still ensures only a single thread can emit onNext onCompleted or onError at a time but does not hold a lock while doing so Instead of blocking threads it will accept the incoming events into a buffer Thus it becomes an asynchronous operator The merge operator which impacts flatMap now uses SerializedObserver along with any other place in RxJava that needed synchronization ### Implementation 3 implementatations were written and tested queue and counter https github com benjchristensen RxJava blob serialize implementations rxjava core src main java rx observers SerializedObserverViaQueueAndCounter java queue and lock https github com benjchristensen RxJava blob serialize implementations rxjava core src main java rx observers SerializedObserverViaQueueAndLock java atomic state machine https github com benjchristensen RxJava blob serialize implementations rxjava core src main java rx observers SerializedObserverViaStateMachine java Performance testing revealed https github com benjchristensen RxJava blob serialize implementations rxjava core src perf java rx operators OperatorSerializePerformance java java 1 streams emitting in a tight loop Testing for single threaded overhead blocking synchronization SynchronizedObserver Run 10 58 186 310 ops sec Run 11 60 592 037 ops sec Run 12 58 099 263 ops sec Run 13 59 034 765 ops sec Run 14 58 231 548 ops sec state machine technique SerializedObserverViaStateMachine Run 10 34 668 810 ops sec Run 11 32 874 312 ops sec Run 12 33 389 339 ops sec Run 13 35 269 946 ops sec Run 14 34 165 013 ops sec using queue and counter technique SerializedObserverViaQueueAndCounter Run 10 19 548 387 ops sec Run 11 19 471 069 ops sec Run 12 19 480 112 ops sec Run 13 18 720 550 ops sec Run 14 19 070 383 ops sec using queue and lock technique SerializedObserverViaQueueAndLock Run 10 51 295 152 ops sec Run 11 50 317 937 ops sec Run 12 51 126 331 ops sec Run 13 52 418 291 ops sec Run 14 51 694 710 ops sec 2 streams emitting in tight loops so very high contention blocking synchronization SynchronizedObserver Run 10 8 361 252 ops sec Run 11 7 184 728 ops sec Run 12 8 249 685 ops sec Run 13 6 831 595 ops sec Run 14 8 003 358 ops sec faster because it allows each thread to be single threaded while blocking the other state machine technique SerializedObserverViaStateMachine Run 10 4 060 062 ops sec Run 11 3 561 131 ops sec Run 12 3 721 387 ops sec Run 13 3 693 909 ops sec Run 14 3 516 324 ops sec using queue and counter technique SerializedObserverViaQueueAndCounter Run 10 4 300 229 ops sec Run 11 4 395 995 ops sec Run 12 4 551 550 ops sec Run 13 4 443 235 ops sec Run 14 4 158 475 ops sec using queue and lock technique SerializedObserverViaQueueAndLock Run 10 6 369 781 ops sec Run 11 6 933 872 ops sec Run 12 5 652 535 ops sec Run 13 5 503 716 ops sec Run 14 6 219 264 ops sec 2 streams emitting once a millisecond Slow emission so little to no contention blocking synchronization SynchronizedObserver Run 10 1 996 ops sec Run 11 1 996 ops sec Run 12 1 995 ops sec Run 13 1 997 ops sec Run 14 1 996 ops sec state machine technique SerializedObserverViaStateMachine Run 10 1 996 ops sec Run 11 1 996 ops sec Run 12 1 996 ops sec Run 13 1 996 ops sec Run 14 1 996 ops sec using queue and counter technique SerializedObserverViaQueueAndCounter Run 10 1 996 ops sec Run 11 1 996 ops sec Run 12 1 996 ops sec Run 13 1 996 ops sec Run 14 1 995 ops sec using queue and lock technique SerializedObserverViaQueueAndLock Run 10 1 996 ops sec Run 11 1 996 ops sec Run 12 1 997 ops sec Run 13 1 996 ops sec Run 14 1 995 ops sec The state machine solution was tested in production but caused performance problems most likely due to the immense object allocation it needs to do The elegant queue and counter solution does not perform well enough in the non contended case The queue and lock model performs well in the non contended case and under contention despite not being a very elegant solution and requiring the use of mutex locks for the state changes but it does not hold the locks during notification ### Considerations This does allow unbounded buffer growth the same as observeOn and zip instead of blocking the producer threads ### Conclusion The implementation in this pull request can and likely will be improved over time The other implementations are purposefully being shown to allow others to provide further insight on how to do this better This change is important to ensure RxJava is non blocking and our canary testing of this change in the Netflix production environment suggests this change is both performant and functional','RxJava pull requests #902 https netflixoss ci cloudbees com job RxJava pull requests 902 SUCCESS This pull request looks good How about the enqueue drain approach with synchronized counter increment and queue replacement as drain similar to your code No ConcurrentLinkedQueue Possibly but it exposes a different problem starvation One thread could end up constantly looping and draining the queue and never get a chance to return and emit data that it needs to emit I considered setting a max number of loops but when it finishes those loops then the other issue would still occur possibly leaving items in the queue waiting for some period of time until another event The queue drain model works far better when there is a single thread dedicated to draining like in observeOn Stealing threads like this I m not sure how to avoid having one of the two problems and I m debating which one is worse obviously I ve decided starvation is worse for now and termination events always end up causing the queue to be drained But streams are not guaranteed to terminate They can be silent forever like Observable never They can be silent forever like Observable never In which case it would never emit anything and never queue anything But streams are not guaranteed to terminate Of course in which case it s the next onNext that would drain the queue The most concerning type of use case in the current implementation is one where 2 events are emitted one is delivered the other is queued then a long time passes before any further events occur In this use case the second onNext is just sitting in a queue waiting to be delivered The only model I can think of that solves this requires injecting extra concurrency using a Scheduler defaulting to the computation one to drain the queue but optimizing for using the providing thread in the non contended case only using the Scheduler to drain the queue when there is contention I m not a fan of requiring that though for merge since that means flatMap could result in additional concurrency but perhaps it s an okay tradeoff to sometimes end up delivering the events via a different Scheduler think event loop to ensure these two bad cases can t happen It would be a significant departure to start allowing additional scheduling and concurrency on merge though Could a fast producer see that it s starving another thread and proactively steal the canEmit to take over draining for a bit On Thu Mar 13 2014 at 5 48 PM Ben Christensen notifications@github com wrote They can be silent forever like Observable never In which case it would never emit anything and never queue anything But streams are not guaranteed to terminate Of course in which case it s the next onNext that would drain the queue The most concerning type of use case in the current implementation is one where 2 events are emitted one is delivered the other is queued then a long time passes before any further events occur In this use case the second onNext is just sitting in a queue waiting to be delivered The only model I can think of that solves this requires injecting extra concurrency using a Scheduler defaulting to the computation one to drain the queue but optimizing for using the providing thread in the non contended case only using the Scheduler to drain the queue when there is contention I m not a fan of requiring that though for mergesince that means flatMap could result in additional concurrency but perhaps it s an okay tradeoff to sometimes end up delivering the events via a different Scheduler think event loop to ensure these two bad cases can t happen It would be a significant departure to start allowing additional scheduling and concurrency on merge though Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 962#issuecomment 37604736 Could a fast producer see that it s starving another thread and proactively steal the canEmit to take over draining for a bit How would you do that by keeping track of the number of onNext received by each Thread ID And how would it steal the canEmit without blocking I don t know if this issue will remain in a few weeks if we end up implementing the continuation back pressure solution as the inner queue would be bounded to a relatively small size 128 512 1024 and the origin threads would end up parking themselves if they fill their buffers This would naturally cause a form of rescheduling and no single thread would starve out another as all would be required to limit the amount they emit Glad to see people taking notice of the deadlock issue Here are some tweaks that might help the queue and counter case Optimistically start operations by CompareSwapping 1 for 0 into the counter If it succeeds do your work without queueing it then try to drain the queue and decrement out of that responsibility as usual This saves an atomic queue operation when operations don t overlap but costs a CAS when they do Wrap the Observable instead of the Observer This reduces the number of atomic operations when there are multiple subscriptions but makes each serialized operation take longer so will cause more overlap Since draining the queue can potentially live lock a thread keep a non synchronized count of how much work you have drained When it exceeds 10 or 100 or whatever spin off a new thread pool task to do the work so the caller gets control back Handing off to another producer is hard Improving the concurrent queue using the knowledge that our case is many producer single consumer For example a long time ago I tried an idea where producers did a single atomic Exchange https github com Strilanc Strilbrary blob master Strilbrary Threading SingleConsumerLockFreeQueue vb the consumer had no atomic operations but there were issues with when queued operations became visible and that problem complicated draining and ultimately made it slower Hi @Strilanc thanks for getting involved queue and counter case Are you able to get it to perform as well as the queue and lock implementation Wrap the Observable instead of the Observer What do you mean by this Here is the use case that needs to be solved https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorMerge java#L39 Since draining the queue can potentially live lock a thread We have chosen the other tradeoff of possibly delayed delivery right now so this doesn t happen We discuss this tradeoff in the comments above Your proposed solution is one of the possibilities discussed but involves adding additional concurrency which has traditionally been unwanted for cases like merge flatMap I think this issue goes away if we end up implementation the back pressure design we re considering that would eliminate the unbounded buffers and thus naturally eliminate the live lock thread starvation issue Example origin supporting continuation and parking itself https github com benjchristensen RxBackpressure blob master rx bp prototype src main java rx operators OnSubscribeFromIterable java#L69 Improve the concurrent queue Definitely As part of the continuation implementation for back pressure I expect us to end up using optimized ring buffers since we will have fixed size buffers We may be able to use a multi producer single consumer ring buffer in some places but in this case where we re stealing producer threads it s not a traditional producer consumer use case so likely will still need multi producer multi consumer Hey @benjchristensen Are you able to get it to perform as well as the queue and lock implementation I used the optimistic CAS trick as part of fixing a performance problem in an Objective C app that used ReactiveCocoa However that was essentially a single threaded case and I can t test on anything even approaching the scale NetFlix can What do you mean by this Here is the use case that needs to be solved https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorMerge java#L39 You re right that it doesn t apply to that case I was thinking of subscribing to a BehaviorSubject where it would be wasteful to do the serialization once per observer instead of once inside the subject We have chosen the other tradeoff of possibly delayed delivery right now so this doesn t happen We discuss this tradeoff in the comments above I think those comments are all about passing the draining to another producer The suggestion I m giving is to transfer the work to the thread pool This avoids issues where the queue stops until another producer comes along and the corresponding tricky synchronization involved in that but in this case where we re stealing producer threads it s not a traditional producer consumer use case so likely will still need multi producer multi consumer Yes it is a bit of a unique case The consumer is only ever in one place but that place keeps teleporting around I can t test on anything even approaching the scale NetFlix can I don t think the Netflix scale impacts this very much as many application use cases regardless of horizontal or vertical scale apply There are 3 primary use cases that occur when serializing 1 No contention This needs to be optimized for as it s very common and the JVM does a great job with locks of recognizing there is no contention and performing well 2 Highly Contended This happens when tight for while loops are emitting and being merged It s somewhat of a bad use case but it happens Locks perform rather well per thread since they block the other threads 3 Intermittent contention This case is easy with locks queues or CAS and all perform about the same I was thinking of subscribing to a BehaviorSubject where it would be wasteful to do the serialization once per observer instead of once inside the subject That makes sense The suggestion I m giving is to transfer the work to the thread pool This avoids issues where the queue stops until another producer comes along and the corresponding tricky synchronization involved in that Agreed It will be far easier in this case and much more similar to how the queue drain model works in observeOn We ve been trying to eliminate adding concurrency to serialize though as the last thing anyone expects flatMap merge to do is inject a new thread to consume the work In Rx it s fairly normal for the producer to move across threads as long as the emissions are serialized since merging of streams happens all the time or other things like onErrorResumeNext and timeout Moving consumption to a new thread though only happens when explicitly asked for via observeOn That said if the back pressure work does not solve the trade offs thread starvation or notification delay we will likely end up pursuing the fallback solution of moving work to a Scheduler when the live lock counter threshold is hit Optimistically start operations by CompareSwapping 1 for 0 into the counter If it succeeds do your work without queueing it I had done this optimization on the state machine one but hadn t on the queue and counter implementation as I m not quite sure the race condition is safe It seems it should be good as it drains AFTER emitting since this only occurs when count is 0 but I get multiple unit test failures when I attempt this optimization I haven t spent the time to figure out why Code updated to not queue on non contended case here https github com benjchristensen RxJava blob serialize implementations rxjava core src main java rx observers SerializedObserverViaQueueAndCounter java#L50 With this optimization here are the before and after on performance using queue and counter technique SerializedObserverViaQueueAndCounter Run 10 19 548 387 ops sec Run 11 19 471 069 ops sec Run 12 19 480 112 ops sec Run 13 18 720 550 ops sec Run 14 19 070 383 ops sec after optimizations Run 10 40 202 262 ops sec Run 11 40 628 288 ops sec Run 12 41 878 527 ops sec Run 13 43 400 405 ops sec Run 14 40 002 117 ops sec However the queue and lock implementation is still faster Run 10 51 295 152 ops sec Run 11 50 317 937 ops sec Run 12 51 126 331 ops sec Run 13 52 418 291 ops sec Run 14 51 694 710 ops sec and this optimization makes the contended cases slower java Run 10 4 300 229 ops sec Run 11 4 395 995 ops sec Run 12 4 551 550 ops sec Run 13 4 443 235 ops sec Run 14 4 158 475 ops sec after optimizations Run 10 2 857 008 ops sec Run 11 3 093 778 ops sec Run 12 4 009 758 ops sec Run 13 3 094 435 ops sec Run 14 3 166 119 ops sec Even if the performance changes made it better than queue and lock I am not certain this is thread safe and there are 6 unit tests across the codebase now failing whereas queue and lock still performs better and all tests pass I will explore this more as we finish experimenting with back pressure as that will define how merge and the primary use case for serialization synchronization can be implemented @benjchristensen The reason the code is failing is because you are incrementing before the enqueue It is extremely important that it only happen after the enqueue or else the count can desync from the queue size For example Thread D is draining the queue the queue is currently empty but D has not yet called decrementAndGet to move the counter from 1 to 0 Thread P is about to enqueue an item P calls getAndIncrement gets 1 D calls decrementAndGet gets 1 D calls queue poll gets null THIS SHOULD NEVER HAPPEN P calls queue add The count is now off by one w r t the size of the queue The optimization I am suggesting is this queue optimistically try to acquire draining responsibilities without enqueueing if count compareAndSet 0 1 emitNotification t else enqueue then try to acquire draining responsibilities queue add t if count getAndIncrement 0 return reduce to same case as other branch with queue potentially empty emitNotification queue poll drain while count decrementAndGet 0 emitNotification queue poll The reason it is safe to increment the count without enqueueing when it was at 0 is that nothing else is about to dequeue based on the count The count can only be 0 when nothing is draining the queue Your suggested approach in this case by using CAS 0 1 on every attempt is elegant in allowing the queue before increment in the else branch case I like the pattern It does mean we are attempting a CAS that could fail a lot of the time and that may be what s causing a further slow down in the contended performance metrics see below I ve updated the code to your recommended solution https github com benjchristensen RxJava blob serialize implementations rxjava core src main java rx observers SerializedObserverViaQueueAndCounter java#L50 Even with this change there are still unit test failures so something else is wrong I ll have to debug further to understand why More to the point though this implementation is still slower than queue and lock and became even slower in the contended case java 1 streams emitting in a tight loop Testing for single threaded overhead using queue and counter technique SerializedObserverViaQueueAndCounter Run 10 34 238 641 ops sec Run 11 40 711 892 ops sec Run 12 40 732 451 ops sec Run 13 40 819 662 ops sec Run 14 40 870 576 ops sec using queue and lock technique SerializedObserverViaQueueAndLock Run 10 51 295 152 ops sec Run 11 50 317 937 ops sec Run 12 51 126 331 ops sec Run 13 52 418 291 ops sec Run 14 51 694 710 ops sec 2 streams emitting in tight loops so very high contention using queue and counter technique SerializedObserverViaQueueAndCounter Run 10 2 153 329 ops sec Run 11 5 139 837 ops sec Run 12 2 295 464 ops sec Run 13 2 327 337 ops sec Run 14 2 220 375 ops sec using queue and lock technique SerializedObserverViaQueueAndLock Run 10 5 120 561 ops sec Run 11 5 509 731 ops sec Run 12 5 214 265 ops sec Run 13 5 133 194 ops sec Run 14 5 309 957 ops sec As a side note count getAndIncrement 0 is equivalent to count compareAndSet 0 1 unless wanting to hold off on incrementing in the failure case as you re nicely doing in your example as getAndIncrement does compareAndSet under the covers and will only return 0 if it wins incrementing from 0 to 1 This is the JDK code java public final int getAndIncrement for int current get int next current 1 if compareAndSet current next return current This usage works very well in several other places in RxJava such as observeOn that increments decrements concurrently to drain a queue from a single thread code at https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorObserveOn java source c#L109 Thank you for your involvement in this I appreciate the insights and help @benjchristensen My guess for the test failure now is that I did not wrap null into NullSentinel in the CAS case and so it is ignored in emitNotification That check is problematic in the other case as well because getting a null is an indication that something is wrong because we expect polling the queue to succeed I m interested in what could possibly be making lock queue faster Consider what happens in the uncontended case of queue counter A CAS from 0 to 1 forwarding the notification A decrement We have an atomic operation to acquire and an atomic operation to release How is locking doing better Is it the fact that the decrement is actually a read and a CAS Maybe optimistically assuming the value is still 1 on the first attempt to decrement would save some time by avoiding the read Is the runtime using something a bit more flexible than atomics to implement its locking Relaxed atomics or something like that Some kind of lock elision A jit optimization that recognizes single thread visibility I did some profiling to find out where the time is going Interesting things happen I profiled synchronize by itself outside of the use case like so AtomicInteger r new AtomicInteger 0 final int n 10000000 while true final Object obj new Object long n1 System nanoTime for int i 0 i n i synchronized obj long n2 System nanoTime double s n2 n1 Math pow 10 9 double mhz n s Math pow 10 6 System out println new DecimalFormat #0 0 format mhz MHz and the CAS profiling just replaced the synchronized block with this r compareAndSet 0 1 r compareAndSet 1 0 The synchronized results are interesting For about 10 seconds the results hover around 30MHz then they jump to hovering around 350MHz I assume the jit kicked in and did some magic For AtomicInteger the two CAS operations benchmark at about 50MHz Given that I don t understand what exactly is happening to increase the lock performance by an order of magnitude after ten seconds I can t say which will be faster in our use case If that optimization is applicable and applied locks win by a lot If not CAS wins by a bit In the uncontended case @benjchristensen I ve come to the conclusion that I m not going to beat Java s synchronize blocks without some serious effort I m not sure it s even possible in the single threaded case where synchronize s biased locking elides the atomic operations but relies on messing with other threads stacks Thanks for continuing on this I m not surprised we can t beat the compiler I m curious why the CAS operations aren t similarly optimized This exploration isn t done yet and I ll come back to it in coming weeks We don t necessarily need to be faster than locks to end up using CAS there are other benefits to CAS over locks I m seeing a nasty bug related to this I believe where the use of merge SerializedSubscriber has the result of onCompleted being called before onNext has finished I thought I d mention it now while I dig around trying to get a unit test in case it rings bells for those of you that a familiar with the changed code My use case worked as expected in 0 17 0 then not in 0 17 1 at all Unfortunately the code is too complex to present here without adding stupid amounts of noise so I will try to distill a unit test I think the problem has to do with the queue not being drained properly There s a copy away to avoid locking thing happening but drainQueue only drains the copy It doesn t go back and check if there s more to drain which can leave the queue with items hanging Actually I m kind of surprised any concurrent completions are working If terminated is set while the queue is being concurrently drained I don t think anything forwards the completion ever There s also a race on emitting being cleared vs another producer taking up draining Your particular bug is because of this if canEmit we won the right to emit try drainQueue list actual onNext t There s a race with an onComplete firing before that call to drainQueue runs then onNext ruins everything Basically the entire hand off process between producers is wrong in the current queue lock implementation Thanks for that I ll stop chasing a unit test I ll leave it to the rxjava experts to run with On 20 March 2014 11 22 Craig Gidney notifications@github com wrote I think the problem has to do with the queue not being drained properly There s a copy away to avoid locking thing happening but drainQueue only drains the copy It doesn t go back and check if there s more to drain which can leave the queue with items hanging Actually I m kind of surprised any concurrent completions are working If terminated is set while the queue is being concurrently drained I don t think anything forwards the completion ever There s also a race on emitting being cleared vs another producer taking up draining Your particular bug is because of this if canEmit we won the right to emit try drainQueue list actual onNext t There s a race with an onComplete firing before that call to drainQueueruns then onNext ruins everything Basically the entire hand off process between producers is wrong in the current queue lock implementation Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 962#issuecomment 38123526 If terminated is set while the queue is being concurrently drained I don t think anything forwards the completion ever It happens right here https github com Netflix RxJava blob master rxjava core src main java rx observers SerializedObserver java#L160 Can one of you please provide me a test case The only way I can cause a problem so far is if the source Observable breaks the Rx contract Here are examples where threads are racing each other java @Test public void testConcurrency Observable Integer o Observable create new OnSubscribe Integer @Override public void call final Subscriber super Integer s Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner for int i 0 i 10000 i s onNext 1 s onCompleted for int i 0 i 1000 i Observable Integer merge Observable merge o o o TestSubscriber Integer ts new TestSubscriber Integer merge subscribe ts ts awaitTerminalEvent assertEquals 1 ts getOnCompletedEvents size assertEquals 30000 ts getOnNextEvents size List Integer onNextEvents ts getOnNextEvents System out println onNext onNextEvents size onCompleted ts getOnCompletedEvents size Another variant this time with sleeps to cause random concurrent behavior java @Test public void testConcurrencyWithSleeping Observable Integer o Observable create new OnSubscribe Integer @Override public void call final Subscriber super Integer s Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner for int i 0 i 100 i s onNext 1 try Thread sleep 1 catch InterruptedException e e printStackTrace s onCompleted for int i 0 i 100 i Observable Integer merge Observable merge o o o TestSubscriber Integer ts new TestSubscriber Integer merge subscribe ts ts awaitTerminalEvent assertEquals 1 ts getOnCompletedEvents size assertEquals 300 ts getOnNextEvents size List Integer onNextEvents ts getOnNextEvents System out println onNext onNextEvents size onCompleted ts getOnCompletedEvents size Both of those work correctly I am however able to get it to behave poorly when the Rx contract is broken java @Test public void testConcurrencyWithBrokenContract Observable Integer o Observable create new OnSubscribe Integer @Override public void call final Subscriber super Integer s Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner for int i 0 i 10000 i s onNext 1 s onCompleted for int i 0 i 100 i s onNext 1 s onCompleted for int i 0 i 100 i s onNext 1 for int i 0 i 1000 i Observable Integer merge Observable merge o o o TestSubscriber Integer ts new TestSubscriber Integer merge subscribe ts ts awaitTerminalEvent assertEquals 1 ts getOnCompletedEvents size assertEquals 30000 ts getOnNextEvents size List Integer onNextEvents ts getOnNextEvents System out println onNext onNextEvents size onCompleted ts getOnCompletedEvents size This emits java lang AssertionError expected 30000 but was 29377 The fix for this is to not decrement the count if onComplete is received more than once final class InnerObserver extends Subscriber T private boolean innerCompleted false public InnerObserver @Override public void onCompleted if runningCount decrementAndGet 0 completed o onCompleted if innerCompleted we check if already completed otherwise a misbehaving Observable that emits onComplete more than once will cause the runningCount to decrement multiple times innerCompleted true if runningCount decrementAndGet 0 completed o onCompleted cleanup cleanup Just merged the fix for an Observable that emits multiple onComplete Ben this serialized subscriber complicates my world for this reason I am merging asynchronous observables Each observable has a resource that must remain open till all onNext calls have finished for that observable The OnSubscribe for the observable get a fresh resource calls onNext repeatedly then closes the resource and calls onComplete Because the SerializedSubscriber has buffered stuff asynchronously I am encountering the situation where the resource has been closed before the onNext have finished and I get errors Unless I m mistaken this is a most undesirable effect that will complicate the hell out of writing asynchronous Observables @benjchristensen My guess was that if a subject sent an onCompleted in its serialized onNext callback that the onComplete would not forward Something like Subject Object s new Subject s onNext x s sendCompleted bool a new bool 1 s onCompleted a 0 true s sendNext null assert a 0 I apologize if I got some of the method names wrong @davidmoten It sounds like the problem is that the resource is being closed by the producer instead of the consumer when it s the consumer that relies upon it Would it also break if delay was applied to it I don t know the conventions of RxJava well enough to suggest what should be done My guess would be that the consumer should be responsible for disposing the subscription even if it completes and so you d cleanup on dispose rather than cleanup on complete sent @Strilanc good description not sure about delay I ll look it up Cleanup on completion I suspect is achieved with the Observable using method so I ll try that but cleanup on dispose is also a possibility I wrote a quick test and unsubscribe is called even after onCompleted is called so that could work I m a bit concerned in the synchronous case that if I use unsubscribe to close resources then the subsequent observable say in a flatMap might commence and be blocked waiting for a resource from a singleton resource pool @davidmoten I don t know the specifics of the situation so this might be a ridiculous suggestion in context but what about releasing producing rights after on complete is sent but only release the actual resource based on a subscribed reference count So consumer1 subscribes and the resource is allocated The notifications get sent and the resource is now no longer busy but does still have to exist Consumer2 subscribes and does not wait because the resource is not busy despite already being allocated Consumer2 unsubscribes and the resource goes back to allocated but not busy Consumer1 unsubscribes and the resource gets released Each observable has a resource that must remain open till all onNext calls have finished for that observable @davidmoten Once an Observable has emitted all of its onNext it has no further control over the events Anything downstream can be async such as zip and observeOn and onCompleted and cleanup will have been performed by the source Observable while the events are still being processed downstream That is the nature of async push My guess was that if a subject sent a re entrant onCompleted in its serialized onNext callback that the onComplete would not forward @Strilanc The Rx contract is clear that once an onCompleted or onError is received no further events are to be sent Those are terminal events Thus your example breaks the contract by sending onComplete to Observable s and then expecting to send more events to it My guess would be that the consumer should be responsible for disposing the subscription even if it completes and so you d cleanup on dispose rather than cleanup on complete sent The unsubscribe always gets called at the end after onComplete or onError but events can not rely upon the source Observable not having been cleaned up because any number of compositions can cause the source Observable to be long gone by the time the events are processed Some examples include zip observeOn cache replay delay window buffer and now merge The unsubscribe event also can occur well before the final Subscriber receives the events For example the merge operator eagerly invokes unsubscribe as soon as onComplete is received otherwise memory leaks can occur on long lived streaming use cases since the final Subscriber may never actually complete From what I can tell the difference in behavior you re seeing is coincidental Before the synchronized solution would allow a broken contract to flow through such as onNext onCompleted onNext This would flow through until some operator or the final SafeSubscriber filtered out the last onNext that broke the contract The new serialized solution is maintaining the contract and filtering out everything after a terminal event according to the Rx contract It doesn t need to be done on serialized but is an optimization to allow it to finish draining the queue I could go either way on this one but no operator or Observable should depend on events propagating after onCompleted onError or unsubscribe @davidmoten What is the use case you have where emitted events depend on their original Observable not having been cleaned up That is not going to be reliable when it gets composed @benjchristensen https github com benjchristensen thanks for your detailed response I ve refactored my observable to internalize usage of the resource to the Observable and it now only emits items that do not depend on the resource I did this on my first iteration of the code a month ago but found nothing was pushing me to do this in particular clearly hadn t used zip cache etc in my use cases and was deliberately avoiding observeOn The use case was resource jdbc connection and item ResultSet The first action from the observable was always a map to somethiing not dependent on the resultset connection which was frequently flatmapped but SerializedSubscriber threw a spanner in the works and quite rightly so I realize I ve internalized that map now so that a ResultSet is not emitted and all my unit tests pass with 0 17 1 At least now I ll be able to throw async operators at it with impunity now FYI the project is at https github com davidmoten rxjava jdbc Thanks again for your time and to @Strilanc twas all me and was easily fixed Dave On 22 March 2014 01 17 Ben Christensen notifications@github com wrote Each observable has a resource that must remain open till all onNext calls have finished for that observable @davidmoten https github com davidmoten Once an Observable has emitted all of its onNext it has no further control over the events Anything downstream can be async such as zip and observeOn and onCompleted and cleanup will have been performed by the source Observablewhile the events are still being processed downstream That is the nature of async push My guess was that if a subject sent a re entrant onCompleted in its serialized onNext callback that the onComplete would not forward @Strilanc https github com Strilanc The Rx contract is clear that once an onCompleted or onError is received no further events are to be sent Those are terminal events Thus your example breaks the contract by sending onComplete to Observable s and then expecting to send more events to it My guess would be that the consumer should be responsible for disposing the subscription even if it completes and so you d cleanup on dispose rather than cleanup on complete sent The unsubscribe always gets called at the end after onComplete or onError but events can not rely upon the source Observable not having been cleaned up because any number of compositions can cause the source Observable to be long gone by the time the events are processed Some examples include zip observeOn cache replay delay window buffer and now merge The unsubscribe event also can occur well before the final Subscriberreceives the events For example the merge operator eagerly invokes unsubscribe as soon as onComplete is received otherwise memory leaks can occur on long lived streaming use cases since the final Subscriber may never actually complete From what I can tell the difference in behavior you re seeing is coincidental Before the synchronized solution would allow a broken contract to flow through such as onNext onCompleted onNext This would flow through until some operator or the final SafeSubscriberfiltered out the last onNext that broke the contract The new serialized solution is maintaining the contract and filtering out everything after a terminal event according to the Rx contract It doesn t need to be done on serialized but is an optimization to allow it to finish draining the queue I could go either way on this one but no operator or Observable should depend on events propagating after onCompleted onError or unsubscribe @davidmoten https github com davidmoten What is the use case you have where emitted events depend on their original Observable not having been cleaned up That is not going to be reliable when it gets composed Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 962#issuecomment 38278838 Always keep a copy of http go microsoft com fwlink LinkID 205219 next to your keyboard which reminds me we should do a refresh of this and for every language @davidmoten Glad it was easy to resolve @benjchristensen With reference to this problem The most concerning type of use case in the current implementation is one where 2 events are emitted one is delivered the other is queued then a long time passes before any further events occur In this use case the second onNext is just sitting in a queue waiting to be delivered I m encountering this problem now using merge My use case is described here https groups google com forum # topic rxjava GHJS44P4YfQ My assumption at this point is that the problem is here to stay and I m looking for the least objectionable way of handling it Do we need to be able to parameterize the use of a SerializedSubscriber so that we can avoid the behaviour if we choose to In SerializedSubscriber once winning the right to emit we currently drain the queue before the onNext is called Is there any scope for draining the queue some limited configurable number of times AFTER the onNext is called as well @davidmoten If an event sits in the queue until the next event instead of eventually being forwarded even if another event doesn t come along it s a bug Are you actually experiencing this bug @Strilanc Yeah I m experiencing it as described here https groups google com forum # topic rxjava GHJS44P4YfQ My first para above quotes Ben on this one and is known issue I realize on reviewing the conversation above that my rambly ideas seem to have been talked about already I thought I d push it along a little seeing as I m bumping into the issue now though not without a somewhat ugly workaround It strikes me as a serious side effect of work that is trying to ameliorate deadlocks and blocking I have created https github com Netflix RxJava issues 998 for us to continue this discussion and determine how to move forward',RxJava,true,false,false
29386687,'A more robust JMH benchmarking set up','Usage gradle benchmarks java jar rxjava core build distributions rxjava core 0 17 2 SNAPSHOT benchmarks jar For example java jar rxjava core build distributions rxjava core 0 17 2 SNAPSHOT benchmarks jar f 1 wi 10 i 10 tu us bm avgt Benchmark size Mode Samples Mean Mean error Units r o ObservableBenchmark measureBaseline 1 avgt 10 0 003 0 000 us op r o ObservableBenchmark measureBaseline 1024 avgt 10 2 764 0 051 us op r o ObservableBenchmark measureBaseline 1048576 avgt 10 3104 088 49 586 us op r o ObservableBenchmark measureMap 1 avgt 10 0 100 0 003 us op r o ObservableBenchmark measureMap 1024 avgt 10 5 036 0 059 us op r o ObservableBenchmark measureMap 1048576 avgt 10 6693 271 277 604 us op See https github com Netflix RxJava issues 776 for more details','This looks awesome I look forward to using this for all our perf testing RxJava pull requests #903 https netflixoss ci cloudbees com job RxJava pull requests 903 FAILURE Looks like there s a problem with this pull request 1 Thanks I m a bit worried about the failing build though I don t think my changes should have caused those tests to fail I don t think my changes should have caused those tests to fail It doesn t look related Is there a way to maintain historical snapshots over time for getting performance diffs It looks like this change to build gradle broke the Eclipse project import Refreshing dependencies in Eclipse now loads the root project as a source folder and causes other dependency issues Not yet sure why or how to fix it Ah What a shame I Admit to not having actually tested it in Eclipse Works fine in Command Line and in IDEA Would you kindly point out the steps to reproduce this Eclipse and gradle plugin versions and such I ve reproduced it with multiple versions of Eclipse Juno Kepler Luna using the Gradle IDE plugin available in the Eclipse Marketplace screen shot 2014 03 26 at 2 39 24 pm https cloud githubusercontent com assets 813492 2531229 55b29dae b52f 11e3 96ea b6f011983cb2 png Version Kepler Service Release 2 Build id 20140224 0627 Gradle IDE 3 4 0 201310051517 RELEASE org springsource ide eclipse gradle feature feature group GoPivotal Inc With the help of @quidryan I think we ve got this solved Pull request coming This is excellent thank you @gvsmirnov for your help on this Is there a way to measure object allocation in the benchmarks The best I ve found is the HS_GC profiler but it s not obvious how to use that to determine object allocations # Run progress 0 00 complete ETA 00 01 00 # VM invoker Library Java JavaVirtualMachines jdk1 8 0 jdk Contents Home jre bin java # VM options Xmx512m Dfile encoding UTF 8 # Fork 1 of 1 # Warmup 5 iterations 1 s each # Measurement 5 iterations 5 s each # Threads 1 thread will synchronize iterations # Benchmark mode Average time time op # Benchmark rx operators OperatorSerializePerf serializedSingleStream # Parameters size 1048576 # Warmup Iteration 1 91 687 ns op # Warmup Iteration 2 72 425 ns op # Warmup Iteration 3 66 230 ns op # Warmup Iteration 4 66 658 ns op # Warmup Iteration 5 67 470 ns op Iteration 1 65 993 ns op HS GC difference sun gc collector 0 invocations 122 sun gc collector 0 lastEntryTime 4972697000 sun gc collector 0 lastExitTime 4972719000 sun gc collector 0 time 109162000 sun gc compressedclassspace used 568 sun gc generation 0 space 0 used 50104784 sun gc generation 1 space 0 used 32768 sun gc metaspace used 5232 sun gc policy avgMinorIntervalTime 1 sun gc policy avgPromotedAvg 439 sun gc policy avgPromotedDev 1478 sun gc policy avgPromotedPaddedAvg 4873 sun gc policy avgSurvivedAvg 3923 sun gc policy avgSurvivedDev 2660 sun gc policy avgSurvivedPaddedAvg 4056 sun gc policy avgYoungLive 3920 sun gc policy liveSpace 3936 Iteration 2 65 861 ns op HS GC difference sun gc collector 0 invocations 123 sun gc collector 0 lastEntryTime 5002277000 sun gc collector 0 lastExitTime 5002144000 sun gc collector 0 time 105387000 sun gc compressedclassspace used 568 sun gc generation 0 space 0 used 50104784 sun gc generation 0 space 1 used 65536 sun gc generation 0 space 2 used 65536 sun gc generation 1 space 0 used 46608 sun gc metaspace used 6840 sun gc policy avgSurvivedAvg 4832 sun gc policy avgSurvivedDev 345 sun gc policy avgSurvivedPaddedAvg 5868 sun gc policy avgYoungLive 4832 sun gc policy liveSpace 4832 sun gc tlab maxSlowWaste 2 sun gc tlab slowWaste 2 Iteration 3 66 177 ns op HS GC difference sun gc collector 0 invocations 123 sun gc collector 0 lastEntryTime 5023959000 sun gc collector 0 lastExitTime 5023980000 sun gc collector 0 time 104882000 sun gc generation 0 space 1 used 65536 sun gc generation 0 space 2 used 65536 sun gc generation 1 space 0 used 24576 sun gc metaspace used 648 sun gc policy avgMinorIntervalTime 2 sun gc policy avgSurvivedAvg 1588 sun gc policy avgSurvivedDev 3708 sun gc policy avgSurvivedPaddedAvg 12713 sun gc policy avgYoungLive 1588 sun gc policy liveSpace 1600 sun gc policy minorGcCost 1 sun gc policy mutatorCost 1 sun gc tlab maxSlowWaste 2 sun gc tlab slowWaste 2 Iteration 4 66 783 ns op HS GC difference sun gc collector 0 invocations 121 sun gc collector 0 lastEntryTime 4988853000 sun gc collector 0 lastExitTime 4988935000 sun gc collector 0 time 109285000 sun gc compressedclassspace used 568 sun gc generation 0 space 0 used 107367384 sun gc generation 0 space 1 used 65536 sun gc generation 0 space 2 used 65536 sun gc generation 1 space 0 used 32768 sun gc metaspace used 3976 sun gc policy avgMinorIntervalTime 1 sun gc policy avgSurvivedAvg 2029 sun gc policy avgSurvivedDev 2406 sun gc policy avgSurvivedPaddedAvg 5189 sun gc policy avgYoungLive 2029 sun gc policy liveSpace 2016 sun gc tlab maxSlowWaste 1 sun gc tlab slowWaste 1 Iteration 5 66 107 ns op HS GC difference sun gc collector 0 invocations 123 sun gc collector 0 lastEntryTime 5019505000 sun gc collector 0 lastExitTime 5019477000 sun gc collector 0 time 108837000 sun gc generation 0 space 0 used 107367384 sun gc generation 0 space 1 used 65536 sun gc generation 0 space 2 used 65536 sun gc generation 1 space 0 used 32768 sun gc metaspace used 2736 sun gc policy avgMinorIntervalTime 2 sun gc policy avgSurvivedAvg 4671 sun gc policy avgSurvivedDev 3890 sun gc policy avgSurvivedPaddedAvg 6998 sun gc policy avgYoungLive 4671 sun gc policy liveSpace 4672 sun gc policy minorGcCost 1 sun gc policy mutatorCost 1 sun gc tlab maxSlowWaste 1 sun gc tlab slowWaste 1 Result 66 184 99 9 1 370 ns op Statistics min avg max 65 861 66 184 66 783 stdev 0 356 Confidence interval 99 9 64 814 67 554 # Run progress 50 00 complete ETA 00 00 30 # VM invoker Library Java JavaVirtualMachines jdk1 8 0 jdk Contents Home jre bin java # VM options Xmx512m Dfile encoding UTF 8 # Fork 1 of 1 # Warmup 5 iterations 1 s each # Measurement 5 iterations 5 s each # Threads 1 thread will synchronize iterations # Benchmark mode Average time time op # Benchmark rx operators OperatorSerializePerf synchronizedSingleStream # Parameters size 1048576 # Warmup Iteration 1 85 609 ns op # Warmup Iteration 2 65 273 ns op # Warmup Iteration 3 67 605 ns op # Warmup Iteration 4 70 206 ns op # Warmup Iteration 5 67 573 ns op Iteration 1 67 817 ns op HS GC difference sun gc collector 0 invocations 113 sun gc collector 0 lastEntryTime 5009256000 sun gc collector 0 lastExitTime 5009219000 sun gc collector 0 time 115343000 sun gc compressedclassspace used 568 sun gc generation 0 space 0 used 89328184 sun gc generation 0 space 1 used 65536 sun gc generation 0 space 2 used 65536 sun gc generation 1 space 0 used 57344 sun gc metaspace used 5232 sun gc policy avgMinorIntervalTime 2 sun gc policy avgMinorPauseTime 1 sun gc policy avgPromotedAvg 489 sun gc policy avgPromotedDev 1604 sun gc policy avgPromotedPaddedAvg 5301 sun gc policy avgSurvivedAvg 5555 sun gc policy avgSurvivedDev 352 sun gc policy avgSurvivedPaddedAvg 4500 sun gc policy avgYoungLive 5551 sun gc policy liveSpace 5536 sun gc policy minorPauseYoungSlope 1 Iteration 2 65 182 ns op HS GC difference sun gc collector 0 invocations 117 sun gc collector 0 lastEntryTime 4985950000 sun gc collector 0 lastExitTime 4985991000 sun gc collector 0 time 116225000 sun gc compressedclassspace used 568 sun gc generation 0 space 0 used 14292528 sun gc generation 0 space 1 used 65536 sun gc generation 0 space 2 used 65536 sun gc generation 1 space 0 used 40960 sun gc metaspace used 9880 sun gc policy avgMinorIntervalTime 1 sun gc policy avgMinorPauseTime 1 sun gc policy avgPromotedPaddedAvg 1 sun gc policy avgSurvivedAvg 3828 sun gc policy avgSurvivedDev 285 sun gc policy avgSurvivedPaddedAvg 2975 sun gc policy avgYoungLive 3828 sun gc policy liveSpace 3840 sun gc tlab maxSlowWaste 3 sun gc tlab slowWaste 3 Iteration 3 64 883 ns op HS GC difference sun gc collector 0 invocations 118 sun gc collector 0 lastEntryTime 5006972000 sun gc collector 0 lastExitTime 5007203000 sun gc collector 0 time 116378000 sun gc generation 0 space 0 used 14292528 sun gc generation 0 space 2 used 32768 sun gc generation 1 space 0 used 40960 sun gc metaspace used 648 sun gc policy avgMinorIntervalTime 1 sun gc policy avgMinorPauseTime 1 sun gc policy avgSurvivedAvg 3869 sun gc policy avgSurvivedDev 2754 sun gc policy avgSurvivedPaddedAvg 12131 sun gc policy avgYoungLive 3869 sun gc policy liveSpace 3872 sun gc policy minorPauseTime 1 sun gc policy survived 32768 Iteration 4 67 096 ns op HS GC difference sun gc collector 0 invocations 114 sun gc collector 0 lastEntryTime 5001540000 sun gc collector 0 lastExitTime 5001264000 sun gc collector 0 time 114907000 sun gc compressedclassspace used 568 sun gc generation 0 space 0 used 125059448 sun gc generation 0 space 2 used 32768 sun gc generation 1 space 0 used 32768 sun gc metaspace used 3976 sun gc policy avgMinorIntervalTime 4 sun gc policy avgMinorPauseTime 1 sun gc policy avgSurvivedAvg 7072 sun gc policy avgSurvivedDev 2906 sun gc policy avgSurvivedPaddedAvg 15789 sun gc policy avgYoungLive 7072 sun gc policy liveSpace 7072 sun gc policy minorPauseTime 1 sun gc policy survived 32768 sun gc tlab maxSlowWaste 1 sun gc tlab slowWaste 1 Iteration 5 66 292 ns op HS GC difference sun gc collector 0 invocations 116 sun gc collector 0 lastEntryTime 5025068000 sun gc collector 0 lastExitTime 5025017000 sun gc collector 0 time 116565000 sun gc generation 0 space 0 used 125059448 sun gc generation 1 space 0 used 49152 sun gc metaspace used 2736 sun gc policy avgMinorIntervalTime 2 sun gc policy avgPromotedPaddedAvg 1 sun gc policy avgSurvivedAvg 6102 sun gc policy avgSurvivedDev 3403 sun gc policy avgSurvivedPaddedAvg 4108 sun gc policy avgYoungLive 6102 sun gc policy liveSpace 6112 sun gc tlab maxSlowWaste 2 sun gc tlab slowWaste 2 Result 66 254 99 9 4 788 ns op Statistics min avg max 64 883 66 254 67 817 stdev 1 243 Confidence interval 99 9 61 466 71 041 Benchmark size Mode Samples Mean Mean error Units r o OperatorSerializePerf serializedSingleStream 1048576 avgt 5 66 184 1 370 ns op r o OperatorSerializePerf synchronizedSingleStream 1048576 avgt 5 66 254 4 788 ns op These two implementations should have very different object allocation characteristics The time throughput is basically the same but one of them in our production environment works the other causes GC pressure and intermittent problems I m trying to prove that with JMH so I can then test alternate implementations I am unable to get the shadowJar functionality working task perfJar type Jar dependsOn perfClasses from sourceSets perf output sourceSets main output not working task benchmarksJar dependsOn perfJar apply plugin shadow shadow classifier benchmarks includeDependenciesFor runtime perfRuntime transformer com github jengelman gradle plugins shadow transformers ManifestResourceTransformer mainClass org openjdk jmh Main @benjchristensen Uh #991 pretty much undid what I had done One of the main points in using shadowJar was to avoid exactly what you see now the params passed to JMH being hardcoded in the build script So what has happened here is alright for a temporary solution just so it works in Eclipse but we ll have to do it properly I hope I can look into it this weekend @benjchristensen what do you mean exactly by measuring object allocation Which params are being hardcoded which weren t before @quidryan Please see here https github com benjchristensen RxJava commit ab7f40847159baf742ea4180757a3af45350bde0 There are two problems with using a type JavaExec task to run benchmarks 1 Passing arguments to JMH is a pain in the ass see the link above for an example 2 You would need to have the source code in all the environments you want to execute the benchmarks in You would have to build the project in all the environments These two are sufficient to prefer packing everything into a single runnable jar with batteries Concerning args which I didn t realize would part of JMH we can pass in args e g gradlew benchmark PjmhArgs something after adding this to the JavaExec configuration if project hasProperty jmhArgs args jmhArgs I ll defer to @benjchristensen to what the goal of the benchmarks are for which is pertinent for #2 IIRC it s primary purpose to compare the performance of a builds via PRs In which case I d imagine we d want a static set of args to keep things standard across runs If necessary to run on other hosts then the shadow approach makes sense Though I might recommend OneJar instead Yes I just made that change it s pretty straight forward gradlew benchmarks Pjmh f 1 tu ns bm avgt wi 5 i 5 r 1 OperatorSerializePerf I want 3 things 1 The benchmarks task to default to running all benchmarks with reasonable defaults 2 The benchmarks task to support custom arguments as shown above 3 A benchmarksJar task that creates the uber fat shadow Jar that can be used independently of Gradle and taken to other environments I just merged https github com Netflix RxJava pull 995 which allows custom args I would still like a solution for generating the fat jar for execution away from Gradle what do you mean exactly by measuring object allocation @gvsmirnov I would like to measure the impact on GC between two different class implementations and thus want to see things like number of objects allocated pause times young gen time going to synchronization etc Here is the code being tested if it s somehow relevant SerializedObserver https github com Netflix RxJava blob master rxjava core src main java rx observers SerializedObserver java SynchronizedObserver https github com Netflix RxJava blob master rxjava core src main java rx observers SynchronizedObserver java I m testing with JMH and a custom test JMH The benchmark is here https github com Netflix RxJava blob master rxjava core src perf java rx operators OperatorSerializePerf java Custom https github com Netflix RxJava blob master rxjava core src perf java rx archive operators OperatorSerializePerformance java When I run this code in production we see GC issues when using SerializedObserver but benchmarking is not showing this which may mean this class is not actually the issue but signs in prod suggest so as when I switch usage to SynchronizedObserver GC is better I m trying to use JMH to measure performance and memory impact Interestingly the JMH tests show serialized and synchronized as basically performing the same even though my custom tests and production testing show a difference When I turn on HS_GC profiling I get data but am not seeing how it answers my questions Below are some of the results including the HS_GC output Tests run with https github com Netflix RxJava blob master build gradle#L81 #### JMH Benchmarks 0 17 3 Benchmark size Mode Samples Mean Mean error Units r operators OperatorSerializePerf noSerializationSingleThreaded 1024 avgt 5 45 504 1 710 ns op r operators OperatorSerializePerf noSerializationSingleThreaded 1048576 avgt 5 58 600 5 647 ns op r operators OperatorSerializePerf serializedSingleStream 1024 avgt 5 68 610 4 596 ns op r operators OperatorSerializePerf serializedSingleStream 1048576 avgt 5 71 313 2 318 ns op r operators OperatorSerializePerf synchronizedSingleStream 1024 avgt 5 73 322 3 666 ns op r operators OperatorSerializePerf synchronizedSingleStream 1048576 avgt 5 76 518 1 355 ns op 0 17 2 Benchmark size Mode Samples Mean Mean error Units r operators OperatorSerializePerf noSerializationSingleThreaded 1024 avgt 5 45 790 1 184 ns op r operators OperatorSerializePerf noSerializationSingleThreaded 1048576 avgt 5 58 518 3 788 ns op r operators OperatorSerializePerf serializedSingleStream 1024 avgt 5 72 665 7 851 ns op r operators OperatorSerializePerf serializedSingleStream 1048576 avgt 5 74 788 2 946 ns op r operators OperatorSerializePerf synchronizedSingleStream 1024 avgt 5 73 661 3 499 ns op r operators OperatorSerializePerf synchronizedSingleStream 1048576 avgt 5 78 386 5 036 ns op #### Manual Benchmarks 0 17 3 Run 10 9 746 505 ops sec Run 11 9 956 019 ops sec Run 12 10 053 770 ops sec Run 13 10 076 958 ops sec Run 14 9 983 319 ops sec 0 17 2 Run 10 9 851 999 ops sec Run 11 9 726 975 ops sec Run 12 9 719 762 ops sec Run 13 9 668 141 ops sec Run 14 9 799 700 ops sec @param input public void serializedSingleStream Input input for int i 0 i reps i input observable serialize subscribe input subscriber #### GC Profiling ###### 0 17 3 rx operators OperatorSerializePerf noSerializationSingleThreaded HS GC difference sun gc collector 0 invocations 101 sun gc collector 0 lastEntryTime 4996826 sun gc collector 0 lastExitTime 4996824 sun gc collector 0 time 48345 sun gc generation 0 space 0 capacity 37748736 sun gc generation 0 space 1 used 65536 sun gc generation 0 space 2 used 65536 sun gc generation 1 space 0 used 49152 sun gc generation 2 space 0 used 536 sun gc policy avgBaseFootprint 544 sun gc policy avgPromotedDev 3040 sun gc policy avgPromotedPaddedAvg 9120 sun gc policy avgSurvivedAvg 3293 sun gc policy avgSurvivedDev 2172 sun gc policy avgSurvivedPaddedAvg 9810 sun gc policy avgYoungLive 3293 sun gc policy edenSize 37748736 sun gc policy freeSpace 37748736 sun gc policy liveSpace 2752 sun gc policy oldEdenSize 39321600 sun gc policy youngCapacity 39321600 sun gc tlab alloc 4934500 rx operators OperatorSerializePerf serializedSingleStream HS GC difference sun gc collector 0 invocations 109 sun gc collector 0 lastEntryTime 5028125 sun gc collector 0 lastExitTime 5028068 sun gc collector 0 time 51921 sun gc generation 0 space 0 capacity 12058624 sun gc generation 0 space 0 used 46544136 sun gc generation 0 space 1 used 32768 sun gc generation 0 space 2 used 65536 sun gc generation 1 space 0 used 49152 sun gc generation 2 space 0 used 360 sun gc policy avgBaseFootprint 320 sun gc policy avgPromotedDev 3128 sun gc policy avgPromotedPaddedAvg 9385 sun gc policy avgSurvivedAvg 10919 sun gc policy avgSurvivedDev 417 sun gc policy avgSurvivedPaddedAvg 12168 sun gc policy avgYoungLive 10919 sun gc policy decreaseForFootprint 6 sun gc policy edenSize 12058624 sun gc policy freeSpace 12058624 sun gc policy increaseYoungGenForThroughput 5 sun gc policy liveSpace 10592 sun gc policy minorGcCost 1 sun gc policy minorPauseYoungSlope 1 sun gc policy mutatorCost 1 sun gc policy oldEdenSize 6291456 sun gc policy survived 32768 sun gc policy youngCapacity 6291456 sun gc tlab alloc 790550 sun gc tlab maxSlowWaste 32 sun gc tlab slowWaste 32 r o OperatorSerializePerf noSerializationSingleThreaded 1024 avgt 5 45 778 1 837 ns op r o OperatorSerializePerf noSerializationSingleThreaded 1048576 avgt 5 57 498 1 259 ns op r o OperatorSerializePerf serializedSingleStream 1024 avgt 5 68 725 1 119 ns op r o OperatorSerializePerf serializedSingleStream 1048576 avgt 5 72 124 1 131 ns op r o OperatorSerializePerf synchronizedSingleStream 1024 avgt 5 74 341 3 580 ns op r o OperatorSerializePerf synchronizedSingleStream 1048576 avgt 5 78 460 0 347 ns op ###### 0 17 2 rx operators OperatorSerializePerf noSerializationSingleThreaded HS GC difference sun gc collector 0 invocations 101 sun gc collector 0 lastEntryTime 5041703 sun gc collector 0 lastExitTime 5041691 sun gc collector 0 time 48663 sun gc generation 0 space 0 capacity 6815744 sun gc generation 0 space 0 used 10509384 sun gc generation 0 space 2 used 65536 sun gc generation 1 space 0 used 40960 sun gc generation 2 space 0 used 1728 sun gc policy avgBaseFootprint 1728 sun gc policy avgMinorIntervalTime 7 sun gc policy avgPromotedDev 3565 sun gc policy avgPromotedPaddedAvg 10695 sun gc policy avgSurvivedAvg 8504 sun gc policy avgSurvivedDev 3596 sun gc policy avgSurvivedPaddedAvg 2285 sun gc policy avgYoungLive 8504 sun gc policy edenSize 6815744 sun gc policy freeSpace 6815744 sun gc policy liveSpace 6784 sun gc policy oldEdenSize 7340032 sun gc policy survived 65536 sun gc policy youngCapacity 7340032 sun gc tlab alloc 920400 sun gc tlab maxSlowWaste 3 sun gc tlab slowWaste 3 rx operators OperatorSerializePerf serializedSingleStream HS GC difference sun gc collector 0 invocations 113 sun gc collector 0 lastEntryTime 5005975 sun gc collector 0 lastExitTime 5006015 sun gc collector 0 time 53886 sun gc generation 0 space 1 used 32768 sun gc generation 0 space 2 used 65536 sun gc generation 1 space 0 used 40960 sun gc generation 2 space 0 used 1056 sun gc policy avgBaseFootprint 992 sun gc policy avgPromotedDev 3067 sun gc policy avgPromotedPaddedAvg 9201 sun gc policy avgSurvivedAvg 3945 sun gc policy avgSurvivedDev 2143 sun gc policy avgSurvivedPaddedAvg 2485 sun gc policy avgYoungLive 3945 sun gc policy liveSpace 4928 sun gc policy oldEdenSize 6291456 sun gc policy survived 32768 sun gc policy youngCapacity 6291456 sun gc tlab alloc 790200 sun gc tlab maxSlowWaste 26 sun gc tlab slowWaste 26 Benchmark size Mode Samples Mean Mean error Units r o OperatorSerializePerf noSerializationSingleThreaded 1024 avgt 5 46 274 1 587 ns op r o OperatorSerializePerf noSerializationSingleThreaded 1048576 avgt 5 60 240 13 223 ns op r o OperatorSerializePerf serializedSingleStream 1024 avgt 5 73 160 3 774 ns op r o OperatorSerializePerf serializedSingleStream 1048576 avgt 5 76 042 2 867 ns op r o OperatorSerializePerf synchronizedSingleStream 1024 avgt 5 72 692 0 996 ns op r o OperatorSerializePerf synchronizedSingleStream 1048576 avgt 5 76 616 2 982 ns op The shadow jar is now being correctly created as of pull request https github com Netflix RxJava pull 996 I have confirmed that builds from command line importing into Eclipse execution benchmarks via Gradle and using the shadow generated jar are all working',RxJava,true,false,false
29394411,'SubjectSubscriptionManager fix','Fix for #961 If an already unsubscribed Subscriber is added the subscription function ends up in an infinite loop as the inner unsubscription logic changes the state to another object before the outer state machine continues The outer state machine loop now exits if unsubscription happened and doesn t attempt to modify the state The removeObserver method is changed that if the subscription to be removed is not in the array it returns this instead of an unnecessary copy In addition copyOf calls have been replaced by arraycopy to avoid reflective array creation','RxJava pull requests #904 https netflixoss ci cloudbees com job RxJava pull requests 904 FAILURE Looks like there s a problem with this pull request Interesting bug Thanks for the fix As for the test failure looks like testNumberOfThreadsOnScheduledMerge has become non deterministic as a result of recent changes not your commit',RxJava,true,false,false
29493330,'Chain Subscription in TimeoutSubscriber and SerializedSubscriber','This PR chains Subscription in TimeoutSubscriber and SerializedSubscriber Found by @rbramw #951 Thanks for your unit tests @rbramw','RxJava pull requests #905 https netflixoss ci cloudbees com job RxJava pull requests 905 FAILURE Looks like there s a problem with this pull request I have no idea why rx operators OperationParallelMergeTest testNumberOfThreadsOnScheduledMerge failed In my local machine it fails sometimes Is it nondeterministic Rebased RxJava pull requests #915 https netflixoss ci cloudbees com job RxJava pull requests 915 SUCCESS This pull request looks good Thank you Thank you',RxJava,true,false,false
29496306,'Reimplement the ElementAt operator and add it to rxjava scala','','RxJava pull requests #906 https netflixoss ci cloudbees com job RxJava pull requests 906 FAILURE Looks like there s a problem with this pull request RxJava pull requests #907 https netflixoss ci cloudbees com job RxJava pull requests 907 FAILURE Looks like there s a problem with this pull request Rebased RxJava pull requests #916 https netflixoss ci cloudbees com job RxJava pull requests 916 SUCCESS This pull request looks good',RxJava,true,false,false
29563407,'Reimplement the single operator','This PR did the following work Reimplement the single operator Add first last single to rxjava scala When the Observable is empty first last single will throw NoSuchElementException instead of IllegalArgumentException It s more consistent with the Java Collection API e g Deque getFirst http docs oracle com javase 7 docs api java util Deque html#getFirst Deque getLast http docs oracle com javase 7 docs api java util Deque html#getLast This will break the current APIs','RxJava pull requests #908 https netflixoss ci cloudbees com job RxJava pull requests 908 FAILURE Looks like there s a problem with this pull request RxJava pull requests #909 https netflixoss ci cloudbees com job RxJava pull requests 909 FAILURE Looks like there s a problem with this pull request RxJava pull requests #910 https netflixoss ci cloudbees com job RxJava pull requests 910 FAILURE Looks like there s a problem with this pull request RxJava pull requests #917 https netflixoss ci cloudbees com job RxJava pull requests 917 SUCCESS This pull request looks good Thank you @samueltardieu RxJava pull requests #918 https netflixoss ci cloudbees com job RxJava pull requests 918 SUCCESS This pull request looks good Waiting until Rx 0 18 since this is a breaking signature change if dependent on the exception',RxJava,true,false,false
29609489,'What is the proper way to implement observable that get canceled after unsubscribe','Sample java Observable HttpResponse observeResponse String url Observable HttpResponse observable Observable create new Observable OnSubscribeFunc HttpResponse @Override public Subscription onSubscribe final Observer super HttpResponse observer HttpResponse response null try response httpClient getResponse url observer onNext response observer onComplete catch Exeception e observer onError e return new Subscription @Override public void unsubscribe if response null response disconnect return observable Problem with that implementation that unsubscribe don t interrupt execution It seems that this block should be wrapped by FutureTask that got canceled in unsubscribe Probably FutureTask is bad class to use and there is something build in to RxJava','The Subscription is the correct place to do it You can interrupt cancel cleanup or do whatever you wish inside it Here is the signature as of 0 17 java Observable HttpResponse observeResponse String url return Observable create new Observable OnSubscribe HttpResponse @Override public void call final Subscriber super HttpResponse subscriber subscriber add Subscriptions create new Action0 @Override public void call unsubscribe shutdown cleanup here try subscriber onNext value subscriber onCompleted catch Exception e subscriber onError e Problem with that implementation that unsubscribe don t interrupt execution The interruption is an implementation detail of the Subscription you create If it is a thread you want to interrupt then you can do so otherwise you submit the cancellation signal or perform cleanup however it makes sense for the Observable you create @benjchristensen The only way i see to make it cancelable it to wrap this block with FutureTask java try subscriber onNext value subscriber onCompleted catch Exception e subscriber onError e and cancel this future task in unsubscribe @lexer you need to make your Observable asynchronous Scheduler is also an option @zsxwing I just tried async observable I think my problem is that I thought that Interrupted exception is raised after unsubscribe I have looked to RxJava samples and even in async observable example with thread logic relay on subscriber isUnsubscribed I think my problem is that I thought that Interrupted exception is raised after unsubscribe Interrupted exception is like other exceptions You will receive it in onError What about the following code Java Observable HttpResponse observeResponse String url return Observable create new Observable OnSubscribe HttpResponse @Override public void call final Subscriber super HttpResponse subscriber AtomicReference HttpResponse responseRef new AtomicReference HttpResponse subscriber add Subscriptions create new Action0 @Override public void call if responseRef get null responseRef get disconnect subscriber add Schedulers io schedule new Action1 Inner @Override public void call Inner inner try HttpResponse response httpClient getResponse url responseRef set response observer onNext response observer onComplete catch Exeception e observer onError e I m not familiar with these Http apis Maybe you need to check if there is any concurrency issue @zsxwing my problem is that interruptedexception is never thrown I guess I have to check that Im not subscribed anymore before sending result in onNext java try if subscriber isUnsubscribed subscriber onNext value else subscriber onError new InterruptedException subscriber onCompleted catch Exception e subscriber onError e my problem is that interruptedexception is never thrown Where do you call Thread interrupt @lexer Can you provide more context around the code There are many different variables affecting cancellation Are you wrapping an Observable around Apache Async HTTP or Netty If you are returned a Future from your client library then you can call cancel on it If it s a thread you control you can thread interrupt it If it s something that takes a cancellation token you mark the token as cancelled If it s a loop you control you check for unsubscribed If you are working with Futures note that the normal Java future is not good to use as you must block on get If it s a Listenable Completable Future or Akka Scala Twitter variety then you can register the callbacks for onNext and have a mechanism for canceling If you are working on Apache HTTP or Netty check these out RxNetty https github com Netflix RxNetty rxjava apache http https github com Netflix RxJava tree master rxjava contrib rxjava apache http @benjchristensen I m wrapping OkHttp https github com square okhttp that has no async version like Apache http or netty https github com lyft reactive http blob master src main java com lyft reactivehttp ReactiveHttpClient java#L152 I want to immediately stop execution of this block java @Override public Subscription onSubscribe Observer super T observer try T result executeAndProcess request responseProcessor observer onNext result observer onCompleted catch Throwable e observer onError e return Subscriptions empty',RxJava,false,false,false
29727736,'How to throw an exception from within an Observer','Hi I am trying to make the app fail fast when something is going wrong from the Observer I was surprised to see that the Exception was swallowed by RxJava Here is a sample I tried java Observable error new Exception subscribe new Observer Object @Override public void onCompleted @Override public void onError Throwable e throw new IllegalStateException This should crash the app @Override public void onNext Object o Do I need do do anything specific to fail from within an Observer','According to Rx contract onError will be called only once So you need to handle the exception in onError by yourself I understand that onError is called only once I m not trying to forward the exception to something else What I want to do is be able to throw a RuntimeException to make the app terminate RxJava will catch Exception and most Error You can not propagate Exception out of RxJava I m curious why you have such requirement I get why catching all errors from within the flow of RxJava ie observables functions etc to keep the monadic properties but once you reach the Observer the flow is consumed and this the point in the app where you can act on the events The idea here is to fail fast in order to identify easily developer errors during the development phase I was under the assumption after reading this closed issue https github com Netflix RxJava issues 650 that RxJava should not be swallowing exceptions from within an Observer #650 is out of date The Observer is not only used by users but also by RxJava Observer is also used to build operators In my opinion Observable is often asynchronous It means Observer ofer runs in other thread instead of the main thread Even RxJava throws the RuntimeException it only crash the thread That s still hard to debug I suppose that forcing users to handle the exception is a better idea I didn t realise that some operator might be using Observers internally makes more sense now I am handling the exceptions properly I just wanted to figure out a way to make unexpected failures resulting from developer errors to be easier to spot I suppose I ll rely on visual indication and Logs for now This is an odd use case and it skips over the Exceptions throwIfFatal line in subscribe and swallows the error https github com Netflix RxJava blob master rxjava core src main java rx Observable java#L7094 Not ideal at all I think we may need to make SafeSubscriber use an Exception other than RuntimeException that is considered fatal so we don t end up in loops where observer onError throws and then subscribe tries to re send it right back to observer onError again only to get ignored by SafeSubscriber that allows only a single terminal state See here for the RuntimeException that should get thrown all the way up https github com Netflix RxJava blob master rxjava core src main java rx observers SafeSubscriber java#L171 Sorry for reviving an old discussion We also run into the same issue and the change that went in does not really help us Rx contract or not I think I agree with @Dorvaryn that certain errors should simply terminate the app since they can signal developer error rather than anticipated runtime errors A good example are precondition checks and assertions Guava for instances throws IllegalArgumentException when a precondition failed This will throw during an onNext call Why would I want to handle this within the Rx call chain As a developer I violated a method contract and should be informed immediately by seeing the app crash The same goes for null pointers The way this is dealt with right now a static Exceptions throwIfFatal method which cannot be overridden and which does not account for above mentioned cases a plugin system for errors but which is safe guarded against from re throwing errors so this is not an option either While do see your points I think there is definitely a case to be made for failing early outside the Rx contract since you want to terminate the app why would breaking the Rx contract matter anyway It would go a long way to make Rx based apps easier to debug since more often than not errors you expect to fail the app simply disappear in the safe guards applied by SafeSubscriber Actually a much simpler way to solve this would be to change throwIfFatal to always rethrow Error s and not just the 4 specific ones it checks for That way we could wrap exceptions in AssertionError and have it terminate early Was there any particular reason why only 4 kinds of errors are rethrown from throwIfFatal There s other kinds of errors like NoClassDefFoundError that should probably be considered fatal as well I always assumed anything derived from Error is considered fatal anyway Generally errors should be emitted to onError otherwise systems can end up hanging and or leak resources because they never receive a terminal event onComplete onError and therefore never releases user requests unsubscribed for cleanup etc Only fatal errors are thrown and the OnErrorNotImplementedException after the terminal event ensures everything receives an unsubscribe Ben Christensen 310 782 5511 @benjchristensen On Jun 24 2014 at 2 00 PM Matthias K ppler notifications@github com wrote Actually a much simpler way to solve this would be to change throwIfFatal to always rethrow Errors and not just the 4 specific ones it checks for That way we could wrap exceptions in AssertionError and have it terminate early Was there any particular reason why only 4 kinds of errors are rethrown from throwIfFatal There s other kinds of errors like NoClassDefFoundError that should probably be considered fatal as well I always assumed anything derived from Error is considered fatal anyway Reply to this email directly or view it on GitHub Sure but why is something like NoClassDefFound not considered fatal According to Java s Error doc all subclasses are considered fatal The definition of fatal exceptions can definitely be changed Here is what we will want to change https github com Netflix RxJava blob master rxjava core src main java rx exceptions Exceptions java#L82 Would you be okay with replacing these 4 checks with instanceof Error I m not sure if this will have a larger impact but I feel that s the right thing to do here Perhaps Should AssertionError be considered fatal though When we say fatal here it really does mean the app may die it need to be killed as user requests may be hung if this happens In our case I feel an assertion failure should kill the app but I see that in different environments there might be different requirements around such behavior I was actually wondering if there is even a need to split up Exceptions throwIfFatal and the global error handler registered via RxJavaPlugins If we weaken the requirement of the global onError hook to rethrow if desired the logic from throwIfFatal could simply live in a default onError hook and would remain overridable by clients It also looks like a potential source of bugs due to duplication maybe it s by design but the recently rewritten ExecutorScheduler does not invoke throwIfFatal if it catches an error only the global onError hook this makes for one half of the problem we re having since it wraps all job executions in a try catch finally block so even if throwIfFatal would rethrow say a StackOverflowError the job would silently shut down and no one ever sees that error I guess it makes sense in terms of resilience but makes debugging hard since all fatal errors disappear in a void The onError hook is only for logging and insights not for decoration or throwing https github com Netflix RxJava blob master rxjava core src main java rx plugins RxJavaErrorHandler java#L37 The plugin was specifically created to help identify when there is bad code swallowing errors in production environments and other similar diagnostic use cases It was never intended for application logic That s why it doesn t return anything and has a strict contract to never throw If ExecutorScheduler is swallowing fatal errors primarily exceptions thrown from onError then it is a bug The contract for error handling in Rx is 1 All errors thrown by user provided functions or notifications to onNext and onCompleted must be passed to onError unless they are considered fatal primarily to prevent OutOfMemory and StackoverFlow scenarios 2 If onError itself throws an exception there is no choice but to consider it fatal A try catch finally isn t reliable when multiple threads are involved this is why it s so important to route errors to onError and only throw if we have no other choice i e onError itself throws due to the non determinism of what thread it will be thrown on and what resources it will leave hanging Can we step back and clearly define the use case trying to be solved I want to understand if it s the actual Rx contract above that is in question or just a bug in an operator or choice of fatal exceptions that needs to be fixed I see that makes sense The use case we re trying to address is discovering developer failure early In this specific instance we had a precondition check fail on a method argument which was invoked inside an RxJava call chain The precondition check fails with IllegalArgumentException which is a RuntimeException which in turn is not considered fatal by RxJava so gets caught in SafeSubscriber s safety net again there is no reasonable way to recover from that error in the app The result is that our app continues to run in a broken or undefined state since we continue execution after a precondition was violated This is hard to debug and not obvious to the programmer What we want is to crash the app What does your onError handler do with the exception when it receives it It checks it for its type and then decides if it should rethrow or report silently into our crash logging service We rethrow all Errors and all RuntimeExceptions Checked exceptions are either logged depends on the type as well we don t log IOExceptions for instance or are simply ignored because they are expected to be handled by the subscriber in a way appropriate to the context of the subscriber Since your final onError throws it would result in it being treated as fatal and allowed to throw all the way up the stack On the other hand if a developer doesn t implement onError you d just get everything thrown wrapped in an OnErrorNotImplementedException which seems to also results in behavior you d like Considering these two possibilities what about this current state isn t working for you I believe part of the problem is ExecutorScheduler Its run method is @Override public void run if isUnsubscribed return try actual call catch Throwable t RxJavaPlugins getInstance getErrorHandler handleError t finally unsubscribe That is it catches all errors and loops them through the global onError hook which is not allowed to throw So even if SafeSubscriber rethrows it would just end up being swallowed again That said just from my perspective what we could do is to let the developer decide what fatal means when an exception is caught This could be as simple as providing a predicate isFatal e g through the plugin APIs that SafeSubscriber calls instead of the static Exceptions throwIfFatal method and would rethrow on true Plus we need to make sure that this logic is executed in all internal classes the catch Throwable Otherwise we ll end up swallowing errors that shouldn t be swallowed Definitely let the developer decide what fatal means If the user provided Subscriber onError throws an exception it will always be treated as fatal since onError itself failed Due to this I don t see why anything further is needed The only real reason Exceptions throwIfFatal really exists is to avoid recursive loops and stack overflow Otherwise everything gets routed to onError or onError itself throws and the exception is allowed to throw all the way up the stack I believe part of the problem is ExecutorScheduler Agreed If scheduled work fails it has no choice but to throw an exception wherever it is such as here https github com Netflix RxJava blob master rxjava core src main java rx internal schedulers ScheduledAction java#L41 Work being scheduled should never throw but instead propagate to onError but if the action being scheduled doesn t correctly handled that the Scheduler itself does not have a reference to a Subscriber and thus can do nothing but throw No operator should ever behave that way though Work being scheduled should never throw but instead propagate to onError but if the action being scheduled doesn t correctly handled that the Scheduler itself does not have a reference to a Subscriber and thus can do nothing but throw No operator should ever behave that way though Makes sense I m not sure I understand what you re suggesting though All our observables are scheduled so whatever the subscriber does won t matter as it will end up in this catch clause Does that mean there is no way for us to achieve what I outlined I m saying that the operators that do scheduling should do the error handling For example I see that observeOn doesn t catch and propagate to onError https github com Netflix RxJava blob master rxjava core src main java rx internal operators OperatorObserveOn java#L139 If the operator doesn t do it a user has no hope of managing errors',RxJava,false,false,false
29798052,'Notifications for the allocation adverse','I ve seen and used the sentinel pattern in a couple of places in the implementation of operators I figured I d formalize the hacks into one place where bugs can coalesce As a bonus the code that uses it looks a bit cleaner now','RxJava pull requests #911 https netflixoss ci cloudbees com job RxJava pull requests 911 SUCCESS This pull request looks good Nice abstraction',RxJava,true,false,false
29806596,'Subjects are not recognized as internal observer implementations','Based on an issue report https groups google com forum # topic rxjava 6cgorYXy7B0 the following program prints the sequence twice instead of continuously java public class RepeatCacheTest public static void main String args throws Exception Observable from 1 2 3 subscribeOn Schedulers io flatMap i Observable timer i 100 TimeUnit MILLISECONDS map j i cache repeat zip Observable timer 0 300 TimeUnit MILLISECONDS Schedulers newThread a b a subscribe System out println Throwable printStackTrace System out println Done Thread sleep 100000 The problem seems to be in Observable isInternalImplementation L8661 not recognizing the ReplaySubject of the cache operator wrapped by a anonymous Subscriber under Observable A logic is required on L7002 to preserve the safeness of the wrapped Observer somehow private indicator interface Can we consider rx subjects classes as safe Alternatively cache could wrap the subject in a Subscriber so it will count as internal implementation Thoughts','Would this be simplified if we eliminate the isInternalImplementation check that I don t like and use unsafeSubscribe as discussed here https github com Netflix RxJava issues 676#issuecomment 37663897 Sure To be clear the real problem was something else I discovered soon after I posted this issue Closing as not relevant anymore',RxJava,false,false,false
29817158,'Fixed deadlock in Subjects OperatorCache','Fix for Issue #971 I had to rewrite OperatorCache to allow testing for deadlocks in all Subject types The terminationLatch was unnecessarily waiting for existing subscribers to deliver their termination events which caused deadlock with repeat Treating subjects as internal implementations was not necessary to fix the problem','RxJava pull requests #912 https netflixoss ci cloudbees com job RxJava pull requests 912 SUCCESS This pull request looks good I don t understand these changes yet but on first review they are very awkward as the SubjectSubscriptionManager methods now both invoke a function and return a collection True the rewritten Subjects don t require an Action1 they are fine with Action0 The changes had to be made since the CountDonwLatch logic acted as a synchronization block and emitting events while holding locks is prone to deadlocks as the associated issue demonstrates Ah holding the lock is the issue We should find a way of doing that without the latches at all as it is blocking The latch has its use because once the state has been swapped to terminal state we still need to perform some tasks on any related state within the particular subject before client notifications can resume usually it is to set the last event which then will be available to newcomers I haven t merged this yet as I need to spend time better understanding this and the impact on design Since this has conflicts and I did some cleanup based on our discussion above I ve opened https github com Netflix RxJava pull 1040 for merging this',RxJava,true,false,false
29836478,'Merge Handle Bad Observables','concurrency unit tests handle Observable that emits onComplete multiple times See https github com Netflix RxJava pull 962#issuecomment 38191868','RxJava pull requests #913 https netflixoss ci cloudbees com job RxJava pull requests 913 FAILURE Looks like there s a problem with this pull request rx operators OperationParallelMergeTest testNumberOfThreads I know about this and am hunting it down It s unrelated to this pull request',RxJava,true,false,false
29840475,'TestSubject TestObserver and TestScheduler Improvements','','',RxJava,true,false,false
29841138,'GroupBy Time Gap Fixes','I ran head on into the time gap https github com Netflix RxJava issues 844 issue while working on a stream processing use case and new pivot operator I m writing This is a solution It s still not ideal as the Javadocs of BufferUntilSubscriber mention but this is working better than nothing and does not require blocking threads A better solution will come as part of the back pressure work where BufferUntilSubscriber will evolve to have a bounded buffer','RxJava pull requests #914 https netflixoss ci cloudbees com job RxJava pull requests 914 FAILURE Looks like there s a problem with this pull request I should probably fix that random compilation error sitting in master branch',RxJava,true,false,false
29845013,'parallel merge unit test assertions','Using serialize for merge allows less threads to be used under contention instead of blocking and using them all This changes the assertion to be 3 instead of 3 because of that','',RxJava,true,false,false
29860188,'Dematerialize handle non materialized terminal events','This is used for a use case such as java observable flatMap t if x return Observable from Notification create t else return Observable error e dematerialize','',RxJava,true,false,false
29882145,'Merging changes after an Async load','I m not sure if this is the place to ask this but here goes I have an Observable BigThing which loads from disk using an Async utils Observable At the same time there is a Socket connection to a server that has an Observable Packet which may contain updates to BigThing I want to find a way to collate those updates while BigThing is loading then when it has finished loading apply them and emit the fully updated one to the public Observable BigThing which then continues emitting when it gets updated by further updates from the network socket What is the best way to approach this My current solutions is pseudocode java packetsBeforeLoad updatePackets scan new ArrayList Packet packets currentPacket packets add currentPacket return packets takeUntil bigThingAsync last mergedBigThing bigThingAsync zip packetsBeforeLoad bigThing packets bigThing update packets return bigThing first return Observable combineLatest mergedBigThing updatePackets bigThing packet bigThing update packet return bigThing This feels like it will work but I am unsure if it is possible that it will miss updates between when the takeUntil completes and mergedBigThing is emitted into combineLatest I wanted to avoid replay which seems like the obvious answer because this will be long lived and I don t want it to maintain an array that will continue to grow forever after the bigThing has finished loading Perhaps there is a way using switchLatest Any help would be appreciated Dylan','That seems like a solid approach but the concern of a race is valid It s complicated enough that I m not 100 certain I apologize that I don t have the bandwidth right now to consider this further right now but I ll leave it on my list perhaps someone else has time The one possible issue in that code is time gap between subscribes and losing data Here is a solution used internally when hopping threads such as groupBy with hot observables like you have here https github com Netflix RxJava blob master rxjava core src main java rx operators BufferUntilSubscriber java It buffers until a subscription is received and then switches to pass thru in a 2 step process Thanks for your time and input The approach I have taken is to observe both input signals the loading and the updates on the same serial handler scheduler on android so that this whole subgraph is synchronised and new updates will be buffered in the scheduler while the loader observers are finishing It seems to work but it is hard to test Thanks for the link I ll have a look On 27 Mar 2014 04 03 Ben Christensen notifications@github com wrote That seems like a solid approach but the concern of a race is valid It s complicated enough that I m not 100 certain I apologize that I don t have the bandwidth right now to consider this further right now but I ll leave it on my list perhaps someone else has time The one possible issue in that code is time gap between subscribes and losing data Here is a solution used internally when hopping threads such as groupBy with hot observables like you have here https github com Netflix RxJava blob master rxjava core src main java rx operators BufferUntilSubscriber java It buffers until a subscription is received and then switches to pass thru in a 2 step process Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 978#issuecomment 38714330 Closing out as this went stale if you want to discuss further please post to https groups google com forum # forum rxjava',RxJava,false,false,false
29960328,'Android subscriber gets garbage collected prematurely','The code in OperatorWeakBinding java creates a weak reference onto the subscriber in addition to a weak reference onto the Android component Not keeping a string reference on the subscriber is wrong I have had a lot of non delivered messages on cgeo because we use code like java AndroidObservable bindActivity this someObservable subscribe new Observer Do something with the data such as display it in a view The only reference to the subscriber is in the subscription If it is transformed into a weak reference it will be garbage collected much too soon This is a major departure from the usual non Android RxJava subscription model I think the subscriber should be kept as is and not be kept as a weak reference only I understand that this has been done so that the activity life cycle is not extended due to the subscriber keeping a reference onto it I think this is the subscriber responsibility to keep only a weak reference to the activity or fragment Maybe another mechanism to allow the subscriber to use a weak reference to the component should be found but in the meantime the current behaviour seems just wrong to me','cc @mttkay I see what you mean The rationale behind using a weak reference to the subscriber is that in most of the cases it ll be an inner class of the activity in your case too If we would hold a strong reference to the observer we would hold a strong reference to the Activity too so for the life time of the sequence your Activity would immediately leak when attempting to destroy it That said it s not as simple as turning a weak reference into a strong reference but I totally see your point I m open for suggestions here as I ve tried many approaches to solve these issues and we keep finding edge cases where the solutions collapse On the top of my head couldn t we find a way to give the Android component back to the subscriber Something like scala def bindActivity T Activity U activity T sourceObservable Observable U Observable T U This way the subscriber will get a reference to the activity with every item and doesn t need to keep strong references to it Of course it means that the user needs to be cautious in not closing over the activity through other references but it can do so by declaring the subscriber in the companion object rather than in the activity itself if they are not sure to do it correctly forget my remark about the companion object I was thinking in Scala term I meant as a static method in Java @samueltardieu Is this still an issue I believe that as of #1021 that was merged this should no longer be happening Exactly Closing it',RxJava,false,false,false
29996454,'RxJava gradlew issue Could not create task of type ScalaDoc','Hey I m seeing a RxJava build issue error related to Scala Hint I downloaded the special Eclipse for Scala a long time ago for my coursera class Probably something left over It similar to https gist github com jaceklaskowski 9496058 Thanks Matt Matts MacBook Pro RxJava mattmccline gradlew build Downloading http services gradle org distributions gradle 1 8 all zip Unzipping Users mattmccline gradle wrapper dists gradle 1 8 all 2kopnp0i5dq014k75fp36m3vd5 gradle 1 8 all zip to Users mattmccline gradle wrapper dists gradle 1 8 all 2kopnp0i5dq014k75fp36m3vd5 Set executable permissions for Users mattmccline gradle wrapper dists gradle 1 8 all 2kopnp0i5dq014k75fp36m3vd5 gradle 1 8 bin gradle Download http dl bintray com content gvsmirnov gradle plugins com github jengelman gradle plugins shadow 0 8 1 shadow 0 8 1 pom Download http dl bintray com content netflixoss external gradle plugins nl javadude gradle plugins license gradle plugin 0 6 1 license gradle plugin 0 6 1 pom Download http repo1 maven org maven2 com mapvine gradle cobertura plugin 0 1 gradle cobertura plugin 0 1 pom Download http dl bintray com content netflixoss external gradle plugins gradle release gradle release 1 1 5 gradle release 1 1 5 pom Download http repo1 maven org maven2 org ajoberstar gradle git 0 5 0 gradle git 0 5 0 pom Download http repo1 maven org maven2 jdom jdom 1 1 jdom 1 1 pom Download http repo1 maven org maven2 asm asm 3 3 1 asm 3 3 1 pom Download http repo1 maven org maven2 asm asm parent 3 3 1 asm parent 3 3 1 pom Download http repo1 maven org maven2 asm asm commons 3 3 1 asm commons 3 3 1 pom Download http repo1 maven org maven2 com google guava guava 11 0 2 guava 11 0 2 pom Download http repo1 maven org maven2 com google guava guava parent 11 0 2 guava parent 11 0 2 pom Download http repo1 maven org maven2 org sonatype oss oss parent 7 oss parent 7 pom Download http repo1 maven org maven2 com mycila maven license plugin maven license plugin 1 10 b1 maven license plugin 1 10 b1 pom Download http repo1 maven org maven2 com mycila parent pom 5 parent pom 5 pom Download http repo1 maven org maven2 org eclipse jgit org eclipse jgit ui 2 2 0 201212191850 r org eclipse jgit ui 2 2 0 201212191850 r pom Download http repo1 maven org maven2 org eclipse jgit org eclipse jgit parent 2 2 0 201212191850 r org eclipse jgit parent 2 2 0 201212191850 r pom Download http repo1 maven org maven2 org eclipse jgit org eclipse jgit 2 2 0 201212191850 r org eclipse jgit 2 2 0 201212191850 r pom Download http repo1 maven org maven2 org jdom jdom 1 1 jdom 1 1 pom Download http repo1 maven org maven2 asm asm tree 3 3 1 asm tree 3 3 1 pom Download http repo1 maven org maven2 com google code findbugs jsr305 1 3 9 jsr305 1 3 9 pom Download http repo1 maven org maven2 com mycila xmltool xmltool 3 3 xmltool 3 3 pom Download http repo1 maven org maven2 org codehaus plexus plexus utils 2 0 5 plexus utils 2 0 5 pom Download http repo1 maven org maven2 org codehaus plexus plexus 2 0 6 plexus 2 0 6 pom Download http repo1 maven org maven2 com jcraft jsch 0 1 44 1 jsch 0 1 44 1 pom Download http repo1 maven org maven2 org sonatype oss oss parent 6 oss parent 6 pom Download http dl bintray com content gvsmirnov gradle plugins com github jengelman gradle plugins shadow 0 8 1 shadow 0 8 1 jar Download http dl bintray com content netflixoss external gradle plugins nl javadude gradle plugins license gradle plugin 0 6 1 license gradle plugin 0 6 1 jar Download http repo1 maven org maven2 com mapvine gradle cobertura plugin 0 1 gradle cobertura plugin 0 1 jar Download http dl bintray com content netflixoss external gradle plugins gradle release gradle release 1 1 5 gradle release 1 1 5 jar Download http repo1 maven org maven2 org ajoberstar gradle git 0 5 0 gradle git 0 5 0 jar Download http repo1 maven org maven2 asm asm 3 3 1 asm 3 3 1 jar Download http repo1 maven org maven2 asm asm commons 3 3 1 asm commons 3 3 1 jar Download http repo1 maven org maven2 com google guava guava 11 0 2 guava 11 0 2 jar Download http repo1 maven org maven2 com mycila maven license plugin maven license plugin 1 10 b1 maven license plugin 1 10 b1 jar Download http repo1 maven org maven2 org eclipse jgit org eclipse jgit ui 2 2 0 201212191850 r org eclipse jgit ui 2 2 0 201212191850 r jar Download http repo1 maven org maven2 org eclipse jgit org eclipse jgit 2 2 0 201212191850 r org eclipse jgit 2 2 0 201212191850 r jar Download http repo1 maven org maven2 org jdom jdom 1 1 jdom 1 1 jar Download http repo1 maven org maven2 asm asm tree 3 3 1 asm tree 3 3 1 jar Download http repo1 maven org maven2 com google code findbugs jsr305 1 3 9 jsr305 1 3 9 jar Download http repo1 maven org maven2 com mycila xmltool xmltool 3 3 xmltool 3 3 jar Download http repo1 maven org maven2 org codehaus plexus plexus utils 2 0 5 plexus utils 2 0 5 jar Download http repo1 maven org maven2 com jcraft jsch 0 1 44 1 jsch 0 1 44 1 jar The TaskContainer add method has been deprecated and is scheduled to be removed in Gradle 2 0 Please use the create method instead Download http clojars org repo clojuresque clojuresque 1 5 8 clojuresque 1 5 8 pom Download http clojars org repo clojuresque clojuresque 1 5 8 clojuresque 1 5 8 jar Download http repo1 maven org maven2 org jetbrains kotlin kotlin gradle plugin 0 6 1673 kotlin gradle plugin 0 6 1673 pom Download http repo1 maven org maven2 org jetbrains kotlin kotlin project 0 6 1673 kotlin project 0 6 1673 pom Download http repo1 maven org maven2 org jetbrains kotlin kotlin stdlib 0 6 1673 kotlin stdlib 0 6 1673 pom Download http repo1 maven org maven2 org jetbrains kotlin kotlin runtime 0 6 1673 kotlin runtime 0 6 1673 pom Download http repo1 maven org maven2 org jetbrains kotlin kotlin gradle plugin 0 6 1673 kotlin gradle plugin 0 6 1673 jar Download http repo1 maven org maven2 org jetbrains kotlin kotlin stdlib 0 6 1673 kotlin stdlib 0 6 1673 jar Download http repo1 maven org maven2 org jetbrains kotlin kotlin runtime 0 6 1673 kotlin runtime 0 6 1673 jar Download http repo1 maven org maven2 org jetbrains kotlin kotlin gradle plugin core 0 6 1673 kotlin gradle plugin core 0 6 1673 pom Download http repo1 maven org maven2 commons lang commons lang 2 3 commons lang 2 3 pom Download http repo1 maven org maven2 com google guava guava 12 0 guava 12 0 pom Download http repo1 maven org maven2 com google guava guava parent 12 0 guava parent 12 0 pom Download http repo1 maven org maven2 org apache directory studio org apache commons io 2 4 org apache commons io 2 4 pom Download http repo1 maven org maven2 org apache directory studio parent libraries 2 0 0 v20130125 parent libraries 2 0 0 v20130125 pom Download http repo1 maven org maven2 org apache directory studio parent 2 0 0 v20130125 parent 2 0 0 v20130125 pom Download http repo1 maven org maven2 org apache directory project project 27 project 27 pom Download http repo1 maven org maven2 org apache apache 10 apache 10 pom Download http repo1 maven org maven2 org jetbrains kotlin kotlin compiler 0 6 1673 kotlin compiler 0 6 1673 pom Download http repo1 maven org maven2 org jetbrains kotlin kotlin jdk annotations 0 6 1673 kotlin jdk annotations 0 6 1673 pom Download http repo1 maven org maven2 org jetbrains kotlin kdoc 0 6 1673 kdoc 0 6 1673 pom Download http repo1 maven org maven2 commons io commons io 2 4 commons io 2 4 pom Download http repo1 maven org maven2 org apache commons commons parent 25 commons parent 25 pom Download http repo1 maven org maven2 org apache apache 9 apache 9 pom Download http repo1 maven org maven2 org pegdown pegdown 1 1 0 pegdown 1 1 0 pom Download http repo1 maven org maven2 org parboiled parboiled core 1 0 2 parboiled core 1 0 2 pom Download http repo1 maven org maven2 org parboiled parboiled java 1 0 2 parboiled java 1 0 2 pom Download http repo1 maven org maven2 asm asm util 3 3 1 asm util 3 3 1 pom Download http repo1 maven org maven2 asm asm analysis 3 3 1 asm analysis 3 3 1 pom Download http repo1 maven org maven2 org jetbrains kotlin kotlin gradle plugin core 0 6 1673 kotlin gradle plugin core 0 6 1673 jar Download http repo1 maven org maven2 commons lang commons lang 2 3 commons lang 2 3 jar Download http repo1 maven org maven2 com google guava guava 12 0 guava 12 0 jar Download http repo1 maven org maven2 commons io commons io 2 4 commons io 2 4 jar Download http repo1 maven org maven2 org apache directory studio org apache commons io 2 4 org apache commons io 2 4 jar Download http repo1 maven org maven2 org jetbrains kotlin kotlin compiler 0 6 1673 kotlin compiler 0 6 1673 jar Download http repo1 maven org maven2 org jetbrains kotlin kotlin jdk annotations 0 6 1673 kotlin jdk annotations 0 6 1673 jar Download http repo1 maven org maven2 org parboiled parboiled core 1 0 2 parboiled core 1 0 2 jar Download http repo1 maven org maven2 asm asm util 3 3 1 asm util 3 3 1 jar Download http repo1 maven org maven2 asm asm analysis 3 3 1 asm analysis 3 3 1 jar Download http repo1 maven org maven2 org parboiled parboiled java 1 0 2 parboiled java 1 0 2 jar Download http repo1 maven org maven2 org pegdown pegdown 1 1 0 pegdown 1 1 0 jar Download http repo1 maven org maven2 org jetbrains kotlin kdoc 0 6 1673 kdoc 0 6 1673 jar FAILURE Build failed with an exception Where Build file Users mattmccline RxJava language adaptors rxjava scala build gradle line 1 What went wrong A problem occurred evaluating project language adaptors rxjava scala Could not create task of type ScalaDoc Try Run with stacktrace option to get the stack trace Run with info or debug option to get more log output BUILD FAILED Total time 5 mins 18 692 secs','Could you add stacktrace to get the stacktrace of the error What s version of your JDK If it s 1 8 maybe it s the same issue as here http forums gradle org gradle topics enable_to_setup_a_simple_scala_build Hi Shixiong Thank you for looking into the problem Yes the JDK is 1 8 I ll look at the link you have provided next Below is the build with the stacktrace option Matts MacBook Pro RxJava mattmccline gradlew build stacktrace The TaskContainer add method has been deprecated and is scheduled to be removed in Gradle 2 0 Please use the create method instead FAILURE Build failed with an exception Where Build file Users mattmccline RxJava language adaptors rxjava scala build gradle line 1 What went wrong A problem occurred evaluating project language adaptors rxjava scala Could not create task of type ScalaDoc Try Run with info or debug option to get more log output Exception is org gradle api GradleScriptException A problem occurred evaluating project language adaptors rxjava scala at org gradle groovy scripts internal DefaultScriptRunnerFactory ScriptRunnerIm pl run DefaultScriptRunnerFactory java 54 at org gradle configuration DefaultScriptPluginFactory ScriptPluginImpl apply D efaultScriptPluginFactory java 132 at org gradle configuration project BuildScriptProcessor execute BuildScriptPro cessor java 38 at org gradle configuration project BuildScriptProcessor execute BuildScriptPro cessor java 25 at org gradle configuration project ConfigureActionsProjectEvaluator evaluate C onfigureActionsProjectEvaluator java 34 at org gradle configuration project LifecycleProjectEvaluator evaluate Lifecycl eProjectEvaluator java 55 at org gradle api internal project AbstractProject evaluate AbstractProject jav a 468 at org gradle api internal project AbstractProject evaluate AbstractProject jav a 76 at org gradle configuration DefaultBuildConfigurer configure DefaultBuildConfig urer java 31 at org gradle initialization DefaultGradleLauncher doBuildStages DefaultGradleL auncher java 142 at org gradle initialization DefaultGradleLauncher doBuild DefaultGradleLaunche r java 113 at org gradle initialization DefaultGradleLauncher run DefaultGradleLauncher ja va 81 at org gradle launcher exec InProcessBuildActionExecuter DefaultBuildController run InProcessBuildActionExecuter java 64 at org gradle launcher cli ExecuteBuildAction run ExecuteBuildAction java 33 at org gradle launcher cli ExecuteBuildAction run ExecuteBuildAction java 24 at org gradle launcher exec InProcessBuildActionExecuter execute InProcessBuild ActionExecuter java 35 at org gradle launcher exec InProcessBuildActionExecuter execute InProcessBuild ActionExecuter java 26 at org gradle launcher cli RunBuildAction run RunBuildAction java 50 at org gradle api internal Actions RunnableActionAdapter execute Actions java 1 71 at org gradle launcher cli CommandLineActionFactory ParseAndBuildAction execute CommandLineActionFactory java 201 at org gradle launcher cli CommandLineActionFactory ParseAndBuildAction execute CommandLineActionFactory java 174 at org gradle launcher cli CommandLineActionFactory WithLogging execute Command LineActionFactory java 170 at org gradle launcher cli CommandLineActionFactory WithLogging execute Command LineActionFactory java 139 at org gradle launcher cli ExceptionReportingAction execute ExceptionReportingA ction java 33 at org gradle launcher cli ExceptionReportingAction execute ExceptionReportingA ction java 22 at org gradle launcher Main doAction Main java 46 at org gradle launcher bootstrap EntryPoint run EntryPoint java 45 at org gradle launcher Main main Main java 37 at org gradle launcher bootstrap ProcessBootstrap runNoExit ProcessBootstrap ja va 50 at org gradle launcher bootstrap ProcessBootstrap run ProcessBootstrap java 32 at org gradle launcher GradleMain main GradleMain java 23 at org gradle wrapper BootstrapMainStarter start BootstrapMainStarter java 33 at org gradle wrapper WrapperExecutor execute WrapperExecutor java 130 at org gradle wrapper GradleWrapperMain main GradleWrapperMain java 48 Caused by org gradle api tasks TaskInstantiationException Could not create task of type ScalaDoc at org gradle api internal project taskfactory TaskFactory 1 call TaskFactory j ava 126 at org gradle api internal project taskfactory TaskFactory 1 call TaskFactory j ava 121 at org gradle api internal AbstractTask injectIntoNewInstance AbstractTask java 142 at org gradle api internal project taskfactory TaskFactory createTaskObject Tas kFactory java 121 at org gradle api internal project taskfactory TaskFactory createTask TaskFacto ry java 81 at org gradle api internal project taskfactory AnnotationProcessingTaskFactory createTask AnnotationProcessingTaskFactory java 99 at org gradle api internal project taskfactory DependencyAutoWireTaskFactory cr eateTask DependencyAutoWireTaskFactory java 39 at org gradle api internal tasks DefaultTaskContainer create DefaultTaskContain er java 52 at org gradle api internal tasks DefaultTaskContainer create DefaultTaskContain er java 85 at org gradle api tasks TaskContainer create 0 call Unknown Source at org gradle api plugins scala ScalaPlugin configureScaladoc ScalaPlugin groov y 40 at org gradle api plugins scala ScalaPlugin this 2 configureScaladoc ScalaPlugi n groovy at org gradle api plugins scala ScalaPlugin this 2 configureScaladoc callCurren t Unknown Source at org gradle api plugins scala ScalaPlugin apply ScalaPlugin groovy 32 at org gradle api plugins scala ScalaPlugin apply ScalaPlugin groovy at org gradle api internal plugins DefaultPluginContainer providePlugin Default PluginContainer java 104 at org gradle api internal plugins DefaultPluginContainer addPluginInternal Def aultPluginContainer java 68 at org gradle api internal plugins DefaultPluginContainer apply DefaultPluginCo ntainer java 34 at org gradle api internal plugins DefaultObjectConfigurationAction applyPlugin DefaultObjectConfigurationAction java 101 at org gradle api internal plugins DefaultObjectConfigurationAction access 200 DefaultObjectConfigurationAction java 32 at org gradle api internal plugins DefaultObjectConfigurationAction 3 run Defau ltObjectConfigurationAction java 72 at org gradle api internal plugins DefaultObjectConfigurationAction execute Def aultObjectConfigurationAction java 114 at org gradle api internal project AbstractPluginAware apply AbstractPluginAwar e java 39 at org gradle api Project apply call Unknown Source at org gradle api internal project ProjectScript apply ProjectScript groovy 34 at org gradle api Script apply callCurrent Unknown Source at build_6cbd2484ji1s8a6u66c7j8j32q run Users mattmccline RxJava language adap tors rxjava scala build gradle 1 at org gradle groovy scripts internal DefaultScriptRunnerFactory ScriptRunnerIm pl run DefaultScriptRunnerFactory java 52 33 more Caused by java lang NullPointerException at org gradle api DefaultTask init DefaultTask java 33 at org gradle api internal ConventionTask init ConventionTask java 28 at org gradle api tasks SourceTask init SourceTask java 36 at org gradle api tasks scala ScalaDoc init ScalaDoc java 28 at org gradle api tasks scala ScalaDoc_Decorated init Unknown Source at org gradle api internal DependencyInjectingInstantiator newInstance Dependen cyInjectingInstantiator java 62 at org gradle api internal ClassGeneratorBackedInstantiator newInstance ClassGe neratorBackedInstantiator java 36 at org gradle api internal project taskfactory TaskFactory 1 call TaskFactory j ava 124 60 more BUILD FAILED Total time 9 812 secs Matts MacBook Pro RxJava mattmccline From Shixiong Zhu notifications@github com Reply To Netflix RxJava reply i 29996454 30fc8acd6ab4f72ffc0c7714cd73276bf6e93b53 7002312@reply git hub com Date Sunday March 23 2014 7 27 PM To Netflix RxJava RxJava@noreply github com Cc Matt McCline Matt_McCline@yahoo com Subject Re RxJava RxJava gradlew issue Could not create task of type ScalaDoc #980 Could you add stacktrace to get the stacktrace of the error What s version of your JDK If it s 1 8 maybe it s the same issue as here http forums gradle org gradle topics enable_to_setup_a_simple_scala_build Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 980#issuecomment 38407794 Yes the JDK is 1 8 I tested it on JDK 1 8 and got the same problem When I changed back to JDK 1 7 everything is fine So I think that JDK 1 8 is incompatible with gradle My gradle version is 1 11 Did you encounter this problem after you updated to JDK 1 8 I had this a long ago The issue is with the Scala compiler not recognizing Java 8 and throwing error in the gradle task early on JDK 7 works fine Well I wanted to try out Ben Christensen s Example of RxJava being used with Java 8 lambdas http bl ocks org benjchristensen 4965520 Will it work to install RxJava under JDK 1 7 then switch to 1 8 afterwards Thanks for looking into this On Mar 25 2014 at 12 29 AM akarnokd notifications@github com wrote I had this a long ago The issue is with the Scala compiler not recognizing Java 8 and throwing error in the gradle task early on JDK 7 works fine Reply to this email directly or view it on GitHub Causing me issues too I m going to comment out ScalaDoc until it works as this is a real nuisance I can t even import the project into an IDE environment where Java 8 is being used @mccline36 You can use RxJava binaries built for Java 6 from a Java 8 project and it will work fine This issue is only if trying to build RxJava using Java 8 which is not necessary since it works with Java 6 onwards Here is the bug report http issues gradle org browse GRADLE 3023 Doesn t even look like I can comment out this behavior Grrrrr To work around this for now I have to comment out the rxjava scala module in settings gradle language adaptors rxjava scala I also have to skip all Javadoc tasks which break in Java 8 gradlew clean build x javadoc Hi Ben Thank you very much That did the trick I have a successful build Matt From Ben Christensen notifications@github com Reply To Netflix RxJava reply i 29996454 30fc8acd6ab4f72ffc0c7714cd73276bf6e93b53 7002312@reply git hub com Date Wednesday March 26 2014 9 40 PM To Netflix RxJava RxJava@noreply github com Cc Matt McCline Matt_McCline@yahoo com Subject Re RxJava RxJava gradlew issue Could not create task of type ScalaDoc #980 To work around this for now I have to comment out the rxjava scala module in settings gradle language adaptors rxjava scala I also have to skip all Javadoc tasks which break in Java 8 gradlew clean build x javadoc Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 980#issuecomment 38768519 Closing out builds with Java 6 7 work fine Java 8 Gradle and Scala are a wreck right now',RxJava,false,false,false
29998458,'Rx Design Guidelines','Update http go microsoft com fwlink LinkID 205219 to reflect the latest RxJava implementation','',RxJava,false,false,false
30099259,'Pivot Operator','','RxJava pull requests #919 https netflixoss ci cloudbees com job RxJava pull requests 919 FAILURE Looks like there s a problem with this pull request RxJava pull requests #921 https netflixoss ci cloudbees com job RxJava pull requests 921 SUCCESS This pull request looks good',RxJava,true,false,false
30118393,'add OperationToOperator and unit tests and overload for lift method','I found myself using this method a lot to easily create an Operator so that I can use the lift method For example Suppose I want to use lift to perform a concat on a sequence of observables followed by count java private static T Func1 Observable Observable T Observable Integer concatCount return new Func1 Observable Observable T Observable Integer @Override public Observable Integer call Observable Observable T source return Observable concat source count I can then use the suggested lift overload with the function above java source lift MyClass Integer concatCount or I could have made an Operator form of it especially if its component operations don t have readily available Operator forms to chain together java private static T Operator Integer Observable T concatCountOperator return OperationToOperator toOperator MyClass T concatCount','RxJava pull requests #920 https netflixoss ci cloudbees com job RxJava pull requests 920 SUCCESS This pull request looks good To summarize the intent of this PR it intends to add this signature java public R Observable R lift Func1 super Observable T extends Observable R function and allows this type of usage java puts 0 before and 100 after an observable Func1 Observable Integer Observable Integer surround Observable Integer source return Observable concat Observable just 0 source Observable just 100 List Integer list Observable range 1 3 surround the source with 0 and 100 liftOrChain surround get as a list toList toBlockingObservable single This would emit 0 1 2 3 100 Perhaps this is better called chain as opposed to lift since lift is lifting a function against Subscriber into an Observable and this is actually chaining Observable processing together java public R Observable R chain Func1 super Observable T extends Observable R function Do we need a cover type on this as well to handle generics Right now the T and R are not marked super and I think they need to be @headinthebox What do you think about this Ping @headinthebox on this one again I ve pondered this one a bit more and for my usage I could do without the lift overload or chain and would have more flexibility if a static method existed with this signature java public static Operator R T toOperator Func1 Observable T Observable R function What do you think @benjchristensen RxJava pull requests #1120 https netflixoss ci cloudbees com job RxJava pull requests 1120 SUCCESS This pull request looks good I ll still need to remove the use of PublishSubject in OperationToOperator but is there a Subject implementation that performs this simple pass through Review of my attempt to avoid use of PublishSubject would be welcome thanks RxJava pull requests #1121 https netflixoss ci cloudbees com job RxJava pull requests 1121 SUCCESS This pull request looks good This reminds me of the selector based multicast I e source multicast PublishSubject create o concat 1 o 100 toList Although using a single subscriber subject has less overhead Thanks for that I didn t know about the multicast method On 18 May 2014 17 54 akarnokd notifications@github com wrote This reminds me of the selector based multicast I e source multicast PublishSubject create o concat 1 o 100 toList Although using a single subscriber subject has less overhead Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 983#issuecomment 43433758 RxJava pull requests #1123 https netflixoss ci cloudbees com job RxJava pull requests 1123 SUCCESS This pull request looks good As pointed out by @akarnokd the function could include a subscribeOn call that makes subscription asynchronous so I included a CountDownLatch to wait for subscription to happen How is this operator different from public final R Observable R publish Func1 super Observable T extends Observable R selector The signature is the same Observable R lift Func1 super Observable T extends Observable R function I very often use Publish in this form when you want to subscribe to a source multiple times I agree @headinthebox I overlooked that method when proposing the lift overload Would a non multicasting alternative be useful as well via lift toOperator function Closing this out as there is not enough agreement for merging and it can no longer be merged Discussion can continue at https github com Netflix RxJava issues 1416',RxJava,true,false,false
30149780,'Tests and Javadoc for Pivot','','',RxJava,true,false,false
30165838,'Non deterministic SynchronizedObserver runConcurrencyTest','Seeing this fail intermittently java lang AssertionError Concurrency test failed expected 173500 but was 151756 at org junit Assert fail Assert java 93 at rx observers SynchronizedObserverTest runConcurrencyTest SynchronizedObserverTest java 377 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 39 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 25 at java lang reflect Method invoke Method java 597 at org junit runners model FrameworkMethod 1 runReflectiveCall FrameworkMethod java 45 at org junit internal runners model ReflectiveCallable run ReflectiveCallable java 15 at org junit runners model FrameworkMethod invokeExplosively FrameworkMethod java 42 at org junit internal runners statements InvokeMethod evaluate InvokeMethod java 20 at org junit internal runners statements RunBefores evaluate RunBefores java 28 at org junit runners ParentRunner runLeaf ParentRunner java 263 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 68 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 47 at org junit runners ParentRunner 3 run ParentRunner java 231 at org junit runners ParentRunner 1 schedule ParentRunner java 60 at org junit runners ParentRunner runChildren ParentRunner java 229 at org junit runners ParentRunner access 000 ParentRunner java 50 at org junit runners ParentRunner 2 evaluate ParentRunner java 222 at org junit runners ParentRunner run ParentRunner java 300 at org gradle api internal tasks testing junit JUnitTestClassExecuter runTestClass JUnitTestClassExecuter java 80 at org gradle api internal tasks testing junit JUnitTestClassExecuter execute JUnitTestClassExecuter java 47 at org gradle api internal tasks testing junit JUnitTestClassProcessor processTestClass JUnitTestClassProcessor java 69 at org gradle api internal tasks testing SuiteTestClassProcessor processTestClass SuiteTestClassProcessor java 49 at sun reflect GeneratedMethodAccessor7 invoke Unknown Source at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 25 at java lang reflect Method invoke Method java 597 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 35 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 24 at org gradle messaging dispatch ContextClassLoaderDispatch dispatch ContextClassLoaderDispatch java 32 at org gradle messaging dispatch ProxyDispatchAdapter DispatchingInvocationHandler invoke ProxyDispatchAdapter java 93 at Proxy2 processTestClass Unknown Source at org gradle api internal tasks testing worker TestWorker processTestClass TestWorker java 103 at sun reflect GeneratedMethodAccessor6 invoke Unknown Source at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 25 at java lang reflect Method invoke Method java 597 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 35 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 24 at org gradle messaging remote internal hub MessageHub Handler run MessageHub java 355 at org gradle internal concurrent DefaultExecutorFactory StoppableExecutorImpl 1 run DefaultExecutorFactory java 66 at java util concurrent ThreadPoolExecutor Worker runTask ThreadPoolExecutor java 886 at java util concurrent ThreadPoolExecutor Worker run ThreadPoolExecutor java 908 at java lang Thread run Thread java 662 Test https github com Netflix RxJava blob master rxjava core src test java rx observers SynchronizedObserverTest java Source https github com Netflix RxJava blob master rxjava core src main java rx observers SynchronizedObserver java','Fixed in https github com Netflix RxJava pull 986 Fixed in https github com Netflix RxJava pull 986',RxJava,false,false,false
30165973,'Fix SynchronizedObserver runConcurrencyTest','It wasn t waiting on all threads before emitting onCompleted','',RxJava,true,false,false
30166414,'Fix Non Deterministic Pivot Test','This fixes a test that failed on build servers small slow single or dual core machines','',RxJava,true,false,false
30167732,OnErrorFailedException,'Re throw when onError throws an Exception This fixes https github com Netflix RxJava issues 969','RxJava pull requests #922 https netflixoss ci cloudbees com job RxJava pull requests 922 FAILURE Looks like there s a problem with this pull request RxJava pull requests #923 https netflixoss ci cloudbees com job RxJava pull requests 923 SUCCESS This pull request looks good',RxJava,true,false,false
30203589,'Operator publishTo int subscriberCount with no call to connect required','I have the following situation 1 I have one source Observable which is expensive so I only want one Subscriber at the source 2 I need to tee the events into two Observable s 3 there will be a lot of data so I don t want to cache 4 publish is exactly what I want however 5 my code is organised in such a way that where the subscribe is eventually performed the ConnectableObservable from publish is unreachable Re organising the code is not the answer It is organised this way for reusability reasons The contract of publish is to provide a ConnectableObservable that waits until I call connect before emitting to all subscribed Observable s What I need is an Observable that doesn t wait for a call to connect but instead for a specified number of Subscriber s to subscribe I propose this could be signatured Observable T publishTo int expectedSubscriberCount though I m not fussy what name it has Under the hood this might easily be implemented as an auto connecting ConnectableObservable I ve coded an example of doing such a thing in this AutoConnectingObservableExample gist https gist github com GrahamLea 9780986','An alternative solution would be an overload of cache such as cache int subscriberCount which only caches values until they have been emitted to subscriberCount consumers I think the practise of proactively rejecting subscribers over subscriberCount is a good one though Are you aware of refCount https github com Netflix RxJava wiki Connectable Observable Operators#connectableobservablerefcount It will connect when there are subscribers and disconnect unsubscribe when there are no more subscribers You could implement what you need using a PublishSubject which you subscribe all the required subscriptions to then you subscribe that one to the refCounted publish d Observable java somewhere in your reusable code library expensivePublishedObservable makeExpensiveObservable publish refCount Your application code PublishSubject a PublishSubject create a subscribe first a subscribe second library getExpensiveObservable subscribe a Thanks for the suggestion Dylan Your example above is a little different to what I m doing The tee that I want to do is actually inside the library code as you refer to it then re combined and returned to the application part as a single Observable As such there is only one subscribe in the application but due to the tee and the recombination the source ends up being subscribed to twice without a cache or a publish in the middle So in your example you have the two client Observables subscribing as part of the application code but I have those two in the library code and I don t want any subscribing to happen in there You could use doOnNext on the source Observable and make that call onNext on a PublishSubject to tee the calls java PublishSubject tee PublishSubject create subscribe to tee here expensivePublishedObservable doOnNext next tee onNext next This has the downside that all subscriptions to expensivePublishedObservable will use the same tee subject I m not sure if that is what you are looking for Closing out as the conversation is stale if further discussion on this is wanted please post to https groups google com forum # forum rxjava',RxJava,false,false,false
30258277,'Quasar integration contrib module','This module integrates RxJava with Quasar https github com puniverse quasar in several ways It provides A fiber based scheduler A fiber blocking version of BlockingObservables Viewing Quasar channels as Observables and transforming Observables into channels Quasar channels are a CSP mechanism very similar to channels in the Go programming language','RxJava pull requests #924 https netflixoss ci cloudbees com job RxJava pull requests 924 FAILURE Looks like there s a problem with this pull request This looks great I need to update the build job to use JDK 7 for this module if this can t work with Java 6 Is that the case that s fine if so as it s not targeting Android Right we plan to add Android support in version 0 7 Does that mean you will downgrade from Java 7 to Java 6 Since your code states VERSION_1_6 for source can you change the target to 1 6 as well so it builds without changing our build server Not sure yet haven t given it much thought Based on your gradle build the source complies with Java 6 If that s the case all that is needed is changing the target to Java 6 as well and it will build on our server Seems to build RxJava pull requests #926 https netflixoss ci cloudbees com job RxJava pull requests 926 FAILURE Looks like there s a problem with this pull request RxJava pull requests #927 https netflixoss ci cloudbees com job RxJava pull requests 927 FAILURE Looks like there s a problem with this pull request RxJava pull requests #928 https netflixoss ci cloudbees com job RxJava pull requests 928 FAILURE Looks like there s a problem with this pull request So it looks like your code does indeed need Java 7 Yeah seems so Well Quasar requires 7 but I thought we might be able to get away with compiling this module on 6 Apparently not On Mar 27 2014 7 38 PM Ben Christensen notifications@github com wrote So it looks like your code does indeed need Java 7 Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 990#issuecomment 38835973 Okay I ll need to spend some time validating that our build is okay after I migrate the build server to using 7 Once I do that then I ll merge this',RxJava,true,false,false
30258790,'JMH Benchmark Build Config','Fixes the Gradle config for JMH so it works from command line and projects import into Eclipse correctly See https github com Netflix RxJava pull 963 Thanks @quidryan','RxJava pull requests #925 https netflixoss ci cloudbees com job RxJava pull requests 925 SUCCESS This pull request looks good',RxJava,true,false,false
30260842,'@SafeVarargs and Android','There is one feature of Java 7 I would really like to use but Android is holding it back it s @SafeVarargs to solve https github com Netflix RxJava issues 686 From Overloads Folks from the Android side what happens if we build code that uses @SafeVarargs Does it break you or does the runtime just ignore it The reason I wonder is because it s an annotation so I m wondering if the annotation actually affects bytecode or if it just isn t seen at runtime if running on Java 6 Is there some kind of Android test suite we can run against a Jar to validate the byte code is all valid','cc @mttkay @jmhofer @zsxwing Looks like it was added in API 19 http developer android com reference java lang SafeVarargs html It seems to just be a compile time annotation I ll download SDK 19 and test it On 27 March 2014 09 41 Ben Christensen notifications@github com wrote cc @mttkay https github com mttkay @jmhofer https github com jmhofer @zsxwing https github com zsxwing Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 992#issuecomment 38752214 It seems to work even when running on an ICS api 14 device though the target api must be set to 19 for it to be imported It is defined have Runtime retention https android googlesource com platform libcore master luni src main java java lang SafeVarargs java I m not sure how linking it against one defined in a jar using java 7 will work out though my java fu is not that strong On 27 March 2014 10 41 Dylan Sale dylan sale@gmail com wrote Looks like it was added in API 19 http developer android com reference java lang SafeVarargs html It seems to just be a compile time annotation I ll download SDK 19 and test it On 27 March 2014 09 41 Ben Christensen notifications@github com wrote cc @mttkay https github com mttkay @jmhofer https github com jmhofer @zsxwing https github com zsxwing Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 992#issuecomment 38752214 That s great news If I provide a jar built with Java 7 can you test linking to a jar Sure thing Dylan Sale On 27 March 2014 14 42 Ben Christensen notifications@github com wrote That s great news If I provide a jar built with Java 7 can you test linking to a jar Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 992#issuecomment 38767527 I have no other obvious place to place a binary so am using Dropbox https www dropbox com s fkt7vlox946pig0 rxjava core 0 17 3 SNAPSHOT jar This file was built using OpenJDK 1 7 0_45 with @SafeVarargs The branch this was built from is at https github com Netflix RxJava pull 994 It seems to work though it gets a bunch of warnings while building Warning Gradle rx Subscriber class rx Subscriber class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx Observable class rx Observable class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx Observable Operator class rx Observable Operator class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx functions Func1 class rx functions Func1 class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx functions Function class rx functions Function class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx Subscription class rx Subscription class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx functions Action1 class rx functions Action1 class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx observers Subscribers class rx observers Subscribers class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx subscriptions CompositeSubscription class rx subscriptions CompositeSubscription class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx functions Action2 class rx functions Action2 class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx plugins RxJavaPlugins class rx plugins RxJavaPlugins class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx Scheduler class rx Scheduler class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx functions Func2 class rx functions Func2 class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx functions FuncN class rx functions FuncN class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx observables ConnectableObservable class rx observables ConnectableObservable class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx subjects BehaviorSubject class rx subjects BehaviorSubject class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx subjects PublishSubject class rx subjects PublishSubject class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx functions Action0 class rx functions Action0 class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx subscriptions Subscriptions class rx subscriptions Subscriptions class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx functions Func0 class rx functions Func0 class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx subjects Subject class rx subjects Subject class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx Observer class rx Observer class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx functions Func3 class rx functions Func3 class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx Observable OnSubscribe class rx Observable OnSubscribe class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx functions Action class rx functions Action class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx schedulers Schedulers class rx schedulers Schedulers class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx plugins RxJavaObservableExecutionHook class rx plugins RxJavaObservableExecutionHook class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx observables BlockingObservable class rx observables BlockingObservable class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx Observable OnSubscribeFunc class rx Observable OnSubscribeFunc class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx functions Func9 class rx functions Func9 class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx functions Func8 class rx functions Func8 class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx functions Func7 class rx functions Func7 class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx functions Func6 class rx functions Func6 class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx functions Func5 class rx functions Func5 class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx functions Func4 class rx functions Func4 class major version 51 is newer than 50 the highest major version supported by this compiler Warning Gradle rx Scheduler Inner class rx Scheduler Inner class major version 51 is newer than 50 the highest major version supported by this compiler Hmm I m seeing some odd behaviour with it saying missing symbols in the log no crashes though I ll have a closer look tomorrow if someone else hasn t given a better answer Looks like KitKat api 19 supports jdk 7 but you need to setup some compiler flags in gradle turn it on http tools android com tech docs new build system user guide#TOC Using sourceCompatibility 1 7 Did anyone try to build their Android project with JDK 6 We re still using JDK 6 Unfortunately my team is on a tight release schedule right now so I don t have time to look into this before next week Generally though this will trigger a compile time check yes If that s the case the only problem I can think of off the top of my head is that the dexer might be unable to resolve the annotation when processing the RxJava JAR Keep in mind that the dex file contains everything including direct and transitive dependencies I was building with JDK 6 Thanks for playing with that I ll spend some more time on this It s not okay to have version 51 if people expect version 50 What s the roadmap for Android dev being moved onto version 51 JDK 7 and no longer requiring version 50 JDK 6 Closing out failed experiment and I found @VarArgs don t actually solve the problem anyways https github com Netflix RxJava issues 686#issuecomment 38851070 I m not sure when JDK 7 development will become the norm but it is certainly supported using the latest build tools You can even target older versions of android as long as you don t use new features that require library support I m on Mac however and getting a version of JDK 7 is not proving easy I m on Mac however and getting a version of JDK 7 is not proving easy What do you mean by this It s available via Oracle http www oracle com technetwork java javase downloads jdk7 downloads 1880260 html http download oracle com otn pub java jdk 7u51 b13 jdk 7u51 macosx x64 dmg The download completes about 20mb in for me I m not sure why Oh how fun I have JDK 6 and 7 installed on my Mac back to back I occasionally switch via JAVA_HOME As Dylan pointed out Java 7 is supported with the latest Android build tools rev 19 and since IIRC it s byte code compliant with Java 6 with the exception of try with resources a compiled build should work on all Android versions The problem I guess is one of adoption At SoundCloud we re still stuck with Java 6 because a testing library we use Great Expectations refuses to compile under Java 7 I admit I haven t researched this further as it wasn t a priority for us but I imagine others either have similar problems or more likely simply don t see enough value in Java 7 to bump their tool chain Understood My intention is for RxJava 1 0 to remain on Java 6 This SafeVarargs thing is not important enough to move to Java 7 even if it worked but it ends up that it doesn t actually solve the problem anyways because of nested generics',RxJava,false,false,false
30275185,'JMH Perf Tests','1 Migrate all previous tests into rx archive until we have matured with JMH 2 JMH config in gradle 3 Start of benchmarking with JMH for baseline map and serialize To Run Inside rxjava core invoke gradlew benchmarks Or from base invoke gradlew benchmarks and it will scan each sub module for benchmarks and then only find them in rxjava core Output Result 72 204 99 9 7 524 ns op Statistics min avg max 69 221 72 204 74 048 stdev 1 954 Confidence interval 99 9 64 680 79 729 Benchmark size Mode Samples Mean Mean error Units r jmh Baseline forLoopInvokingFunction 1024 avgt 5 3230 689 486 080 ns op r jmh Baseline forLoopInvokingFunction 1048576 avgt 5 3394679 521 148858 373 ns op r operators OperatorMapPerf mapIdentityFunction 1 avgt 5 91 338 8 504 ns op r operators OperatorMapPerf mapIdentityFunction 1024 avgt 5 5626 727 1209 108 ns op r operators OperatorMapPerf mapIdentityFunction 1048576 avgt 5 6268747 085 258008 983 ns op r operators OperatorSerializePerf noSerializationSingleThreaded 1024 avgt 5 42 198 0 791 ns op r operators OperatorSerializePerf noSerializationSingleThreaded 1048576 avgt 5 45 935 0 911 ns op r operators OperatorSerializePerf serializedSingleStream 1024 avgt 5 69 410 10 499 ns op r operators OperatorSerializePerf serializedSingleStream 1048576 avgt 5 72 305 11 450 ns op r operators OperatorSerializePerf synchronizedSingleStream 1024 avgt 5 72 238 7 233 ns op r operators OperatorSerializePerf synchronizedSingleStream 1048576 avgt 5 72 204 7 524 ns op','Thank you @gvsmirnov for help getting this running Please don t hesitate to provide suggestions and tips The things I m still trying to figure out are 1 How to measure object allocation 2 Passing arguments into the gradlew benchmarks command as right now everything is hardcoded inside build gradle 3 How to generate an UberJar ShadowJar with all necessary code so the testing can be done via an executable jar as JMH typically done RxJava pull requests #929 https netflixoss ci cloudbees com job RxJava pull requests 929 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
30275941,'Use @SafeVarargs for From and Merge','A proposed change if we can demonstrate it works with Android See https github com Netflix RxJava issues 992 for discussion Intended to eliminate overloads as defined in https github com Netflix RxJava issues 686','RxJava pull requests #930 https netflixoss ci cloudbees com job RxJava pull requests 930 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
30345952,'Support Custom JMH Args','Support executions of benchmarks such as gradlew benchmarks Pjmh f 1 tu ns bm avgt wi 5 i 5 r 1 OperatorSerializePerf By default it will run all benchmarks if no args are passed','',RxJava,true,false,false
30354323,Perfshadowjar,'','That s working great thank you The only thing I d like to do now is have a benchmarksJar task name instead of shadowJar RxJava pull requests #931 https netflixoss ci cloudbees com job RxJava pull requests 931 SUCCESS This pull request looks good',RxJava,true,false,false
30403027,'Proposed Scheduler Interface Change for 0 18 yes again','Reviewing the Scheduler interface changes of 0 17 with @headinthebox revealed that we re not 100 happy with the outcome particularly after learning that Java 8 does not allow referencing this from within a lambda The Scheduler interface as of 0 17 is java class Scheduler public abstract Subscription schedule Action1 Scheduler Inner action public abstract Subscription schedule Action1 Scheduler Inner action final long delayTime final TimeUnit unit public Subscription scheduleRecursive Action1 Recurse action public Subscription schedulePeriodically Action1 Scheduler Inner action long initialDelay long period TimeUnit unit public int degreeOfParallelism public long now public static final class Recurse public void schedule public void schedule long delay TimeUnit unit public abstract static class Inner implements Subscription public abstract void schedule Action1 Scheduler Inner action long delayTime TimeUnit unit public abstract void schedule Action1 Scheduler Inner action public long now We have determined two problems with this 1 Inner Outer Dance In practice we have found that usage is always one of two things either you just interact with the outer and don t care about the Inner or you immediately need the Inner and have to do an awkward first scheduling just to get access to the Inner See here https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorObserveOn java#L98 and weep 2 Recursion The Action1 Scheduler Inner signature was chosen and put on both outer and inner so that an inner class could refer to itself using this to simply reschedule itself from the outer onto the inner It was assumed this would work in Java 8 lambdas but unfortunately we did not prove it This works with anonymous classes java Schedulers newThread schedule new Action1 Inner @Override public void call Inner inner System out println do stuff recurse inner schedule this but this does not with lambdas java Schedulers newThread schedule inner System out println do stuff inner schedule this doesn t compile So we end up with this java Schedulers newThread scheduleRecursive recurse System out println do stuff recurse schedule At that point it s clear that Inner is not working well and we have Recurse to fix the problem Thus the proposed changes breaking again are java class Scheduler public final Subscription schedule Action1 Recurse action public final Subscription schedule Action1 Recurse action final long delayTime final TimeUnit unit public final Subscription schedulePeriodically Action1 Recurse action long initialDelay long period TimeUnit unit public abstract Inner createInner for advanced use cases like observeOn public int degreeOfParallelism public long now now the primary interface public static final class Recurse public final void schedule public final void schedule long delay TimeUnit unit public final void schedule Action1 Recurse action public final void schedule Action1 Recurse action final long delayTime final TimeUnit unit now mostly an implementation detail except for advanced use cases public abstract static class Inner implements Subscription public abstract void schedule Action1 Recurse action long delayTime TimeUnit unit public abstract void schedule Action1 Recurse action public long now The name of Recurse is up for debate It may be possible to merge Recurse and Inner but I haven t figured it out yet The reason is that Inner is a single instance representing a thread or event loop whereas Recurse represents an Action or work Thus a given Inner could have multiple Recurse actions scheduled on to it It is being an Action that allows it to recurse by invoking schedule that just reschedules itself This would make it better support Java 8 lambdas and simply recursion while also better supporting via the createInner method the more complicated use cases like observeOn where current code is very awkward This needs to be the last refactor of this so we nail it down and stop breaking things and can get to 1 0 Let the discussion begin','Here is the state of scheduler in rxcpp v2 In order to allow tight tail recursion the rxcpp v2 scheduler has a type currently called schedulable https rxcpp codeplex com SourceControl latest#Rx v2 src rxcpp rx scheduler hpp C class schedulable public schedulable_base composite_subscription lifetime scheduler controller action activity recursed_scope_type recursed_scope public schedulable schedulable composite_subscription cs scheduler q action a lifetime std move cs controller std move q activity std move a inline composite_subscription get_subscription inline scheduler get_scheduler inline action get_action inline auto set_recursed const recurse r const recursed request tail recursion inline void operator const composite_subscription inline bool is_subscribed const inline weak_subscription add shared_subscription s const inline weak_subscription add dynamic_subscription s const inline void remove weak_subscription w const inline void clear const inline void unsubscribe const scheduler inline clock_type time_point now const inline void schedule const inline void schedule clock_type duration when const inline void schedule clock_type time_point when const action inline action_duration type get_duration const inline void operator const schedulable scbl const recurse r const The tail recursion can only be requested in the callback from the scheduler So for this implementation if you transport the schedulable out and then request tail recursion the process will exit If I run into the Inner issue in observe_on I will just make schedulable extract it from the scheduler in the constructor through a private or detail accessor A scheduler takes a schedulable and ignores the scheduler it contains C class scheduler public scheduler_base public typedef scheduler_base clock_type clock_type inline clock_type time_point now const inline void schedule const schedulable scbl const inline void schedule clock_type duration when const schedulable scbl const inline void schedule clock_type time_point when const schedulable scbl const The range operator requests tail recursion C template class T struct range public source_base T template class Subscriber void on_subscribe Subscriber o auto state std make_shared state_type init state sc schedule make_schedulable o share the same subscription with the scheduler const rxsc schedulable self if state remaining 0 o on_completed o is unsubscribed if o is_subscribed terminate loop return send next value state remaining o on_next state next state next static_cast T state step state next tail recurse this same action to continue loop self In C it is essential to keep virtual function calls out of an inner loop To make tail recursion work efficiently the recursion objects create a space on the stack inside the virtual function call in the actor that allows the callback and the scheduler to share stack space that records the request and the allowance without any virtual calls in the loop C template class F inline action make_action F f action_duration type d action_duration runs_short auto fn std forward F f return action std make_shared detail action_type d tail recurse inside of the virtual function call until a new action lifetime or scheduler is returned fn const schedulable s const recurse r auto scope s set_recursed r while s is_subscribed r reset fn s if r is_allowed r is_requested if r is_requested s schedule break The current_thread uses a thread local recursion to indicate that tail recursion is only allowed when the queue is empty C const auto recursor queue get_recursion get_recurse loop until queue is empty for auto when queue top when std this_thread sleep_until when true when queue top when auto what queue top what queue pop what recursor if queue empty break Based on these implementation requirements for C would you recommend a different signature from this java class Scheduler public final Subscription schedule Action1 Recurse action public final Subscription schedule Action1 Recurse action final long delayTime final TimeUnit unit public final Subscription schedulePeriodically Action1 Recurse action long initialDelay long period TimeUnit unit public abstract Inner createInner for advanced use cases like observeOn public int degreeOfParallelism public long now now the primary interface public static final class Recurse public final void schedule public final void schedule long delay TimeUnit unit public final void schedule Action1 Recurse action public final void schedule Action1 Recurse action final long delayTime final TimeUnit unit now mostly an implementation detail except for advanced use cases public abstract static class Inner implements Subscription public abstract void schedule Action1 Recurse action long delayTime TimeUnit unit public abstract void schedule Action1 Recurse action public long now @headinthebox Does this change your perspective on the Java design at all I have submitted a pull request with these changes Usage looks like this java import java util concurrent TimeUnit import rx Scheduler Inner import rx Scheduler Recurse import rx functions Action1 import rx schedulers Schedulers public class Test public static void main String args Schedulers newThread schedule new Action1 Recurse @Override public void call Recurse r System out println do stuff recurse r schedule this Schedulers newThread schedule recurse System out println do stuff recurse schedule Schedulers newThread schedule recurse System out println do stuff recurse schedule 1000 TimeUnit MILLISECONDS Schedulers newThread schedule recurse recurse schedule re System out println do more stuff Inner inner Schedulers newThread createInner inner schedule re System out println do stuff re schedule r System out println do more stuff Code outline screen shot 2014 04 02 at 11 08 31 pm https cloud githubusercontent com assets 813492 2600101 6c680404 baf6 11e3 916e c41a817bc328 png This is the time to voice opinions and affect change Once we make these changes we re headed towards 1 0 and really do not want to change these signatures again I welcome bike shedding and arguing over names signatures etc for the next couple days but would like to wrap it up and move forward by the weekend unless a glaring issue is found I would appreciate suggestions for better names than Recurse and Inner neither of which I particularly like @kirkshoop If you have a chance to answer my previous question I d appreciate it so we make sure these changes address broad use cases and are not bound to a specific language since even though we re on the JVM there are several different languages we support and it would be preferable for Rx across platforms to be similar Based on these implementation requirements for C would you recommend a different signature from this Oh My Well I had a long reply but it just got lost I know better than to use the web interface I can t write it again so here is the summary RxCpp took the insight from a comment by @akarnokd I think to another RxJava issue that the parameter to subscribe is like subscriber which is also like subject in that they are all objects whose single concern is to bind other single concern objects together In this case the parameter would be a type that binds the scheduler with private access to its inner the action and the subscription together and then expose the functionality of Recurse Inner Subscription and Action1 The subscription would be removed from the Action1 in this case A name that comes to mind is ScheduleAction I can still count the lines of Java that I have written so be gentle class ScheduleAction public final Action1 ScheduleAction get_action public final Subscription get_subscription public final Scheduler get_scheduler public final bool isUnsubscribed public final void unsubscribe action methods Sorry I didn t look them up public long now uses scheduler public final void schedule public final void schedule long delay TimeUnit unit uses inner public final void schedule ScheduleAction action public final void schedule ScheduleAction action final long delayTime final TimeUnit unit class Scheduler public final Subscription schedule ScheduleAction action public final Subscription schedule ScheduleAction action final long delayTime final TimeUnit unit public final Subscription schedulePeriodically ScheduleAction action long initialDelay long period TimeUnit unit private to ScheduleAction abstract Inner createInner I would use a friend decl in C public int degreeOfParallelism public long now Thank you @kirkshoop for the feedback If I understand correctly the primary change would be hiding the Inner from public use I m going to repost a comment from https github com Netflix RxJava pull 1014#issuecomment 39477335 about a use case that requires Inner being accessible publicly The problem I ve had with combining them Inner and Recurse is that when first creating an Inner there is no Action to invoke Using the ThreadLocal to store the current action doesn t solve this it would just make it non obvious why inner schedule doesn t work the first time and the API would be odd that I can get an Inner with a schedule method even though nothing has been invoked yet The reason for this scenario is that retrieving an Inner via createInner is needed to make use cases like observeOn less awkward Here is the example where Inner is retrieved before an Action is executed in observeOn java protected void schedule if counter getAndIncrement 0 if recursiveScheduler null recursiveScheduler scheduler createInner add recursiveScheduler recursiveScheduler schedule new Action1 Recurse @Override public void call Recurse inner pollQueue The reason is that the recursion happens externally the operator is doing it rather than internally inside the Action Inner Action Recurse Therefore we have use cases where Inner is used before Recurse makes sense so the API is not appropriate when they are combined Thus if we have ScheduledAction Recurse as the only public type and hide Inner as an implementation detail we can not gracefully solve the observeOn use case without doing what it does now https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorObserveOn java#L94 java protected void schedule if counter getAndIncrement 0 if recursiveScheduler null add scheduler schedule new Action1 Inner @Override public void call Inner inner recursiveScheduler inner pollQueue else recursiveScheduler schedule new Action1 Inner @Override public void call Inner inner pollQueue Is solving this use case gracefully a good enough reason for exposing Inner via the createInner method Most people will never need to use it and only interact with Recurse or ScheduledAction or whatever we call it and thus only see the Inner type on the createInner method that they ignore The Scheduler createInner method feels similar to the Observable unsafeSubscribe method Thanks @benjchristensen What prevents this protected void schedule if counter getAndIncrement 0 ScheduleAction action scheduler new Action1 ScheduleAction @Override public void call ScheduleAction inner pollQueue action schedule The scheduler being passed in there is the outer one which means it would create a new inner each time and could depending on which Scheduler it is spawn a new thread for every ScheduledAction Also by doing it that way it makes the Subscription logic unclear A ScheduledAction schedule should not return a Subscription each time as unsubscribing from it would shut down the entire inner scheduler so unsubscribing on one should not shut down all actions This is why the Scheduler schedule methods return Subscription as it represents the Inner thread or event loop but the Recurse schedule and Inner schedule methods return void I would like to pick up these particular points in person at React if possible EDIT I am kirk dot shoop at microsoft com I had the chance to meet @kirkshoop in person while in London and we reviewed the needs of CPP and Java and came to agreement on the proposed model We are considering slightly changed names though to improve the semantic meaning java class Scheduler public final Subscription schedule Action1 Schedulable action public final Subscription schedule Action1 Schedulable action final long delayTime final TimeUnit unit public final Subscription schedulePeriodically Action1 Schedulable action long initialDelay long period TimeUnit unit public abstract EventLoop createEventLoop for advanced use cases like observeOn public int degreeOfParallelism public long now now the primary interface public static final class Schedulable public final void schedule public final void schedule long delay TimeUnit unit public final void schedule Action1 Schedulable action public final void schedule Action1 Schedulable action final long delayTime final TimeUnit unit now mostly an implementation detail except for advanced use cases public abstract static class EventLoop implements Subscription public abstract void schedule Action1 Schedulable action long delayTime TimeUnit unit public abstract void schedule Action1 Schedulable action public long now Neither of us are sold on Schedulable or EventLoop nor Recurse or Inner so please let us know if you have better ideas There are 3 types of usage patterns to address with this design #### 1 Single Action The simplest case where only a single action is scheduled which results in a new inner EventLoop being created Use Cases subscribeOn unsubscribeOn timeout interval timer Example java scheduler schedule new Action1 Schedulable @Override public void call final Schedulable re do work here #### 2 Inner Recursion Simple recursion where the work to be repeated is derived from inside the initially scheduled Action generally just repeating itself Use Cases retry repeat Example java scheduler schedule new Action1 Schedulable @Override public void call final Schedulable re do work here then recursively reschedule re schedule Beyond just rescheduling itself it can reschedule with a delay or schedule a different Action on the inner EventLoop it has access to via the Schedulable #### 3 Outer Recursion The more complex case but actually quite common requirement is outer recursion This use case exists because the scheduling of work is being driven by outer notifications such as via onNext Use Cases observeOn repeat and should be things like debounce which are currently implemented wrong Example java final EventLoop eventLoop scheduler createEventLoop public void onNext T t eventLoop schedule new Action1 Schedulable @Override public void call final Schedulable re do work here A single EventLoop Inner needs to be created and reused for all notifications received thus a reference to it must exist and be used for scheduling Each onNext will then schedule work to be performed sequentially on the same EventLoop ### Current Design The current design is java class Scheduler public final Subscription schedule Action1 Schedulable action public final Subscription schedule Action1 Schedulable action final long delayTime final TimeUnit unit public final Subscription schedulePeriodically Action1 Schedulable action long initialDelay long period TimeUnit unit public abstract EventLoop createEventLoop for advanced use cases like observeOn public int degreeOfParallelism public long now now the primary interface public static final class Schedulable public final void schedule public final void schedule long delay TimeUnit unit public final void schedule Action1 Schedulable action public final void schedule Action1 Schedulable action final long delayTime final TimeUnit unit public long now now mostly an implementation detail except for advanced use cases public abstract static class EventLoop implements Subscription public abstract void schedule Action1 Schedulable action long delayTime TimeUnit unit public abstract void schedule Action1 Schedulable action public long now This design achieves all of the goals but it has duplication of signatures to favor a simple model for use cases 1 and 2 while still addressing 3 ### Alternate Design We could reduce some of the duplication of the Scheduler API by accepting use case 3 as the primary case and all others work within it java class Scheduler public abstract EventLoop createEventLoop for advanced use cases like observeOn public int degreeOfParallelism public long now now the primary interface public static final class Schedulable public final void schedule public final void schedule long delay TimeUnit unit public final void schedule Action1 Schedulable action public final void schedule Action1 Schedulable action final long delayTime final TimeUnit unit public long now now mostly an implementation detail except for advanced use cases public abstract static class EventLoop implements Subscription public abstract void schedule Action1 Schedulable action long delayTime TimeUnit unit public abstract void schedule Action1 Schedulable action public long now The drawback of this for usage is that now the createEventLoop needs to be used for use cases 1 and 2 and the Subscription explicitly captured java instead of this subscriber add scheduler schedule new Action1 Schedulable @Override public void call final Schedulable re do work here it would now be this EventLoop loop scheduler createEventLoop subscriber add loop loop schedule new Action1 Schedulable @Override public void call final Schedulable re do work here ### Bikeshed Now is the time to bikeshed on this and argue over the design and names while accounting for these 3 use cases I personally think we should leave the 3 redundant methods on Scheduler to simplify the easy use cases of 1 and 2 so createEventLoop only ever gets used for use case 3 Reviewing with @headinthebox #### Option 1 java class Scheduler public final Subscription schedule Action1 Schedulable action public final Subscription schedule Action1 Schedulable action final long delayTime final TimeUnit unit public final Subscription schedulePeriodically Action1 Schedulable action long initialDelay long period TimeUnit unit public abstract EventLoop getEventLoop for advanced use cases like observeOn public int degreeOfParallelism public long now now the primary interface public static final class Schedulable public final void reschedule public final void reschedule long delay TimeUnit unit public final void schedule Action1 Schedulable action public final void schedule Action1 Schedulable action final long delayTime final TimeUnit unit public long now now mostly an implementation detail except for advanced use cases public abstract static class EventLoop implements Subscription public abstract void schedule Action1 Schedulable action long delayTime TimeUnit unit public abstract void schedule Action1 Schedulable action public long now #### Option 2 java class Scheduler public final Subscription schedule Action1 Schedulable action public final Subscription schedule Action1 Schedulable action final long delayTime final TimeUnit unit public final Subscription schedulePeriodically Action1 Schedulable action long initialDelay long period TimeUnit unit public abstract Inner getInner for advanced use cases like observeOn public int degreeOfParallelism public long now now the primary interface public static final class Schedulable public final void reschedule public final void reschedule long delay TimeUnit unit public final void schedule Action1 Schedulable action public final void schedule Action1 Schedulable action final long delayTime final TimeUnit unit public long now now mostly an implementation detail except for advanced use cases public abstract static class Inner implements Subscription public abstract void schedule Action1 Schedulable action long delayTime TimeUnit unit public abstract void schedule Action1 Schedulable action public long now #### Option 3 java class Scheduler public final Subscription schedule Action1 Recurse action public final Subscription schedule Action1 Recurse action final long delayTime final TimeUnit unit public final Subscription schedulePeriodically Action1 Recurse action long initialDelay long period TimeUnit unit public abstract Inner getInner for advanced use cases like observeOn public int degreeOfParallelism public long now now the primary interface public static final class Recurse public final void reschedule public final void reschedule long delay TimeUnit unit public final void schedule Action1 Recurse action public final void schedule Action1 Recurse action final long delayTime final TimeUnit unit public long now now mostly an implementation detail except for advanced use cases public abstract static class Inner implements Subscription public abstract void schedule Action1 Recurse action long delayTime TimeUnit unit public abstract void schedule Action1 Recurse action public long now Preference by @headinthebox is option 2 above which changes EventLoop back to Inner because EventLoop has different semantic meaning than the very generic Inner An event loop on a NewThreadScheduler versus Trampoline vs something else is rather different We plan on making the final decision tomorrow April 15th now that this has been available for debate for over a week I would like to see something descriptive in place of inner If EventLoop is not descriptive then use SerialQueue or anything else that specifies the behavior of scheduling on the returned object There will be code that relies on the behavior of the returned object and it should have a name that matches the contract it implements allactionswililberunintheorderthattheyarescheduledoneatatime is too long a name but Inner is not a name at all Kirk just a gut feeling but able sounds like an interface to me In fact you could almost extract the different schedule methods and now though I don t know what that s for and just wondering sorry it s late and I should be going to bed so I might be rambling what happens if the schedule methods on Scheduler return EventLoop Inner instead of Subscription That way you wouldn t need a separate getEventLoop and since EventLoop implements Subscription you could still use it as such and fwiw I agree with @kirkshoop re naming That way you wouldn t need a separate getEventLoop and since EventLoop implements Subscription you could still use it as such It means that work must be scheduled and executed just to get the reference This in turn means that volatile mutable references must be used and set on first work such as an onNext rather than immutable final references to the EventLoop Inner assigned at subscription time That may or may not be an issue then use SerialQueue or anything else that specifies the behavior of scheduling on the returned object Good feedback just a gut feeling but able sounds like an interface to me What do you suggest calling the Recurse Schedulable type I don t understand what you could almost extract the different schedule methods is referring to as far as API design Being an interface is not helpful in this case The point of the Recurse Schedulable type is combining an Inner EventLoop with an Action0 that can be rescheduled recursively for use case 2 By the way we could always swing the opposite direction and make the user worry about the use cases and only expose the most basic functional aspects java class Scheduler public abstract InnerClassOfSomeName getInnerClassOfSomeName public int degreeOfParallelism public long now public abstract static class InnerClassOfSomeName implements Subscription public abstract void schedule Action0 action long delayTime TimeUnit unit public abstract void schedule Action0 action public final void schedulePeriodically Action0 action long initialDelay long period TimeUnit unit public long now #### 1 Single Action java final InnerClassOfSomeName is scheduler getInnerClassOfSomeName is schedule new Action0 @Override public void call do work here is unsubscribe with lambda java final InnerClassOfSomeName is scheduler getInnerClassOfSomeName is schedule do work here is unsubscribe #### 2 Inner Recursion java final InnerClassOfSomeName is scheduler getInnerClassOfSomeName is schedule new Action0 @Override public void call do work here then recursively reschedule is schedule this this will NOT work with lambdas only anonymous inner classes is unsubscribe #### 3 Outer Recursion java final InnerClassOfSomeName is scheduler getInnerClassOfSomeName public void onNext T t is schedule new Action0 @Override public void call do work here is unsubscribe with lambdas java final InnerClassOfSomeName is scheduler getInnerClassOfSomeName public void onNext T t is schedule do work here is unsubscribe I don t like this approach but it s an option It means that work must be scheduled and executed just to get the reference This in turn means that volatile mutable references must be used and set on first work such as an onNext rather than immutable final references to the EventLoop Inner assigned at subscription time That may or may not be an issue right you are scratch that I was thinking of something like this java final InnerClassOfSomeName is scheduler schedule new Action0 @Override public void call do work here then reschedule is reschedule is unsubscribe Obviously that won t work Sorry for wasting your time I don t understand what you could almost extract the different schedule methods is referring to as far as API design Being an interface is not helpful in this case That was a knee jerk reaction because both Schedulable Recurse as well as EventLoop Inner contain the method signatures java void schedule Action1 Schedulable action long delayTime TimeUnit unit void schedule Action1 Schedulable action long now You re probably correct that this doesn t define an interface just a gut feeling but able sounds like an interface to me What do you suggest calling the Recurse Schedulable type My objection was that in the JDK adjectives are often usually interfaces or annotations Runnable Cloneable Comparable @Nullable etc Though I guess Observable is a good counterexample both inside and outside the JDK I don t really have a better suggestion either and Schedulable is fine Something along the line of Executor might make sense since you call schedule on something to which you submit an action for execution later Obviously Executor itself is very much in use already Please don t let me hold you up I just ran across a tweet by @headinthebox and started bikeshedding on an impulse @kirkshoop I actually think Inner should have a less prescriptive name Obviously that won t work Sorry for wasting your time @ccmtaylor not a problem at all I appreciate your involvement Can t you see how many breaking changes to the API have happened due to mistakes I ve either written or merged I only know about this particular use case because I ve implemented Scheduler 3 times now My objection was that in the JDK adjectives are often usually interfaces or annotations good point I guess Observable is a good counterexample both inside and outside the JDK If the JVM supported extension methods Observable would probably be an interface like it is in C# started bikeshedding on an impulse That s what we asked for on this one so thank you The craziest ideas or simplest questions can spark a thought and change a design or just prove an API isn t clear Down to choosing between java class Scheduler public abstract Inner getInner public int degreeOfParallelism public long now public abstract static class Inner implements Subscription public abstract void schedule Action0 action long delayTime TimeUnit unit public abstract void schedule Action0 action public final void schedulePeriodically Action0 action long initialDelay long period TimeUnit unit public long now #### Pros very simple API small surface area forces correct usage by getting the Inner then doing work #### Cons recursion does not work with lambdas java class Scheduler public final Subscription schedule Action1 Schedulable action public final Subscription schedule Action1 Schedulable action final long delayTime final TimeUnit unit public final Subscription schedulePeriodically Action1 Schedulable action long initialDelay long period TimeUnit unit public abstract Inner getInner for advanced use cases like observeOn public int degreeOfParallelism public long now now the primary interface public static final class Schedulable public final void reschedule public final void reschedule long delay TimeUnit unit public final void schedule Action1 Schedulable action public final void schedule Action1 Schedulable action final long delayTime final TimeUnit unit public long now now mostly an implementation detail except for advanced use cases public abstract static class Inner implements Subscription public abstract void schedule Action1 Schedulable action long delayTime TimeUnit unit public abstract void schedule Action1 Schedulable action public long now #### Pros supports all 3 use cases including recursion with lambdas one step less on single action use case skip the createInner step #### Cons using the single action use case can lead to incorrectly performing outer recursion via single action execution on the outer Scheduler broad and repetitive surface area awkward existence of type and naming of Scheduler Recurse just to support lambda recursion Reading up on recursive lambdas in Java 8 it looks like it was allowed at some point but not in the shipping version no idea why not Page 49 of http www angelikalanger com Lambdas LambdaReference pre release pdf demonstrates it It means that recursive use of lambda expressions is not supported and anonymous inner classes must be used instead Brian Goetz showed it as possible back in December 2011 http cr openjdk java net briangoetz lambda lambda state 4 html like this java final Runnable r This reference to r is legal if allDone workQueue add r else displayResults but that no longer works in the shipping version and those examples were removed from the final post by Brian Goetz on the topic http cr openjdk java net briangoetz lambda lambda state final html What about SerialScheduler instead of Inner java class Scheduler public abstract SerialScheduler getSerialScheduler public int degreeOfParallelism public long now public abstract static class SerialScheduler implements Subscription public abstract void schedule Action0 action long delayTime TimeUnit unit public abstract void schedule Action0 action public final void schedulePeriodically Action0 action long initialDelay long period TimeUnit unit public long now Scheduler SerialScheduler has a bit too much cowbell for my taste Okay Reading up on recursive lambdas in Java 8 it looks like it was allowed at some point but not in the shipping version no idea why not maybe it s got something to do with the fact that lambdas aren t compiled to inner classes but use invokedynamic http cr openjdk java net briangoetz lambda lambda translation html When the compiler encounters a lambda expression it first lowers desugars the lambda body into a method whose argument list and return type match that of the lambda expression possibly with some additional arguments for values captured from the lexical scope if any At the point at which the lambda expression would be captured it generates an invokedynamic call site which when invoked returns an instance of the functional interface to which the lambda is being converted This call site is called the lambda factory for a given lambda The dynamic arguments to the lambda factory are the values captured from the lexical scope The bootstrap method of the lambda factory is a standardized method in the Java language runtime library called the lambda metafactory The static bootstrap arguments capture information known about the lambda at compile time the functional interface to which it will be converted a method handle for the desugared lambda body information about whether the SAM type is serializable etc The link is from 2012 but seems to agree with a recent article http www takipiblog com 2014 01 16 compiling lambda expressions scala vs java 8 afaict Page 49 of http www angelikalanger com Lambdas LambdaReference pre release pdf demonstrates it Wow awesome reference What about SerialScheduler instead of Inner Scheduler SerialScheduler has a bit too much cowbell for my taste some alternatives I came up with Scheduler Rescheduler because you use it to reschedule the task but maybe that s even more cowbell Scheduler Trampoline the functionality is similar to using a trampoline for tail calls I m not sure how to read Scheduler Inner Is it an inner scheduler e g a scheduler for inner loops or is it just some inner class of Scheduler Re the choice between the two approaches I d personally err on the side of making the API so that it can t be used incorrectly even if it s less pretty especially if use case 3 is common and would be the one that you d tend to get wrong I m not sure but If the single use usecase is common you could still add a convenience method right Or would this invite the incorrect use in use case 3 again java class Scheduler public abstract Foo getFoo public int degreeOfParallelism public long now new public Subscription scheduleOnce Action0 action Foo foo getFoo foo schedule action return foo public abstract static class Foo implements Subscription public abstract void schedule Action0 action long delayTime TimeUnit unit public abstract void schedule Action0 action public final void schedulePeriodically Action0 action long initialDelay long period TimeUnit unit public long now As I mentioned earlier I ve never actually used this part of RxJava myself so I can t really provide more than gut reactions maybe it s got something to do with the fact that lambdas aren t compiled to inner classes but use invokedynamic I imagine you re right that it s related to that though with the nuance that it allows them to do different things in the future even though currently Java 8 initial release at runtime they become inner classes I m not sure how to read Scheduler Inner Is it an inner scheduler e g a scheduler for inner loops or is it just some inner class of Scheduler We think of it as Inner Scheduler the scheduler for inner loops Scheduler Trampoline There is an actual TrampolineScheduler so we can t call this more generic thing Trampoline as well I d personally err on the side of making the API so that it can t be used incorrectly I tend to agree after reviewing the two extremes with @headinthebox and at this point that has pushed us to the simplest API with the least surface area If the single use usecase is common Yes we can always add something like scheduleOnce but I m going to avoid that right now as that can be added in the future if we decided it is needed It s a little more verbose in the operators without it but it is very clear as to what is being done I have submitted a pull request that is the simplified API https github com Netflix RxJava pull 1047 I m copying the description here for completeness on this thread as the design changed slightly during implementation I changed getInner to inner as both get and create seem wrong since it s up to the Scheduler implementation as to what happens when the Inner is instantiated I had to made the Inner schedule methods return Subscription for the 4th use case listed below java class Scheduler public abstract Inner inner public int degreeOfParallelism public long now public abstract static class Inner implements Subscription public abstract Subscription schedule Action0 action long delayTime TimeUnit unit public abstract Subscription schedule Action0 action public final void schedulePeriodically Action0 action long initialDelay long period TimeUnit unit public long now While migrating to this I found a 4th use case in addition to the previously discussed 3 that required the schedule methods inside Inner to also return Subscription for canceling the individual tasks as opposed to the entire Inner Here are the use cases #### 1 Single Action java final Inner is scheduler inner is schedule new Action0 @Override public void call do work here is unsubscribe with lambda java final Inner is scheduler inner is schedule do work here is unsubscribe #### 2 Inner Recursion java final Inner is scheduler inner is schedule new Action0 @Override public void call do work here then recursively reschedule is schedule this this will NOT work with lambdas only anonymous inner classes is unsubscribe #### 3 Outer Recursion java final Inner is scheduler inner public void onNext T t is schedule new Action0 @Override public void call do work here is unsubscribe #### 4 Outer Recursion with Task Cancellation This is used for things like debounce and throttleLast where tasks are being scheduled and cancelled as onNext notifications are received java final Inner is scheduler inner SerialSubscription serial new SerialSubscription public void onNext T t schedule a new task and cancel previous if not yet executed serial set is schedule new Action0 @Override public void call do work here is unsubscribe Items open for discussion still 1 The Inner name is still not great 2 The Subscription being returned by Inner schedule has a different meaning than the Inner implements Subscription and could be a source of confusion but I don t see a better way to handle it An Inner must be unsubscribed after finishing work whereas the Subscription returned from inner schedule is optional only for canceling a task After migrating the codebase to this API my impression is the small surface area of the API is preferable the lack of specific support of inner recursion is not a problem in practice the few places it s needed it will be okay to not use lambdas since Oracle decided to not allow recursive use of lambdas the inner factory method forces thinking about the Subscription behavior and I found fixed bugs After migrating the codebase to this API my impression is the small surface area of the API is preferable Code speaks After sleeping on this I m thinking it may make sense after all to call the factory method createInner Even though some implementations will reuse an inner event loop even those will create a new Inner each time since it also represents the Subscription and lifecycle of all actions scheduled on that Inner Thus it does create something new each time and needs to be disposed of Using inner or getInner does not convey the resource lifecycle whereas createInner does Usage would be like this java final Inner is scheduler createInner is schedule new Action0 @Override public void call do work here clean up at some point is unsubscribe or when inside an OnSubscribe function it needs to be like this java final Inner is scheduler createInner is schedule new Action0 @Override public void call onNext onCompleted then cleanup is unsubscribe Because of the cleanup requirements I think it should be createInner so the signature of Scheduler is java class Scheduler public abstract Inner createInner public int degreeOfParallelism public long now public abstract static class Inner implements Subscription public abstract Subscription schedule Action0 action long delayTime TimeUnit unit public abstract Subscription schedule Action0 action public final void schedulePeriodically Action0 action long initialDelay long period TimeUnit unit public long now Anyone else think it s cleaner to change degreeOfParallelism to just parallelism Like Possible replacements for Scheduler Inner Scheduler Serial Scheduler Loop Scheduler Queue Scheduler SerialQueue Scheduler Sequence Yes I m just trolling the thesaurus In code these would be scheduler createInner scheduler createSerial scheduler createLoop scheduler createQueue scheduler createSerialQueue scheduler createSequence I m trying to figure out what word communicates that we are creating something that executes tasks sequentially has a lifecycle must be cleaned up Current state java class Scheduler public abstract Inner createInner public int parallelism public long now public abstract static class Inner implements Subscription public abstract Subscription schedule Action0 action long delayTime TimeUnit unit public abstract Subscription schedule Action0 action public Subscription schedulePeriodically Action0 action long initialDelay long period TimeUnit unit public long now What about Task Feels natural to me to schedule a task and it also seems to fit your criterias Task is a single thing whereas Inner represents a queue of tasks to be executed Also Task is more synonymous with Future especially since that s what Net uses to represent Future I m proceeding with merging this as it currently stands but not yet releasing it The only thing left to debate I believe is if someone can give a better name than Scheduler Inner Along the way as you re mulling over the interface I d appreciate any comments on the Scheduler documentation on the wiki https github com Netflix RxJava wiki Scheduler Anything missing or misleading Any areas that need more attention this scheduler is backed by an Executor thread pool that will grow as needed For the IO scheduler this detail is no longer true as it does not use an Executor any longer and can change So the important part is that it will grow as needed and allocate threads whether from a pool or new to support blocking IO Using Scheduler The examples look good but would result in leaks as they never call inside unsubscribe You refer to this later but I m concerned people would miss that and copy paste those examples without realizing that Generally it can t be done synchronously after the schedule call as that defeats the whole point so the inside needs to be added to the Subscriber to be unsubscribed when it is or inside the action itself it needs to unsubscribe when done if it is a fire and forget style execution Thus there are 2 approaches to handling the subscription 1 inside the action as your example shows 2 by registering with a Subscriber such as subscriber add inside so the Scheduler Inner gets unsubscribed when the Subscriber is In short the docs look great thank you it s just the unsubscribe requirement that I think needs clarification We have adopted the simplified Scheduler design but the Scheduler Inner name still exists and is still not liked Final chance before releasing to debate and change the name Possible replacements for Scheduler Inner Scheduler Worker Scheduler Serial Scheduler Loop Scheduler Queue Scheduler SerialQueue Scheduler Sequence In code these would be scheduler createWorker scheduler createSerial scheduler createLoop scheduler createQueue scheduler createSerialQueue scheduler createSequence I m trying to figure out what word communicates that we are creating something that executes tasks sequentially has a lifecycle must be cleaned up We do not want something specific like EventLoop as that has more specific connotation that may not hold true in an implementation of Scheduler Inner We also don t want something redundant like Scheduler InnerScheduler or Scheduler SerialScheduler Please vote on the above or provide us with a more inspired name cc @samuelgruetter @zsxwing @jmhofer @akarnokd @kirkshoop @mattpodwysocki @headinthebox @daveray @michaeldejong @mttkay @mattrjacobs @johnhmarks @davidmoten Threadpool Scheduler although not conforming with the reqs above I vote for scheduler createQueue which implies that it is a collection or rather a priority queue which must be emptied and cleaned up properly Threadpool Scheduler There s nothing about a Scheduler that requires a thread pool in fact several of them do not use a thread pool or even necessarily plural threads Especially the inner one is not a pool since it is specifically sequential in nature scheduler createQueue I m okay with this option I also like scheduler createWorker as it implies a single instance of something doing work that then needs to be stopped @benjchristensen I d also vote for scheduler createWorker I like Worker Worker 1 Worker looks like it s going to win @headinthebox are you okay with this The signature will look like this java class Scheduler public abstract Worker createWorker public int parallelism public long now public abstract static class Worker implements Subscription public abstract Subscription schedule Action0 action long delayTime TimeUnit unit public abstract Subscription schedule Action0 action public Subscription schedulePeriodically Action0 action long initialDelay long period TimeUnit unit public long now I can live with that Guess we have a winner then I will make the change to Scheduler Worker This means we re now free to release 0 18 whenever we re ready',RxJava,false,false,false
30404934,'Serialization Behavior','Opening this issue to capture document and discuss how serialization serialize merge flatMap mergeMap behaves and is implemented Prior to 0 17 1 all serialization was done via blocking synchronization This is how Rx Net does it so we adopted the same pattern This however breaks the model of Rx which is supposed to be non blocking and be usable in non blocking environments think NIO event loops like Netty Vert x and Node js style apps Blocking a thread while merging can significantly impact throughput in an application based on event loops The migration https github com Netflix RxJava pull 962 to doing serialization instead of synchronization came with trade offs ##### Back Pressure To be non blocking means it must becomes async and allow threads to deliver their notifications queueing if necessary and return This can result in buffer bloat and typical back pressure problems Solutions to this are being explored https github com benjchristensen RxBackpressure internally and with other teams companies and will result in changes in the future ##### Concurrency One way of solving the problem without blocking is similar to observeOn and everything gets dropped into a queue and another thread pulls off the queue This however means that we are injecting additional concurrency in places it is not expected and generally not desired The current implementation does not do this It uses the threads that are pushing events through and steals a single thread at a time to push through whatever is in the queue and then itself and then return to do its own work ##### Thread Starvation Stealing threads opens up the possibility of thread starvation If a thread loops continually to drain the queue and the queue always is getting filled by other threads it will never be released to do its own work This would means that the events intended for it to deliver would never be delivered as it is always busy delivering events on behalf of other threads ##### Delayed Delivery To prevent thread starvation the current implementation only allows draining the queue once This can be increased to multiple iterations but at some point it stops draining and returns and allows another thread to win and start draining During the time gap between the draining thread finishing and and a new thread taking over there may be a delay where events stay in the queue This can delay delivery of events In a fast moving stream this is not a problem as another thread immediately takes over In an intermittent stream however this can possibly mean long non determistic delays ### Possible Improvements There are a few ways to improve this situation without reverting back to blocking Metrics could be kept to know if a stream is fast moving and thus thread starvation is an issue and draining should be handed off to another thread If starvation is not an issue then the queue could be fully drained before returning This is still not perfect and would still risk one of the two occurring but could probably solve most cases The difficult is doing so without significantly impacting normal performance Another option is conditionally scheduling delivery onto another Scheduler when starvation is happening This would allow most cases to be done by stealing threads but flip to an observeOn style model if contention and or starvation is happening ### Next steps If the current functionality is breaking your use cases you may want to stay on 0 17 0 while working with us to improve Most use cases have shown to work fine with 0 17 1 behavior and the non blocking and deadlock free characteristics are necessary I welcome discussion unit tests pull requests and assistance on this Existing performance tests that need work https github com Netflix RxJava blob master rxjava core src perf java rx operators OperatorSerializePerf java https github com Netflix RxJava blob master rxjava core src perf java rx archive operators OperatorSerializePerformance java Existing unit tests https github com Netflix RxJava blob master rxjava core src test java rx operators OperatorSerializeTest java https github com Netflix RxJava blob master rxjava core src test java rx observers SerializedObserverTest java','I recommend the following Steal the current thread and continue draining even if work is queued while you re draining If some limit is exceeded either in number of work items or time duration spin off a thread or other async execution thingy to handle draining the queue from then on This guarantees items can t sit indefinitely in the queue and will not live lock of callers indefinitely spin off a thread or other async execution thingy to handle draining the queue from then on So it s clear what this means the Rx contract is to never inject concurrency unless a Scheduler overload is offered that controls what Scheduler is used This means every flatMap mergeMap merge and mergeDelayError method needs an overload with a Scheduler This is around 30 methods The livelock is only an issue when there s already concurrency since other threads have to be adding data but I suppose if every one of them was in some context the async thingy we spun off might violate that What about some sort of hand off After the limit is exceeded the current consumer sets a flag that others check when they re producing The first producer that comes along is then forced to block so the consumer can hand off to them after it finishes the next job The first producer that comes along is then forced to block so the consumer can hand off to them after it finishes the next job The problem I see with this is that we have no idea how quickly the onNext will complete and thus can block for non deterministic periods of time On event loops that s a real problem We could argue that if anyone is doing something like that they are doing the wrong thing but I m not sure we can The backpressure https github com Netflix RxJava issues 1000 solution will affect the design of this In particular it will mean the buffer becomes bounded and may naturally prevent thread starvation as the fast producers will park themselves The addition of backpressure machinery may or may not necessitate the additional concurrent consumer I suggest changing the current implementation to tradeoff for risking starvation rather than delaying delivery The starvation problem seems less likely to occur and a symptom of other problems lack of backpressure Or should we leave this as is until we get the backpressure stuff in place I m not all that comfortable yet adding more threads to deal with serializing other threads It feels wrong and makes for a confusing API particularly on flatMap since a Scheduler would exist but not be used for real work just sometimes pushing notifications suggest changing the current implementation to tradeoff for risking starvation I would vote for that as a temporary fix until we have the back pressure stuff in place Sounds acceptable to me And me Interesting discussion Please review changes on this pull request https github com Netflix RxJava pull 999 In particular this commit https github com benjchristensen RxJava commit 5b317ad827f624bed6cbf5f2e04df050ebbe01d0 moving comment from pull request apologies for joining this a little late but had a couple of observations questions in theory this wasn t a problem for Vert x because as long as all the events that trigger the callbacks come from the Vert x event loop those calls are already serialized so there is no contention it does imply that all code using RxJava in Vert x does not use any other threads schedulers that might cause it to block or switch threads in the Vert x model the design requires you to delegate slow blocking operations to separate dedicated worker verticles that use their own thread pool and communication with those threads is via an async event bus mechanism this means that there is no slow operation that can happen via onNext each processing pipeline should complete quickly otherwise the event loop will starve other Verticles tied to the same Thread From what I understand of the current solution this means that in Vert x the short circuit where no queue is created will always be executed and there will be minimal impact It also means that Vert x is relying on not introducing Concurrency without an explicitly provided Scheduler aside I assume naively this never happens as the user would also need a matching observeOn with a customer Scheduler to ensure the thread isolation is preserved Hi Peter as long as all the events that trigger the callbacks come from the Vert x event loop those calls are already serialized This assumes that multiple network requests on different event loops are never happening Perhaps in Vert x this is prevented but it is definitely not the case in many apps using NIO Netty where multiple network calls on separate event loops can all be merged together it does imply that all code using RxJava in Vert x does not use any other threads schedulers that might cause it to block or switch threads I don t understand how synchronization serialization relates to this comment can you please elaborate this means that there is no slow operation that can happen via onNext each processing pipeline should complete quickly otherwise the event loop will starve other Verticles tied to the same Thread A pipeline processing quickly is not sufficient since Rx supports streams not just scalar responses thus a stream from one thread can starve out another stream on a different thread if merged together Each onNext may be fast but when merging 2 or more threads together one thread that is emitting many onNext notifications rapidly such as in a tight loop can result in other threads being blocked Even if each onNext is fast all other event loops can end up waiting for a non deterministic time until that thread yields or is parked by the OS and lets other threads work We are seeking a solution where instead of the other thread s being blocked they can asynchronously deliver their results and move on to continue processing other work if they are event loops To complete this solution we need back pressure https github com Netflix RxJava issues 1000 so as to park pause streams that are too fast for the consumer which in this case could just be the merge bottleneck this means that in Vert x the short circuit where no queue is created will always be executed and there will be minimal impact If everything is always done on the same event loop yes you would have the best case scenario and should see little to no change It also means that Vert x is relying on not introducing Concurrency without an explicitly provided Scheduler This isn t quite right Rx never injects concurrency without an operator asking for it and in all those cases where it is required there is an overload that accepts a Scheduler to change the default If an operator is used that requires concurrency though it uses a default Scheduler such as Schedulers computation This is why I m against using a separate thread in merge serialize to drain as it injects concurrency where it s not expected Operators that do inject concurrency because it s needed by definition are things like observeOn interval timer buffer and window involving time timeout throttle sample and surely others All of these have a Scheduler scheduler overload If you want to force all of these to always run on the Vert x event loop s then you may want to leverage the RxJavaDefaultSchedulers plugin https github com Netflix RxJava blob master rxjava core src main java rx plugins RxJavaPlugins java#L187 to override the system defaults and make everything always run on a Vert x event loop Hi Ben aware this might be too Vert x specific for this issue so if you d prefer to move to a different issue group thread just lmk This assumes that multiple network requests on different event loops are never happening Perhaps in Vert x this is prevented but it is definitely not the case in many apps using NIO Netty where multiple network calls on separate event loops can all be merged together Right This is particular to Vert x where all callbacks to requests from a Verticle instance are serialized back to that instance on the same event loop thread it does imply that all code using RxJava in Vert x does not use any other threads schedulers that might cause it to block or switch threads I don t understand how synchronization serialization relates to this comment can you please elaborate It doesn t directly relate other than that both thread stealing and injecting concurrency would most likely break in Vert x The current solution only works because the existing serialization prevents the problem case happening something I wasn t 100 on and wanted to confirm We are seeking a solution where instead of the other thread s being blocked they can asynchronously deliver their results and move on to continue processing other work if they are event loops To complete this solution we need back pressure #1000 so as to park pause streams that are too fast for the consumer which in this case could just be the merge bottleneck Understood and back pressure throttling is the only real solution If everything is always done on the same event loop yes you would have the best case scenario and should see little to no change Yep Just wanted to confirm that This isn t quite right Rx never injects concurrency without an operator asking for it That was my understanding but my early reading of the original request was that it was being proposed as a solution glad you ve decided against it If you want to force all of these to always run on the Vert x event loop s then you may want to leverage the RxJavaDefaultSchedulers plugin https github com Netflix RxJava blob master rxjava core src main java rx plugins RxJavaPlugins java#L187 to override the system defaults and make everything always run on a Vert x event loop The problem is that the blocking operations cannot run on the event loop thread but the subscriptions would have to and more specifically run on the same thread that triggered the operator not any event loop thread I think that might require a custom scheduler that has to be passed into Operators and or observeOn might use registerDefaultSchedulers to block any code from using a default scheduler as a developer aid though The current solution only works because the existing serialization prevents the problem case happening something I wasn t 100 on and wanted to confirm How is this different than if synchronization was used In that case if multiple threads existed each would push their notifications through In short if inside a Vert x vertical there is ever a case when multiple threads are being merged together both serialize and synchronize would be problematic to Vert x The problem is that the blocking operations cannot run on the event loop thread What blocking operations are you referring to The only blocking operations I m aware of after eliminating synchronize are those inside BlockingObservable which if anyone uses they get what they ask for How is this different than if synchronization was used In that case if multiple threads existed each would push their notifications through In short if inside a Vert x vertical there is ever a case when multiple threads are being merged together both serialize and synchronize would be problematic to Vert x The only case was where serialization _always_ deferred to a seperate thread for delivery What blocking operations are you referring to The only blocking operations I m aware of after eliminating synchronize are those inside BlockingObservable which if anyone uses they get what they ask for Indeed Even a tight loop or CPU intensive code would be problematic as the threading model means that occupying a thread will starve other operations that are pinned to the same thread even if there are other cores available Even a tight loop or CPU intensive code would be problematic Yes but this is typical of any event loop system The goal is for RxJava to have nothing that would block a thread park sleep wait but that does not prevent a developer from writing computationally intensive code that saturates a thread loop If someone is going to do computationally intensive work they would need to use subscribeOn observeOn to move it off then back on the event loop just as they would need to do background processing when interacting with Vert x without Rx correct Yes but this is typical of any event loop system The goal is for RxJava to have nothing that would block a thread park sleep wait but that does not prevent a developer from writing computationally intensive code that saturates a thread loop Splitting hairs at this stage but yes A system that pins work to the same thread is just more susceptible to becoming unbalanced vs one that runs events on a pool of threads If someone is going to do computationally intensive work they would need to use subscribeOn observeOn to move it off then back on the event loop just as they would need to do background processing when interacting with Vert x without Rx correct Vert x has a separate model for this a WorkerVerticle it uses a separate thread pool and interfaces via the async event bus so no additional thread synchronization is needed That said it is quite coarse grained so providing support for subscribeOn observeOn might be worthwhile We have removed SynchronizedObserver and have been using SerializedObserver for several releases now',RxJava,false,false,false
30407766,'New Implementation of SerializedObserver','Rewrite of SerializedObserver by @akarnokd discussed at https github com Netflix RxJava pull 962#discussion_r10601839 from this Gist https gist github com akarnokd 9545150 #### JMH Benchmarks 0 17 3 Benchmark size Mode Samples Mean Mean error Units r operators OperatorSerializePerf noSerializationSingleThreaded 1024 avgt 5 45 504 1 710 ns op r operators OperatorSerializePerf noSerializationSingleThreaded 1048576 avgt 5 58 600 5 647 ns op r operators OperatorSerializePerf serializedSingleStream 1024 avgt 5 68 610 4 596 ns op r operators OperatorSerializePerf serializedSingleStream 1048576 avgt 5 71 313 2 318 ns op r operators OperatorSerializePerf synchronizedSingleStream 1024 avgt 5 73 322 3 666 ns op r operators OperatorSerializePerf synchronizedSingleStream 1048576 avgt 5 76 518 1 355 ns op 0 17 2 Benchmark size Mode Samples Mean Mean error Units r operators OperatorSerializePerf noSerializationSingleThreaded 1024 avgt 5 45 790 1 184 ns op r operators OperatorSerializePerf noSerializationSingleThreaded 1048576 avgt 5 58 518 3 788 ns op r operators OperatorSerializePerf serializedSingleStream 1024 avgt 5 72 665 7 851 ns op r operators OperatorSerializePerf serializedSingleStream 1048576 avgt 5 74 788 2 946 ns op r operators OperatorSerializePerf synchronizedSingleStream 1024 avgt 5 73 661 3 499 ns op r operators OperatorSerializePerf synchronizedSingleStream 1048576 avgt 5 78 386 5 036 ns op #### Manual Benchmarks java 0 17 3 Run 10 9 746 505 ops sec Run 11 9 956 019 ops sec Run 12 10 053 770 ops sec Run 13 10 076 958 ops sec Run 14 9 983 319 ops sec 0 17 2 Run 10 9 851 999 ops sec Run 11 9 726 975 ops sec Run 12 9 719 762 ops sec Run 13 9 668 141 ops sec Run 14 9 799 700 ops sec @param input public void serializedSingleStream Input input for int i 0 i reps i input observable serialize subscribe input subscriber','RxJava pull requests #932 https netflixoss ci cloudbees com job RxJava pull requests 932 FAILURE Looks like there s a problem with this pull request RxJava pull requests #936 https netflixoss ci cloudbees com job RxJava pull requests 936 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
30411236,Backpressure,'Thus far Rx has left backpressure solutions an exercise for the user It can be done via manual feedback loops and operators like throttle sample window etc The drawback of this is that it requires someone understanding the implication of every operator and when it might be async buffer queue and requires the effort to create a feedback loop and hook it up correctly Some use cases will probably always require this type of manual effort but it s worth exploring whether we can solve the general use cases within Rx Most Rx operators are synchronous in nature meaning the producing thread does not return until the work is completed The map operator is a good example It does computation work to transform from T R and nothing else There are some operators though that are async in nature and involve unbounded buffers These include observeOn zip and merge as of 0 17 1 which means flatMap is affected It also happens if an Observer is writing the data out to non blocking IO such as a Netty channel In all of these example if the producer is fast such as an in memory Iterable loading a file or a firehose of events over a network buffer bloat and eventually OutOfMemory can easily occur After some experimentation and talking with various individuals teams and companies about this topic a possible solution is the use of co routines from the producing Observable that a Subscriber can request data from in batches #### Prototype Code A prototype of this is being experimented with at https github com benjchristensen RxBackpressure though it is not yet complete as of this writing The general idea is that an Observable OnSubscribe implementation could register a producer co routine with the Subscriber and then only push data down when the Subscriber has said how much it can receive It becomes a conditional push model The co routine can then be parked by the producer by finishing work and returning releasing the thread and then unparked or resumed by the Subscriber when it wants more In this way no threads are blocked and only the amount of data the Subscriber can handle is sent The same model can work across threads or across the network If the Observable chain has no async operators then it will be executed with an infinite request and behave exactly as it does today without any parking If an async operator is in the chain then it will request a batch size equaling it s internal buffer say 128 512 1024 etc A simple producer of an Iterable would look like this https github com benjchristensen RxBackpressure blob master rx bp prototype src main java rx operators OnSubscribeFromIterable java ignoring debates over naming and API java public final class OnSubscribeFromIterable T implements OnSubscribe T final Iterable extends T is public OnSubscribeFromIterable Iterable extends T iterable this is iterable @Override public void call final Subscriber super T o state is outside the co routine below final Iterator extends T iter is iterator define the co routine Action1 Request func new Action1 Request @Override public void call final Request r if r countDown return while iter hasNext final T value iter next o onNext value if r countDown we have delivered all that was requested so park be returning and releasing this thread return o onCompleted register co routine with Subscriber o setProducer func The observeOn operator is async and thus will request batches as needed The relevant code looks like this https github com benjchristensen RxBackpressure blob master rx bp prototype src main java rx operators OperatorObserveOn java java private void pollQueue do Object v queue poll if v null if v instanceof Sentinel if v NULL_SENTINEL observer onNext null else if v COMPLETE_SENTINEL observer onCompleted else if v instanceof ErrorSentinel observer onError ErrorSentinel v e else observer onNext T v requested while counter decrementAndGet 0 observer isUnsubscribed if requested 0 requested SIZE request more starting the co routine up again request SIZE The subscribeOn operator decorates the co routine https github com benjchristensen RxBackpressure blob master rx bp prototype src main java rx operators OperatorSubscribeOn java#L79 so scheduling is retained and is started on the desired thread each time rather than the consuming thread doing the work java public void setProducer final Action1 rx Subscriber Request producer subscriber setProducer new Action1 Request @Override public void call final rx Subscriber Request r inner schedule new Action1 Inner @Override public void call Inner inner producer call r The take and skip operators compose the batch sizes to adjust accordingly to what is being taken or skipped https github com benjchristensen RxBackpressure blob master rx bp prototype src main java rx operators OperatorTake java#L93 https github com benjchristensen RxBackpressure blob master rx bp prototype src main java rx operators OperatorSkip java#L51 The Subscriber manages the life cycle of when the co routine is run https github com benjchristensen RxBackpressure blob master rx bp prototype src main java rx Subscriber java#L97 For example if the final Subscriber in the chain is hit and no async operator was involved it immediately invokes the co routine with 1 request size so it is infinite #### Example Use Cases Use case are being written here https github com benjchristensen RxBackpressure tree master rx bp examples src test java rx examples #### Handling Observables Without Co routines Implementing an Observable that supports backpressure is more complicated and not all will support it In those cases the async operators will onError stating that an Observable is not respecting the backpressure and suggest resolutions linking to documentation probably The two routes at that time are 1 fix the Observable to support backpressure or 2 use one of several backpressure operators that will be added such as whileParkedDrop whileParkedBuffer whileParkedBufferThenDrop int maxCount whileParkedBlock when blocking is okay such as on Quasar fibers IO threads etc whileParkedUnsubscribe such as on a hot stream like mouse events #### Outstanding Work An earlier prototype not public had zip functioning but the current code does not We know how it is done and this model works with it but have not yet spent the time to re implement it We need to The biggest outstanding item is making merge work and thus flatMap This is the major hurdle of any backpressure solution working We myself @abersnaze @headinthebox and others have whiteboarded it and believe we have a solution but my schedule has not allowed me to code it I have held off on writing this post as I wanted to code it up first but since I still haven t had time I wanted to get this information public instead of holding it up The planned design for merge is that each Observable being merged would have it s own buffer of say 128 items and then the consumer would request n items which would come in round robin fashion from all of the merged buffers Each individual Observable would exert it s own backpressure upstream Slow Observables may never fill their buffer while fast ones will We will not attempt to limit the horizontal growth number of Observables being merged but will limit the vertical growth size of buffer for each Observable The challenge with this is making sure performance and fairness are balanced #### Next Steps 1 Finish prototype implementatation of merge and zip 2 Finish examples across threads and netwwork 3 Bikeshed and debate APIs and naming conventions 4 Prove or disprove performance functionality tradeoff 5 Test long enough to convince ourselves we re not going to cause deadlocks livelocks hangs somewhere co routines not running I look forward to your help making this happen','Does the source Observable need to guarantee to call setProducer If not looks setProducer can not be triggered automatically The main issues that I have run into while trying to implement back pressure involving continuations in rxcpp are synchronization and additional complexity everywhere it is not localized Combined these really pessimize performance I think that there is a way to localize the complexity behind three interfaces Two already exist scheduler and connectable_observable The new interface is resumable_observable which just adds pause and resume to observable Edit resumable_observable is not required of course it is just a renaming of connectable_observable The new name for connect is resume and the new name for unsubscribe is pause The usage depends on the type of source ### Hot Observables The pause implementations that are meaningful for Hot Observables are unsubscribe or buffer These can be realized with some operators An operator that takes an existing connectable_observable source for the buffering behavior and returns a resumable_observable pause calls unsubscribe and resume calls connect Operators that take observable and directly implement a buffering behaviour pause switches into buffering mode and resume plays the buffer out ### Cold Observables The Hot back pressure policies are available by applying publish to turn the observable Hot then use one of the Hot operators that return a resumable_observable The additional policy which only applies to Cold observables is to stop the production of the next value until resumed This does require a continuation Fortunately Cold Observables already create a continuation per value Cold Observables take a scheduler and call schedule in some form for each value The continuation that is needed to support resumable_observable is passed to schedule already To exploit this a new regulator type wraps an existing scheduler and has methods get_scheduler pause and resume The regulator scheduler keeps its own queue and schedules itself on the wrapped scheduler to pop the next item and run it A new operator that takes the regulator and an observable returns a resumable_observable pause will stop scheduling the regulator queue and resume will start scheduling the regulator queue ### Join Operators These would change to accept resumable_observable s ### Cold Example C regulator current_thread r auto counter range int 0 100000000 1 r get_scheduler counter skip 1 resume r zip counter resume r int lhs int rhs return std make_pair lhs rhs subscribe std pair int int p std cout p std endl ### Hot Example C button_downs resume_with_subscribe zip button_ups resume_with_subscribe button_down lhs button_up rhs return std make_pair lhs rhs subscribe std pair button_down button_up p std cout p std endl Does the source Observable need to guarantee to call setProducer No It can continue to act just like right now Supporting backpressure is optional While discussing with @abersnaze and @headinthebox we contemplated using a minimum buffer size throughout the codebase like 32 64 or 128 so if an Observable is going to emit less than that it doesn t need to worry about back pressure at all If not looks setProducer can not be triggered automatically What do you mean by this If it s not set there s nothing to trigger and the source Observable is responsible for emitting via onNext as normal @kirkshoop Thank you for getting involved in the conversation I apologize that I don t fully understand the proposed implementation but I ll provide comments based on my interpretation We initially implemented the pause solution and moved on from it after discussion with other teams such as at Typesafe who have used the pause solution before and found issues with it We instead inverted pause resume to the batch continuation model The pause solution works very well within a single process where pausing can be fairly deterministic by sharing an atomic volatile reference across thread boundaries It does not work well across network boundaries though which is often the source of data requiring back pressure It is far too non deterministic to asynchronously request a source to pause and therefore still requires unbounded buffers or dropping data Also anything that is modeled after ConnectableObservable is immediately not composable and requires awkward coding just like publish and connect requires Cold Observables take a scheduler and call schedule in some form for each value This is very inefficient and exactly what we have sought to avoid in RxJava particularly as of version 0 17 where the Subscription is injected into the source so that a while loop can happen synchronously and still unsubscribe Scheduling each notification is not something we do very often at all Also this does not apply well to network requests which are the source for most cold observables Generally they are happening on a separate thread or an event loop and the notifications are not rescheduled again on a separate thread Nor do we use CurrentThreadScheduler which was significantly diminished in importance as of RxJava 0 17 due to the inefficiency of it in normal cases Thus cold observables generally do not have a thread or event loop to pause Forcing them to do so to achieve back pressure would force everyone to pay a performance penalty even in the best case where back pressure is not needed synchronization and additional complexity everywhere it is not localized Combined these really pessimize performance What extra synchronization is required The proposed solution using continuations does not change the threading model or introduce any extra use of schedulers concurrency I am concerned with performance impact for cases that don t require back pressure but thus far because of the batch request approach which then allows async onNext notifications it does not seem to be a performance problem still too early to perform all performance testing to know for sure though The case where performance will be impacted are the very ones where buffer bloat is a problem and it is purposefully slowing it down to the rate of consumption The one area where performance is an interesting challenge and will be with continuations as well is non blocking serialization https github com Netflix RxJava issues 998 Okay I am caught up now I was designing for a different system I think that we agree that we are happy with the existing Rx behavior for Hot Observables and that this back pressure discussion is for Cold Observables It is far too non deterministic to asynchronously request a source to pause and therefore still requires unbounded buffers or dropping data I disagree with this The buffer can be bounded declaratively on the source operator In fact I argue that a declarative chunk size and buffer size that is passed to Request in your design provides two benefits 1 The appropriate chunk size is dependent on the source not the subscriber or operators Modifications of the request value in Take and Skip would not affect the throughput of the source because the Request will always schedule chunks to keep the local buffer full so they are not needed 2 Providing declarative sizes allows the Request to create overlapping calls for subsequent chunks when the buffer has room for a chunk I have a application where the latency for a request is 13sec but the data in that request only contains the data needed for the next 10sec If the requests are not overlapped then the pipeline stalls horribly The buffer size ensures that no data is dropped and that the size is bounded A good minimum for the buffer size is 1 5 chunk size I still think that pause and resume suffice as the control surface They would not control the scheduling directly they would synchronously control the buffer draining which would indirectly trigger more chunks as the buffer emptied The source should be paused synchronously in on_next when the declared input buffer for the subscriber is full The source should be resumed when the buffer has space This ensures that the buffers in the whole expression are bounded However the buffer draining could be controlled with the current request count control surface as well I still think it is important to change the Request impl to support overlapped chunk requests with declared sizes for the chunk and buffer I think that in addition to chunk size and buffer size there should be two scheduler arguments One for the overlapped chunk requests and the other for the buffer draining This is very inefficient and exactly what we have sought to avoid in RxJava Yes this is very inefficient It added complexity to the scheduler in rxcpp to control the perf issue while still allowing current_thread to be fully supported I have looked at the code for RxJava s approach now and I have a background mental task deciding whether to similarly limit support for current_thread in rxcpp Thanks What extra synchronization is required The Request design does not have the same issues that I was running into with both the resumeWith is_resumed and the allocateMarble completeMarble designs Although the later would have had some interesting debugger applications The source should be resumed when the buffer has space Agreed but I don t understand how we would have resume and request count in the same system To me resume and request count are competing implementations for the same thing restarting work after it being paused It seems you are referring to having batch sizes when you say the buffer can be bounded declaratively on the source operator but then suggest we can work with just pause resume and not request count so I m not following What we re trying to achieve is that when resume is invoked whatever it is called that is passes along how much space is in the buffer for the upstream to send Are you suggesting that only the IO boundary needs the request count functionality and everything operating internally in the same process then just use pause resume to drain from the IO Observable buffer I think that in addition to chunk size and buffer size there should be two scheduler arguments One for the overlapped chunk requests and the other for the buffer draining We attempted this in an early prototype and it became ridiculously complex because the co routine state now needed to be thread safe and handle concurrent execution I m open to it as I agree it would be good but it s not clear yet how to make it simple to implement and I haven t spent enough time to try and determine alternative implementations To understand what I mean take a look at the OnSubscribeFromIterable example at the beginning of this issue it has this line in it java final Iterator extends T iter is iterator If we allowed overlapped requests in this example the producer could no longer use a simple iterator The buffer can be bounded declaratively on the source operator Since I m obviously not quite understanding can you elaborate more on what you mean by this and how it interacts with resume pause request count please I don t understand how we would have resume and request count in the same system To me resume and request count are competing implementations for the same thing restarting work after it being paused I am suggesting that a cold observable that supports back pressure has both a producer and a consumer inside The producer generates requests for a chunk size of items and the consumer stores a buffer size of items Subscriber setProducer void Request Subscriber and int Request get_chunk_size are the surface of the producer pause resume and optionally request count are the surface of the consumer The internal consumer is exposed as the Observable that can be subscribed to resume pause and request count all control the draining of the buffer in the source operator What we re trying to achieve is that when resume is invoked whatever it is called that is passes along how much space is in the buffer for the upstream to send Conceptually request count is just resume count on_next pause Once the source has separated the producer from the consumer what benefit is achieved by passing the count up Thanks for explaining I need to think about this more and trace it through the composition of merge zip skip take observeOn subscribeOn to understand It won t happen quickly unfortunately as I m wrapping up other things and traveling to London in a couple days for a conference My initial reaction though is that we shouldn t have both pause resume and request count traveling to London in a couple days for a conference Me too will you be at React My initial reaction though is that we shouldn t have both pause resume and request count I agree #### Complexity of source operator implementation I was thinking more about the operator implementations in this design and it changed the design a bit range should not be overlapped or buffered iterator should not be overlapped and should be buffered I am thinking of a generator that takes time in getNext Thus I think that a declarative max concurrency parameter to the producer is also required iterator and range would set it to 1 and neither would have to constrain the chunk or buffer sizes To simplify the implementation of the operators supporting overlapped calls Add a function Subscriber setStateSelector T T T and change Subscriber setProducer T void T Subscriber The producer function calls state stateSelector state bufferStart bufferNext bufferNext bufferStart chunk_size produce state new BufferSubscriber buffer bufferStart bufferNext The producer will not overlap calls to stateSelector and the BufferSubscriber will control the synchronization of the buffer access for produced values The produce and stateSelector functions supplied by the source operator can choose to share the same state across overlapped calls and deal with the sync themselves or stateSelector can choose to return an independent state value so that produce does not synchronize at all Me too will you be at React Yes I will be If you re there we ll definitely need to meet IMHO both pause resume and request count is trying to shove a square peg into a round hole I ve been thinking about an alternative design inspired by alternative abstractions for handling streams scala trait Observer T def onNext elem T Future Unit def onError ex Throwable Unit def onComplete Unit So basically Observer onNext can tell the Observable about when it is ready for more by means of its return type a Future For the Observable itself nothing much changes i e UPDATE because I pulled this out of my arse haven t thought about the implications but the above doesn t solve the problem still thinking about it Hi @alexandru thanks for getting involved In early prototypes I tried making onNext return Future and it became unwieldy very quickly However it still feels like it may be a valid approach I too am considering this more As a side note one practical concern is memory impact of allocating a future for every onNext @benjchristensen you re right it would be more heavy and I believe this would go against the design goals of Rx NET RxJava as you d have to make the whole abstraction to be entirely async I personally prefer it that way for the use cases that are of concern to me but it would make it impractical for certain use cases for which Rx was designed for the usual pick your poison applies I m exploring it for a bit asking for feedback on the scala user mailing list so if you can tolerate Scala code and my strong opinions here are some details I ve thought about https groups google com forum # topic scala user ckgrXz_4F_A @benjchristensen in case you re interested I have a proof of concept flatMap was a little tricky to implement but I think I got it https github com alexandru monifu blob 4a5b112cc2e24776f532cb7fdeb6d6692fa2f10c monifu rx src shared scala monifu rx Observable scala#L173 The interesting difference is that the obvious flatMap implementation behaves like you d expect from Stream or Iterable as in as observables are emitted by our source new subscriptions only happen after the previous ones are done so everything is ordered and for example this producer would generate elements once per second scala Observable fromTraversable 0 until 1000 filter x x 5 0 flatMap x Observable interval 1 second take 5 map y x y To implement the flatMap with the behavior from RxJava I would need to do buffering whereas RxJava needs to do buffering for the above behavior Thanks @alexandru for this I m just catching up after traveling so I probably won t have time today to review this but I definitely will I also had the chance to talk with the Akka team Roland Viktor Jonas and @kirkshoop from Microsoft working on RxCPP and got some interesting implementation ideas so there are several things I need to prototype and report on here when I get through my backlog @benjchristensen no rush it s good to evaluate all options and I d be glad if I could give you some ideas to make RxJava better As I was saying I m not seeing you implementing my solution because for it to work well it means to turn it into something that s maybe not Rx net anymore and maybe you got better ideas already Btw another idea I had as part of my toy project https github com alexandru monifu tree rx monifu rx src shared scala monifu rx is to provide 2 implementations for Observers and Observables one synchronous and one asynchronous much like how Scala separates between immutable and mutable collections since sometimes you can t have a one size fits all The asynchronous observer would be scala trait Observer T def onNext elem T Future Ack def onError ex Throwable Future Unit def onCompleted Future Unit The synchronous observer would be scala trait Observer T def onNext elem T Ack def onError ex Throwable Unit def onCompleted Unit Where Ack is basically an acknowledgment flag with which the Observer can send messages to upstream scala sealed trait Ack object Ack case object Continue extends Ack case object Stop extends Ack So you return Continue if you want to receive the next element or Stop to inform the source that you want the stream to stop as an alternative to calling onCompleted and relying on auto detaching In case of the asynchronous Observer it s a Future Ack and the rule is until the Future isn t completed then the source doesn t send And because I added it in the synchronous version the interesting thing is that this Ack message makes jumping threads harder e g there s no room for subscribeOn or listenOn anymore But that s OK because for async stuff you ve got the async version that I think will work much better To be honest I was a little afraid that it won t work before implementing flatMap but if flatMap is possible then everything is Btw I m not sure how familiar you are with Scala s Future Promise but their design is really sweet and it s the reason for why my implementation was doable in a short amount of time In case you ll look at my code and don t understand something I ll be happy to reply The work on this issue for supporting back pressure relates to interoperability work being done as part of http www reactive streams org which is an initiative to provide a standard for asynchronous stream processing with non blocking back pressure on the JVM Discussion from https github com Netflix RxJava issues 1001#issuecomment 44448887 However backpressure is a huge undertaking most of us need to learn a new paradigm and way of coding and it will certainly affect all operators Even if I had the time I couldn t make it under a month not to mention in a battle ready fashion In what way is this considered a new way of coding I also don t see it affecting all operators only the ones that are async like zip merge observeOn There are other complicated cases BehaviorSubject PublishSubject ReplaySubject plain size time size time GroupBy any operator with timing i e Buffer Window Sample Take Skip etc Agree with @akarnokd and @benjchristensen adding back pressure leads to a rather different API with fewer operators so I think it is better to consider it as a separate effort Progress on developing this solution can be seen at https github com Netflix RxJava pull 1382 Progress on this can now be seen in 0 20 0 RC1 being released today Release notes for 0 20 0 RC1 https github com Netflix RxJava releases tag 0 20 0 RC1 I m trying to sketch out some wiki documentation for this as well But I m not entirely clear as to what s going on so the page now is in a sort of thinking aloud state I d appreciate some feedback https github com Netflix RxJava wiki Backpressure In particular under what circumstances do creators of new observables and operators need to implement Producers and what other steps do they need to take to support backpressure or to indicate that they don t support it Who calls a Subscriber s setProducer p onSetProducer p methods and why On Tue Jul 15 2014 at 10 30 AM Ben Christensen notifications@github com wrote Release notes for 0 20 0 RC1 https github com Netflix RxJava releases tag 0 20 0 RC1 Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1000#issuecomment 49065540 David M Gross PLP Consulting @DavidMGross I ll need to spend more time on the documentation in the next week or two with you 0 20 0 RC2 successfully passed a 24 hour production canary on the Netflix API Can anyone using Android please test 0 20 0 RC2 and report back on issues if any In particular we need to make sure merge flatMap work okay as they have fast paths that conditionally use sun misc Unsafe that won t work on Android if the conditions are not correctly using alternate data structures for Android Any other issues related to 0 20 changes that need to be solved before releasing 0 20',RxJava,false,false,false
30412064,'Roadmap to 1 0','I want everyone to know where we re heading and what s left before we hit 1 0 From the beginning we have allowed ourselves to do breaking changes on each 0 x release as we were aware that the design was not finished when we started this project We are getting close to being done Our goal is to release 1 0 in the coming months after stabilizing the API so that it can be relied upon without breaking every couple months #### Project Structure When we hit 1 0 we intend on splitting out the language adaptors into their own top level projects such as RxScala RxClojure RxGroovy RxKotlin RxJRuby etc This will allow each project to iterate as needed at their own pace especially since some will need to continue iterating while the RxJava core stabilizes For example if RxScala needs breaking changes it can bump it s major version while RxJava does not This is particularly important to RxScala for handling changes such as Scala 2 10 2 11 2 12 etc Major contrib modules will also be moved out such as RxAndroid which also needs its own life cycle #### Outstanding Work The major items of work to be finished before 1 0 are Backpressure https github com Netflix RxJava issues 1000 Serialization Behavior https github com Netflix RxJava issues 998 Scheduler API https github com Netflix RxJava issues 997 Remove all deprecated methods classes Finish migrating all operators to using lift and chaining the Subscription via Subscriber The primary goal is to nail down the public API New functionality can come in 1 1 1 2 etc The secondary goal is for all operators to work as advertised regarding unsubscribe back pressure and non blocking There will always be bugs that s why 1 x y will still be active after release but the desire is to not need to ship 2 x soon after 1 x as this is a low level library that once entrenched becomes hard to migrate we create significant pain at Netflix on each 0 x release #### Going Forward Please comment if you feel there are other critical things to achieve before 1 0 The fastest way to getting us to 1 0 is helping us achieve the work stated above','Based on discussion with @headinthebox we will probably move rx joins into a separate module prior to 1 0 since this API does not yet feel finalized If over time it matures it can be brought back into core in 1 1 1 2 etc but we can t leave things in the core that may need public API changes Removing deprecated methods classes A few still remain to be done before 1 0 but can t be done until all operators are migrated Observable OnSubscribeFunc Observable create OnSubscribeFunc SafeObservableSubscription SafeObserver Migrating operators to using lift and Subscriber is now the priority for making progress to 1 0 I will personally be tackling the back pressure prototypes and eventually propose the change via a pull request This work is being tracked at #1000 I d like to start working on these Is the Scheduler API stable for now so any changes to it won t require me to rebase In addition could you setup an issue with checkboxes dedicated to each remaining operator Thanks @akarnokd I really appreciate your help on this I believe the Scheduler changes are stable unless someone quickly comes up with a better name for Inner I m just waiting on @mattpodwysocki to review the changes so we are in sync with RxJS Rx Net going forward before releasing 0 18 On the topic of migrating all of the operators I think there are a few things we should nail down as patterns we want to follow so operator implementations are similar to ease ongoing maintenance Things I can think of are a common well tuned ring buffer SPSC ring buffers will become useful in the async operators as well once back pressure allows us to be bounded how we apply locking synchronization we have various different approaches and styles right now when should state machines be used when should synchronized be used when should lock be used when should OnSubscribe vs Operator lift be used how should error handling be done see map as an example Perhaps we should create a README inside the rx operators package meant as an internal coding guide for decisions to these and other things we determine as practices we want to follow What patterns do you think we should be following to the above questions and others you are considering Version 0 18 0 was released with the Scheduler changes removal of rx joins and majority of deprecation cleanup Sorry for the delay but I needed to implement a few operators to establish a pattern for myself Ring buffer Whenever buffering is required with fixed size and there is only addition and removal one should use ArrayDeque instead of LinkedList Note however that ArrayDeque grows by doubling its capacity and may consume extra memory beyond the intended fixed size Eventually we might need a custom ringbuffer implementation Locking Synchronization For light contention such as when an observable and a scheduled action races for a shared object there isn t much difference between the two Therefore I prefer using synchronized as it is more readable For heavy contention state machines with randomized backoffs on CAS failures seem to be the way to go but implementing such logic is not trivial So in case a new concurrent operator needs to be implemented start off by using synchronized blocks to establish the base behavior then let one of the experts rewrite it to a state machine OnSubscribe vs Lift Use OnSubscribe if the operator works as a primary source of events from or there are many source observables that need to be mangled together merge Use lift if the operator modulates a primary source of events map @akarnokd wrt to backpressure and groing Shouldn t if you want to mirror a ringbuffer the ArrayDequeue or whatever be initalized to the required size upfront so you dont need to grow it You can preallocate the slots more or less so you also have less garbage flying around like with the LinkedList From the JDK source code ArrayDeque appears to round up the initial capacity to the next power of 2 and doubles it everytime it grows In addition the usage pattern in RxJava is as follows add check size remove i e if it is full it will add the latest item discover that it has overgrown the expected capacity and remove on item If the capacity happens top be power of two adding one element doubles the size which is then wasted wrt to backpressure and groing Once we implement #1000 there should be very few places left that require unbounded buffers and we can leverage ring buffers even in places such as observeOn and zip @akarnokd Thanks for the feedback I ll take a stab at writing a README to record this for our sake and anyone else getting involved One more question when we need to handle the case that the source Observable doesn t obey the Rx contract In my opinion if SafeSubscriber can not help handle the misbehaving Observable we need to handle it in the operator What use case are you referring to Operators assume sequential correct behavior The comment from @akarnokd here https github com Netflix RxJava pull 1115#discussion_r12029695 Answered the specific question on that issue more generally most operators should not need to concern themselves with unsubscribe behavior unless their purpose is to unsubscribe such as take Operators should also be able to assume sequential notifications and contract compliance The serialize operator is for making a source be sequential if it s not We don t however have anything to force an operator to not emit anything after onComplete or onError Some operators will stop functioning after a terminal state such as groupBy while others will work just fine like map With the release of 0 18 I am not aware of any further major breaking changes beyond the final removal of the last remaining deprecated signatures such as Observable OnSubscribeFunc There are a few operators such as buffer that @headinthebox is reviewing for correctness and possibly change their behavior from Rx Net which we have tried to match based on his experience over the past couple years The goal is that within a few months we can have a stable API and release 1 0 and let the 1 x version live for a long time without further breaking changes @benjchristensen I m happy to help with any Gradle related stuff Thanks @alkemist I don t know enough quite yet to know what to ask for but once I do I ll update here For all contributors involved in this for a variety of reasons I d really like to push towards having a 1 0 Release Candidate with the API locked down and all major features bugs resolved by July 1st This is only 5 weeks away but I intend on focusing as much as I can towards making this happen Once we hit the 1 0RC phase I expect we ll stay on RC for a while month or two to ensure testing so that 1 0 Final can be considered battle tested Issue #1000 is the biggest hurdle to achieving this as all of the other issues seem to almost be resolved As we approach 1 0RC we will also split the major sub modules into their own top level projects I d appreciate input on this A few issues with rxjava core is covered by PRs and there seems to be things not properly exposed in Scala but otherwise the the current standing is okay I don t know about the standing with the new computation scheduler However backpressure is a huge undertaking most of us need to learn a new paradigm and way of coding and it will certainly affect all operators Even if I had the time I couldn t make it under a month not to mention in a battle ready fashion A few issues with rxjava core is covered by PRs and there seems to be things not properly exposed in Scala but otherwise the the current standing is okay We can let RxScala continue pre 1 0 if we want Our intent is to split it out I don t know about the standing with the new computation scheduler I think we can get this stuff solved fairly soon and then let it bake for a while None of that requires API changes though backpressure is a huge undertaking It is indeed non trivial but we ve done enough prototyping that it s not completely unknown most of us need to learn a new paradigm and way of coding and it will certainly affect all operators Moved over to https github com Netflix RxJava issues 1000#issuecomment 44449871 for discussion instead of hijacking this issue with a long discussion on backpressure Scala bindings are just catchup nothing fundamental but I think it is fine to start separating the various bindings so they can move at their own pace such that we can stabilize the core I think I should be able to finish the remaining methods of RxScala in 1 2 weeks Thanks @zsxwing @headinthebox and I had a chance to review the roadmap together and we intend on pursuing the following 0 19 0 with the current set of performance bug and API fixes 0 19 x releases with continued performance bug fixes and additive changes to things like RxScala though core is mostly settled from an API perspective 0 20 x with backpressure split RxScala RxAndroid etc into their own top level projects RxJava core 1 0 Release Candidate 1 with all deprecated methods and classes removed and the API frozen only additive changes going forward as many 1 0 RCs as needed until they stabilize on performance and bugs 1 0 Final once we consider it fully production worthy each of the new top level projects can choose when they wish to hit 1 0 and can diverge on their release schedule and versioning The plan is for the new top level projects to live at https github com ReactiveX The anticipated first round of top level projects extracted from RxJava are RxScala RxGroovy RxClojure RxJRuby RxKotlin RxAndroid @benjchristensen so RxJava will be under the netflix org and the others move to ReactiveX Or do you also plan to move RxJava over Also does the addition of a 0 20 move the 1 0 RC behind of the originally anticipated schedule We also plan to move RxJava over The work on 0 20 has always been planned #1000 and hopefully will not delay us previous work on prototypes is what gives me this view The APIs and core functionality should be able to be locked down on the time frame I won t be surprised if there are edge cases that keep us iterating on release candidates for a few things once we get there Version 0 20 with backpressure #1000 is approaching release worthiness based on Netflix production canaries I expect to release 0 20 in the next 2 weeks though I do need confirmation from Android devs before proceeding The intention is to followup shortly after 0 20 0 with 1 0 0 RC1 that will remove all deprecated methods and types Items being tracked for 1 0 are in milestone https github com Netflix RxJava issues direction desc milestone 2 page 1 sort updated state open',RxJava,false,false,false
30421243,'Additional error handling','I would like an error handling operator that behaves like a mix between onErrorResumeNext and onErrorReturn What I d like it to do is let me replace the emission that caused the error like onErrorReturn but put that replacement value in place of the emitted item in the original set of emissions and keep moving along as if nothing happened like onErrorResumeNext','The problem is that onErrorResumeNext doesn t know how far up the observable chain the error happened One pattern that I ve used is to split each potentially error able units of work into its own observables than do a mergeDelayError to make it whole again mergeDelayError from 1 2 3 4 5 window 1 map unit return unit map n if n 3 throw new RuntimeException I don t like three return n 1 The result is value rx Observable@17974715 OnNext 2 OnNext 3 OnNext 5 OnNext 6 OnError java lang RuntimeException I don t like three Take a look at onErrorFlatMap @abersnaze That s close to what I want except you are losing an emission I am expecting to be able to replace the 3 with something else and keep the same number of emissions @benjchristensen Can you provide a quick usage example I couldn t find any docs online and the javadoc in the code doesn t have an example I m trying it in a unit test and it s not working how I expect it doesn t move on from the error Here s an example of what I m expecting java @Test public void onErrorResumeNext_shouldAllowRetryAfterFixingErrors final List String actual new ArrayList String Observable from new Integer 1 2 3 4 5 flatMap new Func1 Integer Observable String @Override public Observable String call final Integer integer return Observable create new Observable OnSubscribe String @Override public void call Subscriber super String subscriber if integer 3 RuntimeException e new RuntimeException I don t like 3 Throwable throwable OnErrorThrowable addValueAsLastCause e integer subscriber onError throwable else subscriber onNext String valueOf integer subscriber onCompleted onErrorFlatMap new Func1 OnErrorThrowable Observable extends String @Override public Observable extends String call OnErrorThrowable onErrorThrowable return Observable create new Observable OnSubscribe String @Override public void call Subscriber super String subscriber subscriber onNext 2 subscriber onCompleted subscribe new Action1 String @Override public void call String string actual add string assertThat actual hasSize 5 assertThat actual containsExactly 1 2 2 4 5 @christopherperry it was only lost because I let the error propagate By adding an onErrorReturn a fall back can be returned and because no errors make it out the mergeDelayError can be replaced with either merge or concat groovy concat from 1 2 3 4 5 window 1 map unit return unit map n if n 3 throw new RuntimeException I don t like three return n 1 onErrorReturn four output is value rx Observable@1d275b4d OnNext 2 OnNext 3 OnNext four OnNext 5 OnNext 6 OnCompleted Here are 2 versions that work with onErrorFlatMap java import java util Arrays import org junit Test import rx Observable import rx Subscriber import rx exceptions OnErrorThrowable import rx functions Func1 import rx observers TestSubscriber public class Issue1002 @Test public void onErrorFlatMap_shouldAllowFixingErrors_1 TestSubscriber String ts new TestSubscriber Observable from new Integer 1 2 3 4 5 flatMap new Func1 Integer Observable String @Override public Observable String call final Integer integer return Observable create new Observable OnSubscribe String @Override public void call Subscriber super String subscriber if integer 3 RuntimeException e new RuntimeException I don t like 3 Throwable throwable OnErrorThrowable addValueAsLastCause e integer subscriber onError throwable else subscriber onNext String valueOf integer subscriber onCompleted onErrorFlatMap new Func1 OnErrorThrowable Observable extends String @Override public Observable extends String call OnErrorThrowable onErrorThrowable return Observable from 2 subscribe ts System out println ts getOnNextEvents ts assertReceivedOnNext Arrays asList 1 2 2 4 5 @Test public void onErrorFlatMap_shouldAllowFixingErrors_2 TestSubscriber String ts new TestSubscriber Observable from new Integer 1 2 3 4 5 map new Func1 Integer String @Override public String call final Integer integer if integer 3 integer 5 throw new RuntimeException I don t like integer else return String valueOf integer onErrorFlatMap new Func1 OnErrorThrowable Observable extends String @Override public Observable extends String call OnErrorThrowable onErrorThrowable System err println Swallowing error onErrorThrowable getMessage return Observable from String valueOf onErrorThrowable getValue this restores the value subscribe ts System out println ts getOnNextEvents ts assertReceivedOnNext Arrays asList 1 2 3 4 5 Why doesn t this work when I return java Observable create new Observable OnSubscribe String @Override public void call Subscriber super String subscriber subscriber onNext 2 subscriber onCompleted instead of java Observable from 2 from the error mapping function That s not the issue it s flatMap merge used by flatMap that filters everything after seeing onError I ll probably change that in the next release so it doesn t do that Ben Christensen 310 782 5511 @benjchristensen On Mar 28 2014 at 4 43 PM Christopher Perry notifications@github com wrote Why doesn t this work when I return Observable create new Observable OnSubscribe String @Override public void call Subscriber super String subscriber subscriber onNext 2 subscriber onCompleted instead of Observable from 2 from the error mapping function Reply to this email directly or view it on GitHub @benjchristensen Are you saying this is a bug in flatMap What I m trying to do is clean up some data from a bad network request and re submit the request as many times as the response returns an error I need to use Observable create to clean it up and try again For swallowing errors and continuing yes flatMap is not allowing that For retries does the retry operator not work PM Christopher Perry notifications@github com wrote @benjchristensen Are you saying this is a bug in flatMap What I m trying to do is clean up some data from a bad network request and re submit the request as many times as the response returns an error I need to use Observable create to clean it up and try again Reply to this email directly or view it on GitHub Could you materialize the observable then map the error into an onNext notification and then dematerialize That might be a lot of overhead though Yes materializing is the easy way to handle errors as events but I avoid it anywhere performance is important If we had value types it would likely be the suggested approach but it creates a lot of extra objects There is an internal approach we use that got codified here https github com Netflix RxJava blob master rxjava core src main java rx operators NotificationLite java It may interest you for your use case but don t use this class directly unless you re willing to risk broken APIs since this is not part of the public API The reason this is not how materialize itself works is because it s not type safe and uses Object It works well for internal operators though @benjchristensen I need to retry with a cleaned up request Retry doesn t allow me to change the request just retry the one I already tried @christopherperry Makes sense regarding retry We have a case like that as well Making onErrorFlatMap work with merge doesn t look like it can be done without causing other problems The use of onErrorFlatMap to ignore and allow further errors is somewhat outside the Rx contract generally it should just handle the single error but works well in case like map The merge use case immediately unsubscribes from the Observable when an error or complete is emitted See see https github com Netflix RxJava issues 897 for more background on this and how memory leaks occur without this Thus the onErrorFlatMap or other error swallowing must happen on the Observable before merging Makes sense but isn t obvious It s a subtle yet important difference Perhaps some documentation around this would help others Yes we need to do this on the onErrorFlatMap operator which is a bit of an outlier Issue for improving documentation https github com Netflix RxJava issues 1221',RxJava,false,false,false
30479995,'Func0 can transparently implement java util concurrent Callable','This change doesn t change the API at all for users of Func0 but it makes all Func0 objects immediately reusable with any JDK API that accepts Callables For example a Func0 can now be submitted directly to an ExecutorService for asynchronous execution It also allows the elimination of a small amount of redundant code within RxJava itself','Looks like a fine change anyone else have comments on this cc @akarnokd Fine with me Thanks RxJava pull requests #933 https netflixoss ci cloudbees com job RxJava pull requests 933 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
30489355,'Subjects cannot be used in Android 2 2','Many phones are still running Android 2 2 API 8 Arrays copyOf was introduced in API 9 and is used in SubjectSubscriptionManager If we want RxJava to be able to run on the widest range of platforms maybe we should use System arrayCopy instead of Arrays copyOf','Yeesh not even the Java 6 APIs can be counted on In this case it should be easy to switch to System arrayCopy instead of Arrays copyOf Generally though we compile against Java 6 You want to submit a PR converting from Arrays copyOf to System arrayCopy Sure But it is not the only one it looks like java util Deque used at least in joins OperationSkipLast and OperationTakeLast is not supported either https developer android com reference java util Deque html noticed because of https github com cgeo cgeo issues 3707 Do we want Android 2 3 API 9 to be supported by RxJava or not The question is do we want Android 2 3 to be supported at all History on migrating from Java 5 to Java 6 is here https github com Netflix RxJava issues 153 Android adoption http developer android com about dashboards index html utm_source ausdroid net However in August 2013 versions older than Android 2 2 accounted for about 1 of devices that checked in to Google servers not those that actually visited Google Play Store I only target 2 3 and above unless a client specifically asks for lower very rare only one has I don t see much of a need for rxjava to support lower than 2 3 and that need will only get less over time On 1 Apr 2014 03 47 Ben Christensen notifications@github com wrote History on migrating from Java 5 to Java 6 is here #153 https github com Netflix RxJava issues 153 Android adoption http developer android com about dashboards index html utm_source ausdroid net However in August 2013 versions older than Android 2 2 accounted for about 1 of devices that checked in to Google servers not those that actually visited Google Play Store Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1004#issuecomment 39114972 We are in the process as dropping support for 2 3 in cgeo too keeping a legacy version which doesn t use RxJava around It looks like the best thing to do rather than to ask every library to not even support Java 6 I agree Java 6 itself is end of lifed let alone Java 5 So it s only a matter of documentation somewhere the sentence Android API version 9 and later Android 2 3 are supported should appear So it s only a matter of documentation somewhere the sentence Android API version 9 and later Android 2 3 are supported should appear Please submit a PR to modify the README for Android to clarify it as you feel is best https github com Netflix RxJava blob master rxjava contrib rxjava android README md It is just a few places where you use Arrays copyOf actually it is just 2 places at the moment so why not support it I have no issue with the change being made but according to the comments above there are other things that don t work as well and there is nothing to prevent other breaking changes to happen since Java 6 is the minimum',RxJava,false,false,false
30535646,'add toMap from Java Observable','Added three overloads of toMap to Scala Observable','Please also add some examples to RxScalaDemo on how these methods can be used And every PR should have a small description When I run the toMapExample1 test I get a StackOverflowError Can you please fix this RxJava pull requests #934 https netflixoss ci cloudbees com job RxJava pull requests 934 FAILURE Looks like there s a problem with this pull request Seems that there was some git error Tests pass for me merging',RxJava,true,false,false
30545736,'WeakReference ist sometimes Null in WeakSubscriber','I used the method bindFragment when I go repeatedly from activity A to B back and forth is from and to the weak reference to the Subscriber zero','I m not sure if this is the same issue described above but we ve seen similar issues where using an anonymous function will result in the subscription being GCed because there is only the WeakReference holding it The only fix so far is to hold a hard reference to the subscription in the Fragment or Activity and consequently unsubscribing in ondestroy which kind of defeats the purpose of OperatorWeakBinding and bindFragment over fromFragment I m not sure if there s a good solution since holding a hard ref to the subscription usually means holding a ref indirectly to the fragment as well cc @bencodes If I have understood you correctly they use fromFragment instead bindFragement but the method is deprecated Isn t this similar to #979 I think it is and we should discuss possible solutions there Ah yes it s the same as 979 in my case I m not sure if that s what @markus2610 is also talking about Yes I did mean it I believe this was fixed due to #1021 so closing If not please re open with details on what is left to do',RxJava,false,false,false
30547787,'Yet another unimplemented class in Android 2 3','From release 2014 03 31 java lang NoSuchMethodError java util Deque iterator at rx operators OperationTakeLast TakeLast ItemObserver onCompleted OperationTakeLast java 83 at rx Observable 28 onCompleted Observable java 7007 at rx observers SafeSubscriber onCompleted SafeSubscriber java 73 at rx Observable 28 onCompleted Observable java 7007 at rx observers SafeSubscriber onCompleted SafeSubscriber java 73 at rx subjects SubjectSubscriptionManager SubjectObserver onCompleted SubjectSubscriptionManager java 258 at rx Notification accept Notification java 153 at rx subjects PublishSubject 2 call PublishSubject java 80 at rx subjects PublishSubject 2 call PublishSubject java 72 at rx subjects SubjectSubscriptionManager 1 call SubjectSubscriptionManager java 114 at rx subjects SubjectSubscriptionManager 1 call SubjectSubscriptionManager java 57 at rx Observable subscribe Observable java 7076 at rx operators OperationMulticast MulticastConnectableObservable 1 call OperationMulticast java 48 at rx operators OperationMulticast MulticastConnectableObservable 1 call OperationMulticast java 45 at rx Observable subscribe Observable java 7080 at rx Observable subscribe Observable java 7003 at rx operators OperationRefCount RefCount onSubscribe OperationRefCount java 46 at rx Observable 1 call Observable java 235 at rx Observable 1 call Observable java 231 at rx Observable subscribe Observable java 7080 at rx Observable subscribe Observable java 7003 at rx operators OperationTakeLast TakeLast onSubscribe OperationTakeLast java 64 at rx operators OperationTakeLast 1 onSubscribe OperationTakeLast java 43 at rx Observable 1 call Observable java 235 at rx Observable 1 call Observable java 231 at rx Observable subscribe Observable java 7080 at rx Observable subscribe Observable java 7003 at rx operators OperationMaterialize MaterializeObservable onSubscribe OperationMaterialize java 57 at rx Observable 1 call Observable java 235 at rx Observable 1 call Observable java 231 at rx Observable subscribe Observable java 7080 at rx Observable subscribe Observable java 7003 at rx operators OperationToIterator toIterator OperationToIterator java 48 at rx observables BlockingObservable getIterator BlockingObservable java 161 at rx observables BlockingObservable 2 iterator BlockingObservable java 459 at rx observables BlockingObservable singleOrDefault BlockingObservable java 398 at rx observables BlockingObservable lastOrDefault BlockingObservable java 278 at cgeo geocaching network HtmlImage waitForBackgroundLoading HtmlImage java 223 at cgeo geocaching Geocache storeCache Geocache java 1614 at cgeo geocaching Geocache refreshSynchronous Geocache java 1531 at cgeo geocaching CacheListActivity LoadDetailsThread refreshCache CacheListActivity java 1154 at cgeo geocaching CacheListActivity LoadDetailsThread run CacheListActivity java 1132 Deque is implemented only starting with API 9','Sorry intended to submit this to c geo closing please delete',RxJava,false,false,false
30591141,'Fix premature garbage collection of subscriber','Keeping a weak binding onto the subscriber makes it possible to prematurely get the subscriber garbage collected if there are no other references to it Here we chose to pass around the component to which the subscriber is tied in form of a pair BoundPayload This allows the subscribers to get a reference on the guaranteed non collected target without keeping it in the closure This introduces an interface change but the current implementation is wrong and should never be used see issues #979 and #1006 An example usage can be seen at https github com samueltardieu cgeo blob bound payload main src cgeo geocaching PocketQueryList java#L50 where selectFromPocketQueries references the target activity through pocketQueryLists target in the subscriber cc @mttkay','I would like @mttkay to review this as I m not very involved in the Android side so am not the right person for this RxJava pull requests #935 https netflixoss ci cloudbees com job RxJava pull requests 935 FAILURE Looks like there s a problem with this pull request The failure from CloudBees is about rx operators OperatorPivotTest testConcurrencyAndSerialization which is untouched and doesn t used any modified code Please ignore it sorry for not responding too much going on right now I hope I ll get to it before or by the weekend Meanwhile you can try running all the Android samples using this Give it some stress rotations and such and see if you see any unwanted behavior or memory leaks The tests pass so the observable is correctly unsubscribed when it becomes invalid or unreferenced I ve run a modified version of cgeo in the field using this patch and haven t noticed any problem So I finally had a chance to look into this I see your idea with this but this implementation does not work either as in it regresses on what this operator sets out to fix not leaking context It leaks the activity in every rotation change and it leaks it too when backing out of the Activity while the sequence is still in progress At a quick glance this is simply because of the fact that it s keeping a strong reference to the subscriber and the subscriber is keeping a strong reference to the Activity since it s an inner class so the weak reference is never cleared In essence this operator now does nothing You could as well have simply subscribed the activity to it without using it and would wind up in the same situation Unfortunately it s very difficult to unit test this but it s very easy to verify in practice create a sequence that outlives your activity use this operator turn StrictMode on and send it through a few config changes Even when hitting the back button the subscriber is not released and keeps a reference to the activity and keeps emitting notifications to it In fact I ve created the android samples module as a sandbox for such things Frankly at SoundCloud we ve stopped using any of these operators We simply unsubscribe manually at the appropriate time again have a look at the samples module it contains examples using managed subscriptions that achieve the same goals I ve went back and forth with these implementations here and no one has found a solution that covers everyone s needs That said I think unless someone is confident to have found a solution that works for everyone my vote is to remove of all these operators from the core library and simply encourage people to manage their subscription references themselves Although I remember @benjchristensen saying that this too is discouraged outside an operator implementation For the record here s the code I used thrown together quickly Activity @Override protected void onCreate Bundle savedInstanceState super onCreate savedInstanceState setContentView R layout observer_activity source Observable String getLastNonConfigurationInstance if source null source SampleObservables numberStrings 1 200 100 cache AndroidObservable bindActivity this source subscribe new rx Observer BoundPayload ObserverActivity String @Override public void onCompleted @Override public void onError Throwable throwable @Override public void onNext BoundPayload ObserverActivity String atBoundPayload System out println this TextView textView TextView findViewById android R id text1 textView setText atBoundPayload payload Output after 7 rotation changes D SurfaceFlinger 490 setOrientation mFbdev 0xb860f9d8 mFbDev setOrientation 0xb671ecc0 orientation 0 I gralloc_vbox86 490 setOrientation orientation 0 I ActivityManager 466 Config changes 1480 1 0 mcc mnc en_US ldltr sw384dp w384dp h567dp 320dpi nrml port finger qwerty v v dpad v s 15 D dalvikvm 1481 GC_EXPLICIT freed 169K 9 free 3871K 4224K paused 0ms 1ms total 4ms E StrictMode 1481 class com netflix rxjava android samples ObserverActivity instances 8 limit 1 E StrictMode 1481 android os StrictMode InstanceCountViolation class com netflix rxjava android samples ObserverActivity instances 8 limit 1 E StrictMode 1481 at android os StrictMode setClassInstanceLimit StrictMode java 1 I just thought of another problem don t we love solving problems Binding a context reference to an Rx notification in this case through BoundPayload introduces a very subtle issue since HandlerThreadScheduler posts that data to the Android message loop then even if we solve the above issue you create another often significant window of time in which you leak that reference since the message plus everything attached to it the callable that will execute the notification in this case will stick around until the message is actually processed That s a problem since Android stops processing the message loop when going through a rotation change it literally ignore your messages that queue up until after onResume is called on the next instance of the recreated Activity So until then you have a second reference to your activity until its new counterpart is fully constructed and ready to render For more information Square has written an article about this a while ago http corner squareup com 2013 12 android main thread 2 html I spent the afternoon investigating other approaches using Reference such as counting via reference queues but I think it will never work that way We need an external signal whether an activity is still valid and should probably not rely on the garbage collector The obvious but insufficient signals are 1 isFinishing only true if someone requested to destroy the activity but not e g true for a config change 1 isDestroyed reports true even before super onDestroy is called great But only available since API level 17 so practically useless for now at SoundCloud we still support API 9 1 isChangingConfigurations true when going through a config change so would be a perfect complement to 1 But only available since API level 11 so only useful for modern Android devices One other possibility could be to leverage FragmentManager it has an isDestroyed method This would have the benefit of being available to older clients through the support v4 package I ll investigate further I finally removed my calls to bindActivity and bindFragment Since I manage the subscriptions explicitly I too prefer not to use those mechanisms after all If I have a leak well this is my fault and no different from any other leak Thanks @samueltardieu for your feedback Would you agree to recommend removing bindActivity and bindFragment since they re also broken apparently for the 1 0 release of RxJava and instead focus on providing exhaustive sample code that demonstrates how to properly handle this via subscriptions I just spend some more time inspecting in which order Android processes these messages in different scenarios and found some interesting patterns unfortunately all this is undocumented and I had to resort to experimentation observation logging and reading source code I found that the following seems to be true For Activities rotation changes these are atomic w r t life cycle calls When unsubscribing in onDestroy no messages emitted through the main thread scheduler will arrive between onPause of the destroyed Activity and onResume of the new activity instance since unsubscribing also releases the reference to the subscriber and by extension the Activity we re already safe and done finishing via finish or back button destruction in this case is not atomic even unsubscribing in onDestroy will open a window for messages to arrive between onPause and onDestroy However this can be caught with a test for isFinishing For Fragments rotation changes similar rules apply since the fragment life cycle is bound to the activity life cycle rotation changes are atomic and no messages are processed between Fragment#onPause and Fragment#onResume Re subscribing to an observable should therefore happen in either onResume or onViewCreated since both hooks are called atomically and both guarantee the Activity will be attached and the view tree constructed Unsubscribing should happen in onDestroyView or onPause respectively Activity finishing again similarly there s a window of time where messages can arrive in a fragment observer when the attached activity is in the process of being finished which leads me to the conclusion that the fragment validator that was being used was also incomplete So my suggestion is discard the idea of automatically unsubscribing from a sequence for now instead clearly document where a sequence needs to be unsubscribed from rewrite bindActivity to merely test a bound activity for isFinishing and clear the reference in unsubscribe rewrite bindFragment to also test for getActivity isFinishing the two helper methods still add value even if they force you to manage subscriptions since they stop messages from being forwarded in the above mentioned cases but it sort of brings us back to where we were a few weeks ago Sorry just to clarify I meant to say we should keep the bindFragment and bindActivity helpers but I will rewrite the operator to not use weak references and make the necessary amendments to accommodate for the behavior mentioned above I will also add samples and more documentation to clarify these shortcomings Please have a look at #1021 We can understand this as a middle ground between the deprecated OperatorObserveFromAndroidComponent and the last experiment using weak references In summary you will have to manage subscriptions the only case it auto unsubscribes is if the activity reports that it s scheduled to get finished it s still re subscribable a problem we had with the old operator and I added a sample activity for that case it s still flexible w r t using custom predicates to close the sequence it still schedules on the main UI thread I think this is far as we can get with this for now I personally don t think it s a big deal to have manual subscription management I actually like that level of control You often need it anyway sometimes you want to always stop listening when the component is paused but other times only when it gets destroyed I like your PR I didn t try it I just read it I agree that manual subscription is more appropriate I often have a resumeSubscriptions in my components as well as a createSubscriptions and I add subscriptions there respectively in onResume and onCreate and automatically unsubscribe them in my onPause and onDestroy methods',RxJava,true,false,false
30637724,'Android Adding a new RetainedFragment example','I wanted to augment the current RetainedFragment example class to address some scenarios I have run into using the patterns defined in the current example I was hoping to get some feedback on a more complete scenario I have been working on which is the following On a typical login screen when the user taps a button we want to fire off our network request in an observable We want to show a progress dialog and then show either success or an error dialog when it fails We want to gracefully handle rotation and app switching in case a user does something else after firing off the login call When the user returns we should be able to tell them there was an error or continue forward I tried to address this scenario above but specifically I wanted to try and complete the following Get all the benefits from the current example i e rotation support Make sure the callbacks are not triggered while the app is not in focus Make the example be triggered by a user action i e a user tapping a button Hoping to get some feedback on the example and see if there are any issues with the sample implementation Any issues you see here @mttkay or other android RX users Thanks','This looks fine I m just wondering if it really adds much value over the existing sample It s almost identical with the exception of moving subscription logic to onResume onPause instead of onViewCreated onDestroyView and firing the observable manually via a button click How about this to make this sample more interesting over the existing one have the observable toggle the button state You could map a completed notification to a boolean which in turn is used to set the enabled state Then at least there s a new dimension to this sample binding observables to views not just screens Also let s give it a more meaningful name RetainedFragmentActivity2 doesn t convey much meaning to a reader Or do you think it will get too verbose thanks @mttkay I will go ahead and update the PR with your suggestions this week I will try and come up with some less verbose but understandable name for the class itself My updated sample now uses the observable to make the data request and then maps that observable to a boolean value where a user can control the state of the UI I also updated the class documentation to closer match the current samples Let me know what you think RxJava pull requests #947 https netflixoss ci cloudbees com job RxJava pull requests 947 ABORTED I was wondering is there a reason the samples don t use the AndroidObservable class for binding Are these examples safe in terms of being garbage collected properly I assume since we are unsubscribing in onPause we are fine but I just want to make sure Ive been following the AndroidObservable classes but haven t seen the justification for using them if I am subscribing and unsubscribing Any insight on this would be great Thanks Is this ready for merging after the last commit We probably want to wait for @mttkay to sign off on the updated example Not sure if he has been able to look at the latest update Upon further investigation his might actually get updated again based on the status of #1021 I think it s fine just land it I look at the samples module as an ever moving target anyway I see some things here that we should take as clues for providing proper operators to bind sequences to views where a notification s value is mapped to a view property I believe this is what the original Reactive Extensions and ports like ReactiveCocoa already provide but RxJava is lacking since RxJava client platform independent unlike ReactiveCocoa which was build with the Apple SDK in mind from the ground up There have been a few attempts already at providing such view bindings for Android cf ViewObservable but it s far from exhaustive Hopefully the core elements for Android scheduling on the main looper attaching sequences to screens have settled and are stable going forward so I m open to explore new territory I really wanted to nail the core use cases first before looking into the nice to haves Should this be merged Merge it We can iterate on samples frequently it s not that anything relies on them On Apr 15 2014 11 58 PM Ben Christensen notifications@github com wrote Should this be merged Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 1009#issuecomment 40539718',RxJava,true,false,false
30661632,UnsafeSubscribe,'Migrate from reflection to unsafeSubscribe as per discussion at https github com Netflix RxJava issues 676 All operators are migrated to using unsafeSubscribe instead of relying on their package to avoid SafeSubscriber wrapping','With these changes I m seeing non deterministic failure of OperatorGroupByTest testStaggeredCompletion It s not yet clear why RxJava pull requests #937 https netflixoss ci cloudbees com job RxJava pull requests 937 FAILURE Looks like there s a problem with this pull request Problem appears to be related to the delay operator https github com Netflix RxJava issues 1011 RxJava pull requests #938 https netflixoss ci cloudbees com job RxJava pull requests 938 FAILURE Looks like there s a problem with this pull request The unit tests passed that were failing previously build is timing out on Quasar tests for some reason though they work on our other build servers and locally RxJava pull requests #940 https netflixoss ci cloudbees com job RxJava pull requests 940 ABORTED',RxJava,true,false,false
30662064,'Delay Operator Non Deterministic','It appears that delay is non deterministic in how it schedules work java return group delay 100 TimeUnit MILLISECONDS map new Func1 Integer Integer public Integer call Integer t System out println t return t 10 I see this type of output 76 78 86 92 74 94 62 98 90 88 96 82 84 80 It is expected to be ordered 82 84 86 88 90 92 94 96 98','When this gets fixed restore the OperatorGroupByTest testStaggeredCompletion unit test',RxJava,false,false,false
30665841,'Removed window between the two synchronized blocks','In the original version there was a window between finding a null queue and setting emitting false due to being in different synchronized block If another thread came in this window it created a new queue with its event which was not emitted until another onXXX method was called causing unnecessary event delivery delay While running the tests the SerializedObserverTest testNotificationDelay failed from time to time due to thread timing I haven t fixed this test','RxJava pull requests #939 https netflixoss ci cloudbees com job RxJava pull requests 939 ABORTED Strange contrib quasar tests pass in timely manner on my local machine Thanks for this looks good Benchmarks suggest no meaningful change which is good as this should have been a change for a case not covered in these tests Benchmark size Mode Samples Mean Mean error Units r o OperatorSerializePerf noSerializationSingleThreaded 1024 avgt 5 45 329 1 851 ns op r o OperatorSerializePerf noSerializationSingleThreaded 1048576 avgt 5 57 587 3 061 ns op r o OperatorSerializePerf serializedSingleStream 1024 avgt 5 67 744 2 928 ns op r o OperatorSerializePerf serializedSingleStream 1048576 avgt 5 73 889 2 139 ns op r o OperatorSerializePerf synchronizedSingleStream 1024 avgt 5 72 970 3 083 ns op r o OperatorSerializePerf synchronizedSingleStream 1048576 avgt 5 76 640 1 677 ns op compared with 0 17 3 Benchmark size Mode Samples Mean Mean error Units r operators OperatorSerializePerf noSerializationSingleThreaded 1024 avgt 5 45 504 1 710 ns op r operators OperatorSerializePerf noSerializationSingleThreaded 1048576 avgt 5 58 600 5 647 ns op r operators OperatorSerializePerf serializedSingleStream 1024 avgt 5 68 610 4 596 ns op r operators OperatorSerializePerf serializedSingleStream 1048576 avgt 5 71 313 2 318 ns op r operators OperatorSerializePerf synchronizedSingleStream 1024 avgt 5 73 322 3 666 ns op r operators OperatorSerializePerf synchronizedSingleStream 1048576 avgt 5 76 518 1 355 ns op',RxJava,true,false,false
30669288,'scala PublishSubject is inaccessible','scala private scala object PublishSubject def apply T PublishSubject T new PublishSubject T rx subjects PublishSubject create T There s no way to create it I believe this object should be public','Publish subject is the default subject and can be accessed via rx lang scala Subject See https github com Netflix RxJava blob master language adaptors rxjava scala src main scala rx lang scala Subject scala Still what is the point of preventing access On April 12 2014 11 38 22 AM EEST Ross Lawley notifications@github com wrote Publish subject is the default subject and can be accessed via rx lang scala Subject See https github com Netflix RxJava blob master language adaptors rxjava scala src main scala rx lang scala Subject scala Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1013#issuecomment 40275240 Sent from my Android device with K 9 Mail Please excuse my brevity Access is not at all prevented just a different name leveraging the fact that Scala has traits in NET ISubject Subject in RxJava Subject PublishSubject in Scala Subject It is not prevented per se but is awfully counterintuitive I looked up the appropriate subject type from github docs try to create it and can t while all the other type of subjects can be instantiated And I don t see how this serves any purpose Lets say PublishSubject can be instantiated via its object and not Subject object What is the downside of that The downside of current situation is that you get confused people like me I guess there should be an upside to that as well but I don t see it Could you point it out On April 12 2014 12 28 12 PM EEST headinthebox notifications@github com wrote Access is not at all prevented just a different name leveraging the fact that Scala has traits in NET ISubject Subject in RxJava Subject PublishSubject in Scala Subject Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1013#issuecomment 40276043 Sent from my Android device with K 9 Mail Please excuse my brevity One type instead of two Less is better Same for Subscriptions The fact that we are forced to call Subject PublishSubject in RxJava is just horrible Names are the most precious resource in designing APIs Ok it s your project so it s your call However the least that can be done is a comment in code and docs that in scala PublishSubject needs to be instantiated via Subject Do you agree On April 12 2014 12 54 37 PM EEST headinthebox notifications@github com wrote One type instead of two Less is better Same for Subscriptions The fact that we are forced to call Subject PublishSubject in RxJava is just horrible Names are the most precious resource in designing APIs Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1013#issuecomment 40276479 Sent from my Android device with K 9 Mail Please excuse my brevity Makes sense but IMHO ideally you should consider the Scala API by itself not mirroring it to the RxJava one Same for all other languages such as Rx NET RxJS What is called Foo there can be called Baz here Case in point Select map or Where filter or Subject PublishSubject Yes but I tried to find scala docs for subjects and couldn t find them If they exist they need better visibility Perhaps a link in the wiki near each section On April 12 2014 1 48 29 PM EEST headinthebox notifications@github com wrote Makes sense but IMHO ideally you should consider the Scala API by itself not mirroring it to the RxJava one Same for all other languages such as Rx NET RxJS What is called Foo there can be called Baz here Case in point Select map or Where filter or Subject PublishSubject Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1013#issuecomment 40277392 Sent from my Android device with K 9 Mail Please excuse my brevity I agree with @arturaz I didn t find anything that would imply that Subject PublishSubject I m not a Scala architecture expert so I can t provide much input in that respect all I can say is from a user standpoint it was a bit confusing seeing that all the other Subject s had public access while PublishSubject didn t I guess I could ve looked in the scala package instead of the scala subjects package Just my 0 02 Done in https github com Netflix RxJava pull 1216',RxJava,false,false,false
30748868,'Scheduler with Recurse Inner','API changes as per https github com Netflix RxJava issues 997 Usage looks like this java import java util concurrent TimeUnit import rx Scheduler Inner import rx Scheduler Recurse import rx functions Action1 import rx schedulers Schedulers public class Test public static void main String args Schedulers newThread schedule new Action1 Recurse @Override public void call Recurse inner System out println do stuff recurse inner schedule this Schedulers newThread schedule recurse System out println do stuff recurse schedule Schedulers newThread schedule recurse System out println do stuff recurse schedule 1000 TimeUnit MILLISECONDS Schedulers newThread schedule recurse recurse schedule re System out println do more stuff Inner inner Schedulers newThread createInner inner schedule re System out println do stuff re schedule r System out println do more stuff Code outline screen shot 2014 04 02 at 11 08 31 pm https cloud githubusercontent com assets 813492 2600101 6c680404 baf6 11e3 916e c41a817bc328 png','RxJava pull requests #941 https netflixoss ci cloudbees com job RxJava pull requests 941 ABORTED I would go for a combined Inner and Recurse scheduler by hiding the current inner action in a ThreadLocal variable Here https gist github com akarnokd 9950338 is an example Scheduler infrastructure and a NewThreadScheduler implemented like this I m not certain however that this ThreadLocal logic works for a TrampolineScheduler or TestScheduler The problem I ve had with combining them is that when first creating an Inner there is no Action to invoke Using the ThreadLocal to store the current action doesn t solve this it would just make it non obvious why inner schedule doesn t work the first time and the API would be odd that I can get an Inner with a schedule method even though nothing has been invoked yet The reason for this scenario is that retrieving an Inner via createInner is needed to make use cases like observeOn less awkward Here is the example where Inner is retrieved before an Action is executed in observeOn java protected void schedule if counter getAndIncrement 0 if recursiveScheduler null recursiveScheduler scheduler createInner add recursiveScheduler recursiveScheduler schedule new Action1 Recurse @Override public void call Recurse inner pollQueue The reason is that the recursion happens externally the operator is doing it rather than internally inside the Action Inner Action Recurse Therefore we have use cases where Inner is used before Recurse makes sense so the API is not appropriate when they are combined Now the solution is passing a scheduler to the user I just got an opposite idea Can we let the user tell us how to schedule For example java public class Scheduler public final Subscription schedule Func1 ScheduleAction ScheduleAction action public final Subscription schedule Func1 ScheduleAction ScheduleAction action final long delayTime final TimeUnit unit public final Subscription schedulePeriodically Func1 ScheduleAction ScheduleAction action long initialDelay long period TimeUnit unit public abstract Inner createInner for advanced use cases like observeOn public int degreeOfParallelism public long now public static final class ScheduleAction private static final none new ScheduleAction public static final ScheduleAction none return none public ScheduleAction Action1 Recurse action long initialDelay long period TimeUnit unit now mostly an implementation detail except for advanced use cases public abstract static class Inner implements Subscription public abstract void schedule ScheduleAction public long now public static void main String args Scheduler scheduler recursively schedule the current action scheduler schedule new Func1 ScheduleAction ScheduleAction public ScheduleAction call ScheduleAction action return action create a new ScheduleAction scheduler schedule new Func1 ScheduleAction ScheduleAction public ScheduleAction call ScheduleAction action return new ScheduleAction quit the recursive schedule process scheduler schedule new Func1 ScheduleAction ScheduleAction public ScheduleAction call ScheduleAction action return ScheduleAction none We send the current ScheduleAction to the user and the user needs to return a ScheduleAction to tell Scheduler how to schedule the next action What s more if we change ScheduleAction to ScheduleAction T to allow the user returns a T value via ScheduleAction that may be convenient in some situation @zsxwing I don t understand what the Func1 ScheduledAction ScheduledAction signature buys us as opposed to recurse which doesn t require the developer to create new Recurse or ScheduledAction types It seems more complicated that the Recurse method signatures Discussion of the signatures are continuing at https github com Netflix RxJava issues 997 Agreed I gave up the Func1 idea',RxJava,true,false,false
30792918,'Remove Redundant protectivelyWrap Method','','',RxJava,true,false,false
30804754,'API Design Review Subscriber add','In 0 17 we added Subscriber and it has an add Subscription s method on it I have found the most common question about the Subscriber change in 0 17 is how to handle Subscription logic and resource cleanup Many people tend to miss the add method and assume that only isUnsubscribe can be polled not realizing unsubscribe events can be registered via callback Should we rename the method to something such as addSubscription Subscription s or registerSubscription Subscription s so it is clearer Current signature java public abstract class Subscriber T implements Observer T Subscription public final void add Subscription s public final void unsubscribe public final boolean isUnsubscribed Possible changes java public abstract class Subscriber T implements Observer T Subscription public final void addSubscription Subscription s public final void unsubscribe public final boolean isUnsubscribed java public abstract class Subscriber T implements Observer T Subscription public final void registerSubscription Subscription s public final void unsubscribe public final boolean isUnsubscribed The reason we left is as add is that due to the argument it felt redundant to say addSubscription Subscription s when the argument type already describes it as add Subscription s I want to make sure we all agree on this even if we leave it as is before we hit 1 0','Perhaps add a method to Subscriber addOnUnsubscribeListener Action0 This just wraps the action in a subscription and adds it It makes it clear what the intent of the action is I think it is fine as is Instead of making the API all weird we should record this in the docs One option might be to make Subscriber implement Collection Subscription Anyone else have opinions on this @jhusain brought up a different perspective on this His point was that it s a bad API to have the mutable add on Subscriber and it would be better to make operator implementations decorate the Subscriber and intercept the unsubscribe if they are interested in the event This would mean operators that want to register a callback could instead call a factory such as Subscriber create Subscriber b Subscription p that would decorate the unsubscribe method with something like java void unsubscribe p unsubscribe actual unsubscribe This would be a cleaner and purer public API on Subscriber as it wouldn t have the CompositeSubscription add style behavior baked into it It would require 1 extra object allocation per Operator that needs a subscription callback cc @headinthebox Mmm not sure I buy this IMHO it is pretty intuitive that you have a collection of subscriptions to which you can add things While I do like immutable collections in certain cases i e when you want to accumulate stuff and hand off snapshots in the interim the fact that collections of subscriptions are mutable like regular Java lists never was an issue in the use cases for composite subscriptions where inside an operator you add several subscriptions and return the composite So I would go for the conservative approach of sticking to the normal collection paradigm Let s not try to mix metaphors A common use case I considered last night that would not work with @jhusain s proposed change is a Subscriber calling unsubscribe on itself such as take https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorTake java#L84 and this is a deal breaker for me It wouldn t work because the invocation of unsubscribe is happening inside the object not on the wrapped version Yeah just realizing that I m relying on dynamic inheritance for this scenario which is commonplace in JavaScript but not really practical in Java After various discussions we are going to leave things as they are',RxJava,false,false,false
30820742,'toList should return an empty list and not null','This is the behavior I was expecting but was surprised when it returned me a null and tanked the code that tried to use the list Hmmm wrote a test expecting a failure but it passes java @Test public void toList_shouldNotReturnNull TestSubscriber List Integer testSubscriber new TestSubscriber List Integer List Integer in null Observable from in toList subscribe testSubscriber List List Integer list testSubscriber getOnNextEvents assertThat list isNotNull Not quite sure how to repro I dug into this and I think the TestSubscriber is the reason the test passes while actual behavior is that it will pass a null back If you look at TestSubscriber getOnNextEvents it uses TestObserver getOnNextEvents which uses Collections unmodifiableList to return the events','I don t see how it would ever return a null with this code java public final class OperatorToObservableList T implements Operator List T T @Override public Subscriber super T call final Subscriber super List T o return new Subscriber T o final List T list new ArrayList T @Override public void onCompleted try o onNext new ArrayList T list o onCompleted catch Throwable e onError e @Override public void onError Throwable e o onError e @Override public void onNext T value list add value In this operator implementation note how it always has a List and emits it in onComplete The list it returns can include a null as null is a valid value but the list itself can t be null java @Test public void testListWithNullValue Observable String w Observable from Arrays asList one null three Observable List String observable w lift new OperatorToObservableList String @SuppressWarnings unchecked Observer List String observer mock Observer class observable subscribe observer verify observer times 1 onNext Arrays asList one null three verify observer Mockito never onError any Throwable class verify observer times 1 onCompleted This is an empty list java @Test public void testEmpty List Integer l Observable Integer empty toList toBlockingObservable last assertNotNull l assertTrue l isEmpty This has a single null value in the list java @Test public void testNullInList List Integer l Observable Integer just null toList toBlockingObservable last assertNotNull l assertNull l get 0 Closing out as no response @christopherperry if you can reproduce this against with a unit test please re open',RxJava,false,false,false
30871899,'retry never unsubscribes from source until operator completes','The retry operator re subscribes to the source Observable if a retry is attempted however it never unsubscribes from the source for the previous attempt relying instead on the CompositeSubscription to cleanup when the operator completes This could cause problems esp with infinite retry operators I ve created a test possible fix to illustrate the problem but its perhaps not the cleanest fix https github com petermd RxJava commit f2b09138cd548f08d987571e20fb8783b94a60c0 The solution only applies for async Observables as with a sync Observable the error can occur before the Subscription has been returned so there is no obvious way to unsubscribe','Thank you for submitting a unit test and fix I pulled in your code and modified it somewhat to use SerialSubscription which is intended for this type of use case and merged https github com Netflix RxJava pull 1019 Ah figured there had to be a nicer way Thanks',RxJava,false,false,false
30878161,'Fix retry never unsubscribes from source until operator completes','This fixes https github com Netflix RxJava issues 1018 Thank you @petermd','RxJava pull requests #942 https netflixoss ci cloudbees com job RxJava pull requests 942 ABORTED',RxJava,true,false,false
30917775,'Upgrade Gradle wrapper for Android samples to Gradle 1 11','Android Studio 0 5 4 refuses to build with 1 10','RxJava pull requests #943 https netflixoss ci cloudbees com job RxJava pull requests 943 ABORTED There is a bug in our deploy process to Maven Central that is holding us back on Gradle 1 8 Can this wait another 4 8 weeks until we get the fix that allows us to move forward If not I ll have to downgrade to 1 8 every time I do a release then upgrade again Hey Ben the samples module is self contained and ships its own Gradle wrapper Its build is decoupled and triggered through an intermediary module android samples build wrapper that is part of the main build but that should be unaffected That said it should cause no harm to merge this Did you run into any issues I can double check Oh right I saw the change but didn t pay attention to it being only inside Android samples Sorry about that',RxJava,true,false,false
30934029,'OperatorWeakBinding to not use WeakReferences anymore','related issues https github com Netflix RxJava pull 1008 https github com Netflix RxJava issues 1006 https github com Netflix RxJava issues 979 I changed the samples to actually use bindActivity and bindFragment','RxJava pull requests #944 https netflixoss ci cloudbees com job RxJava pull requests 944 FAILURE Looks like there s a problem with this pull request @samueltardieu @tehmou @zsxwing @mironov nsk Could you guys check this out The discussion is in #1008 I think this is a good compromise the subscribers won t be garbage collected anymore before they are kept as a reference subscriptions will not be delivered if the component has been properly unsubscribed as documented subscriptions will not be delivered if the component has been freed or if the validator fails so they won t arrive if the component has been replaced by another I am in favor of applying it I like this I was already handling subscriptions in a superclass so the weak reference thing seemed unnecessary I d prefer it this way I followed both discussion #1008 and this one and for me this is still unclear @mttkay I was wondering if you don t mine telling if Implementation like this u2020 sample https github com JakeWharton u2020 blob master src main java com jakewharton u2020 ui gallery GalleryView java could leak If not the purpose of bindActivity and bindFragment Hi Nicolas ad u2020 I d have to look into the details but it looks as if he unsubscribes in onDetachedFromWindow If that means releasing the context then it won t leak ad bindActivity bindFragment There s two things here these two helper methods and the underlying operator The underlying operator binds an observable to a target object using a predicate releasing the reference to the target as soon as the predicate starts to fail The two helpers use this to bind observables to Activities and Fragments respectively More precisely bindActivity schedules the observable s notifications on the main UI thread and adds a check that unsubscribes listeners and prevents notifications from being forwarded as soon as the activity is about to get finished either by pressing back or by calling finish It s just a convenience method for calling observeOn AndroidObservable mainThread and checking manually in your observers whether the activity isFinishing bindFragment same just that the predicate here not only tests for the host activity not getting finished but also that the fragment is still attached It s just a safe guard in cases a notification arrives when the fragment has already been detached from the activity Since observers usually access views and other context related fields this would make them crash Does that make sense @mttkay thanks a lot for this detailed answer u2020 Just to be sure so unsubscribing releases any reference to the observer right In this sample the inner class Observer has a reference to the context via an adapter bindActivity bindFragment make sense So does this mean bindActivity and bindFragment effectively have the same behavior as the old fromFragment and fromActivity since we re no longer using WeakReferences Other than naming and using lift are there any advantages to bind over from So does this mean bindActivity and bindFragment effectively have the same behavior as the old fromFragment and fromActivity since we re no longer using WeakReferences No Actually the Observable returned by the old fromFragment and fromActivity can only be subscribed once @vinc3m1 on top of what @zsxwing said they also tighten the validation on fragments a bit since notifications generated while the activity is in the process of getting finished will not be forwarded anymore just an extra safety net I guess Agree @zsxwing on the naming aspect How about OperatorConditionalBinding Does that make sense other suggestions Ah thanks for the clarification @mttkay @zsxwing That single subscription thing should probably be documented right also OperatorConditionalBinding sounds good to me 1 1 OperatorConditionalBinding is good to me Looks like this is still in progress @mttkay please let me know when this is ready for merging RxJava pull requests #951 https netflixoss ci cloudbees com job RxJava pull requests 951 SUCCESS This pull request looks good @benjchristensen this is good to go RxJava pull requests #952 https netflixoss ci cloudbees com job RxJava pull requests 952 SUCCESS This pull request looks good Thanks @mttkay',RxJava,true,false,false
30997963,'Merging streams from Future based subscriptions fails for RxJava 0 17','Hi The merge operation fails for me starting from RxJava 0 17 I refactored to the new OnSubscribe idiom as follows public class ResponseOnSubscribe implements Observable OnSubscribe Response @Override public void call Subscriber super Response subscriber try Future Response f builder execute newAsyncHandler subscriber subscriber add Subscriptions from f catch IOException e throw Throwables propagate e https github com s urbaniak rxning blob master src main java org urbaniak ning ResponseOnSubscribe java As you see I add create a Subscription from a future and add it the the subscriber I also provide a convenience factory method to create an Observable public static Observable Response create final AsyncHttpClient BoundRequestBuilder builder return Observable create new ResponseOnSubscribe builder When I construct a merged Observable like so @Test public void testMerge AsyncHttpClient client new AsyncHttpClient Observable HttpResponseBodyPart obs1 NingObservable createChunked client prepareGet http www wikipedia org Observable HttpResponseBodyPart obs2 NingObservable createChunked client prepareGet http www google com Observable HttpResponseBodyPart bodies Observable merge obs1 obs2 bodies toBlockingObservable last I recognize the following behavior and exception java util concurrent CancellationException at com ning http client providers netty NettyResponseFuture cancel NettyResponseFuture java 177 at rx subscriptions Subscriptions 2 unsubscribe Subscriptions java 76 at rx subscriptions CompositeSubscription unsubscribeFromAll CompositeSubscription java 175 at rx subscriptions CompositeSubscription unsubscribe CompositeSubscription java 168 at rx Subscriber unsubscribe Subscriber java 59 at rx subscriptions CompositeSubscription remove CompositeSubscription java 138 at rx operators OperatorMerge 1 InnerObserver cleanup OperatorMerge java 103 at rx operators OperatorMerge 1 InnerObserver onCompleted OperatorMerge java 85 at org urbaniak ning ChunkedOnSubscribe 1 onCompleted ChunkedOnSubscribe java 47 at org urbaniak ning ChunkedOnSubscribe 1 onCompleted ChunkedOnSubscribe java 38 What happens imho is that CompositeSubscription java 168 prematurely unsubsribes from any streams that are not completed yet I recognized this behavior in my code starting from https github com Netflix RxJava issues 897 Am I missing something or is my assumption about the behavior of merge fundamentally wrong or do I use the 0 17 facilities in a wrong way Please find a minimal implementation at https github com s urbaniak rxning A mvn test will reveal the failing tests on the console Thanks for any pointers and thanks for this very great library Sergiusz','It will call unsubscribe on each Observable after it completes This is what merge is supposed to do but wasn t before 0 17 which is why you re just now seeing this in your code You can see the code here https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorMerge java#L100 and the issue that resulted in this change at https github com Netflix RxJava issues 897 Without this memory leaks can occur If you look at the code you ll see that it only calls unsubscribe when onComplete or onError is received by calling childSubscriptions remove this and unsubscribing only the currently terminated Observable not all others I think the problem is that your code is emitting a Response object that is tied to the Future and that it fails even if cancelled after having received a successful response An Observable can and should be unsubscribed as soon as it emits onError or onCompleted See section 4 3 of Rx Design Guidelines for more on this 4 3 Assume resources are cleaned up after an OnError or OnCompleted message Paragraph 4 1 states that no more messages should arrive after an OnError or OnCompleted message This makes it possible to cleanup any resource used by the subscription the moment an OnError or OnCompleted arrives Cleaning up resources immediately will make sure that any side effect occurs in a predictable fashion It also makes sure that the runtime can reclaim these resources Thus you should not emit anything to onNext that relies upon unsubscribe not having been called since you can t control the processing later in the sequence it can be delayed buffered rescheduled etc and should be pure data In this particular example just emit the value of the Response rather than Response itself and it should work Thanks a lot for your extensive answer and for taking your time I refactored my code to emit a String instead of the original Response object but observed still the very same behavior I was also aware of the Rx Design Guidelines and the design principle not to emit values that rely on possibly cleaned resources the Future in this case and did not see any references to the original Future in the Response object But you brought me on the right track by explaining the intended behavior of OperatorMerge and by looking at the stacktrace more carefully The cause of the problem is a side effect which became visible after the #897 optimizations What happens is the following Assuming you have two Streams 1 and 2 being merged together 1 Stream 1 completes 2 OperatorMerge unsubscribes from Stream 1 as per #897 earlier than in previous implementations 3 The unsubscription operation is delegated to calling cancel on the Future of Stream 1 4 Now unfortunately whenever you call cancel on the request Future the Apache ning library calls AsyncHandler#onThrowable with an instance of a j u c CancellationException as per https github com AsyncHttpClient async http client blob master providers netty src main java org asynchttpclient providers netty future NettyResponseFuture java#L168 5 The AsyncHandler#onThrowable callback propagates the CancellationException to Stream 1 s Observer by calling obs#onError Throwable 6 The underlying MergeOperator correctly propagates the thrown Exception and also finishes Stream 2 prematurely with an error My workaround unfortunately is to ignore a concrete CancellationException in the callback and abusing Exceptions for control flow @Override public void onThrowable Throwable t if t instanceof CancellationException obs onError t Am I reading that correctly that the Future always will emit an exception even if already successfully completed That is the behavior I am observing Here is the set of String messages gathered by a ConcurrentLinkedQueue replaying the stream of merged events without the instanceof check and Stream 1 ending before Stream 2 onNext Stream 2 onNext Stream 1 onNext Stream 1 onNext Stream 2 onNext Stream 2 onNext Stream 1 onNext Stream 2 onNext Stream 1 onNext Stream 2 onNext Stream 1 onNext Stream 2 onCompleted Stream 1 unsubscribe Stream 1 thus calling Future cancel onError Stream 1 received java util concurrent CancellationException because the Future was cancel ed and propagating to onError unsubscribe Stream 2 unsubscribed due to error To be more precise I observe this behavior if and only if one cancel s via unsubscribe a ning request Future that is already completed as is done in Observable#merge If one unsubscribes to a Future that has not completed yet i e by using Observable#take the CancellationException is not being emitted This behavior really is dependent on the library you use in my case ning I d suggest this is a bug with the Ning Future since it shouldn t do anything if cancel is called if it has already received a successful response Closing my issue as there is nothing to be done in RxJava',RxJava,false,false,false
31068973,'retry with onErrorResumeNext','Hi Guys found another bug that is critical from my point of view when using both retry and onErrorResumeNext combinators the original sequence is being consumed after error Example scala val brokenStream Observable interval 500 millis map randomBreak _ brokenStream retry retryCount 3 onErrorResumeNext Observable empty subscribe println _ In this example after 3 errors the subscriber switches to the alternative empty sequence correctly but the original brokenStream sequence is continued being consumed non stop It can easily be seen by writing a log inside the randomBreak function','I believe this is solved as of 0 18 3 when the operators were migrated to use lift I tried confirming with this code java import rx Observable import rx Subscriber import rx schedulers Schedulers public class TestRetryOnErrorResumeNext public static void main String args Observable Long o Observable create Subscriber super Long s long l 0 while s isUnsubscribed System out println Emitting l l s onNext l if l 10 s onError new RuntimeException forced failure break subscribeOn Schedulers computation o retry 3 onErrorResumeNext Observable empty subscribe System out println try Thread sleep 1000 catch InterruptedException e e printStackTrace If the issue still exists in 0 18 3 please re open this with a unit test Ah fix was in https github com Netflix RxJava pull 1027',RxJava,false,false,false
31103317,'possible problem with OperatorRetry and nested subscription','as reported on the Group https groups google com forum # topic rxjava Kz8NnlvRDkc there is a problem with OperatorRetry in combination with other operators i _think_ the issue might be because OperatorRetry re uses the child Subscriber inner CompositeSubscription causing it to be inadvertently completed so re subscribe fails https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorRetry java#L85 I ve added a test and the suggested fix just use a new Subscriber which does address the problem https github com petermd RxJava commit d9fef71f51a261dbe1ad78c2a9a42d2c9b1acb8b FYI Might also be related #1023','Thank you I think you are right I added some comments on your commit Could you send a RP Fixed in https github com Netflix RxJava pull 1027 Thanks @petermd',RxJava,false,false,false
31121205,'Concurrency issue in ReplaySubject','In our testing we ve seen a few ArrayIndexOutOfBoundsExceptions in the replay subject Observable OnError java lang IndexOutOfBoundsException Index 272 Size 272 at java util ArrayList rangeCheck ArrayList java 635 at java util ArrayList get ArrayList java 411 at rx subjects ReplaySubject replayObserverFromIndex ReplaySubject java 198 at rx subjects ReplaySubject access 000 ReplaySubject java 52 at rx subjects ReplaySubject 1 call ReplaySubject java 74 at rx subjects ReplaySubject 1 call ReplaySubject java 69 at rx subjects SubjectSubscriptionManager 1 call SubjectSubscriptionManager java 54 at rx subjects SubjectSubscriptionManager 1 call SubjectSubscriptionManager java 48','Since ArrayList s internal array and size fields are not volatile they may get out of sync for other threads Synchronizing over the history prevents concurrent reads so either we should use ReaderWriterLock or have a SerializedObserver FastList variant with volatile marked fields Found the issue we had overlapping onNext calls going to the replay subject Wrapping the observable side of the subject with serialized observer resolved the issue',RxJava,false,false,false
31121257,'Adding a unit test to demo a concurrency issue with Observer catchup on a ReplaySubject','For issue #1025','RxJava pull requests #945 https netflixoss ci cloudbees com job RxJava pull requests 945 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
31144519,'isolate subscriber used for retries cleanup tests','potential fix for #1024 there is an outstanding question see commit comments about whether its appropriate for the operator to use unsafeSubscribe given that it does not completely isolate the Subscriber from a badly behaved Observable','RxJava pull requests #946 https netflixoss ci cloudbees com job RxJava pull requests 946 FAILURE Looks like there s a problem with this pull request @benjchristensen can you clarify the usage of unsafeSubscribe I m also confused now Thank you It wouldn t have been getting SafeSubscriber before unsafeSubscribe anyways because this operator lives inside rx operator so the wrapping would have been skipped It would have had some extra try catch error handling in synchronous execution prior to the unsafeSubscribe change but that should be it The use of unsafeSubscribe leaves operators to ensure contracts are kept The SafeSubscriber should really only be used to wrap the user provided Subscriber or Observer at the very end because it has uber error handling calls execution hooks etc Some operators will definitely need to do special things like unsubscribing such as merge and retry but those would not have ever been happening since isInternalImplementation checks in Observable would have prevented these from being wrapped by SafeSubscriber before so any bugs found about this should have already existed Operators should just propagate errors or let them throw since the final SafeSubscriber or lift will handle them which is why unsafeSubscribe is as lightweight as it is I ll review this code and merge or modify if needed The fix is good thank you @petermd',RxJava,true,false,false
31176914,'0 17 5 isUnsubscribe regression','I am having an issue when upgrading from 0 17 4 to 0 17 5 I tried to reproduce the bug with a simple sample but weren t able to do so So I am sorry about the verbosity of the explanation below The issue is that my flatmapped background operation subscriber become prematurely unsubcribed Please find below the original code java couchsurfingServiceAPI getUser args userId flatMap new Func1 Response Observable extends User @Override public Observable extends User call Response response Observable User user Observable just RetrofitUtils fromJson gson response getBody User class if RetrofitUtils isStale response networkManager isConnectedOrConnecting return Observable concat user couchsurfingServiceAPI refreshUser args userId return user finallyDo new Action0 @Override public void call isLoadingSubject onNext false observeOn AndroidSchedulers mainThread My issue is that the concat operation run properly on the first Observable and for some reason the subscriber becomes unsubscribed which result in the following onNext finallyDo to never be executed I can reproduce the issue with the following dumb code java couchsurfingServiceAPI getUser args userId flatMap new Func1 Response Observable extends User @Override public Observable extends User call Response response return couchsurfingServiceAPI refreshUser args userId finallyDo new Action0 @Override public void call isLoadingSubject onNext false observeOn AndroidSchedulers mainThread Just reverting to 0 17 4 solves this issue','subscriber become prematurely unsubcribed Do you mean that the Observable can not be subscribed more than once or just the current subscriber become unsubcribed Does this happen with 0 17 6 I can t see anything obviously wrong in the flatMap just two minor things What are the observables returned by your API I haven t spent time to debug your example and compare the differences and it lacks sufficient detail to be run but on the surface it looks to me like couchsurfingServiceAPI could be reusing a single Subscription for each stream both the original getUser and each subsequent via refreshUser and that won t work I The contract is that when each streams emits onComplete or onError it will be unsubscribed Thus each refreshUser invocation will emit an Observable that is subscribed to by the underlying merge inside flatMap and when it completes it will be unsubscribed If the Subscription is shared it would also unsubscribe the parent getUser which would prevent an onComplete or onError from being propagated Please confirm that the Subscription on each Observable instance is unique @All thanks for looking a this issue @zsxwing the current subscriber become unsubcribed @akarnokd no 0 17 6 doesn t solve the issue @benjchristensen Not sure See below The following is the state of my investigation getUser and refreshUser implementations are from the Retrofit https github com square retrofit library If you look at the Retrofit implementation https github com square retrofit blob master retrofit src main java retrofit RestAdapter java#L240 you will see that they use different Subscriptions However I just discovered this morning that the issue seams to be happening only when Retrofit is configured in Mock mode See MockRestAdapter https github com square retrofit blob master retrofit mock src main java retrofit MockRestAdapter java which has a different Rx implementation See https github com square retrofit blob master retrofit mock src main java retrofit MockRestAdapter java#L538 I cannot investigate further right now I ll post any update when I come back to it The MockRestAdapter was changed as of May 8th Does this issue still exist If so can you help me understand what exactly I should be looking at I believe this was solved by upgrading to 0 19 in Retrofit https github com square retrofit blob master pom xml#L54',RxJava,false,false,false
31328932,'IndexOutOfBoundsException with ReplaySubject','Hi folks I m new to RxJava so let me know if I m doing something obvious wrong I need to defer the completion of my observables basically creating a observable passing it back to the consumer and eventually do something with it from a netty response I figured I need to use Subjects for this correct Once I get a response back from my server I call java subject onNext msg subject onCompleted And it seems to work most of the time but my log is also cluttered with something like this java lang IndexOutOfBoundsException Index 2 Size 2 at java util ArrayList rangeCheck ArrayList java 635 at java util ArrayList get ArrayList java 411 at rx subjects ReplaySubject replayObserverFromIndex ReplaySubject java 198 at rx subjects ReplaySubject replayObserver ReplaySubject java 189 at rx subjects ReplaySubject caughtUp ReplaySubject java 178 at rx subjects ReplaySubject onNext ReplaySubject java 162 Sometimes index and size are 2 sometimes 1 Here is the testing code how I make use of it simplified java for long l 0 true l request ReplaySubject Object ob ReplaySubject create kick the stuff towards the network passing along the actual request and my observable producer onData request ob wait on the latch for fun before moving to the next one final CountDownLatch latch new CountDownLatch 1 ob subscribe new Action1 Object @Override public void call Object o latch countDown latch await Any ideas Cheers Michael','Btw I saw some other tickets which relate to using serialize on the observer where we subscribe but either I m doing it wrong or it doesn t solve the issue for me Hi Check if the ReplaySubject s onNext is not called from multiple threads You can manually wrap the ReplaySubject with SerializedObserver @akarnokd do you mean called from a different thread where it is created or that the onNext method is called more than once from different threads The first one is true since I signal the observable from inside the netty event loop while it was created outside in the main thread The latter is not because I call onNext only once and then immediately onCompleted afterwards Okay The exception java lang IndexOutOfBoundsException Index 2 Size 2 indicates that it received 2 notifications at some point but one of the thread s didn t observe the change in the internal buffer hence the exception I m not familiar with Netty but is it possible the event loop jumps threads That should never be the case no I now wrapped it but it seems to happen still java lang IndexOutOfBoundsException Index 1 Size 1 at java util ArrayList rangeCheck ArrayList java 635 at java util ArrayList get ArrayList java 411 at rx subjects ReplaySubject replayObserverFromIndex ReplaySubject java 198 at rx subjects ReplaySubject replayObserver ReplaySubject java 189 at rx subjects ReplaySubject caughtUp ReplaySubject java 178 at rx subjects ReplaySubject onNext ReplaySubject java 162 at rx observers SerializedObserver onNext SerializedObserver java 138 I basically did java SerializedObserver Object ser new SerializedObserver Object Observer observable ser onNext msg ser onCompleted One note to complete the picture further my subscriber is actually called because I never see the traffic stalling I guess if its never called it would wait forever and traffic would stall Could you try the following things In debug check the stacktrace which called latch countDown Delay the ob subscribe call a bit until you are sure the producer has produced the data @akarnokd ha I think I found it your first point brought me the epiphany It s true that one event loop is always on the same thread but I forgot that I m distributing the same op together with the same observable to all my channels for performance testing So 1 observable ended up in 3 different event loops I tried just using one thread for all of them it works Or I just need to make sure it only gets picked up by one socket then it s also fine I m closing this here since it doesn t appear to be a bug Cheers mate @akarnokd What do you think we should do about this The contract is then producers invoke onNext sequentially but I find people accidentally call subjects quite often from multiple threads I don t want to start synchronizing serializing as that goes against the Rx design of not adding synchronization unless it is requested but at the same time it would be good if we at least recognize when bad things happen and report with useful errors or handle concurrent access from subjects without paying a penalty when that doesn t happen First of all ReplaySubject should document explicitly that it can t be concurrently used as an Observer We could modify History next to check for the index mismatch java int s list size if s index get throw new ConcurrentModificationException list add v index incrementAndGet But I m not certain about its reliability',RxJava,false,false,false
31349389,'Benchmarking Add JMH benchmark for ReplaySubject','Adds some benches for the replay subject I E Benchmark nextRuns Mode Samples Mean Mean error Units r s ReplaySubjectPerf subscribeAfterEvents 1 thrpt 5 1898239 827 57634 047 ops s r s ReplaySubjectPerf subscribeAfterEvents 1024 thrpt 5 35680 927 470 929 ops s r s ReplaySubjectPerf subscribeAfterEvents 1048576 thrpt 5 32 427 1 462 ops s r s ReplaySubjectPerf subscribeBeforeEvents 1 thrpt 5 1427820 733 19194 452 ops s r s ReplaySubjectPerf subscribeBeforeEvents 1024 thrpt 5 36835 800 264 748 ops s r s ReplaySubjectPerf subscribeBeforeEvents 1048576 thrpt 5 35 520 1 145 ops s','RxJava pull requests #948 https netflixoss ci cloudbees com job RxJava pull requests 948 FAILURE Looks like there s a problem with this pull request Nice thank you',RxJava,true,false,false
31357098,'Fix NPE in SubjectSubscriptionManager','If unsubscribed it should just return not continue forward If it does the newState is null and it throws an NPE','',RxJava,true,false,false
31357809,'Scheduler with Schedulable EventLoop','API changes as per https github com Netflix RxJava issues 997','RxJava pull requests #949 https netflixoss ci cloudbees com job RxJava pull requests 949 FAILURE Looks like there s a problem with this pull request Whoops my refactor didn t include Scala I ll have to update that',RxJava,true,false,false
31371696,'Manual Merge #1027','While reviewing #1027 I added another unit test to understand the issue Fix by @petermd is good','RxJava pull requests #950 https netflixoss ci cloudbees com job RxJava pull requests 950 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
31377582,'How to extend Rx Subjects','I want to create my own subject similar to BehaviorSubject but with sync method to get last value Look like all classes are internal and it s very hard to extend or create own implementation of Subject T Any advice what base classes I should use for creating my custom subjects','Currently implemented it this way java public final class ReactiveProperty T extends Subject T T private BehaviorSubject T subject private T value public static T ReactiveProperty T create T value final BehaviorSubject T subject BehaviorSubject create value OnSubscribe T onSubscribe new OnSubscribe T @Override public void call Subscriber super T subscriber subject subscribe subscriber return new ReactiveProperty T onSubscribe subject value protected ReactiveProperty OnSubscribe T onSubscribe BehaviorSubject T subject T value super onSubscribe this subject subject this value value public T get return value @Override public void onCompleted subject onCompleted @Override public void onError Throwable e subject onError e @Override public void onNext T newValue if newValue equals value value newValue subject onNext newValue I have kept SubjectSubscriptionManager private as I don t trust its public API Evidence of this is shown here https github com Netflix RxJava pull 1040 It s also very complicated to use so I don t think I ever want to expose it as part of the public API The way you ve done it by building on top of an existing Subject is far easier @benjchristensen if my implementation is the way to do it i will close this issue I think it s a good approach using the basic Subject implementations as building blocks and not trying to recreate the subscription management stuff Unless a use case shows up that can t be done this way let s stick with this',RxJava,false,false,false
31448927,'Scala cleanup','Review by @headinthebox and @samuelgruetter','RxJava pull requests #953 https netflixoss ci cloudbees com job RxJava pull requests 953 SUCCESS This pull request looks good Does this code still work with older Scala versions where SI 7818 https issues scala lang org browse SI 7818 is not yet fixed This change is local to rxjava scala and doesn t affect clients As long as we don t support cross building with the older scala versions we are ok On 14 Apr 2014 14 40 samuelgruetter notifications@github com wrote Does this code still work with older Scala versions where SI 7818 https issues scala lang org browse SI 7818 is not yet fixed Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 1035#issuecomment 40352810 True as long as But what if someone wants to build it with Scala 2 10 2 I d find it safer to keep these ascriptions for some time I m fine with that Can we formalize what level of backwards source compatibility we guarantee RxJava pull requests #955 https netflixoss ci cloudbees com job RxJava pull requests 955 SUCCESS This pull request looks good Also scaladoc mentions rx lang scala util Closing that I can t find Is scaladoc obsolete Yes that s obsolete fixes are welcome The whole rx lang scala util package was removed because it contained only Timestamped which was replaced by Tuple2 and Opening and Closing which were replaced by type parameters or Any Should this be merged Is it a breaking change Formally that is a breaking change However I don t expect many users to specify Closing type parameter explicitly Otherwise source compatibility is preserved RxJava pull requests #958 https netflixoss ci cloudbees com job RxJava pull requests 958 SUCCESS This pull request looks good Looks good to me Should have been done together with window',RxJava,true,false,false
31454927,'replaced FRP with RP in README title','Mentioning Functional Reactive Programming causes confusion and misconception I think it s better to simply stick with Reactive Programming','RxJava pull requests #954 https netflixoss ci cloudbees com job RxJava pull requests 954 FAILURE Looks like there s a problem with this pull request Well that s interesting This PR only removes one word from the README file Can you provide supporting reasoning on this I m likely fine with the change but please share your reasons and I m aware of the debate over behaviors FRAN etc and the inability of computer scientists to agree People argue over reactive programming too since all of these are generic words used for different things over the decades The original idea of Functional Reactive Programming FRP is to model differential equations in a functional language A rather simplified characterization of FRP is that it is a programming paradigm involving datatypes that represent continuous values typically over time The complete history past present and future of values has a first class representation in the FRP paradigm In contrast Rx concerns itself with Observable streams of asynchronous events which are time discrete Whereas in FRP one can ask for the value of some entity at a specific moment in time this is clearly not the case in Rx In other words streams in FRP model continuously varying values whereas streams in Rx are just collections then if needed at all I would distinguish discrete reactive programming from continuous reactive programming like you can have discrete random variables and continuous random variables anyway As far as the programming paradigm is concerned I think that the Rx approach is clearly a functional one On Mon Apr 14 2014 at 8 57 PM Georgi Khomeriki notifications@github com wrote The original idea of Functional Reactive Programming FRP is to model differential equations in a functional language A rather simplified characterization of FRP is that it is a programming paradigm involving datatypes that represent continuous values typically over time The complete history past present and future of values has a first class representation in the FRP paradigm In contrast Rx concerns itself with Observable streams of asynchronous events which are time discrete Whereas in FRP one can ask for the value of some entity at a specific moment in time this is clearly not the case in Rx In other words streams in FRP model continuously varying values whereas streams in Rx are just collections Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 1036#issuecomment 40404329 __ O reality goes far beyond imagination @GeorgiKhomeriki Thanks for your explanation and @LucDupAtGitHub for getting involved Fundamentally the problem I see is that very specific meanings were given to very generic words within a niche of the industry and now natural use of the same term by a broader audience is being declared as wrong If one takes async reactive programming and combines it with a functional programming style and gets functional reactive code suddenly you step on the niche definition otherwise known as FRP which is specifically identified with continuous values Thus if someone were to use reactive functional to describe Rx instead of functional reactive there would be no issues even though it s just an awkward reordering of the words The term reactive programming itself isn t very helpful either as imperative callback hell is also reactive programming It s actually similar to how object oriented programming means different things in different languages that claim to implement OO but each in their own style Therefore saying Rx is not functional reactive programming comes across as if one particular implementation of async programming say imperative listeners declared to others that they can t be reactive because they claimed the word Considering all of this and the fact that reactive programming is not itself descriptive enough what should reactive programming push based done with a functional style higher order functions avoidance of state and mutability composition etc be called I fully agree with Ben s arguments remember I wrote if needed at all almost implicitly meaning btw not as far as I am concerned in fact more generally it mostly makes more sense to slightly abuse common known vocabulary than to inventing your own vocabulary for example Try Z although it has a flatMap method is not really a monad it does not satisfy the monad laws but hey why would we not call it a monad in the informal way instead of inventing a new name which one ok Try Z can be turned into an applicative functor satisfying the applicative functor laws but afaik one of the goals of Try Z is to fail fast and not to fail slow and somehow accumulate error messages so let us stick to Functional Reactive Programming just my 2 cents Luc On Tue Apr 15 2014 at 12 32 AM Ben Christensen notifications@github com wrote @GeorgiKhomeriki https github com GeorgiKhomeriki Thanks for your explanation and @LucDupAtGitHub https github com LucDupAtGitHub for getting involved Fundamentally the problem I see is that very specific meanings were given to very generic words within a niche of the industry and now natural use of the same term by a broader audience is being declared as wrong If one takes async reactive programming and combines it with a functional programming style and gets functional reactive code suddenly you step on the niche definition otherwise known as FRP which is specifically identified with continuous values Thus if someone were to use reactive functional to describe Rx instead of functional reactive there would be no issues even though it s just an awkward reordering of the words The term reactive programming itself isn t very helpful either as imperative callback hell is also reactive programming It s actually similar to how object oriented programming means different things in different languages that claim to implement OO but each in their own style Therefore saying Rx is not functional reactive programming comes across as if one particular implementation of async programming say imperative listeners declared to others that they can t be reactive because they claimed the word Considering all of this and the fact that reactive programming is not itself descriptive enough what should reactive programming push based done with a functional style higher order functions avoidance of state and mutability composition etc be called Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 1036#issuecomment 40426315 __ O reality goes far beyond imagination From a historical perspective I would not say that Rx comes from a functional core the goal was to deal with asynchronous data streams like iterable but then push based One may even say Rx is rather imperative since it makes concurrency and time explicit using schedulers which generalize Java executors I carefully avoid mentioning the word FRP in the context of Rx because in the Haskell world it refers to a very specific semantic model of time varying values Absolutely nothing wrong with that but totally different from the design decisions behind Rx despite the fact that both systems have higher order functions like map and filter Comparing Rx and FRP is like comparing JavaScript and C While there are plenty of superficial correspondences both use curly braces and semicolons the semantics are vastly different Interestingly nobody seems to get confused between C and JavaScript but often people do get confused about what Rx offers when they hear the word FRP to describe it Unfortunately the word reactive is quickly losing its proper meaning like agile My original use of reactive is very precise and simple http en wikipedia org wiki Reactive_system A reactive system is a system that responds reacts to external events and matches precisely what an Observable T is I m going to change it to RxJava Reactive Extensions for the JVM since there is absolutely nothing anyone can complain about with that since Rx Reactive Extensions Hi sorry for slightly abusing this mailing list for an announcement I am responsible for the JVM languages track and also involved in the JavaSE track of Devoxx 2014 I would like to remind you that this is an important conference for which you can propose a talk 10 days left this one is for Ben Christensen Ben if you wish I propose you as an invited speaker thanks a lot Luc Duponcheel __ O reality goes far beyond imagination',RxJava,true,false,false
31540372,'javadoc style broken when build with jdk7','the jdk7 javadoc style does not match the javadocStyleSheet css in maven central repository when version 0 17 3 the jar was build by jdk7 and the javadoc style was broken','Until someone gets around to dealing with this a low priority unfortunately please use the hosted javadocs http netflix github io RxJava javadoc Replaced by https github com Netflix RxJava issues 1502',RxJava,false,false,false
31591374,'rxjava android parameterize OperatorViewClick by concrete view type','Parameterize OperatorViewClick observable to actual View type So actual view with it native type can be used So instead of Observable View imageClicks ViewObservable clicks imageView false imageClicks subscribe new Action1 View @Override public void call View view ImageView imageView ImageView view imageView setImageBitmap bitmap you can use Observable ImageView imageClicks ViewObservable clicks imageView false imageClicks subscribe new Action1 ImageView @Override public void call ImageView view view setImageBitmap bitmap','cc @mttkay for review as it is for Android Looks good to me',RxJava,true,false,false
31591852,'Published Javadoc is not current','It doesn t contain the rx functions package','I ll fix that simple oversight Now if someone could just fix Javadoc generation so it actually works on Java 6 7 8 all at the same time Why do you need to generate on all versions On Wed Apr 16 2014 at 8 01 AM Ben Christensen notifications@github com wrote I ll fix that simple oversight Now if someone could just fix Javadoc generation so it actually works on Java 6 7 8 all at the same time Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1039#issuecomment 40540003 It s updated http netflix github io RxJava javadoc I don t need to generate on all versions it s just that people have different JVMs on their machines or build servers and Javadoc breaks every single JVM release For example try building RxJava with Java 8 ScalaDoc prevents it You could conditionally disable the Gradle tasks based on the JVM version Oh really Mind telling me what incantation I have to do for that someTask onlyIf JavaVersion current java8Compatible While wearing a pink hat and jumping over a stick See http www gradle org docs current javadoc org gradle api JavaVersion html Thanks Unfortunately it doesn t help me fix the ScalaDoc issue at least not in my attempts rxjava scala benjchristensen gradlew build FAILURE Build failed with an exception Where Build file RxJavaFork language adaptors rxjava scala build gradle line 1 What went wrong A problem occurred evaluating root project rxjava scala Could not create task of type ScalaDoc Try Run with stacktrace option to get the stack trace Run with info or debug option to get more log output BUILD FAILED I tried the following ScalaDoc onlyIf JavaVersion current isJava7 scaladoc onlyIf JavaVersion current isJava7 tasks scaladoc onlyIf JavaVersion current isJava7 tasks ScalaDoc onlyIf JavaVersion current isJava7 The error is happening early during task creation Can you run with s please and provide the output rxjava scala benjchristensen gradlew build s FAILURE Build failed with an exception Where Build file Users benjchristensen development github RxJavaFork language adaptors rxjava scala build gradle line 1 What went wrong A problem occurred evaluating root project rxjava scala Could not create task of type ScalaDoc Try Run with info or debug option to get more log output Exception is org gradle api GradleScriptException A problem occurred evaluating root project rxjava scala at org gradle groovy scripts internal DefaultScriptRunnerFactory ScriptRunnerImpl run DefaultScriptRunnerFactory java 54 at org gradle configuration DefaultScriptPluginFactory ScriptPluginImpl apply DefaultScriptPluginFactory java 132 at org gradle configuration project BuildScriptProcessor execute BuildScriptProcessor java 38 at org gradle configuration project BuildScriptProcessor execute BuildScriptProcessor java 25 at org gradle configuration project ConfigureActionsProjectEvaluator evaluate ConfigureActionsProjectEvaluator java 34 at org gradle configuration project LifecycleProjectEvaluator evaluate LifecycleProjectEvaluator java 55 at org gradle api internal project AbstractProject evaluate AbstractProject java 468 at org gradle api internal project AbstractProject evaluate AbstractProject java 76 at org gradle configuration DefaultBuildConfigurer configure DefaultBuildConfigurer java 31 at org gradle initialization DefaultGradleLauncher doBuildStages DefaultGradleLauncher java 142 at org gradle initialization DefaultGradleLauncher doBuild DefaultGradleLauncher java 113 at org gradle initialization DefaultGradleLauncher run DefaultGradleLauncher java 81 at org gradle launcher exec InProcessBuildActionExecuter DefaultBuildController run InProcessBuildActionExecuter java 64 at org gradle launcher cli ExecuteBuildAction run ExecuteBuildAction java 33 at org gradle launcher cli ExecuteBuildAction run ExecuteBuildAction java 24 at org gradle launcher exec InProcessBuildActionExecuter execute InProcessBuildActionExecuter java 35 at org gradle launcher exec InProcessBuildActionExecuter execute InProcessBuildActionExecuter java 26 at org gradle launcher cli RunBuildAction run RunBuildAction java 50 at org gradle api internal Actions RunnableActionAdapter execute Actions java 171 at org gradle launcher cli CommandLineActionFactory ParseAndBuildAction execute CommandLineActionFactory java 201 at org gradle launcher cli CommandLineActionFactory ParseAndBuildAction execute CommandLineActionFactory java 174 at org gradle launcher cli CommandLineActionFactory WithLogging execute CommandLineActionFactory java 170 at org gradle launcher cli CommandLineActionFactory WithLogging execute CommandLineActionFactory java 139 at org gradle launcher cli ExceptionReportingAction execute ExceptionReportingAction java 33 at org gradle launcher cli ExceptionReportingAction execute ExceptionReportingAction java 22 at org gradle launcher Main doAction Main java 46 at org gradle launcher bootstrap EntryPoint run EntryPoint java 45 at org gradle launcher Main main Main java 37 at org gradle launcher bootstrap ProcessBootstrap runNoExit ProcessBootstrap java 50 at org gradle launcher bootstrap ProcessBootstrap run ProcessBootstrap java 32 at org gradle launcher GradleMain main GradleMain java 23 at org gradle wrapper BootstrapMainStarter start BootstrapMainStarter java 33 at org gradle wrapper WrapperExecutor execute WrapperExecutor java 130 at org gradle wrapper GradleWrapperMain main GradleWrapperMain java 48 Caused by org gradle api tasks TaskInstantiationException Could not create task of type ScalaDoc at org gradle api internal project taskfactory TaskFactory 1 call TaskFactory java 126 at org gradle api internal project taskfactory TaskFactory 1 call TaskFactory java 121 at org gradle api internal AbstractTask injectIntoNewInstance AbstractTask java 142 at org gradle api internal project taskfactory TaskFactory createTaskObject TaskFactory java 121 at org gradle api internal project taskfactory TaskFactory createTask TaskFactory java 81 at org gradle api internal project taskfactory AnnotationProcessingTaskFactory createTask AnnotationProcessingTaskFactory java 99 at org gradle api internal project taskfactory DependencyAutoWireTaskFactory createTask DependencyAutoWireTaskFactory java 39 at org gradle api internal tasks DefaultTaskContainer create DefaultTaskContainer java 52 at org gradle api internal tasks DefaultTaskContainer create DefaultTaskContainer java 85 at org gradle api tasks TaskContainer create 0 call Unknown Source at org gradle api plugins scala ScalaPlugin configureScaladoc ScalaPlugin groovy 40 at org gradle api plugins scala ScalaPlugin this 2 configureScaladoc ScalaPlugin groovy at org gradle api plugins scala ScalaPlugin this 2 configureScaladoc callCurrent Unknown Source at org gradle api plugins scala ScalaPlugin apply ScalaPlugin groovy 32 at org gradle api plugins scala ScalaPlugin apply ScalaPlugin groovy at org gradle api internal plugins DefaultPluginContainer providePlugin DefaultPluginContainer java 104 at org gradle api internal plugins DefaultPluginContainer addPluginInternal DefaultPluginContainer java 68 at org gradle api internal plugins DefaultPluginContainer apply DefaultPluginContainer java 34 at org gradle api internal plugins DefaultObjectConfigurationAction applyPlugin DefaultObjectConfigurationAction java 101 at org gradle api internal plugins DefaultObjectConfigurationAction access 200 DefaultObjectConfigurationAction java 32 at org gradle api internal plugins DefaultObjectConfigurationAction 3 run DefaultObjectConfigurationAction java 72 at org gradle api internal plugins DefaultObjectConfigurationAction execute DefaultObjectConfigurationAction java 114 at org gradle api internal project AbstractPluginAware apply AbstractPluginAware java 39 at org gradle api Project apply call Unknown Source at org gradle api internal project ProjectScript apply ProjectScript groovy 34 at org gradle api Script apply callCurrent Unknown Source at build_6n23296erdvpb19ifuo1gvgnda run Users benjchristensen development github RxJavaFork language adaptors rxjava scala build gradle 1 at org gradle groovy scripts internal DefaultScriptRunnerFactory ScriptRunnerImpl run DefaultScriptRunnerFactory java 52 33 more Caused by java lang NullPointerException at org gradle api DefaultTask init DefaultTask java 33 at org gradle api internal ConventionTask init ConventionTask java 28 at org gradle api tasks SourceTask init SourceTask java 36 at org gradle api tasks scala ScalaDoc init ScalaDoc java 28 at org gradle api tasks scala ScalaDoc_Decorated init Unknown Source at org gradle api internal DependencyInjectingInstantiator newInstance DependencyInjectingInstantiator java 62 at org gradle api internal ClassGeneratorBackedInstantiator newInstance ClassGeneratorBackedInstantiator java 36 at org gradle api internal project taskfactory TaskFactory 1 call TaskFactory java 124 60 more BUILD FAILED Can I exclude that task This is for https github com Netflix RxJava blob master language adaptors rxjava scala build gradle This is http issues gradle org browse GRADLE 3023 @pniederw do you know of any workaround for this @alkemist I don t @benjchristensen looks like our Scala plugin is just busted on Java 8 I ll try and get this fixed for the next release I can t see any way to use ScalaDoc with Gradle and Java 8 Okay thanks',RxJava,false,false,false
31598757,'Merge and Cleanup of #972','@akarnokd I have manually merged your changes https github com Netflix RxJava pull 972 and migrated from Action1 to Action0 as we discussed Can you review what I did on top of your changes to make sure it s correct It seems correct to me but there is some nuanced concurrency here obviously hence your fixes and I would appreciate your validation','RxJava pull requests #956 https netflixoss ci cloudbees com job RxJava pull requests 956 SUCCESS This pull request looks good The changes look fine Great thanks for the review Going to merge and release I really appreciate your involvement on this one thank you',RxJava,true,false,false
31600005,'Allow global strategy for dealing with OnErrorNotImplementedException','It would be very useful to be able to provide a strategy to deal with this via the plugin mechanism In my case I d want to wrap the cause of this exception in another exception and rethrow I can imagine the following cases 1 Log the exception and rethrow i e I _only_ want to log unhandled exceptions 2 Action the exception and don t rethrow 3 Translate the exception to something else I d be happy to take a shot at adding this','Sounds reasonable Perhaps the RxJavaErrorHandler can be changed to meet these needs as I d rather not have 2 different plugins for handling errors We can incorporate it into 0 18 or 0 19 Right now we have public void handleError Throwable e but perhaps that just needs to return Throwable to allow decorating Here s another plugin for error handling that has worked well https github com Netflix Hystrix blob master hystrix core src main java com netflix hystrix strategy executionhook HystrixCommandExecutionHook java#L98 The more powerful plugin though is RxJavaObservableExecutionHook Between onCreate and onLift you can decorate every step of an Observable sequence and intercept all onError invocations This may be another area for you to look at that doesn t need API changes to RxJava just an implementation from your end we use the onCreate one for some fairly creative things in our production environment If something is added it should be to RxJavaErrorHandler yes handleError doesn t quite work because it doesn t differentiate between normal errors and OnErrorNotImplemented Will look into RxJavaObservableExecutionHook and report back I think I worked it out https github com ratpack ratpack blob master ratpack rx src main java ratpack rx RxRatpack java#L39 This seems to work for my simple tests but I m not RxJava guru enough to know when this isn t going to be enough I think this ticket can be closed',RxJava,false,false,false
31606563,'Kotlin M7 and full compatibility with 0 17 0','','RxJava pull requests #957 https netflixoss ci cloudbees com job RxJava pull requests 957 SUCCESS This pull request looks good RxJava pull requests #959 https netflixoss ci cloudbees com job RxJava pull requests 959 FAILURE Looks like there s a problem with this pull request RxJava pull requests #960 https netflixoss ci cloudbees com job RxJava pull requests 960 SUCCESS This pull request looks good Thanks @MarioAriasC',RxJava,true,false,false
31639862,'Reduce the scope of locking to increase parallelism','In my rxmon project https github com vigdorchik rxmon I make heavy use of combineLatest This change that reduces the scope of locking should help increase combineLatest throughput I wish I could report the speedup numbers but I couldn t find how to publish RxJava to maven locally to try it out','RxJava pull requests #961 https netflixoss ci cloudbees com job RxJava pull requests 961 FAILURE Looks like there s a problem with this pull request I saw this failure without my change and I believe it s unrelated On Wed Apr 16 2014 at 5 14 PM CloudBees pull request builder plugin notifications@github com wrote RxJava pull requests #961 https netflixoss ci cloudbees com job RxJava pull requests 961 FAILURE Looks like there s a problem with this pull request Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 1043#issuecomment 40596720 Review by @benjchristensen and @akarnokd I ll take a look sounds like a good change We have started doing perf testing using JMH You can take a look at examples here https github com Netflix RxJava tree master rxjava core src perf java rx operators It would be useful to add one for this operator to measure before after performance The change looks okay but not certain about the performance gains Two other things It would be great if you could rewrite it to the new Operator Subscriber idiom The original had a race condition between next and error you d need to wrap the incoming observer subscriber into a SerializedSubscriber This change doesn t work It allows onCompleted before all onNext have been triggered',RxJava,true,false,false
31726715,'Retry in Scala adaptor is ambiguous','The retry overload leads to ambiguities object Test extends App import rx scala lang _ null Observable String retry 3 both method retry in trait Observable of type rx lang scala Observable String and method retry in trait Observable of type retryCount Int rx lang scala Observable String match argument types Int null Observable String retry 3','The problem is that there are two interpretations for o retry 3 o retry retryCount Int or o retry apply 3 Maybe we should remove apply method from trait Observable considering it s likely to cause such ambiguities without careful attention cc @samuelgruetter Yes I d vote for removing def apply index Int Observable T since it s probably not used that often and elementAt is a better more explicit name Thanks @samuelgruetter for weighing in Based on the two of you agreeing I ll merge that change Agree with @samuelgruetter Closed as I believe the fix was merged',RxJava,false,false,false
31738376,'0 16 x Possible bug in Sample Observable operator','The Observable sample Observable operator behaves non intuitively at least to me Here is the javadoc description Return an Observable that emits the results of sampling the items emitted by the source Observable whenever the specified sampler Observable emits an item or completes Which I understand as The resulting Observable emits the current value of src for each value emitted by sampler repeating src last value if required in case sampler frequency src frequency But the current behavior as of 0 16 1 is When sampling a source Observable src using a sampler Observable the resulting Observable res always emits only once the last value of src even if sampler s frequency is superior to src s Code example val src Observable interval 1 TimeUnit SECONDS val sampler Observable interval 1 TimeUnit MILLISECONDS val res src sample sampler res subscribe aLong System out println aLong aLong Actual output aLong 0 aLong 1 aLong 2 aLong 3 aLong 4 Expected output aLong 0 thousand times aLong 1 thousand times aLong 2 thousand times aLong 3 thousand times aLong 4 thousand times Is my understanding of the javadoc wrong orcan we concider the current behavior as a bug Was it already reported and fixed in 0 17 Thanks for your hard work','Yes this is a bug Together with @headinthebox I also just found this out We found that the following Java code prints out infinite amounts of 3 s Java Observable concat Observable from 1 2 3 Observable never sample 1L TimeUnit SECONDS subscribe System out println The NET variant works correctly NET using System using System Reactive Linq namespace Playground class MainClass public static void Main string args var xs new 1 2 3 ToObservable Concat Observable Never int var ys xs Sample TimeSpan FromMilliseconds 10 ys Subscribe Console WriteLine e Console WriteLine e Message Console WriteLine Console ReadLine and only prints 3 once The marble diagram describes correctly the current behavior but seems to contradict the text description stating that a sample is taken whenever the specified sampler Observable emits an item or completes My current use case requires the behavior as defined in letter and is more intuitive to me If the current one is the expected one I guess the javadoc should be altered and a new operator override could be provided I haven t checked the rxnet behavior and the introtorx sample 0 only shows the case where sampler frequency src frequency 0 http www introtorx com content v1 0 10621 0 13_TimeShiftedSequences html#Sample @rvanheest Good to know you are looking into it guys If this is is indeed considered as a bug I thing the culprit lays at https github com Netflix RxJava blob master rxjava core src main java rx operators OperationSample java#L197 For some reason the code especially guards against sending the same source value twice using the valueTaken boolean It was a bit odd at the time but I think L197 does this value once thing correctly L85 https github com Netflix RxJava blame master rxjava core src main java rx operators OperationSample java#L85 does not clear the value flag hence it will repeat the last value indefinitely @akarnokd @DavidMGross Thanks for your quick answers and reaction The javadoc patch does indeed describe accurately the current behavior Still the emit value from source whenever sampler emits behavior could also prove useful would such a variant be considerable for inclusion We can get this fixed fairly easily in the next release it should not be emitting anything repeating the last value if nothing has been emitted in a given time window from the source This should be fixed as of 0 18 2 based on some basic testing I did Can someone confirm Yes I can confirm that this bug is fixed now When running the same program as shown above I now get 3 only printed once instead of over and over again Also while running other programs that used this method I noticed that the behavior is now correct Thanks for fixing it Java public class RxSampleTest public static void main String args throws IOException Observable concat Observable from 1 2 3 Observable never sample 1L TimeUnit SECONDS subscribe System out println System in read Thanks for confirming @rvanheest',RxJava,false,false,false
31778060,'0 16 1 onErrorReturn does not work without an onError subscription','Perhaps I am just misunderstanding the use case documentation here It seems that using onErrorReturn has no effect when subscribing with an onNext _unless I also subscribe an onError _ For example the Func1 in this pseudocode is not called on error so this does not work java public Observable Foo example1 Observable Foo observable createFooObservable observable subscribe new Action1 Foo return observable onErrorReturn new Func1 Throwable Foo But this does work as expected more or less by calling the Func1 as well as the Action1 Throwable when an error occurs java public Observable Foo example1 Observable Foo observable createFooObservable observable subscribe new Action1 Foo new Action1 Throwable return observable onErrorReturn new Func1 Throwable Foo Is this a bug or expected If it makes a difference my real observables from from Hystrix 1 3 13 I m primarily trying to understand if this is PEBKAC or not','In the first example without onError java observable subscribe new Action1 Foo The above code will throw OnErrorNotImplementedException So Func1 will not be called Can you clarify why you need to subscribe the observable in this method Maybe you just need doOnNext E g java public Observable Foo example1 Observable Foo observable createFooObservable return observable doOnNext new Action1 Foo onErrorReturn new Func1 Throwable Foo I don t see a doOnNext did you mean doOnEach I m not sure that I _need_ to subscribe Most of the documentation I read implied that subscribe was the correct way to register a success callback for each item emitted by an observable Is that not true When should subscribe be preferred over doOnEach I ll try doOnEach Your code is not connecting the chain java public Observable Foo example1 Observable Foo observable createFooObservable observable subscribe new Action1 Foo return observable onErrorReturn new Func1 Throwable Foo Note how you subscribe to observable and then afterwords you create a completely new observable with onErrorReturn and return that but you ve already subscribed to it The subscribe step is what actually kicks off the work java public Observable Foo example1 Observable Foo observable createFooObservable return observable onErrorReturn new Func1 Throwable Foo public void doStuff example1 subscribe new Action1 Foo Do that and now the subscribe is happening AFTER the onErrorReturn is put on the chain Thanks Ben I did try that combination but that leads to behavior that I don t want because onErrorReturn hides errors by replacing them with a value which looks successful If I subscribe to the observable returned by onErrorReturn then the Action1 runs even when an error occurred but that s not the flow I m trying to create Then why are you using onErrorReturn If you want to get the error pass in an error handler on subscribe If you don t pass in an error handler to subscribe it will throw OnErrorNotImplemented The onErrorReturn function is for handling errors like a try catch If you want to receive the error and blow up then subscribe with an error handler In the try catch analogy this is the logic I m going for java Foo foo try foo createFoo successHandler foo catch Throwable t errorHandler t foo DEFAULT_FOO_VALUE return foo Does that clarify my intent Try these java import rx Observable public class ErrorHandlingExample public static void main String args System out println default default error handling getStream subscribe ErrorHandlingExample successHandler ErrorHandlingExample errorHandler System out println onErrorReturn onErrorReturn getStream onErrorReturn ErrorHandlingExample errorHandler subscribe ErrorHandlingExample successHandler public static Observable Integer getStream return Observable from 1 2 3 1 4 5 map i if i 1 throw new RuntimeException injected failure else return i public static void successHandler int n System out println Success n public static int errorHandler Throwable t System out println Error t getMessage return 99 Note how the second allows handling the error and returning a default value I think the best way to translate the try catch statement would be using a combination of doOnComplete doOnError and onErrorReturn I think this code would give the expected behavior getObservable doOnComplete ErrorHandlingExample successHandling doOnError ErrorHandlingExample errorHandling onErrorReturn e DEFAULT_VALUE subscribe ErrorHandlingExample onNextHandling @benjchristensen that second example does not work for my case since the successHandler will print 99 onErrorReturn Success 1 Success 2 Success 3 Error injected failure Success 99 Whereas I would only want it to print 1 2 3 4 5 but be exposed as a stream 1 2 3 99 4 5 to other consumers The do methods are purely side effecting so if that s what is wanted by these handler methods then yes that s a great solution for doOnError The doOnComplete won t do anything there though since successHandling is expecting to receive int n and doOnComplete won t do that but doOnNext will whereas I would only want it to print 1 2 3 4 5 but be exposed as a stream 1 2 3 99 4 5 to other consumers So change how the handler works java getStream doOnNext ErrorHandlingExample successHandler doOnError ErrorHandlingExample errorHandler onErrorFlatMap e Observable from 99 subscribe ErrorHandlingExample otherStreams I also changed to using onErrorFlatMap since it looks like you want the stream to continue skip the error instead of just handle it and terminate The handlers receive this Success 1 Success 2 Success 3 Error injected failure Success 4 Success 5 The output stream gets this otherStreams 1 otherStreams 2 otherStreams 3 otherStreams 99 otherStreams 4 otherStreams 5 I m not sure I understand the reason for using onErrorFlatMap Is there any difference between java getStream doOnNext ErrorHandlingExample successHandler doOnError ErrorHandlingExample errorHandler onErrorFlatMap e Observable from 99 and java getStream doOnNext ErrorHandlingExample successHandler onErrorReturn ErrorHandlingExample errorHandler I do realize the second example here is very close to your original suggestion https github com Netflix RxJava issues 1046#issuecomment 40827524',RxJava,false,false,false
31782240,'Scheduler Simplification','API redesign simplification as per discussion at https github com Netflix RxJava issues 997 The Scheduler API in this pull request is java class Scheduler public abstract Inner Inner public int degreeOfParallelism public long now public abstract static class Inner implements Subscription public abstract Subscription schedule Action0 action long delayTime TimeUnit unit public abstract Subscription schedule Action0 action public final void schedulePeriodically Action0 action long initialDelay long period TimeUnit unit public long now While migrating to this I found a 4th use case in addition to the previously discussed 3 that required the schedule methods inside Inner to also return Subscription for canceling the individual tasks as opposed to the entire Inner Here are the use cases #### 1 Single Action java final Inner is scheduler inner is schedule new Action0 @Override public void call do work here is unsubscribe with lambda java final Inner is scheduler inner is schedule do work here is unsubscribe #### 2 Inner Recursion java final Inner is scheduler inner is schedule new Action0 @Override public void call do work here then recursively reschedule is schedule this this will NOT work with lambdas only anonymous inner classes is unsubscribe #### 3 Outer Recursion java final Inner is scheduler inner public void onNext T t is schedule new Action0 @Override public void call do work here is unsubscribe #### 4 Outer Recursion with Task Cancellation This is used for things like debounce and throttleLast where tasks are being scheduled and cancelled as onNext notifications are received java final Inner is scheduler inner SerialSubscription serial new SerialSubscription public void onNext T t schedule a new task and cancel previous if not yet executed serial set is schedule new Action0 @Override public void call do work here is unsubscribe','RxJava pull requests #962 https netflixoss ci cloudbees com job RxJava pull requests 962 SUCCESS This pull request looks good In ExecutorScheduler the innerSubscription is replaced if schedule is called multiple times for example with different delay values unsubscribing the inner cancels only the latest schedule Is this intentional No it s not intentional Thanks for seeing that The ExecutorScheduler really needs to be completely deleted though It breaks the contract by allowing concurrent execution I know of no good way to make it work without building event loops on top of the thread pools which defeats the purpose I m leaning heavily towards deleting ExecutorScheduler completely See https github com Netflix RxJava issues 713 and https github com Netflix RxJava issues 711 I will replace the computation scheduler with a pool of event loops Merging this don t want to conflate this PR with the one where I eliminate ExecutorScheduler',RxJava,true,false,false
31837189,'Remove ExecutorScheduler New ComputationScheduler','Removing ExecutorScheduler as it does not comply with the contract of sequential execution A Scheduler needs to guarantee sequential execution but putting work on a multi threaded thread pool allows concurrent execution See https github com Netflix RxJava issues 711 and https github com Netflix RxJava issues 713','RxJava pull requests #964 https netflixoss ci cloudbees com job RxJava pull requests 964 SUCCESS This pull request looks good',RxJava,true,false,false
31837554,'Move rx joins to rxjava joins module','Migrating rx joins into a separate contrib module as part of roadmap to 1 0 https github com Netflix RxJava issues 1001#issuecomment 40390984 This is being done until the rx joins API has further time to mature as it is likely to change and we can t make breaking changes any further once we hit 1 0','RxJava pull requests #965 https netflixoss ci cloudbees com job RxJava pull requests 965 FAILURE Looks like there s a problem with this pull request Non deterministic test rx operators OperatorPivotTest testConcurrencyAndSerialization',RxJava,true,false,false
31848107,'Reimplement the SkipLast operator','This PR did the following work Reimplemented the SkipLast operator to two different classes OperatorSkipLast and OperatorSkipLastWithTimed Fixed a bug in OperatorSkipLastWithTimed that when all elements are valid onCompleted will not be called The unit test is testSkipLastTimedWhenAllElementsAreValid','RxJava pull requests #966 https netflixoss ci cloudbees com job RxJava pull requests 966 FAILURE Looks like there s a problem with this pull request RxJava pull requests #967 https netflixoss ci cloudbees com job RxJava pull requests 967 SUCCESS This pull request looks good Updated to ArrayDeque NotificationLite Thank you @akarnokd and @benjchristensen RxJava pull requests #968 https netflixoss ci cloudbees com job RxJava pull requests 968 SUCCESS This pull request looks good RxJava pull requests #969 https netflixoss ci cloudbees com job RxJava pull requests 969 SUCCESS This pull request looks good',RxJava,true,false,false
31859548,'Manual Merge #967','Manually merge #967','',RxJava,true,false,false
31859947,'Scheduler Cleanup','ComputationScheduler EventLoopsScheduler Restoring parallel to using Schedulers computation','',RxJava,true,false,false
31860686,'Deprecation Cleanup','The time has come to delete the deprecated methods classes A few still remain to be done before 1 0 but can t be done until all operators are migrated Observable OnSubscribeFunc Observable create OnSubscribeFunc SafeObservableSubscription SafeObserver','Note that I removed the deprecation marker on the from and merge methods and left them as is based on https github com Netflix RxJava issues 992#issuecomment 38957463 RxJava pull requests #970 https netflixoss ci cloudbees com job RxJava pull requests 970 SUCCESS This pull request looks good',RxJava,true,false,false
31864675,'Missing Quasar instrumentation on Observable 2 call','https groups google com forum # topic quasar pulsar user bC94ftfcXtM','',RxJava,false,false,false
31864688,'close #1054','','RxJava pull requests #971 https netflixoss ci cloudbees com job RxJava pull requests 971 SUCCESS This pull request looks good',RxJava,true,false,false
31865348,'Add drop skip and dropRight skipLast to rxscala','','RxJava pull requests #972 https netflixoss ci cloudbees com job RxJava pull requests 972 SUCCESS This pull request looks good Please no dropRight This API is so incompatible with reactive model that I d relay it to the user to subscribe and aggregate what he wants rather than promoting this API to Observable Just my 2c though @vigdorchik What is your reason for this Rx has had this operator for a very long time called skipLast It is indeed not useful for infinite streams but there are several operators like that including concat and reduce that are useful when they fit the use case but useless when it s an infinite stream Not all operators are meant for all use cases Even the zip operator can be very problematic if misused combining slow and fast streams for example Ah ok My usecase was indeed infinite streams and I wasn t prepared for finite case If I were designing the API now I would suggest Future instead of Observable for finite case delegating to map on Lists but it s again just me Future instead of Observable for finite case That is not as simple as you think Which future to use And also Futures are hot so this can subtely change the order of side effects In other words xs DoSomeOperationThatReturnsASingleElement should not start processing unless you subscribe to it or if xs is already hot This discussion comes up every so often about letting the type communicate things like finite vs infinite and scalar vs vector It was discussed to some degree here https groups google com d topic rxjava MBtpYmUJauE discussion In Rx Net they have Task and Observable which work well together On the JVM there are many different Future implementations some great some not The java util concurrent Future is not usable so we would either have to create yet another Future like type that works with Observable can combine them etc or choose an implementation and make RxJava dependent on it not desirable Beyond this comes the more nuanced arguments of whether a scalar response which ultimately encompasses or could encompass finite streams that are aggregated down to a single response should be typed differently You can read the link above to see more on that and the compositional challenges it causes types get lost quickly when composing @headinthebox I see Futures don t capture subscription So it s not Future but is it a full blown Observable @benjchristensen Yes we could extract something make it composable and not call it Future I ll read the discussion to see what complications it causes Sorry guys for bringing up the old topic I should have read the discussions first Not a problem for bringing it up it s an interesting one and one that doesn t have a clear answer If you want to discuss it further either revive the mailing list thread or start a new Github Issue 1 Is it true that skipLast will cache all items until onCompleted as the new addition to the javadoc comments states It seems that it shouldn t have to do such extensive cacheing For skipLast n it should only need to cache n items for skipLast t only those items that have arrived during that time window On Mon Apr 21 2014 at 10 25 AM headinthebox notifications@github com wrote 1 Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 1056#issuecomment 40954851 David M Gross PLP Consulting I ve been thinking about the timed skipLast and it could emit old enough elements in onNext and thus freeing up the internal buffer @akarnokd Yes I think we only need to cache the items in the specified time window Please help review the new implementation #1065',RxJava,true,false,false
31866491,'Fix issue #1044','This PR eliminated the ambiguities described in #1044','RxJava pull requests #973 https netflixoss ci cloudbees com job RxJava pull requests 973 SUCCESS This pull request looks good RxJava pull requests #974 https netflixoss ci cloudbees com job RxJava pull requests 974 FAILURE Looks like there s a problem with this pull request RxJava pull requests #975 https netflixoss ci cloudbees com job RxJava pull requests 975 SUCCESS This pull request looks good',RxJava,true,false,false
31919598,'Typo in javadoc','','RxJava pull requests #976 https netflixoss ci cloudbees com job RxJava pull requests 976 SUCCESS This pull request looks good',RxJava,true,false,false
31947815,'How to hook to unsubscribe event','In previous version of RxJava Observable create returned Subscription object and it was possible to define unsubscribe method In new version of RxJava I can only check subscriber isUnsubscribed Is it somehow possible to implement unsubscribe for created observable or it s not compatible with new design','The Subscriber also has an void add Subscription method for registering an unsubscribe callback @abersnaze Thanks that helps It just not clear for me how i should implement isUnsubscribed My understanding is that it is set outside when subscription is used java subscriber add new Subscription @Override public void unsubscribe @Override public boolean isUnsubscribed dont know how i should implement this Try Subscriptions create final Action0 unsubscribe @zsxwing @abersnaze thanks a lot now finally got it',RxJava,false,false,false
31951404,'Operations to rewrite','Core All w lift Any w lift Exist and IsEmpty are built upon Any AsObservable w OnSubscribe Buffer w lift size time window skip observable boundary observable start end CombineLatest w OnSubscribe Concat w OnSubscribe Debounce w lift time window another observable DefaultIfEmpty w lift Defer w OnSubscribe Delay w lift DelaySubscribe w OnSubscribe DelayViaObservable w OnSubscribe Dematerialize w lift Distinct w lift regular custom equality comparator DistinctUntilChanged w lift FinallyDo w lift FlatMap w lift rename to MergeMap regular with iterator as sub collection MergeMapIterable GroupByUntil w lift GroupJoin w OnSubscribe Interval replace with Timer Join w OnSubscribe MergeDelayError w lift MergeMaxConcurrent w lift Multicast w OnSubscribe regular factory selector OnErrorResumeNextViaObservable w lift OnErrorReturn w lift OnExceptionResumeNextViaObservable w lift ParallelMerge just rename RefCount w OnSubscribe Replay w OnSubscribe Sample w lift time state sharing bug another Observable SequenceEquals just rename Skip w lift into OperatorSkipTimed SkipUntil w lift Switch w lift Take w lift count time TakeLast w lift count time TakeUntil w lift TakeWhile w lift remove indexed variant ThrottleFirst w lift TimeInterval w lift Timer w OnSubscribe ToMap w OnSubscribe ToMultimap w OnSubscribe ToObservableFuture w OnSubscribe Using w OnSubscribe Window w lift size time window skip observable boundary observable start end contrib string Optionally refactor operators into separate classes contrib async util StartFuture just rename OperationFromFunctionals InvokeAsync w OnSubscribe ForEachFuture just rename DeferFuture just rename contrib math Average w lift may keep current op composition int long float double w extractor function Min MinBy Max MaxBy w lift may keep current op composition Sum w lift may keep current op composition contrib computation expressions IfThen w OnSubscribe SwitchCase w OnSubscribe DoWhile WhileDo w OnSubscribe contrib joins When w OnSubscribe','I m working on Buffer but still have to hunt down some test failures Do we expect any of the following proposed operators to be revived chunkify deferCancellableFuture rxjava async doWhile forEachFuture BlockingObservable forIterable fromCancellableFuture rxjava async fromFuture generate generateAbsoluteTime ifThen startCancellableFuture rxjava async switchCase whileDo On Tue Apr 22 2014 at 7 50 AM akarnokd notifications@github com wrote I m working on Buffer but still have to hunt down some test failures Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1060#issuecomment 41049048 David M Gross PLP Consulting ifThen switchCase doWhile whileDo are in contrib computation expressions I m not sure about the CancelableFuture variants as they conceptionally didn t really work in Java i e attempt to mirror C# cancellation tokens chunkify generate generateAbsoluteTIme forIterable probably not While we are at it I have some trouble with buffer Func0 Observable variant I would expect the returned Observable to supply multiple absolute boundary events but the current implementation calls for a new Observable whenever a previous one fired an event causing an exponential explosion ChunkedOperation L515 https github com Netflix RxJava blob master rxjava core src main java rx operators ChunkedOperation java#L515 The reason seems to be to produce a relative windowing in the associated test method https github com Netflix RxJava blob master rxjava core src test java rx operators OperationBufferTest java#L272 Before we proceed please review what I wrote at https github com Netflix RxJava issues 1001#issuecomment 40970098 and let s agree upon the coding principles Do we expect any of the following proposed operators to be revived I doubt it Let s get the current operators as of 0 18 polished for 1 0 New operators or matured ones from the contrib modules can come over in 1 x releases if found to be commonly needed The only one not on the list I can think of needing to re add is the groupBy overload that takes a selector It was unceremoniously dropped a few releases ago when I did refactoring I skipped combineLatest as there was PR #1043 not long ago I wonder if @vigdorchik still wants to implement it @akarnokd sorry I m out of context here @zsxwing I ll do Window All done and merged',RxJava,false,false,false
31955857,OperatorAll,'Reimplemented All Issue #1060','RxJava pull requests #977 https netflixoss ci cloudbees com job RxJava pull requests 977 SUCCESS This pull request looks good',RxJava,true,false,false
31958201,OperatorAny,'Reimplemented Any aka IsEmpty and Exists Issue #1060','RxJava pull requests #978 https netflixoss ci cloudbees com job RxJava pull requests 978 SUCCESS This pull request looks good',RxJava,true,false,false
31959033,'Fix bugs in equals and hashCode of Timestamped','equals and hashCode of Timestamped are not correct I just used eclipse to generate a new one','RxJava pull requests #979 https netflixoss ci cloudbees com job RxJava pull requests 979 SUCCESS This pull request looks good',RxJava,true,false,false
31961934,'Operator AsObservable','Rewritten AsObservable Issue #1060','RxJava pull requests #980 https netflixoss ci cloudbees com job RxJava pull requests 980 SUCCESS This pull request looks good',RxJava,true,false,false
31970857,'Optimize OperatorSkipLastTimed','Changed OperatorSkipLastTimed to only cache the latest items in the specified time window','RxJava pull requests #981 https netflixoss ci cloudbees com job RxJava pull requests 981 SUCCESS This pull request looks good',RxJava,true,false,false
31986734,'CompositeSubscription fix','A bug in the remove method caused ArrayIndexOutOfBoundsException if the composite is not empty and trying to remove a subscription that is not in the composite at all','RxJava pull requests #982 https netflixoss ci cloudbees com job RxJava pull requests 982 SUCCESS This pull request looks good',RxJava,true,false,false
32013394,'Version 0 18 0','The release of 0 18 0 is nearly ready to go and includes Scheduler API changes https github com Netflix RxJava issues 997 Move of rx joins to separate module https github com Netflix RxJava pull 1049 Removal of most deprecated classes methods https github com Netflix RxJava pull 1053 Is there anything else that is a breaking change that we should get incorporated into 0 18 0 before releasing All further work towards 1 0 is listed at https github com Netflix RxJava issues 1001 The only known breaking changes still to come are the final removal of deprecated methods classes that weren t yet possible to remove','',RxJava,false,false,false
32031128,'add synchronous test of resubscribe after error','I ve added a simple synchronous test of resubscription after error Retry has had a chequered history of late and I think might benefit from extra tests The scenario is perhaps covered by the recent additions with #1027 but the test additions for that were async and more complex This simple scenario broke for versions to 0 16 1 to 0 17 4 hung with 0 17 5 and passes in 0 17 6','RxJava pull requests #983 https netflixoss ci cloudbees com job RxJava pull requests 983 SUCCESS This pull request looks good Thank you',RxJava,true,false,false
32031267,'Manual Merge of OperatorAll','','',RxJava,true,false,false
32031498,'Manual Merge of OperatorAny','','RxJava pull requests #984 https netflixoss ci cloudbees com job RxJava pull requests 984 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
32031658,'Manual Merge of AsObservable','','RxJava pull requests #985 https netflixoss ci cloudbees com job RxJava pull requests 985 SUCCESS This pull request looks good',RxJava,true,false,false
32032153,'Scheduler Inner Scheduler Worker','As per decision at https github com Netflix RxJava issues 997#issuecomment 40998613','',RxJava,true,false,false
32045629,OperatorBuffer,'Operator Buffer split into 4 variants Issue #1060 There are some important behavioral changes compared to the original versions When an onError event appears from anywhere the currently accumulated chunk s are NOT emitted before the error is propagated This conforms with Rx Design Guideline 6 6 The Observable returned by the Func0 inside the buffer Func0 Observable B now is used as long as possible and whenever it fires an event a new buffer chunk is started The Func0 is called only once per subscriber The original called it and subscribed to it all the time causing all increasing resubscriptions','RxJava pull requests #986 https netflixoss ci cloudbees com job RxJava pull requests 986 SUCCESS This pull request looks good',RxJava,true,false,false
32058918,OperatorConcat,'Operator Concat Issue #1060','RxJava pull requests #987 https netflixoss ci cloudbees com job RxJava pull requests 987 FAILURE Looks like there s a problem with this pull request RxJava pull requests #988 https netflixoss ci cloudbees com job RxJava pull requests 988 SUCCESS This pull request looks good I am merging despite having the question about serialization as that s an optimization question',RxJava,true,false,false
32069002,OperatorDebounce,'Operator Debounce Issue #1060 Two notes The behavior of the timed debounce has changed In the original if an onCompleted event arrived after an onNext event that last value was lost This new version emits the last value if it can then completes This is consistent with the selector based debounce operator from before and now In both overloads when the emission is run in parallel with the onCompleted of the main the last event might or might not reach the client subscriber one of the threads will grab the last value but the call to the client onCompleted might prevent the value delivery in the emission thread This couldn t happen in the original as the event emissions where performed under the lock as well We need to decide if we want to handle this corner case','RxJava pull requests #989 https netflixoss ci cloudbees com job RxJava pull requests 989 SUCCESS This pull request looks good when the emission is run in parallel with the onCompleted of the main It seems to me we should ensure delivery and thus let the onNext emit onCompleted after it s done if there s a race Okay I ll add the necessary queue drain logic tomorrow to fix that case Closing due to merge conflicts Will post a new PR',RxJava,true,false,false
32107906,'It is impossible to provide unsubscribe action','Observable create is deprecated and instead comment advises to use Observable apply https github com Netflix RxJava blob master language adaptors rxjava scala src main scala rx lang scala Observable scala#L2589 The problem is there is no way to supply unsubscribe action via apply function For example scala val sub Observable apply Int observer println created Subscription println Unsubscribed subscribe println _ e println error println complete1 readLine sub unsubscribe println complete readLine will never produce Unsubscribed string To make it worse replacing create with apply will compile and initialize subscription properly it is only unsubscribe will stop work If I have some resource created when subscribing thread or socket I d like to be able to shutdown it I do not see how it can be done if create is deprecated Also I could not find any unit test which would cover this use case Subscription unsubscribe actions are tested without integration with observable so possible error when unsubscribe is not called is missing','In the new API you need to use Subscriber add to add a Subscription E g scala val sub Observable apply Int subscriber println created subscriber add Subscription println Unsubscribed subscribe println _ e println error println complete1 Thanks @zsxwing this works well But I still think the comment in obsolete attribute should be corrected because I could not locate any hint how to use new API anywhere @zsxwing Is there a comment somewhere for us to remove I will add an example for the Subscriber API and update the comment Thanks Let me know when we can close this I thought we agreed to keep create with the old signature I thought we agreed to keep create with the old signature Yes I meant updating docs and more examples Please help review #1239 thanks Docs and example added so closing',RxJava,false,false,false
32114245,'A problem occurred evaluating project rxjava contrib rxjava quasar','Tried to compile the source using gradlew clean build Get those What went wrong A problem occurred evaluating project rxjava contrib rxjava quasar Could not resolve all dependencies for configuration rxjava contrib rxjava quasar quasar Could not download artifact com google guava guava 16 0 1@jar Artifact com google guava guava 16 0 1@jar not found','Looks like your local maven cache is corrupted You can see that the project is building here https github com Netflix RxJava#master build status Thank you maven cache corrupted is accurate Resolved after removing more than 20 versions of guava there',RxJava,false,false,false
32125271,'Notification should implement Serializable','This is a request to have Notification and its subclasses OnNext OnCompleted and OnError implement java s Serializable interface to e g feed an observable over the network or to persist it to disk See this link for an example http stackoverflow com questions 23250012 serializing rx java observable over the network I originally thought that this was the whole point of materialize and was surprised that Notification s didn t implement that interface Have I misunderstood this What is the purpose of the materialize method if not this','Materialize is not for serialization it is for treating all notification types including onError and onCompleted as events so they don t cause a terminal event It allows performing logic on errors and completions as if they are just normal onNext events We have no intention of implementing the java Serializable interface as the Java Serialization system is nothing but pain It is pretty trivial to convert the onNext onError onCompleted into network events such as using SSE It s the data that requires user intervention to serialize If you re interested in seeing one approach to serializing Observable s over the network take a look at this https github com Netflix RxNetty tree master rx netty remote observable',RxJava,false,false,false
32134963,OperatorCombineLatest,'Operator CombineLatest Issue #1060 Remarks Added an overload to Observable which accepts any number of sources Not sure why it wasn t exposed before Perhaps removed Relying on just the SO s onNext is not enough as leaving the synchronized block allows reordering of onNext calls Therefore the combinator uses the trick from SerializedObserver to make sure the combination order is consistent with whe winning of the synchronization race','RxJava pull requests #990 https netflixoss ci cloudbees com job RxJava pull requests 990 SUCCESS This pull request looks good',RxJava,true,false,false
32138592,OperatorDefaultIfEmpty,'Operator DefaultIfEmpty Issue #1060','RxJava pull requests #991 https netflixoss ci cloudbees com job RxJava pull requests 991 FAILURE Looks like there s a problem with this pull request The failures are unrelated I think but haven t commented on it here or the other cases',RxJava,true,false,false
32139509,OperatorDefer,'Operator Defer Issue #1060','RxJava pull requests #992 https netflixoss ci cloudbees com job RxJava pull requests 992 SUCCESS This pull request looks good',RxJava,true,false,false
32145037,OperatorDelay,'Operator Delay Issue #1060 I ve applied the same item delaying logic found in the timed delay to the selector based delay It looks elegant but adds a few extra layers layers and thus increases the per item delivery overhead','RxJava pull requests #993 https netflixoss ci cloudbees com job RxJava pull requests 993 SUCCESS This pull request looks good Isn t this simpler if we just use a scheduler inside an Operator The previous implementation seemed wrong to me it feels like it should just be this ignoring subscriptions in this pseudo code java public void onNext T t schedulerWorker schedule s onNext t delayTime delayUnit I ve noticed that in the original but since the Worker is stateful unsubscribing one would prevent any other clients from running scheduled work Therefore I create workers per child Subscribers instead of one per operator Edit sorry I misread your comment It would work until an onCompleted event is fired and the last onNext is still in the schedule Making sure the onCompleted is delayed is complicated I had implemented in the original selector version but when using the concat trick it will be emitted at the right time since both the source and the last single observable complete unsubscribing one would prevent any other clients from running scheduled work If the entire subscription is unsubscribed we want the worker to shut down Each Subscriber will have its own Scheduler Worker It s very similar to observeOn https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorObserveOn java#L69 just delayed instead of immediate Yes one Worker per Subscriber As for the simplified onNext you are proposing It would work until an onCompleted event is fired and the last onNext is still in the schedule Making sure the onCompleted is delayed is complicated I had implemented in the original selector version but when using the concat trick it will be emitted at the right time since both the source and the last single observable complete Hmmm if the onCompleted is also being scheduled wouldn t it be fine We could only delay onCompleted the same amount as every onNext which might be unwanted The second concern is that the worker might get unsubscribed right after the onCompleted got scheduled Got it So can we use the scheduler worker for onNext and then your concat trick for the onComplete The reason is that it seems overly complicated and heavy right now using a multicast ReplaySubject to handle this I ve been fiddling with this and came up with a less weighted version java Observable Observable T seqs observable map new Func1 T Observable T public Observable T call final T x final AsyncSubject T result AsyncSubject create scheduler createWorker schedule new Action0 @Override public void call result onNext x result onCompleted delay unit return result return Observable concat seqs We need the AsyncSubject because the x emission might happen before or after the concat subscribes to the observable representing the future x If it is still too heavy I could create an AsyncSubject variant that has simplified subscription management limited to one client the concat I was worried about the workers but they can be shared properly https gist github com akarnokd 11269808 I ll create a new PR due to the changes in master',RxJava,true,false,false
32147437,OperatorDematerialize,'Operator Dematerialize Issue #1060 Two notes Since the dematerialize is an instance method there is no correct type parametrization for the operator Therefore I just used a raw version in the call The original dematerialize could send out two onCompleted or an onError followed by an onCompleted because the materialize always adds an onCompleted after the raw events This affected operators due to unsafeSubscribe This new version ensures this doesn t happen','RxJava pull requests #994 https netflixoss ci cloudbees com job RxJava pull requests 994 SUCCESS This pull request looks good',RxJava,true,false,false
32149962,OperatorDistinct,'Operator Distinct Issue #1060 I didn t port the variant with the custom key comparator because it has been decided to rely on Object equals and there were not exposed anyway','RxJava pull requests #995 https netflixoss ci cloudbees com job RxJava pull requests 995 SUCCESS This pull request looks good',RxJava,true,false,false
32151784,OperatorDistinctUntilChanged,'Operator DistinctUntilChanged Issue #1060 Again I haven t ported the custom comparator version','RxJava pull requests #996 https netflixoss ci cloudbees com job RxJava pull requests 996 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
32152957,OperatorFinallyDo,'Operator FinallyDo Issue #1060','RxJava pull requests #997 https netflixoss ci cloudbees com job RxJava pull requests 997 SUCCESS This pull request looks good',RxJava,true,false,false
32157398,OperatorMergeMap,'Operator MergeMap namely the paired and the one which turns all event kinds into Observables to merge Issue #1060','RxJava pull requests #998 https netflixoss ci cloudbees com job RxJava pull requests 998 SUCCESS This pull request looks good',RxJava,true,false,false
32158693,OperatorToObservableFuture,'Also make the Observable be able to unsubscribe Issue #1060','RxJava pull requests #999 https netflixoss ci cloudbees com job RxJava pull requests 999 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
32186765,'Manual Merge of Several PRs','This was a manual merge since each of these was conflicting due to the changing import statements at the top I really wish Github allowed easily handling these','RxJava pull requests #1000 https netflixoss ci cloudbees com job RxJava pull requests 1000 FAILURE Looks like there s a problem with this pull request I was afraid of these conflicts to happen',RxJava,true,false,false
32202540,'Hangs from Unhandled Errors when Scheduling','I found a use case where the unsafeSubscribe combined with Scheduler since 0 17 5 can cause a hang in certain cases because a terminal event onError in this case never gets emitted Here is an example java inner schedule new Action0 @Override public void call o unsafeSubscribe subscriber In this case if the Observable being subscribed to throws an exception breaks the contract instead of using onError the Exception is completely swallowed because it s inside a Scheduler on another thread Here s a unit test demonstrating it java @Test public void testThrownErrorHandling TestSubscriber String ts new TestSubscriber String Observable create new OnSubscribe String @Override public void call Subscriber super String s throw new RuntimeException fail subscribeOn Schedulers computation subscribe ts ts awaitTerminalEvent 1000 TimeUnit MILLISECONDS ts assertTerminalEvent Because it s inside a Scheduler the catch all inside lift does not help this case There are two options as I see it 1 Make every use of unsafeSubscribe inside a Scheduler try catch onError 2 Make unsafeSubscribe just a tad safer for the broken contract case Option 1 is not great as all it takes is one mistaken place and we end up with code that hangs without any clue as to why Option 2 is simple no cost and solves it everywhere It does not defeat the reason for unsafeSubscribe as this will not involve SafeSubscriber plugin invocation or anything else that should only happen with subscribe The code will change from java public final Subscription unsafeSubscribe Subscriber super T subscriber onSubscribe call subscriber return subscriber to java public final Subscription unsafeSubscribe Subscriber super T subscriber try onSubscribe call subscriber catch Throwable e handle broken contracts subscriber onError e return subscriber','',RxJava,false,false,false
32202788,'Handle Thrown Errors with UnsafeSubscribe','oxymoronic commit here adding some safety to unsafeSubscribe fixes https github com Netflix RxJava issues 1090','',RxJava,true,false,false
32202797,'Restore ObservableExecutionHook onCreate','','RxJava pull requests #1002 https netflixoss ci cloudbees com job RxJava pull requests 1002 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
32210708,OperatorDelay,'Operator Delay rewritten and improved as discussed in #1082 For Issue #1060','RxJava pull requests #1003 https netflixoss ci cloudbees com job RxJava pull requests 1003 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1003 https netflixoss ci cloudbees com job RxJava pull requests 1003 FAILURE Looks like there s a problem with this pull request Outdated base',RxJava,true,false,false
32212343,'Operator debounce2','Operator Debounce again with improvements as discusssed in #1075 For Issue #1060','RxJava pull requests #1004 https netflixoss ci cloudbees com job RxJava pull requests 1004 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
32215102,OperatorGroupByUntil,'Operator GroupByUntil For Issue #1060 While rewriting I ve noticed a common pitfall with the observation of the duration many other operators react to onNext or onCompleted but one should only expire once I ll review my recent operators and post a separate PR if any','RxJava pull requests #1005 https netflixoss ci cloudbees com job RxJava pull requests 1005 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
32218966,OperatorGroupJoin,'Operator GroupJoin for Issue #1060 Maybe this could be moved to the new joins','RxJava pull requests #1006 https netflixoss ci cloudbees com job RxJava pull requests 1006 FAILURE Looks like there s a problem with this pull request Is this better associated with rxjava joins',RxJava,true,false,false
32232975,OperatorToMultimap,'Operator ToMultimap Issue #1060','RxJava pull requests #1007 https netflixoss ci cloudbees com job RxJava pull requests 1007 SUCCESS This pull request looks good RxJava pull requests #1009 https netflixoss ci cloudbees com job RxJava pull requests 1009 SUCCESS This pull request looks good',RxJava,true,false,false
32233828,OperatorTimerAndSample,'Operator Timer and Sample Because there was a dependency in Sample towards the now removed Interval I had to reimplement Sample in this PR as well Note that the new OperatorSampleWithTime schedules its first sample call before any upstream code is executed Given the TestScheduler a sample with 1sec and a timer with 1sec as well won t sample any value The reason is that in the internal queue of TestScheduler the sampler s action to take the sample is followed by the action to emit the timer s value','RxJava pull requests #1008 https netflixoss ci cloudbees com job RxJava pull requests 1008 SUCCESS This pull request looks good',RxJava,true,false,false
32235879,OperatorToMap,'Operator ToMap Issue #1060','RxJava pull requests #1010 https netflixoss ci cloudbees com job RxJava pull requests 1010 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
32238285,OperatorUsing,'Operator Using Issue #1060','RxJava pull requests #1011 https netflixoss ci cloudbees com job RxJava pull requests 1011 SUCCESS This pull request looks good RxJava pull requests #1021 https netflixoss ci cloudbees com job RxJava pull requests 1021 SUCCESS This pull request looks good',RxJava,true,false,false
32239032,'Operator async','contrib async util mostly renames deprecated api removed file comment fixed Sidenote for me NetBeans 8 0 editor shows errors in all the files unable to find rxjava core classes Using build command from the menu works This is true for the other contrib packages as well Any tips on why','RxJava pull requests #1012 https netflixoss ci cloudbees com job RxJava pull requests 1012 SUCCESS This pull request looks good This is true for the other contrib packages as well Any tips on why In Eclipse this isn t happening The Gradle build files are configured for Eclipse and IDEA but not Netbeans so perhaps it s not creating the project files correctly for Netbeans I can t remember when I did the last contrib work but it worked back then I used Eclipse for the other PRs',RxJava,true,false,false
32242329,'rxjava android Poposal Call action immediately in HandlerThreadScheduler if thread is the same','By avoiding unnecessary Runnable creation and posting it to handler we can decrease overhead when scheduling is made from the same thread Current Activity runOnUIThread is implemented in the same way java public final void runOnUiThread Runnable action if Thread currentThread mUiThread mHandler post action else action run','RxJava pull requests #1013 https netflixoss ci cloudbees com job RxJava pull requests 1013 SUCCESS This pull request looks good This looks good to me but since I don t use Android can others who do comment on this cc @mttkay @zsxwing Looks good to me Great idea I was thinking to add this as well I wonder if it should be optional however sometimes you need to be sure to post a runnable if modifying certain view properties during a layout pass for example We have already a discussion here https github com Netflix RxJava pull 949 Activity runOnUIThread is only used in the non recursive case However for HandlerThreadScheduler we want to support both recursive and non recursive schedule Maybe adding an option to the HandlerThreadScheduler constructor to indicate if it supports recursive schedule But it would require the user learning the implementations of operators They needs to be aware of which operator will use recursive schedule I m not convinced by this idea Yes the main goal of this PR is to make mainThreadScheduler works like Activity runOnUIThread as in most cases it not require recursion On the other hand sometimes user may want to use HandlerThreadScheduler for recursive tasks and other long running tasks So may be it will be better to add option as @zsxwing suggest to constructor but leave existed constructor with single Handler argument as default recursive implementation so it will have the same behavior as now But make mainThreadScheduler non recursie by default So if the user do not want to worry about implementation he can use handlerThreadScheduler as before I remember there was a PR before which was pretty much the same @zsxwing can you elaborate on why it doesn t work with recursive scheduling In which cases do you use recursive scheduling Unless I m simply not aware of it I don t think I ever had the need for it on Android Maybe we can find a compromise because I generally agree that the extra roundtrip through the main looper is unnecessary overhead @mattkay the PR is #949 My comments are here https github com Netflix RxJava pull 949#issuecomment 37259805 and https github com Netflix RxJava pull 949#issuecomment 37290132 @mattkay and your comment https github com Netflix RxJava pull 949#issuecomment 37274257 How about this approach Use immediate way for mainThread by default Use usual one for default HandlerThreadScheduler RxJava pull requests #1052 https netflixoss ci cloudbees com job RxJava pull requests 1052 FAILURE Looks like there s a problem with this pull request @zsxwing Could you elaborate again on a case where you need recursive scheduling I m not sure I understand when it s useful I m afraid we use a very simple formulaic approach on Android which is putting something on a background thread and observing it on the main thread Is this used when rescheduling something as part of an observable transformation In any event I think we should get some numbers to back up that it actually improves performance We should measure what the exact performance gains are on at least a few devices and a varying numbers of events Could you elaborate again on a case where you need recursive scheduling Now looks only repeat and retry need recursive scheduling However if the count parameter is small StackOverflowError and Application Not Responding should not happen @Yarikx do you have some number to prove the performance improvement Maybe this is a premature optimization Sorry for delay @zsxwing ok I had some metrics before but i will try to make new ones Ok I check some metrics I don t sure that the measurement is done right but it s enough to make some assumptions All metrics was taken from Nexus S Not the fastest phone now but it s not the slowest ether So I created two instances of HandlerThreadScheduler let s call them immediate and recursive java Handler handler new Handler Scheduler immediate AndroidSchedulers handlerThread handler true Scheduler recursive AndroidSchedulers handlerThread handler false # The good part in this part i tested minimal delay for scheduling one item This action was made in button handler after Activity was created and all UI was initialized and Handler queue was empty java public void test View view Handler handler new Handler Scheduler immediate AndroidSchedulers handlerThread handler true Scheduler recursive AndroidSchedulers handlerThread handler false Observable from 1 timestamp observeOn immediate subscribe new Action1 Timestamped Integer @Override public void call Timestamped Integer timestamped long time System currentTimeMillis timestamped getTimestampMillis Log d Immediate time time Observable from 1 timestamp observeOn recursive subscribe new Action1 Timestamped Integer @Override public void call Timestamped Integer timestamped long time System currentTimeMillis timestamped getTimestampMillis Log d Recursive time time and the output after few button clicks 05 08 11 36 47 632 17468 17468 com example rxjavaperformancetest app D Immediate time 0 05 08 11 36 47 632 17468 17468 com example rxjavaperformancetest app D Recursive time 1 05 08 11 36 48 937 17468 17468 com example rxjavaperformancetest app D Immediate time 0 05 08 11 36 48 937 17468 17468 com example rxjavaperformancetest app D Recursive time 1 05 08 11 36 50 007 17468 17468 com example rxjavaperformancetest app D Immediate time 0 05 08 11 36 50 007 17468 17468 com example rxjavaperformancetest app D Recursive time 0 05 08 11 36 50 914 17468 17468 com example rxjavaperformancetest app D Immediate time 0 05 08 11 36 50 914 17468 17468 com example rxjavaperformancetest app D Recursive time 1 So actual gap between sending Runnable to Handler is not so much to worry about But this is very simple example as we can start to execute posted task right after button handler # The bad part Now let s try to process some sequence java public void test View view Handler handler new Handler Scheduler immediate AndroidSchedulers handlerThread handler true Scheduler recursive AndroidSchedulers handlerThread handler false Observable range 0 20 timestamp observeOn immediate subscribe new Action1 Timestamped Integer @Override public void call Timestamped Integer timestamped long time System currentTimeMillis timestamped getTimestampMillis Log d Immediate time time Observable range 0 20 timestamp observeOn recursive subscribe new Action1 Timestamped Integer @Override public void call Timestamped Integer timestamped long time System currentTimeMillis timestamped getTimestampMillis Log d Recursive time time And the test result 05 08 11 31 11 460 17324 17324 com example rxjavaperformancetest app D Immediate time 0 05 08 11 31 11 460 17324 17324 com example rxjavaperformancetest app D Immediate time 0 05 08 11 31 11 460 17324 17324 com example rxjavaperformancetest app D Immediate time 0 05 08 11 31 11 460 17324 17324 com example rxjavaperformancetest app D Immediate time 0 05 08 11 31 11 460 17324 17324 com example rxjavaperformancetest app D Immediate time 1 05 08 11 31 11 468 17324 17324 com example rxjavaperformancetest app D Immediate time 0 05 08 11 31 11 468 17324 17324 com example rxjavaperformancetest app D Immediate time 1 05 08 11 31 11 468 17324 17324 com example rxjavaperformancetest app D Immediate time 0 05 08 11 31 11 468 17324 17324 com example rxjavaperformancetest app D Immediate time 0 05 08 11 31 11 468 17324 17324 com example rxjavaperformancetest app D Immediate time 0 05 08 11 31 11 468 17324 17324 com example rxjavaperformancetest app D Immediate time 0 05 08 11 31 11 468 17324 17324 com example rxjavaperformancetest app D Immediate time 0 05 08 11 31 11 468 17324 17324 com example rxjavaperformancetest app D Immediate time 0 05 08 11 31 11 476 17324 17324 com example rxjavaperformancetest app D Immediate time 0 05 08 11 31 11 476 17324 17324 com example rxjavaperformancetest app D Immediate time 1 05 08 11 31 11 476 17324 17324 com example rxjavaperformancetest app D Immediate time 0 05 08 11 31 11 476 17324 17324 com example rxjavaperformancetest app D Immediate time 0 05 08 11 31 11 476 17324 17324 com example rxjavaperformancetest app D Immediate time 0 05 08 11 31 11 476 17324 17324 com example rxjavaperformancetest app D Immediate time 0 05 08 11 31 11 476 17324 17324 com example rxjavaperformancetest app D Immediate time 0 05 08 11 31 11 484 17324 17324 com example rxjavaperformancetest app D Recursive time 9 05 08 11 31 11 492 17324 17324 com example rxjavaperformancetest app D Recursive time 9 05 08 11 31 11 492 17324 17324 com example rxjavaperformancetest app D Recursive time 10 05 08 11 31 11 492 17324 17324 com example rxjavaperformancetest app D Recursive time 12 05 08 11 31 11 492 17324 17324 com example rxjavaperformancetest app D Recursive time 13 05 08 11 31 11 492 17324 17324 com example rxjavaperformancetest app D Recursive time 12 05 08 11 31 11 492 17324 17324 com example rxjavaperformancetest app D Recursive time 13 05 08 11 31 11 492 17324 17324 com example rxjavaperformancetest app D Recursive time 11 05 08 11 31 11 492 17324 17324 com example rxjavaperformancetest app D Recursive time 12 05 08 11 31 11 492 17324 17324 com example rxjavaperformancetest app D Recursive time 12 05 08 11 31 11 492 17324 17324 com example rxjavaperformancetest app D Recursive time 12 05 08 11 31 11 492 17324 17324 com example rxjavaperformancetest app D Recursive time 13 05 08 11 31 11 492 17324 17324 com example rxjavaperformancetest app D Recursive time 13 05 08 11 31 11 492 17324 17324 com example rxjavaperformancetest app D Recursive time 14 05 08 11 31 11 492 17324 17324 com example rxjavaperformancetest app D Recursive time 13 05 08 11 31 11 500 17324 17324 com example rxjavaperformancetest app D Recursive time 14 05 08 11 31 11 500 17324 17324 com example rxjavaperformancetest app D Recursive time 14 05 08 11 31 11 500 17324 17324 com example rxjavaperformancetest app D Recursive time 15 05 08 11 31 11 500 17324 17324 com example rxjavaperformancetest app D Recursive time 14 05 08 11 31 11 500 17324 17324 com example rxjavaperformancetest app D Recursive time 15 Now we see that first item processing on recursive scheduler start only after finishing current task emitting items to scheduler Actually in current example there is not so much work to do but in real apps there can be more UI related work so sequence observing will delay even more Another thing As we process each item in it s own Runnable we see that processing gap grows linearly as sequence grows because each item processing adds 0 5 2 ms # The ugly part Let s do last example but add few more layers of scheduling and we will run it on onCreate method to simulate case when user have some more work to do and when Handler queue is not empty java Observable range 0 20 timestamp observeOn immediate observeOn immediate observeOn immediate observeOn immediate observeOn immediate observeOn immediate observeOn immediate subscribe new Action1 Timestamped Integer @Override public void call Timestamped Integer timestamped long time System currentTimeMillis timestamped getTimestampMillis Log d Immediate time time Observable range 0 20 timestamp observeOn recursive observeOn recursive observeOn recursive observeOn recursive observeOn recursive observeOn recursive observeOn recursive subscribe new Action1 Timestamped Integer @Override public void call Timestamped Integer timestamped long time System currentTimeMillis timestamped getTimestampMillis Log d Recursive time time and the output 05 08 11 53 15 054 17896 17896 com example rxjavaperformancetest app D Immediate time 1 05 08 11 53 15 054 17896 17896 com example rxjavaperformancetest app D Immediate time 0 05 08 11 53 15 054 17896 17896 com example rxjavaperformancetest app D Immediate time 0 05 08 11 53 15 054 17896 17896 com example rxjavaperformancetest app D Immediate time 0 05 08 11 53 15 054 17896 17896 com example rxjavaperformancetest app D Immediate time 1 05 08 11 53 15 054 17896 17896 com example rxjavaperformancetest app D Immediate time 0 05 08 11 53 15 054 17896 17896 com example rxjavaperformancetest app D Immediate time 0 05 08 11 53 15 054 17896 17896 com example rxjavaperformancetest app D Immediate time 1 05 08 11 53 15 054 17896 17896 com example rxjavaperformancetest app D Immediate time 0 05 08 11 53 15 054 17896 17896 com example rxjavaperformancetest app D Immediate time 0 05 08 11 53 15 062 17896 17896 com example rxjavaperformancetest app D Immediate time 0 05 08 11 53 15 062 17896 17896 com example rxjavaperformancetest app D Immediate time 0 05 08 11 53 15 062 17896 17896 com example rxjavaperformancetest app D Immediate time 0 05 08 11 53 15 062 17896 17896 com example rxjavaperformancetest app D Immediate time 0 05 08 11 53 15 062 17896 17896 com example rxjavaperformancetest app D Immediate time 0 05 08 11 53 15 062 17896 17896 com example rxjavaperformancetest app D Immediate time 0 05 08 11 53 15 062 17896 17896 com example rxjavaperformancetest app D Immediate time 1 05 08 11 53 15 062 17896 17896 com example rxjavaperformancetest app D Immediate time 0 05 08 11 53 15 062 17896 17896 com example rxjavaperformancetest app D Immediate time 0 05 08 11 53 15 062 17896 17896 com example rxjavaperformancetest app D Immediate time 0 05 08 11 53 15 289 17896 17896 com example rxjavaperformancetest app D Recursive time 222 05 08 11 53 15 289 17896 17896 com example rxjavaperformancetest app D Recursive time 222 05 08 11 53 15 289 17896 17896 com example rxjavaperformancetest app D Recursive time 223 05 08 11 53 15 289 17896 17896 com example rxjavaperformancetest app D Recursive time 223 05 08 11 53 15 289 17896 17896 com example rxjavaperformancetest app D Recursive time 224 05 08 11 53 15 289 17896 17896 com example rxjavaperformancetest app D Recursive time 224 05 08 11 53 15 289 17896 17896 com example rxjavaperformancetest app D Recursive time 224 05 08 11 53 15 289 17896 17896 com example rxjavaperformancetest app D Recursive time 225 05 08 11 53 15 289 17896 17896 com example rxjavaperformancetest app D Recursive time 225 05 08 11 53 15 289 17896 17896 com example rxjavaperformancetest app D Recursive time 226 05 08 11 53 15 289 17896 17896 com example rxjavaperformancetest app D Recursive time 226 05 08 11 53 15 296 17896 17896 com example rxjavaperformancetest app D Recursive time 227 05 08 11 53 15 296 17896 17896 com example rxjavaperformancetest app D Recursive time 227 05 08 11 53 15 296 17896 17896 com example rxjavaperformancetest app D Recursive time 227 05 08 11 53 15 296 17896 17896 com example rxjavaperformancetest app D Recursive time 227 05 08 11 53 15 296 17896 17896 com example rxjavaperformancetest app D Recursive time 228 05 08 11 53 15 296 17896 17896 com example rxjavaperformancetest app D Recursive time 228 05 08 11 53 15 296 17896 17896 com example rxjavaperformancetest app D Recursive time 228 05 08 11 53 15 296 17896 17896 com example rxjavaperformancetest app D Recursive time 228 05 08 11 53 15 296 17896 17896 com example rxjavaperformancetest app D Recursive time 229 So we see here huge gap enough to be noticed by the user in UI ## Conclusion Of course immediate way of handler thread scheduling is more dangerous because we can get StackOverflowException in some cases But usually work scheduled in main thread is usually simple and just manipulate UI elements But for cases when we want to receive some expensive data that can be cached api call or bitmap immediate way can be very helpful Sorry for the late reply Thank you for your work @Yarikx However looks your test is unfair Firstly you are measuring the time interval between each action and the subscribe method Secondly you are using the same handler So the actions using recursive need to run after the actions using immediate It means that the first time interval of recursive is whole time of immediate action time interval Could you redo your test by timeInterval and run the test for immediate and recursive separately E g Java Observable range 0 20 observeOn immediate timeInterval immediate subscribe new Action1 TimeInterval Integer @Override public void call TimeInterval Integer interval Log d Immediate time interval getIntervalInMilliseconds In addition make sure subscribe also runs in the handler So I suppose the code should be Java public void testImmediate Handler handler new Handler final Scheduler immediate AndroidSchedulers handlerThread handler true immediate createWorker schedule new Action0 @Override public void call Observable range 0 20 observeOn immediate timeInterval immediate subscribe new Action1 TimeInterval Integer @Override public void call TimeInterval Integer interval Log d Immediate time interval getIntervalInMilliseconds public void testRecursive Handler handler new Handler final Scheduler recursive AndroidSchedulers handlerThread handler false recursive createWorker schedule new Action0 @Override public void call Observable range 0 20 observeOn recursive timeInterval recursive subscribe new Action1 TimeInterval Integer @Override public void call TimeInterval Integer interval Log d Recursive time interval getIntervalInMilliseconds In general I d be very careful with such manual measurements Have a look at this document outlining how deceiving micro benchmarks can beL http www ibm com developerworks java library j jtp02225 index html The lack of authoritative documentation for Dalvik and the optimizations it applies makes that even worse Another thing I m worries about is that introducing this change will in fact change the behavior of client code in some cases so we might see application code failing Here s why Say in one of your fragments you create an observable and connect it in onCreate to a subscriber that fills the results into a view With the current implementation this works since observeOn mainThread will post the callbacks to the message loop you re guaranteed to not receive them before the fragment has been fully constructed i e they will not arrive until after onViewCreated is called which is where you initialize your views With this optimization in place however the callbacks become synchronous when executed from the main thread so if the Observable was scheduled to run on the main thread you will not get the call back immediately i e before your views are fully initialized As a result your application will crash Given connecting a synchronous observable in fragment onCreate is not very likely I m just saying these are things that have to be considered In fact after some consideration I m against applying this patch I think of observeOn as sending a message through the given scheduler and if it s documented that sending a message this way always goes through Android s message loop then as a caller we get predictable behavior and can rely on the guarantees Android gives us w r t how these messages are processed such as treating a rotation change of an Activity as an atomic operation from the perspective of message processing In other words we re still fulfilling Android s message loop contract since we re merely adapting its API to fulfill RxJava s Scheduler contract in terms of an Android message loop By applying optimizations like these we re bypassing the message loop and create non deterministic behavior where sometimes the message loop is involved sometimes it isn t This will make it difficult to reason about failure on the call site unless this behavior is clearly documented Perhaps there is a way to make this explicit in the type system or in the Scheduler APIs Another option would be to introduce a variant of HandlerThreadScheduler which performs such optimizations only using the message loop when necessary and treating a scheduled action as a synchronous message call otherwise @mttkay I think you are right After some thoughts I also don t think this is the best way to do operations on handler I still think that there is better way to deal with main thread but it s not here right now So I will close this PR',RxJava,true,false,false
32249143,OperatorJoin,'Operator Join Issue #1060 Remark now that the client onNext is called outside the synchronization block joint results may appear in arbitrary order in case both left and right observables emit values concurrently I suppose the strict ordering is not really expected here but someone who uses this operator can tell @duncani perhaps','RxJava pull requests #1014 https netflixoss ci cloudbees com job RxJava pull requests 1014 FAILURE Looks like there s a problem with this pull request rx operators OperatorPivotTest testConcurrencyAndSerialization needs some fixing rx operators OperatorPivotTest testConcurrencyAndSerialization needs some fixing yes it does',RxJava,true,false,false
32254316,'Operator merge delay error','Operator MergeDelayError Issue #1060','RxJava pull requests #1015 https netflixoss ci cloudbees com job RxJava pull requests 1015 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
32256176,'ReplaySubject replay calls onComplete multiple times','In the following code java ConnectableObservable Integer intObs Observable from Sets newHashSet 1 2 replay twoAndFour connect Observable Integer fooObs intObs toList map new Func1 List Integer Integer @Override public Integer call List Integer integers return 1 The return 1 statement gets hit twice Because the toList aggregate function is being called its expected that the intObs toList observer should only emit 1 object Unfortunately the ReplaySubject that backs replay ends up calling onComplete multiple times which results in the toList operator calling onNext multiple times This can lead to a lot of unexpected results One of the reasons for this happening is that it seems as though most operators don t unsubscribe after being completed as well as making sure onComplete and onError only get called once Is there a reason most operators don t create subscribers that adhere to the rxGuidelines mentioned in the SafeSubscriber class http go microsoft com fwlink LinkID 205219 Any help would be much appreciated Thanks Blake','This is a bug When subscribing to a terminated ReplaySubject it first replays the entire history and the termination event then detects it has terminated and replays the remaining history and the termination event again I ll post a fix shortly Awesome Thanks D Closing as the fix was merged',RxJava,false,false,false
32259797,OperatorMergeMaxConcurrent,'Operator MergeMaxConcurrent Issue #1060','RxJava pull requests #1016 https netflixoss ci cloudbees com job RxJava pull requests 1016 SUCCESS This pull request looks good',RxJava,true,false,false
32263489,'Fix ReplaySubject s double termination problem','Fix for issue #1105','RxJava pull requests #1017 https netflixoss ci cloudbees com job RxJava pull requests 1017 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
32269258,OperatorMulticastAndReplay,'Operator Multicast and Replay because Replay is effectively a multicasted subject Issue #1060','RxJava pull requests #1018 https netflixoss ci cloudbees com job RxJava pull requests 1018 SUCCESS This pull request looks good',RxJava,true,false,false
32271576,OperatorOnErrorResumeNextViaObservable,'Operator OnErrorResumeNextViaObservable Issue #1060','RxJava pull requests #1019 https netflixoss ci cloudbees com job RxJava pull requests 1019 SUCCESS This pull request looks good',RxJava,true,false,false
32272467,OperatorOnErrorReturn,'Operator OnErrorReturn Issue #1060','RxJava pull requests #1020 https netflixoss ci cloudbees com job RxJava pull requests 1020 SUCCESS This pull request looks good',RxJava,true,false,false
32302971,OperatorTimeInterval,'Operator TimeInterval Issue #1060','RxJava pull requests #1022 https netflixoss ci cloudbees com job RxJava pull requests 1022 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1023 https netflixoss ci cloudbees com job RxJava pull requests 1023 SUCCESS This pull request looks good RxJava pull requests #1024 https netflixoss ci cloudbees com job RxJava pull requests 1024 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
32303720,OperatorThrottleFirst,'Operator ThrottleFirst and moved tests in ThrottleFirstTests to OperatorThrottleFirstTest Issue #1060','RxJava pull requests #1025 https netflixoss ci cloudbees com job RxJava pull requests 1025 SUCCESS This pull request looks good',RxJava,true,false,false
32305091,'testing push to remote fork repository','testing pull request to a fork','RxJava pull requests #1026 https netflixoss ci cloudbees com job RxJava pull requests 1026 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
32305106,'testing push to remote fork repository','testing pull request to a fork','RxJava pull requests #1027 https netflixoss ci cloudbees com job RxJava pull requests 1027 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
32313580,OperatorTakeWhile,'Operator TakeWhile Issue #1060','RxJava pull requests #1028 https netflixoss ci cloudbees com job RxJava pull requests 1028 SUCCESS This pull request looks good RxJava pull requests #1038 https netflixoss ci cloudbees com job RxJava pull requests 1038 SUCCESS This pull request looks good',RxJava,true,false,false
32330557,'subscriber methods with scheduler create ambiguous overloads for Groovy and Java 8','Hi In 0 18 there are the following methods public final Subscription subscribe final Action1 super T onNext final Action1 Throwable onError public final Subscription subscribe final Action1 super T onNext Scheduler scheduler The problem here is that Action1 and Scheduler are both SAM types This makes closure coercions and lambda expressions ambiguous and requires extra syntax to specify the coercion target type Could the Scheduler accepting methods be renamed There are other similar methods of course','@headinthebox and @akarnokd What is the reason for having the Scheduler overloads on the subscribe methods I honestly can not remember why that happened Seems like that should just be using subscribeOn and does not need these overloads This is not something we want to leave as is because it breaks Groovy and Clojure It also makes it slightly less convenient to use a Java 8 lambda expressions because you need to add the target type to the expression Never understood why this it not in net I would junk that overload Not even sure what it is supposed to do Looks like a convenience shortcut and we should avoid ambiguity problems with Java 8 while RxJava is in a allowed API flux I vote for removal So do I let s remove them Would it be worth some tests that reflectively check the public API for any methods that are overloaded with different SAM types i e this problem to catch this before leaking out again Yes a test like that would be good You interesting in doing it Sure I ll do it I ll do something for the methods on Observable it could then later be adapted to other applicable types Thanks and I ll delete the methods shortly',RxJava,false,false,false
32336111,'Operator OnExceptionResumeNextViaObservable','Operator OnExceptionResumeNextViaObservable Issue #1060','RxJava pull requests #1029 https netflixoss ci cloudbees com job RxJava pull requests 1029 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
32336675,'Operator ParallelMerge','Operator ParallelMerge just renamed Issue #1060','RxJava pull requests #1030 https netflixoss ci cloudbees com job RxJava pull requests 1030 SUCCESS This pull request looks good',RxJava,true,false,false
32337906,OperatorRefCount,'Operator RefCount #1060','RxJava pull requests #1031 https netflixoss ci cloudbees com job RxJava pull requests 1031 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
32339776,OperatorSequenceEqual,'Operator SequenceEqual #1060 Lightened the operator but note that NotificationLite escaping an operator may cause undesired effects in other operators relying on NotificationLite as well','RxJava pull requests #1032 https netflixoss ci cloudbees com job RxJava pull requests 1032 SUCCESS This pull request looks good',RxJava,true,false,false
32341471,OperatorSkipTimed,'Operator SkipTimed #1060 There was an unexpected dependency in OperationTakeTimedTest and is surely to cause conflict when TakeTimed is rewritten Once all operators have been merged I suggest we create a primary TestException and rewrite tests to use it instead of all those custom exception classes everywhere','RxJava pull requests #1033 https netflixoss ci cloudbees com job RxJava pull requests 1033 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
32342576,OperatorSkipUntil,'Operator SkipUntil #1060','RxJava pull requests #1034 https netflixoss ci cloudbees com job RxJava pull requests 1034 SUCCESS This pull request looks good',RxJava,true,false,false
32367550,'Operator Window','Operator Window Issue #1060 Significant changes have been implemented in the new Window operator s behavior The original sized timed and start end observable versions waited until a window has finished and emitted the buffered values as a single Observable from This is not how the Rx NET version behaves where once a window is open values are delivered as they appear from source This has the same effects as groupBy where Observable windows not subscribed immediately will not deliver all values Probably this is why Clojure test test partition all fails but I don t know how to fix it there The callback boundary observable version similar to the buffer variant before constantly created a new observable for each value This new version consistent with the new buffer uses one boundary source per subscribing client The exact variants such as size skip timespan timeshift and observable boundary make extra effort to ensure all events are delivered into one of the windows i e no event will fall between the closing and opening of a window gap when it concurrently appears from the source This rewrite needs more meticulous review due to the changes and their concurrency effects','RxJava pull requests #1035 https netflixoss ci cloudbees com job RxJava pull requests 1035 ABORTED Not sure why it aborts locally it fails on the clojure test FAIL in test partition all core_test clj 470 expected range 15 partition all 30 4 range 15 rx seq o rx partition all 30 4 rx map fn p1__841# rx into p1__841# rx concat b into actual not 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 4 5 6 7 8 9 10 11 12 13 14 8 9 10 11 12 13 14 12 13 14 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Observable windows not subscribed immediately will not deliver all values Perhaps then it needs to use BufferUntilSubscriber like groupBy does That can be arranged but the current BufferUntilSubscriber looks strange I haven t tested it but it throws ClassCastException if a second subscriber subscribes after the pass through mode Plus it allows only a single actual subscriber so a second subscriber would be lost or would overpower the first it throws ClassCastException if a second subscriber subscribes after the pass through mode It is odd that it throws a ClassCastException I can fix that It s because it expects single subscription as this is not multicast The error it should throw is to tell someone to use multicast publish replay etc if they want to multicast it This whole type is odd because we are bridging a time boundary and avoiding the use of a multicast subject on a hot observable that we have created from a potentially cold observable We do not add multicast anywhere unless the user asks for it and probably shouldn t here either I m not sure the overhead of SubjectSubscriptionManager to allow multicasting on something that is not ever supposed to be used for multicasting Do you think we should support multicast on GroupedObservable s that we create and emit from groupBy If so why In PR #1138 I ve fixed BufferUntilSubscriber to behave as a simple PublishSubject for the subsequent subscribers It works and most users compose operations that subscribe once but it is not a least surprising behavior I d add a replayAll and replayOnce operators to GS so users have to explicitly request that behavior Both would immediately subscribe to the group and route everything through ReplaySubject or BufferUntilSubscriber which I would rather rename to ReplayOnceSubject More clarity on the multicast issue if we were to start allowing multicast on a GroupedObservable or similar use cases we would just end up recreating the time gap issue as the first subscriber would drain the queue and subsequent subscribers only get items emitted from then onwards not at all what anyone would expect If someone wants to multicast they should have to explicitly ask and deal with the ConnectableObservable connect behavior and decision of when to subscribe and thus drain the queue in this case I ve fixed BufferUntilSubscriber to behave as a simple PublishSubject for the subsequent subscribers No that s not how it should work I specifically implemented BufferUntilSubscriber without PublishSubject and ReplaySubject behaviors because it s wrong as my previous comment states It should not do multicast It is single purposed for hopping the time gap and that s it',RxJava,true,false,false
32372376,'Add lift to rxscala','This PR added lift to RxScala and also added a Subscriber apply method to support to chain Subscriber s cc @samuelgruetter','RxJava pull requests #1036 https netflixoss ci cloudbees com job RxJava pull requests 1036 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1037 https netflixoss ci cloudbees com job RxJava pull requests 1037 FAILURE Looks like there s a problem with this pull request Thank you for reviewing the codes @samuelgruetter I added the Operator conversion and the tail operator as an exmpale of lift Do you have any better idea about liftExample2 RxJava pull requests #1044 https netflixoss ci cloudbees com job RxJava pull requests 1044 SUCCESS This pull request looks good Is this ready RxJava pull requests #1053 https netflixoss ci cloudbees com job RxJava pull requests 1053 SUCCESS This pull request looks good LGTM Thank you @zsxwing',RxJava,true,false,false
32427031,'Operator contrib math','Operators of contrib math Issue #1060 I only changed the average code to operators left the sum and min max as they were Renamed files to operator','RxJava pull requests #1039 https netflixoss ci cloudbees com job RxJava pull requests 1039 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
32428775,'Operator When','Operator When in contrib joins Issue #1060','RxJava pull requests #1040 https netflixoss ci cloudbees com job RxJava pull requests 1040 SUCCESS This pull request looks good',RxJava,true,false,false
32434371,'Buffer with count skip','Now that we are in breaking change mode perhaps we can revisit the edge conditions for operators like buffer Buffer 2 1 on a stream of odd length will have a buffer of size 1 as the last element In Scala sliding 2 1 will only produce buffers of size 2 I regret the decision we made in Rx NEt for buffer','What changes should we make Scala s solution is pretty refined as expected http www scala lang org api 2 11 0 index html#scala collection Iterator allowing withPartial false and withPadding to specify the edge cases That seems a bit overkill Let s keep things as is you can always filter out section of the wrong length or pad them by hand Was teaching a course today when this question came up again so reopening such that more people can chime in val ys List 0 1 2 3 4 sliding 2 1 toList println ys prints List List 0 1 List 1 2 List 2 3 List 3 4 while scala val zs Observable items 0 1 2 3 4 buffer 2 1 zs subscribe x print x prints Buffer 0 1 Buffer 1 2 Buffer 2 3 Buffer 3 4 Buffer 4 What does List 0 sliding 2 1 print Yes it is kind of weird how they send out partial windows see below Definitively not proposing the scala version withPartial true but defaulting to withPartial false Again I am very much in favor of keeping what we currently have but it one of the questions I get at every course I teach where I show this it is an easy way to point out to people that their code will crash if they don t filter on size when I ask them to differentiate a stream of numbers println List sliding 3 1 toList println List 0 sliding 3 1 toList println List 0 1 sliding 3 1 toList println List 0 1 2 sliding 3 1 toList println List 0 1 2 3 sliding 3 1 toList prints List List List 0 List List 0 1 List List 0 1 2 List List 0 1 2 List 1 2 3 Then println List sliding 4 3 toList println List 0 sliding 4 3 toList println List 0 1 sliding 4 3 toList println List 0 1 2 sliding 4 3 toList println List 0 1 2 3 sliding 4 3 toList println List 0 1 2 3 4 sliding 4 3 toList prints List List List 0 List List 0 1 List List 0 1 2 List List 0 1 2 3 List List 0 1 2 3 List 3 4 For comparison println Observable items buffer 4 3 subscribe x println x println Observable items 0 buffer 4 3 subscribe x println x println Observable items 0 1 buffer 4 3 subscribe x println x println Observable items 0 1 2 buffer 4 3 subscribe x println x println Observable items 0 1 2 3 buffer 4 3 subscribe x println x println Observable items 0 1 2 3 4 buffer 4 3 subscribe x println x println prints Buffer 0 Buffer 0 1 Buffer 0 1 2 Buffer 0 1 2 3 Buffer 3 Buffer 0 1 2 3 Buffer 3 4 @headinthebox Anything further on this before closing I ll be at EPFL Thu Fri let me discuss with Martin Odersky Conclusion let s leave as is Thanks',RxJava,false,false,false
32437327,'Fix for SerializedObserverTest','Fixed the SerializedObserverTest s problematic assertions testMultiThreadedWithNPEinMiddle might schedule all non null values before the exception might reach the serialized observer In addition waiting after the serialization doesn t help because the cheap value emissions get queued up before that again possibly before the exception The new code adds some delays to the non null elements allowing the exception to get into the queue I ve looped it 10 000 times without failure but there is still a non zero chance the new NullPointerException thread is significantly delayed and ends up as the last event testNotificationDelay might fail due to thread scheduling of the two OnNextThread delayed too much in respect to each other before the main thread allows the pass through The fix is to let bot instances Thread reach the run method and then let the main thread pass through them Again a loop of 10 000 succeeded locally Both tests are run 10 times to be more sure','RxJava pull requests #1041 https netflixoss ci cloudbees com job RxJava pull requests 1041 SUCCESS This pull request looks good',RxJava,true,false,false
32439491,'Conditional statements contribution to Operator','Operators rewritten in contrib computation expressions Issue #1060','RxJava pull requests #1042 https netflixoss ci cloudbees com job RxJava pull requests 1042 SUCCESS This pull request looks good',RxJava,true,false,false
32444674,'Operator Switch','Operator Switch Issue #1060','',RxJava,true,false,false
32460228,'Operator TakeTimed','Operator Take with time Issue #1060','RxJava pull requests #1043 https netflixoss ci cloudbees com job RxJava pull requests 1043 SUCCESS This pull request looks good',RxJava,true,false,false
32496679,'Manual Merge of Several PRs','Merging many PRs that were conflicting Heroic work by @akarnokd and @zsxwing on #1060 All unit tests are passing on my machine Going to let this bake a while before a release Other PRs on still on their way','',RxJava,true,false,false
32496744,'collapse imports','attempt to reduce merge conflicts as it s always the import statements that are conflicting','RxJava pull requests #1045 https netflixoss ci cloudbees com job RxJava pull requests 1045 SUCCESS This pull request looks good A note should be posted somewhere that don t call organize imports or equivalent on Observable java so the IDE won t expand these imports back to individual instances',RxJava,true,false,false
32505502,OperatorTakeLast,'Operator TakeLast There are two changes comparing with the original implementations Throw IndexOutOfBoundsException at once when calling takeLast with count 0 Replace IllegalArgumentException with IndexOutOfBoundsException when count 0 in TakeLastWithTimed Issue #1060','RxJava pull requests #1046 https netflixoss ci cloudbees com job RxJava pull requests 1046 SUCCESS This pull request looks good RxJava pull requests #1048 https netflixoss ci cloudbees com job RxJava pull requests 1048 SUCCESS This pull request looks good',RxJava,true,false,false
32505987,OperatorTakeUntil,'Operator TakeUntil Issue #1060','RxJava pull requests #1047 https netflixoss ci cloudbees com job RxJava pull requests 1047 SUCCESS This pull request looks good Generally looks okay but the original logic could be improved a bit Instead of the inner Notification I would use a HALT token to indicate termination so we don t create objects for every raw notification Final both inner Observable RxJava pull requests #1049 https netflixoss ci cloudbees com job RxJava pull requests 1049 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1054 https netflixoss ci cloudbees com job RxJava pull requests 1054 SUCCESS This pull request looks good',RxJava,true,false,false
32511336,'Issues to be fixed with the latest operators','While merging the new operators from issue #1060 some open questions remained This issue tracks the fixes for those OperatorMulticast to not subscribe unsubscribe while holding the lock OperatorRefCount to not connect disconnect while holding the lock OperatorSampleWithTime to unsubscribe when onComplete is called so the periodic schedule can be stopped','',RxJava,false,false,false
32526658,'Fixes to the operators','Fixes for issue #1136 OperatorMulticast is straightforward from concurrency perspective The only consideration is that if the current subscription gets unsubscribed before the connect reaches the unsafeSubscribe it really depends on the source what it will do with an unsubscribed client It is possible to put extra effort to make sure a newly established connection won t get unsubscribed before it is actually connected or if it gets unsubscribed immediately no subscription is attempted at all OperatorSampleWithTime didn t want to push too many PRs so I just included it here There was a missing unsubscribe in the onCompleted that makes sure the worker is stopped Subscribers empty was implemented by returning the same Subscriber to everyone which Subscriber is stateful so if someone unsubscribes it it will appear everywhere as unsubscribed and can have unwanted effects There is no such problem with Observers empty as it is stateless The change just uses Subscribers from to wrap Observers empty and every caller gets its own independent instance OperatorRefCount was a bit more tricky Since it has a connection counter one has to serialize subscriptions with unsubscriptions However it is possible a subscription gets unsubscribed before code reaches the connect check which may disrupt the connection counter The solution is to keep track of the unsubscriptions that happen before the connection attempts and not change the counter in case of out of order behavior The final aim was to avoid leaking the connection statuses if the unsafeSubscribe throws concurrently with a client unsubscribing by using weak tokens integers wouldn t have worked as the first 0 127 are cached in the JVM and would never GC','RxJava pull requests #1050 https netflixoss ci cloudbees com job RxJava pull requests 1050 SUCCESS This pull request looks good Thanks for tackling these complicated issues',RxJava,true,false,false
32533532,'Operator Window and other changes','Operator Window with no first loss functionality Issue #1060 I had to leave my computer so the detailed description will come within a few hours','RxJava pull requests #1051 https netflixoss ci cloudbees com job RxJava pull requests 1051 SUCCESS This pull request looks good Changes in respect to OperatorWindow Theoriginal buffered all events and emitted them at the end of windows as a single hot Observable This version similar to groupBy uses a subject that buffers values until a client subscribes to a window replays the buffered content then relays the rest of the events as they appear from the source This behavior allows code expecting the old buffer all mode to continue functioning but such unrevokable behavior might not be desired in the library Fix for OperatorBufferWithTime unsubscribe on OnCompleted to stop the associated periodic task The rewritten exact operators i e count skip timespan timeshift make extra efforts to ensure values end up in a window even if a window change happens concurrently A sideeffect is that emission may hop threads but are still ensured to apear serially Expanded BufferUntilSubscriber to behave as a regular ReplaySubject for the second etc Subscribers instead of either failing with ClassCastException or stealing overtaking the first client s events BufferUntilSubscriber should not support multicasting we re just recreating the time gap or memory leak problems it was intended to solve If it behaves as a PublishSubject then subsequent subscribers will be missing events If it behaves as a ReplaySubject then it s a memory leak If someone wants to multicast they need to ask for it and deal with ConnectableObservable I won t be able to change this PR until next monday If the other behaviors of the new windows are okay I d suggest a partial merge leaving my BufferUntilSubscriber out and fixing its ClassCastException and stealing overtaking behavior in a separate PR suggest a partial merge leaving my BufferUntilSubscriber out and fixing its ClassCastException and stealing overtaking behavior in a separate PR Agreed I can fix the ClassCastException and just make it onError if someone tries to subscribe twice Under what circumstances if any is buffer window supposed to emit an empty buffer Observable in other words if nothing is emitted by the source Observable during a span of time when any emissions would be allocated to a new buffer Observable will buffer window emit nothing or will it emit an empty buffer Observable I made some guesss when I came up with my marble diagrams but I m not sure if those guesses still hold https github com Netflix RxJava wiki Transforming Observables#buffer https github com Netflix RxJava wiki Transforming Observables#window On Wed Apr 30 2014 at 9 37 AM Ben Christensen notifications@github com wrote suggest a partial merge leaving my BufferUntilSubscriber out and fixing its ClassCastException and stealing overtaking behavior in a separate PR Agreed I can fix the ClassCastException and just make it onError if someone tries to subscribe twice Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 1138#issuecomment 41818932 David M Gross PLP Consulting Every buffer and window operator will emit empty lists and observables except the buffer with size skip variant I kept this oddity as there was a test case for it RxJava pull requests #1064 https netflixoss ci cloudbees com job RxJava pull requests 1064 SUCCESS This pull request looks good',RxJava,true,false,false
32565894,'Weird Issue with SubscribeOn and Schedulers','Hio I m using Rx ina function to perform batched batch writes to a database we are using I have a class which performs this functionality and uses subscribeOn with an executor pool to perform these operations I m running into a situation where the below function ends up hanging and I believe it hangs due to my subscribeOn usage because when I take out subscribeOn I m able to reach the flat map following it but unable to reach that code when subscribeOn is left in java protected Observable SherpaBatchWriteResponse performBatchWriteOnBatchedRecords final Observable IDataRecord encryptedRecordsObs ListeningExecutorService executorService MoreExecutors listeningDecorator new ThreadPoolExecutor 10 10 60L TimeUnit SECONDS new SynchronousQueue Runnable return encryptedRecordsObs buffer MAX_BATCH_SET_RECORDS subscribeOn Schedulers executor executorService flatMap new Func1 List IDataRecord Observable SherpaBatchWriteResponse @Override public Observable SherpaBatchWriteResponse call List IDataRecord writeRecords try SherpaBWRequestItems items createSherpaBatchWriteRequestItemsForDataRecords writeRecords return Observable just sherpaService batchWriteRecords items long switchboardConfig sherpaBatchGetTimeout catch SwitchboardException e return Observable error e catch SherpaException e return Observable error new SwitchboardException SwitchboardErrorCode SHERPA_BATCH_WRITE_FAILED_TO_WRITE_SOME_RECORDS e What also makes this situation weird is that I have two code paths that use this function and one code path succeeds when using it while the other hangs Granted I believe both code paths get to the point where it should be called I have one code path that hangs that looks like java performBatchWriteOnBatchedRecords Observable from Lists newArrayList record1 record2 where as a different code path succeeds that looks like java observable that emits idataRecords and the iDataRecords are fetched in with observables via a network call Observable IDataRecord async getRecordsAsync performBatchWriteOnBatchedRecords async Do you have any idea why this may be happening or any pitfalls I may be falling into I ve created my own operator to run a specific map flatmap function on a pool so I ve been able to overcome this but I m still interested on why subscribeOn was being goofy for me Thanks Blake','Also the operator I wrote is below I didn t use schedulers and this seems to do a good job a putting that one function on an external thread but I d be interested in what subscribe on does differently java public class OperatorFlatMapInPool R T1 implements Observable Operator R T1 final ListeningExecutorService pool final Func1 T1 Observable R func public OperatorFlatMapInPool Func1 T1 Observable R pFunc ListeningExecutorService pPool this pool pPool this func pFunc @Override public Subscriber super T1 call final Subscriber super R subscriber return new Subscriber T1 subscriber @Override public void onCompleted subscriber onCompleted @Override public void onError Throwable e subscriber onError e @Override public void onNext final T1 t1 do function on another thread ListenableFuture Observable R result pool submit new Callable Observable R @Override public Observable R call throws Exception return func call t1 do rest of operations on main thread Observable from result flatMap new Func1 Observable R Observable R @Override public Observable R call Observable R rObservable return rObservable subscribe new Action1 R @Override public void call R r subscriber onNext r new Action1 Throwable @Override public void call Throwable throwable subscriber onError throwable The subscribeOn operator simply invokes the subscribe to the given Observable on the given Scheduler See the code here https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorSubscribeOn java#L56 do rest of operations on main thread That is not moving to a main thread the work will happen on whatever thread is invoking onNext which in this case is from pool If you want the events to be received on a different thread you need to call observeOn to move the notifications For example java Observable from result observeOn Schedulers computation Using subscribeOn is effectively the same as you using pool submit but not the way this example does it The Observable from result code is on a Future and that will just cause Observable to block as java util concurrent Future does not have callbacks You are using ListenableFuture but RxJava does not know about that so you d need to wire that up yourself Quickly hacked code that shows manually running the code on a thread java Observable create new OnSubscribe R public void call Subscriber super R s s add Subscriptions from pool submit new Runnable @Override public void call try s onNext data s onCompleted catch Exception e s onError e vs using subscribeOn to subscribe and run on a new thread java Observable create new OnSubscribe R public void call Subscriber super R s try s onNext data s onCompleted catch Exception e s onError e subscribeOn Schedulers newThread Hi Have you tried debugging your first code Does it reach the flatmap s function Do you actually subscribe to the result of the method in the hanging case Otherwise this construct wastes a threadpool with 10 threads ObserveOn won t paralellize it you need parallelMerge for that I don t see any reason for the hang if not the service call blocks Hey Ben thanks for the help I have a few more questions So to clarify my understanding of this the subscribeOn functionality puts the entire chain on a different thread Determined by scheduler I e if I have java Observable just 1 flatMap flatMapFn map mapFn1 subscribeOn Schedulers newThread map mapFn2 This will result in the Observable just 1 s subscribe being on the new thread and then everything subsequent to that happening on that thread So regardless of where I put subscribeOnIn the chain of observables the observable that starts it off will be on the new thread as will everything after that mapFn1 mapFn2 and FlatMap Is there anyway for mapFn2 to be run back again on the thread that originally hooked the observables together Hey akarnokd Thanks for the reply I ve put breakpoints in my code and in the successful circumstance it does reach the flatmap but does not reach the breakpoint in my unsuccessful circumstance The other weird thing is that I can successfully get there in my unit tests of the broken code path wat I m fine with the 10 threads being wasted here because in actual implementation multiple requests will be using each of those threads I dont want 1 big batch write to hog the thread pool from other requests In what situations would something like this hang Does the following construct work for you please excuse the lambda syntax I m on a tablet right now Observable from Arrays asList 1 2 buffer 2 subscribeOn Schedulers executor executorService flatMap b Observable just 1 subscribe System out println Does it work if you buffer by 3 i did java @Test public void aTest final ListeningExecutorService executorService MoreExecutors listeningDecorator new ThreadPoolExecutor 10 10 60L TimeUnit SECONDS new SynchronousQueue Runnable System out println A Thread currentThread getId Observable from Arrays asList 1 2 buffer 3 subscribeOn Schedulers executor executorService flatMap new Func1 List Integer Observable @Override public Observable Integer call List Integer integers return Observable just 1 map new Func1 Object Object @Override public Object call Object o System out println B Thread currentThread getId System out println done return null toBlockingObservable last System out println C Thread currentThread getId worked for both 2 and 3buffer output was A 1 B 10 done C 1 The last thing I can think of is to create a thread dump when the first case hangs Is this still outstanding and needing resolution not quite I didnt get to figure out how to fix it however java subscribeOn Schedulers executor executorService appears to be remove from the newester version of rxjava and we have figured out a solution for ourselves Thanks for your help Closing out as a solution was found Since the last comments Scheduler from Executor e was added that creates a valid Scheduler from an Executor that complies with the Rx concurrency requirements',RxJava,false,false,false
32626479,'IO Scheduler Thread Caching','With the removal of ExecutorScheduler in 0 18 we also lost the thread caching on the IO Scheduler as it now just uses NewThreadScheduler This causes performance problems and thread growth in use cases where lots of short lived IO actions are performed We can just revert to using an Executor as before since multi threaded Executors can t maintain the Rx contract This means we need to either a figure out how to implement the Rx contract on top of an Executor b add thread caching to NewThreadScheduler or create a new implementation of CachedThreadScheduler for IO The problem with a is that an Executor has it s own queue and to ensure sequential execution we d have to build separate queues on top and then only put something into the Executor queue when the next action can be performed This is an awkward relationship between them and adds overhead because it s queueing twice and has extra machinery between each task so not good for performance I think b is the more efficient and straight forward approach','As I mentioned in the email thread I ll try to implement a variation of option b during the weekend Thanks @jbripley I ll await your pull request As discussed via email let s finish the conversation here it s likely that we want to change Schedulers io to use something like a CachedThreadScheduler implementation This default would be registered here https github com Netflix RxJava blob master rxjava core src main java rx schedulers Schedulers java#L46 Are most of the planned Scheduler changes planned for 0 19 done at this point making it worthwhile to sync my CachedThreadScheduler PR with the current master branch and resubmit Are most of the planned Scheduler changes planned for 0 19 done at this point making it worthwhile to sync my CachedThreadScheduler PR with the current master branch and resubmit The only remaining change is the update on computation scheduler and do memory optimizations Since we don t need to go to Thread level on this scheduler I d go with the implementation This is completed with the merge of https github com Netflix RxJava pull 1276 Thanks @jbripley',RxJava,false,false,false
32679396,'RFC OperatorToObservableList should not use ArrayList buffer with unspecified capacity','toList is not very efficient right now with regards to memory usage It uses ArrayList s default constructor which on Java s RI uses an initial capacity of 10 and on Android of 0 re allocating the list to a minimum of 12 upon emitting the first item through onNext Apparently Android chose 12 as a value that gives empirically good results but it s arbitrary from the perspective of your app nonetheless especially considering that toList will always be used with a bounded number of notifications and this number is often known upfront To give an example we use toList to implement result paging Our page size is often larger than 10 or 12 however so we trigger unnecessary re allocations I suggest we either add an overload of toList that accepts a capacity or change the data structure used for the internal buffering of items','Actually looking at the implementation again I missed that the list is copied before being passed to the subscriber I think we can fix this in an even simpler way by not using ArrayList at all as the internal buffer but instead use something like LinkedList which is not backed by consecutive memory so the problem does not even exist I ve update the issue text and title Change done in #1208',RxJava,false,false,false
32742614,'Update contains signature to contains Object','The original contains signature can not support the following codes java public void test ArrayList String l new ArrayList String l add test Observable ArrayList String o Observable ArrayList String from l o contains Arrays asList test This PR changes the signature from contains T to contains Object It s also consistent with equals Object This change should not break the old codes','RxJava pull requests #1055 https netflixoss ci cloudbees com job RxJava pull requests 1055 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
32765733,'CachedThreadScheduler for use as default IO Scheduler','Here is an implementation of the CachedThreadScheduler discussed in #1140 I ve been testing this against my own web service using load tests and it holds up fairly well There seems to be a bit more retention of expired event loops during high load than I like So I would appreciate a code review to make sure I haven t missed any part of the scheduler subscription life cycle Or if there s any unintentional reference keeping event loops or scheduler Worker instances from being garbage collected','RxJava pull requests #1056 https netflixoss ci cloudbees com job RxJava pull requests 1056 SUCCESS This pull request looks good RxJava pull requests #1057 https netflixoss ci cloudbees com job RxJava pull requests 1057 SUCCESS This pull request looks good RxJava pull requests #1058 https netflixoss ci cloudbees com job RxJava pull requests 1058 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1059 https netflixoss ci cloudbees com job RxJava pull requests 1059 FAILURE Looks like there s a problem with this pull request Not sure where these unit tests failures come from They all work locally at least RxJava pull requests #1060 https netflixoss ci cloudbees com job RxJava pull requests 1060 FAILURE Looks like there s a problem with this pull request If it fails on some pivot test don t worry I checked your source of inspiration and NewThreadScheduler has some issues which appear here directly or indirectly The Subscription returned by the scheduling remains in the innerSubscriptions when it is unsubscribed as the body is most likely never executes This can happen in operator throttle where timeout actions are routinely cancelled by the arrival of a value The solution would be to return a custom Subscription which calls innerSubscription remove as that will take care of the composite and the cancellation of the schedule as well Since schedule can happen from any thread it is possible the action and thus the innerSubscription remove s executes before the innerSubscription add s and leaking references The solution would be to introduce stamping along with the raw subscription or serializing add with remove through queue drain logic but the first needs new classes and the second adds overhead we had some conversation with @benjchristensen a few months ago but due to the unlikely occurrence of the issue it remains unaddressed Pools are not shut down if a worker gets evicted the underlying pool should be shut down explicitly or via core timeout feature otherwise they just stay until the JVM quits This might be addressed inside NewThreadScheduler by hooking up shutdown into the worker s unsubscribe code and you d call unsubscribe on the evicted parent worker as well which is btw a good idea now so it can cleanup its own innerSubscriptions at least RxJava pull requests #1061 https netflixoss ci cloudbees com job RxJava pull requests 1061 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1062 https netflixoss ci cloudbees com job RxJava pull requests 1062 FAILURE Looks like there s a problem with this pull request I think the last two commits addressed the things you mentioned in the third paragraph I ll have a look at the issues you mentioned in the first paragraph RxJava pull requests #1063 https netflixoss ci cloudbees com job RxJava pull requests 1063 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1078 https netflixoss ci cloudbees com job RxJava pull requests 1078 SUCCESS This pull request looks good what should be the class visibility of the scheduler implementations The intent has been for schedulers to not be public and only accessible via Schedulers factory methods The reason for this is that it enforces all access via one place where the RxJavaDefaultSchedulers plugin can intercept them and provide alternates Of course this can t prevent completely custom schedulers but it does prevent the most common case of people instantiating the defaults directly RxJava pull requests #1079 https netflixoss ci cloudbees com job RxJava pull requests 1079 SUCCESS This pull request looks good RxJava pull requests #1118 https netflixoss ci cloudbees com job RxJava pull requests 1118 SUCCESS This pull request looks good RxJava pull requests #1119 https netflixoss ci cloudbees com job RxJava pull requests 1119 SUCCESS This pull request looks good I m still holding off on this while figuring out the Scheduler changes with @akarnokd Also once that is done I would appreciate you rebasing squashing the commits on this PR and re submitting That is a lot of commits and many of them are duplicates from the master branch that have been merged back into yours Also take note of https github com Netflix RxJava issues 1219 Ok I ll do a rebase to clean up the commits a bit and re submit after you and @akarnokd have finalized the Scheduler changes About #1219 are we aiming to have the IO Scheduler just pass a cached threadpool to ExecutorScheduler or is having something like this solution with its own eventloop queue still worth it for the smaller overhead or is having something like this solution with its own eventloop queue still worth it for the smaller overhead This will be more efficient for the common case as it will avoid the extra layer of queueing',RxJava,true,false,false
32788366,'Operator Delay rebase fixes','Operator Delay Issue #1060','RxJava pull requests #1065 https netflixoss ci cloudbees com job RxJava pull requests 1065 SUCCESS This pull request looks good',RxJava,true,false,false
32801440,'Large CompositeSubscription performance improvements','This is a proposition to improve the addition removal speed of the CompositeSubscription in case of thousands of items in it In some operators especially when using Schedulers and or observeOn thousands of items may be present in the composite and since adding removing a new item is O n it takes more and more time to add and remove items once the composite gets large My proposal is to change the composite state implementation to switch to a HashSet representation above a certain threshold and switch back below some The following diagram shows some benchmarking results Configuration i7 920 @ 2 4GHz 32K L1 Data 256K L2 8M L3 6GB DDR3 1333MHz RAM Windows 7 x64 Java 8u05 x64 image https cloud githubusercontent com assets 1269832 2877095 4779ac40 d443 11e3 9c0a 908ea49c6219 png This benchmark how the CompositeSubscription behaves when there are some items already in it and a new unique item is added and removed immediately all single threaded The blue line indicates the current master implementation the red green and purple show the new implementation with thresholds set to 8 16 and 24 respectively Once the internal array size reaches the cache line size it is generally better to use HashSet instead The second benchmark compares how fast can the CompositeSubscription be filled with subscribers to a various capacity and how the target size affects the fill speed image https cloud githubusercontent com assets 1269832 2877162 afcb76a6 d444 11e3 8c4c c3ba85e6c1d3 png When the composite is filled in the one by one array resize performs better until a larger capacity is reached but then again using a HashSet to append further items is faster Unfortunately what seems to be an optimal threshold for the first case performs worse in this case There are some drawbacks of this hybrid approach The optimal threshold value depends on the use case and the target system How can we enable to tune this parameter Parameter tuning could be handy in other places in RxJava how can we enable it I m not 100 certain if I ve correctly implemented the switchover from atomic states to mutable state and back','RxJava pull requests #1066 https netflixoss ci cloudbees com job RxJava pull requests 1066 SUCCESS This pull request looks good I need more time to review this looks like impressive work and analysis Does this still make sense once #1000 is implemented and we can limit the buffering on operators like observeOn It looks like the 1024 buffer size a candidate for default buffer even with #1000 can still benefit from this It depends on the usage pattern If there is a burst of 1000s of new subscriptions a bigger threshold is better If there are lots of small additions and removals while having a moderate number of items in the composite the lower threshold is better I don t know a case where suddenly 1000s of subscriptions get created and added to the composite This change has been incorporated into #1190 so I don t recommend merging this I ll keep this open until the approach is approved or discarded I tested these changes while playing with performance As expected they don t play a role in normal map flatMap use cases using this test https github com benjchristensen RxJava blob performance rxjava core src perf java rx usecases PerfTransforms java #### master performance branch Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapTransformsUsingFrom 1 thrpt 5 3184873 133 172320 420 ops s r u PerfTransforms flatMapTransformsUsingFrom 1024 thrpt 5 9079 937 343 905 ops s r u PerfTransforms flatMapTransformsUsingJust 1 thrpt 5 3411785 677 73767 161 ops s r u PerfTransforms flatMapTransformsUsingJust 1024 thrpt 5 10860 963 294 309 ops s r u PerfTransforms mapTransformation 1 thrpt 5 7208334 997 703327 745 ops s r u PerfTransforms mapTransformation 1024 thrpt 5 18720 797 278 529 ops s #### with CompositeSubscriptionSpeedup merged Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapTransformsUsingFrom 1 thrpt 5 3118494 120 173919 112 ops s r u PerfTransforms flatMapTransformsUsingFrom 1024 thrpt 5 8715 267 298 710 ops s r u PerfTransforms flatMapTransformsUsingJust 1 thrpt 5 3140414 540 17172 305 ops s r u PerfTransforms flatMapTransformsUsingJust 1024 thrpt 5 10226 673 410 795 ops s r u PerfTransforms mapTransformation 1 thrpt 5 6913018 033 123193 805 ops s r u PerfTransforms mapTransformation 1024 thrpt 5 18608 990 377 513 ops s #### reverted changes Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapTransformsUsingFrom 1 thrpt 5 3247111 390 63408 626 ops s r u PerfTransforms flatMapTransformsUsingFrom 1024 thrpt 5 9103 650 223 604 ops s r u PerfTransforms flatMapTransformsUsingJust 1 thrpt 5 3406320 200 121290 155 ops s r u PerfTransforms flatMapTransformsUsingJust 1024 thrpt 5 10882 203 382 654 ops s r u PerfTransforms mapTransformation 1 thrpt 5 7353154 113 185266 016 ops s r u PerfTransforms mapTransformation 1024 thrpt 5 17524 093 518 755 ops s But mine is a bit slower than the master and the 0 16 x I think the reason is that by changing the size of objects the allocator may run out of the cache line at different times I m closing this because of the new subscription containers have these optimizations in separate classes',RxJava,true,false,false
32811763,'Scheduler fixes505','This PR contains some changes to the NewThreadScheduler and EventLoopScheduler which makes them work more correctly and gives some flexibility to them Note that this conflicts with PR #1143 Notable changes Changed NewThreadScheduler to use a ScheduledExecutorService as I don t see any particular reason why not Added proper logic for tracking and unsubscribing scheduled actions Renamed inner classes to better express their purpose got lost in all of those inner EventLoopScheduler workers Added the ability to specify the number of cores and the worker selection policy to EventLoopScheduler Two policies are available round robin and least recent default A new Schedulers fixed method is added which lets the caller specify the pool size Since the EventLoopScheduler is package private I wasn t sure how to expose the worker selection policy In addition EventLoopScheduler implements Subscription so the Scheduler returned by fixed can be terminated I made sure the computation scheduler can t be terminated this way Fixed EventLoopScheduler to track the submitted actions properly Note that the potential Subscription leak due to innerSubscription remove happening before innerSubscription add in EventLoopWorker is not handled It can t happen with NewThreadScheduler though although it would benefit from a CompositeSubscription delete method which doesn t unsubscribe the removed item and thus not interrupting the executor unnecessarily','RxJava pull requests #1067 https netflixoss ci cloudbees com job RxJava pull requests 1067 FAILURE Looks like there s a problem with this pull request Pivot fails again but locally everything works I wonder why sometimes that particular pivot test won t get enough concurrency I ll wait for this to get merged to master and then I ll rebase my PR branch for #1143 to include these changes Pivot fails again but locally everything works I wonder why sometimes that particular pivot test won t get enough concurrency java if Runtime getRuntime availableProcessors 4 System out println max outer concurrency maxOuterConcurrency get assertTrue maxOuterConcurrency get 1 should be 4 since we have 4 threads and cores running but setting at just 1 as this is non deterministic I have no idea why the build system would allow only 1 thread when there are 4 cores It suggests though that this unit test is not trustworthy enough to leave as it yet this is supposed to assert we actually achieve concurrency and aren t single threaded What do you suggest doing with this test I plan to examine the pivot tomorrow and perhaps force a thread switch somehow This change negatively affects performance SchedulerPerformanceTests spt singleResponse Schedulers computation ##### Before Run 11 11 977 855 ops sec Run 12 12 026 921 ops sec Run 13 12 101 234 ops sec Run 14 12 055 745 ops sec ##### After Run 11 4 616 532 ops sec Run 12 4 525 013 ops sec Run 13 4 605 726 ops sec Run 14 4 622 058 ops sec The LRU policy is the source of most of the performance problems Why should we support multiple strategies Also @spodila is working on a new algorithm to replace round robin and taking into account things such as rebalancing the event loops when long running Workers get out of balance over time Thus anything being done to improve these algorithms should be coordinated I ve created an issue to track this https github com Netflix RxJava issues 1149 Yes the LRU s overhead is high compared to the simple subscriber activity I can t think of any trivial way to make it faster but I guess any bookkeping would increase the overhead I can switch back to the original simple round robin to see how the correctness changes affect the performance Thanks That makes sense As part of #1149 I want to mature the performance testing of this stuff using JMH so we let data drive future enhancements of these classes I ll close this and post a new PR without the fixed part',RxJava,true,false,false
32828945,'ReplaySubject Race Condition','A race condition with ReplaySubject was found while debugging a bug report with Hystrix https github com Netflix Hystrix issues 257 It appeared starting with v0 17 and still exists in the master branch I have tracked it down to this code in ReplaySubject java java private static T int replayObserverFromIndex History T history Integer l SubjectObserver super T observer while l history index get observer onNext history list get l l if history terminalValue get null if l 0 System out println terminating without emitting value history terminalValue get accept observer return l A terminal value is being emitted before the onNext is received yet in the Hystrix case it is emitting a value I m working on a stand alone test case for ReplaySubject','It only happens very occasionally but I reproduced it with this java @Test public void testReplayAsCache final List Integer expected Arrays asList 1 for int i 0 i 1000000 i TestSubscriber Integer ts new TestSubscriber Integer Observable just 1 subscribeOn Schedulers computation cache subscribe ts ts awaitTerminalEvent ts assertReceivedOnNext expected ts assertTerminalEvent I think I found the issue java private static T int replayObserverFromIndex History T history int l SubjectObserver super T observer while l history index get observer onNext history list get l l if the emission and termination event happens here the client won t receive the value but see the termination event only if history terminalValue get null if l 0 new IllegalStateException Value expected here Index history index get printStackTrace history terminalValue get accept observer return l Here is a ReplaySubject https gist github com akarnokd 0165a431a3ee0958e576 that did not fail for 100M iterations It puts the terminal value onto the list I haven t checked if performance is affected in some way Awesome thank you @akarnokd You got a fix before I even had time to start digging in It does indeed seem to have fixed it I m going to review it more closely and do performance testing and if all looks well will move forward with this Do you want to submit a PR with it so it s your merge Done reviewing the code looks good Using the NotificationLite mechanism makes it so there is a single list reference now instead of having list terminalValue which eliminates the race between the two With this fix in place I can no longer see the Hystrix bug and the Rx unit test now always passes #### Performance I tested performance using the already existing JMH tests gradlew benchmarks Pjmh f 1 tu ns bm avgt wi 5 i 5 r 1 ReplaySubjectPerf ###### Before Result 30371290 196 99 9 2404998 858 ns op Statistics min avg max 29923647 059 30371290 196 31414333 333 stdev 624570 566 Confidence interval 99 9 27966291 338 32776289 055 Benchmark nextRuns Mode Samples Mean Mean error Units r s ReplaySubjectPerf subscribeAfterEvents 1 avgt 5 465 227 3 719 ns op r s ReplaySubjectPerf subscribeAfterEvents 512 avgt 5 13806 833 254 181 ns op r s ReplaySubjectPerf subscribeAfterEvents 1024 avgt 5 26448 178 654 800 ns op r s ReplaySubjectPerf subscribeAfterEvents 1048576 avgt 5 28268927 778 869942 963 ns op r s ReplaySubjectPerf subscribeBeforeEvents 1 avgt 5 648 489 12 827 ns op r s ReplaySubjectPerf subscribeBeforeEvents 512 avgt 5 13053 491 214 858 ns op r s ReplaySubjectPerf subscribeBeforeEvents 1024 avgt 5 25706 752 401 549 ns op r s ReplaySubjectPerf subscribeBeforeEvents 1048576 avgt 5 30371290 196 2404998 858 ns op ###### After Result 24400896 190 99 9 2129385 605 ns op Statistics min avg max 24041904 762 24400896 190 25358100 000 stdev 552994 679 Confidence interval 99 9 22271510 586 26530281 795 Benchmark nextRuns Mode Samples Mean Mean error Units r s ReplaySubjectPerf subscribeAfterEvents 1 avgt 5 461 561 11 843 ns op r s ReplaySubjectPerf subscribeAfterEvents 512 avgt 5 16507 871 2031 269 ns op r s ReplaySubjectPerf subscribeAfterEvents 1024 avgt 5 31841 435 470 984 ns op r s ReplaySubjectPerf subscribeAfterEvents 1048576 avgt 5 29828781 599 3150737 584 ns op r s ReplaySubjectPerf subscribeBeforeEvents 1 avgt 5 675 099 70 664 ns op r s ReplaySubjectPerf subscribeBeforeEvents 512 avgt 5 11538 548 348 024 ns op r s ReplaySubjectPerf subscribeBeforeEvents 1024 avgt 5 22572 613 203 016 ns op r s ReplaySubjectPerf subscribeBeforeEvents 1048576 avgt 5 24400896 190 2129385 605 ns op The changes slightly impact performance not really sure why but they are small I m going to proceed with this fix I guess it is the small overhead from NotificationLite perhaps adding final to History would enable some JVM optimizations I ll have a look tomorrow Thanks for your help on this it made it possible to quickly release a fix for Hystrix https github com Netflix Hystrix releases tag 1 3 16',RxJava,false,false,false
32837054,'Manual Merge of Delay PR','','',RxJava,true,false,false
32838808,'EventLoopScheduler Algorithm','Issue for tracking and coordinating on improvements to the EventLoopScheduler algorithms which right now is simple round robin In particular how should it behave over time when it last long lived workers on it Should it rebalance and if so how','cc @spodila who is working on this and @akarnokd who is also involved from #1146 Just sent a PR a href https github com Netflix RxJava pull 1197 1197 a for two new variants of EventLoopsScheduler that I have been experimenting with',RxJava,false,false,false
32843220,'Fix ReplaySubject Terminal State Race Condition','Fixes https github com Netflix RxJava issues 1147#issuecomment 42232464 with change from @akarnokd','Unit test to assert this is java @Test public void testRaceForTerminalState final List Integer expected Arrays asList 1 for int i 0 i 1000000 i TestSubscriber Integer ts new TestSubscriber Integer Observable just 1 subscribeOn Schedulers computation cache subscribe ts ts awaitTerminalEvent ts assertReceivedOnNext expected ts assertTerminalEvent I am including that test with a smaller loop size If this bug were to return that test should non deterministically fail even with the smaller loop RxJava pull requests #1068 https netflixoss ci cloudbees com job RxJava pull requests 1068 SUCCESS This pull request looks good RxJava pull requests #1069 https netflixoss ci cloudbees com job RxJava pull requests 1069 SUCCESS This pull request looks good',RxJava,true,false,false
32857662,'RxScala startWith','startWith bindings are missing probably nicest to map to','I ll take it Like Looks @samuelgruetter describe why there is not startWith in RxScala in CompletenessTest scala Scala startWith Iterable T unnecessary because we can just use instead all 9 overloads of startWith startWith _ unnecessary because we can just use instead But startWith is a very convenient way to avoid breaking method chaining @samuelgruetter takes an Observable startWith takes a value What s about the following signatures Scala def U T elem U Observable U val thisJava this asJavaObservable asInstanceOf rx Observable U toScalaObservable thisJava startWith elem def startWith U T that Observable U Observable U val thisJava this asJavaObservable asInstanceOf rx Observable U val thatJava that asJavaObservable asInstanceOf rx Observable U toScalaObservable thisJava startWith thatJava def startWith U T iterable Iterable U Observable U val thisJava this asJavaObservable asInstanceOf rx Observable U toScalaObservable thisJava startWith iterable asJava Any better symbols for startWith Observable and startWith Iterable The one overload I am really interested in is the first one and sorry it seems that is the best choice for naming that as in true some_stream_of_bools For the overloads that take collections and or schedulers startWith is probably fine as a name Sorry I see I can just replace with By we can just use instead I meant that we can use Observable items a b c myObservable instead of myObservable startWith a b c I think this is better because one method less in the API which is already huge and for new users it s hard to get an overview more readable in the sense that the emission order of the elements is left to right i e in the direction you read the code more readable in the sense that you needn t lookup what startWith does when reading code And using on Observables is not a good idea because it s really reserved for List cons and it will confuse users a lot since collections other than lists don t use it I agree that startWith Observable and startWith Iterable are unnecessary But for the version I recommend that we use Yes having and would be nice Remove startWith add and at #1165 This can be closed',RxJava,false,false,false
32857953,'RxScala subjects','Several of the scala bindings for subjects still return subscription instead of a connectableobservable','I ll take it Like',RxJava,false,false,false
32860437,'RxScala Publish overload','Overloads for public final R Observable R publish Func1 super Observable T extends Observable R selector and public final TIntermediate TResult Observable TResult multicast final Func0 extends Subject super T extends TIntermediate subjectFactory final Func1 super Observable TIntermediate extends Observable TResult selector are missing','I ll take it Like',RxJava,false,false,false
32861065,'Missing overload of flatMap','This overload of flatMap is missing http msdn microsoft com en us library hh229199 v vs 103 aspx both RxJava and RxScala This one should not be implemented using flatMap and map otherwise we lose the inherent efficiency of this one','Observable L4234 https github com Netflix RxJava blob master rxjava core src main java rx Observable java#L4234 Apparently we have this as mergeMap java public final R Observable R mergeMap Func1 super T extends Observable extends R onNext Func1 super Throwable extends Observable extends R onError Func0 extends Observable extends R onCompleted return lift new OperatorMergeMapTransform T R onNext onError onCompleted So closing this and then it s a decision of using flatMap or mergeMap for the name which can be debated in https github com Netflix RxJava issues 1500',RxJava,false,false,false
32861123,'Missing overload of groupBy','http msdn microsoft com en us library hh212069 v vs 103 aspx','I can t find the relevant issue but I remember it wasn t implemented because you can call map on the GroupedObservable even though you loose GroupedObservable type in the process',RxJava,false,false,false
32861277,'HistoricalScheduler missing','http msdn microsoft com en us library system reactive concurrency historicalscheduler v vs 103 aspx Easiest to implememt directly i e without a huge family of base classes','When I was working on the TestScheduler enhancements I looked at HistoricalScheduler #642 It uses absolute date and we don t do that in any operators Besides TestScheduler can be advanced to any time value which could be a real millisecond date',RxJava,false,false,false
32865504,'Observable defer and Java 8 type inference','I m having issues with Observable defer and Java 8 and am not sure if there s anything we can do about it java package io reactivex lab edge import rx Observable public class TestDefer public static void main String args Observable defer return Observable from 1 toBlockingObservable single When trying to run this from Eclipse I get this Exception in thread main java lang BootstrapMethodError call site initialization exception at java lang invoke CallSite makeSite CallSite java 328 at java lang invoke MethodHandleNatives linkCallSite MethodHandleNatives java 296 at io reactivex lab edge TestDefer main TestDefer java 8 Caused by java lang ClassFormatError Duplicate method name signature in class file io reactivex lab edge TestDefer Lambda 1 at sun misc Unsafe defineAnonymousClass Native Method at java lang invoke InnerClassLambdaMetafactory spinInnerClass InnerClassLambdaMetafactory java 324 at java lang invoke InnerClassLambdaMetafactory buildCallSite InnerClassLambdaMetafactory java 194 at java lang invoke LambdaMetafactory altMetafactory LambdaMetafactory java 473 at java lang invoke CallSite makeSite CallSite java 301 2 more and trying to compile with JDK I get TestDefer java 8 error method defer in class Observable T#2 cannot be applied to given types Observable defer required Func0 extends Observable extends T#1 found retu 1 reason no instance s of type variable s T#3 exist so that Observable T#3 conforms to extends Observable extends T#1 where T#1 T#2 T#3 are type variables T#1 extends Object declared in method T#1 defer Func0 extends Observable extends T#1 T#2 extends Object declared in class Observable T#3 extends Object declared in method T#3 from T#3 1 error Java version java version 1 8 0_05 Java TM SE Runtime Environment build 1 8 0_05 b13 Java HotSpot TM 64 Bit Server VM build 25 5 b02 mixed mode','It looks like changing the generics can get it to compile This compiles java public static void main String args deferB return Observable from 1 toBlockingObservable single public final static T Observable T deferB Func0 Observable T observableFactory return Observable create new OperatorDefer T observableFactory but this does not java public static void main String args deferA return Observable from 1 toBlockingObservable single public final static T Observable T deferA Func0 extends Observable extends T observableFactory return Observable create new OperatorDefer T observableFactory This compiles but isn t as slick as a one liner java Func0 Observable Integer f Observable from 1 Observable defer f I can t remember if a similar question was asked on lambda dev so you could ask about this issue there Based on similar questions there I guess this is one of the many limitation of the new type inference algorithm it can t propagate types anywhere around lambdas Yeah that s not okay I don t understand the co contra variance on the current defer implementation especially since it doesn t seem to work This doesn t compile inside CovarianceTest java java @Test public void testDeferCovariance Observable defer new Func0 Observable Movie @Override public Observable Movie call if true return Observable from new HorrorMovie else return Observable from new ActionMovie Right now the signature is this java public final static T Observable T defer Func0 extends Observable T observableFactory it seems to work with lambdas when changed to this java public final static T Observable T defer Func0 Observable extends T observableFactory and definitely works with this java public final static T Observable T defer Func0 Observable T observableFactory Since type T is just passing through I don t understand what the extends is getting for us especially since the Movie example doesn t work Can you help me understand why co contra covariance is buying us on this method If it is not giving us anything then let s remove it so it works with lambdas If it actually does serve some value then let s create a new method no idea what to call it without co contra variance that works with lambdas for the far more common case I can t explain this but googling around indicates this to be a javac and JLS problem We can remove the extends after the Func0 We have this pattern on several operators so might worth checking them as well Thanks for the feedback I m going to change it to java public final static T Observable T defer Func0 Observable extends T observableFactory I also confirmed this code works as of Eclipse Luna 4 4M7 It does not work in the Kepler version where it compiles but never actually invokes the Observable inside defer Apparently that s not happy everywhere I need to change it to this java Observable T defer Func0 Observable T observableFactory or leave it like this java Observable T defer Func0 extends Observable extends T observableFactory in order for this code to compile java Observable String deferred Observable defer new Func0 Observable String @Override public Observable String call return null Have I mentioned before that I don t like dealing with extends super generics I want to make it like this java Observable T defer Func0 Observable T observableFactory I really dislike generics The only way to keep these 3 compiling is to leave the code as is java Observable Movie d Observable defer new Func0 Observable extends Movie @Override public Observable extends Movie call if true return Observable from new ActionMovie else return Observable from new HorrorMovie Observable String deferred Observable defer new Func0 Observable extends String @Override public Observable extends String call return null Observable String deferred2 Observable defer new Func0 Observable String @Override public Observable String call return null But this doesn t work with Java 8 lambdas The only thing I can think of doing is having a different operator without extends for the simple cases and supported by lambdas and leaving defer for the complicated ones using anonymous inner classes java defer Func0 extends Observable extends T observableFactory java someOtherName Func0 Observable T observableFactory Then comes the naming challenge there is no other overload of from that takes a Func so we could use that java from Func0 Observable T observableFactory or it could be a factory java factory Func0 Observable T observableFactory or fromFactory Func0 Observable T observableFactory The type of code this is trying to cater to is like this https github com benjchristensen ReactiveLab blob master reactive lab edge src main java io reactivex lab edge EdgeServer java#L46 @headinthebox What do you think the right solution is for this The issue might be with the Java 8 compiler There are some changes coming up in 8u20 which might affect this for the better Also it might be worth posting a question on lambda dev This works in Eclipse 4 4M7 for me with RxJava 0 18 3 java public class Test1 public static void main String args System out println defer 1 get Observable defer Observable from 1 subscribe System out println @SuppressWarnings unchecked public static T Supplier T defer Supplier extends Supplier extends T func return Supplier T func get Try compiling that code from Java 8 lgml bechristensen tmp benjchristensen Library Java JavaVirtualMachines jdk1 8 0 Contents Home bin javac cp rxjava core 0 18 3 jar TestDefer java TestDefer java 9 error method defer in class Observable T#2 cannot be applied to given types Observable defer Observable from 1 subscribe System out println required Func0 extends Observable extends T#1 found Observ om 1 reason no instance s of type variable s T#3 exist so that Observable T#3 conforms to extends Observable extends T#1 where T#1 T#2 T#3 are type variables T#1 extends Object declared in method T#1 defer Func0 extends Observable extends T#1 T#2 extends Object declared in class Observable T#3 extends Object declared in method T#3 from T#3 1 error This is with javac 1 8 0_05 Whether variance is nested the compiler falls over @akarnokd Since you are following the JDK 8_u20 stuff closer than us are these problems going to be solved or do we need to consider reducing support for co contra variance so that the normal use cases can work I can only be sure once 8u20 is released I take the upcoming Eclipse s compiler which doesn t have this problem is the indicator that the issue should be solved by the next release of javac However this http download java net jdk8u20 changes jdk8u20 b15 html q download jdk8u20 changes jdk8u20 b15 html preview build s change notes doesn t seem to mention the issue at hand I d say lets keep the current variance set and if the u20 release doesn t come before last week of June let s change the signatures Sounds good with variance you always loose Eclipse Luna 4 4 release works as expected I can t find any ETA on 8u20 but I guess they will release it right after we changed our signature Looks like August is when it is scheduled for GA release http openjdk java net projects jdk8u releases 8u20 html',RxJava,false,false,false
32874322,'Scheduler correctness improvements','Second round on the scheduler correctness issue Sure it looks more heavy as ScheduledAction now has its own inner CompositeSubscription and a shared reference to the parent innerSubscription I ve tried to benchmark it with SchedulerPerformanceTests but that test is flawed Multiple threads pound on the same long sum value so naturally additions get lost The LongObserver gets unsubscribed after the first loop so from will not actually call onNext but isUnsubscribed a lot Does not wait for the computations to finish and basically measures how fast 5M tasks can be added to the NewThreadScheduler s innerSubscription The flawed test gives 11M ops sec on my machine If I fix the test and run against the master 5M takes extremely long to finish due to the inherent slowness of add remove in CompositeSubscription if large On my 4 core hyperthread enabled machine I get 50k 150k ops second for baseline with a 100k loop The proposed changes run with the flawed test gives 10 8M ops sec With the test fixed and with the proposed changes I get 1 2M ops sec','RxJava pull requests #1070 https netflixoss ci cloudbees com job RxJava pull requests 1070 FAILURE Looks like there s a problem with this pull request @akarnokd do you need help porting it over to JMH I can assist with that That would be great but I don t know how to run a JHM benchmark from NetBeans @akarnokd ideally you run it from the command line as a encapsulated package Once you write the benchmark you package it up as a fat jar and then you can execute your test only ala gradlew benchmarks Pjmh f 1 tu ns bm avgt wi 5 i 5 r 1 OperatorSerializePerf but just replace the name of the benchmark with yours otherwise it will run this one or all if you leave it out Note that with some fiddling around I did this for netty you can fake it from your IDE by either writing a custom Junit runner or just doing it like this https github com netty netty blob master microbench src test java io netty microbench util AbstractMicrobenchmark java Looks like OnActionComplete is no longer used and could be removed True I m working on something else right now so I come back later to remove it RxJava pull requests #1074 https netflixoss ci cloudbees com job RxJava pull requests 1074 SUCCESS This pull request looks good I don t know how to run a JHM benchmark from NetBeans I always run them from command line See comments on how to run here https github com Netflix RxJava blob master build gradle#L92 you package it up as a fat jar This option also exists with the shadow task that needs to be renamed to something like benchmarkJar https github com Netflix RxJava blob master build gradle#L132 Here is the benchmark code https gist github com akarnokd 1f9817e60706569c28e1 Master results https gist github com akarnokd 3efcf8f47a1e988073f8 This implementation https gist github com akarnokd cb57b2ae5ea83ddc833c I added performance tests for observeOn and subscribeOn using Schedulers computation https github com Netflix RxJava blob master rxjava core src perf java rx schedulers ComputationSchedulerPerf java This pull request is far faster on startup when subscribing to an Observable of 1 item and somewhat faster on long running Observables gradlew benchmarks Pjmh f 1 tu ns bm avgt wi 5 i 5 r 1 ComputationSchedulerPerf #### New Code Result 235340 831 99 9 490947 687 ns op Statistics min avg max 90922 636 235340 831 420715 962 stdev 127497 555 Confidence interval 99 9 255606 856 726288 517 Benchmark size Mode Samples Mean Mean error Units r s ComputationSchedulerPerf observeOn 1 avgt 5 2180 371 207 253 ns op r s ComputationSchedulerPerf observeOn 1024 avgt 5 128238 555 17976 667 ns op r s ComputationSchedulerPerf observeOn 1048576 avgt 5 149856485 714 19627546 003 ns op r s ComputationSchedulerPerf subscribeOn 1 avgt 5 2197 782 267 688 ns op r s ComputationSchedulerPerf subscribeOn 1024 avgt 5 414051 806 1536527 849 ns op r s ComputationSchedulerPerf subscribeOn 1048576 avgt 5 235340 831 490947 687 ns op Result 1509019 668 99 9 4443411 014 ns op Statistics min avg max 300644 144 1509019 668 2913322 987 stdev 1153939 730 Confidence interval 99 9 2934391 346 5952430 682 Benchmark size Mode Samples Mean Mean error Units r s ComputationSchedulerPerf observeOn 1 avgt 5 2056 254 554 314 ns op r s ComputationSchedulerPerf observeOn 1024 avgt 5 101872 671 12964 522 ns op r s ComputationSchedulerPerf observeOn 1048576 avgt 5 147002257 143 9201133 563 ns op r s ComputationSchedulerPerf subscribeOn 1 avgt 5 2235 005 336 381 ns op r s ComputationSchedulerPerf subscribeOn 1024 avgt 5 550600 029 482135 695 ns op r s ComputationSchedulerPerf subscribeOn 1048576 avgt 5 1509019 668 4443411 014 ns op #### Master Result 63507 629 99 9 131757 785 ns op Statistics min avg max 38513 407 63507 629 123730 129 stdev 34217 078 Confidence interval 99 9 68250 156 195265 414 Benchmark size Mode Samples Mean Mean error Units r s ComputationSchedulerPerf observeOn 1 avgt 5 51867 073 77712 741 ns op r s ComputationSchedulerPerf observeOn 1024 avgt 5 118883 112 14487 931 ns op r s ComputationSchedulerPerf observeOn 1048576 avgt 5 154828171 429 20611654 844 ns op r s ComputationSchedulerPerf subscribeOn 1 avgt 5 68898 012 200669 541 ns op r s ComputationSchedulerPerf subscribeOn 1024 avgt 5 71403 833 209712 445 ns op r s ComputationSchedulerPerf subscribeOn 1048576 avgt 5 63507 629 131757 785 ns op Result 183126 150 99 9 1168534 854 ns op Statistics min avg max 37927 424 183126 150 725869 905 stdev 303464 791 Confidence interval 99 9 985408 704 1351661 004 Benchmark size Mode Samples Mean Mean error Units r s ComputationSchedulerPerf observeOn 1 avgt 5 50085 795 64485 544 ns op r s ComputationSchedulerPerf observeOn 1024 avgt 5 123673 009 3130 488 ns op r s ComputationSchedulerPerf observeOn 1048576 avgt 5 151220000 000 20063502 154 ns op r s ComputationSchedulerPerf subscribeOn 1 avgt 5 73814 774 202116 247 ns op r s ComputationSchedulerPerf subscribeOn 1024 avgt 5 72216 122 186483 284 ns op r s ComputationSchedulerPerf subscribeOn 1048576 avgt 5 183126 150 1168534 854 ns op One thing I don t like about how this is currently working is that we have to create the ScheduledAction each time and that feels wasteful when we immediately are putting it inside a queue inside PoolWorker It feels like we should be able to unsubscribe the queue and not need to maintain the CompositeSubscription of ScheduledAction instances This may fit with what @spodila is working on as I believe it will maintain a queue per Worker and the underlying threads will pull off the queues In other words by eliminating the use of Executor we get better control of the thread and can get rid of a layer of abstraction Going to merge this however as it is better than the current implementation and we ll continue improving this in #1149 Ooops I forgot to mention there might be some unwanted task executions after NewThreadScheduler is unsubscribed because executor shutdown does not remove pending tasks executor shutdownNow does it EventLoopScheduler is not affected because its worker keeps track of the tasks and cancels them',RxJava,true,false,false
32888637,'Rxscala improvement','Add dropUntil contains repeat doOnTerminate startWith publish variants to RxScala #1151 #1153 cc @headinthebox @samuelgruetter','RxJava pull requests #1071 https netflixoss ci cloudbees com job RxJava pull requests 1071 FAILURE Looks like there s a problem with this pull request Looks the failure is due to the cloudbees network issue RxJava pull requests #1075 https netflixoss ci cloudbees com job RxJava pull requests 1075 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1076 https netflixoss ci cloudbees com job RxJava pull requests 1076 SUCCESS This pull request looks good Scala users all okay with this I am',RxJava,true,false,false
32888973,'Add replay and multicast variants to RxScala','This PR has some breaking changes Change def multicast R T subject rx lang scala Subject R Subscription Observable R to def multicast R T subject rx lang scala Subject R ConnectableObservable R Change def replay Subscription Observable T to def replay ConnectableObservable T Remove Observable apply Int So it s better to merge it at the next major release #1152 #1153 cc @headinthebox @samuelgruetter','RxJava pull requests #1072 https netflixoss ci cloudbees com job RxJava pull requests 1072 SUCCESS This pull request looks good I d like someone with better Scala skills that me to review this please I ll code review it later today but in principle these are simple fixes to bring the other variants of publish in sync with returning connectable observable RxJava pull requests #1081 https netflixoss ci cloudbees com job RxJava pull requests 1081 SUCCESS This pull request looks good RxJava pull requests #1087 https netflixoss ci cloudbees com job RxJava pull requests 1087 SUCCESS This pull request looks good Is this reviewed and ready to go It is conflicting against master so can you please rebase This is also conflicting against #1178 I would like to rebase it after #1178 is merged to master Waiting until #1210 is merged Already merged RxJava pull requests #1129 https netflixoss ci cloudbees com job RxJava pull requests 1129 SUCCESS This pull request looks good Should this wait until we re ready to do 0 19 I think this one can be merged since #1188 has already broken the API @headinthebox @samuelgruetter do you mind it Go for it',RxJava,true,false,false
32891513,'Removed use of deprecated API from tests operators fixed year in head','ers added and removed suppressions fixed line endings replaced tabs with spaces I haven t deleted OnSubscribeFunc because I was not sure when the general cleanup of deprecated stuff will happen I just made sure Java tests don t use it anymore','RxJava pull requests #1073 https netflixoss ci cloudbees com job RxJava pull requests 1073 FAILURE Looks like there s a problem with this pull request This is some seriously heroic cleanup Thank you very much I m so glad to see SafeObservableSubscription gone Ditto Reviewing this again while doing release notes thank you again @akarnokd for this You took care of messy tedious things here that had been piling up for a while and was constantly on the TODO list',RxJava,true,false,false
32901650,'fix to remove drift from schedulePeriodic','When implementing the worker scheduler pattern in rxcpp I implemented schedulePeriodic differently because I predicted that the RxJava version would drift Once the changes were working I verified my prediction in rxcpp I decided to test the same in RxJava and contribute my approach This was my test java import java util concurrent TimeUnit import rx Scheduler import rx schedulers Schedulers import rx functions Action0 public class periodic public static void main String args final Scheduler scheduler Schedulers immediate final Scheduler Worker w scheduler createWorker final long initial TimeUnit SECONDS toMillis 2 final long period TimeUnit SECONDS toMillis 1 final long start scheduler now initial w schedulePeriodically new Action0 long count 0 @Override public void call long tick scheduler now System out println String format expected dms actual dms drift dms count period tick start tick start count period count initial period TimeUnit MILLISECONDS The existing impl causes this output java cp rxjava core build libs rxjava core 0 18 3 SNAPSHOT jar periodic expected 0ms actual 1ms drift 1ms expected 1000ms actual 1002ms drift 2ms expected 2000ms actual 2003ms drift 3ms expected 3000ms actual 3004ms drift 4ms expected 4000ms actual 4005ms drift 5ms expected 5000ms actual 5006ms drift 6ms expected 6000ms actual 6007ms drift 7ms expected 7000ms actual 7008ms drift 8ms expected 8000ms actual 8009ms drift 9ms expected 9000ms actual 9010ms drift 10ms expected 10000ms actual 10011ms drift 11ms expected 11000ms actual 11012ms drift 12ms expected 12000ms actual 12013ms drift 13ms expected 13000ms actual 13014ms drift 14ms expected 14000ms actual 14016ms drift 16ms expected 15000ms actual 15017ms drift 17ms expected 16000ms actual 16018ms drift 18ms expected 17000ms actual 17019ms drift 19ms expected 18000ms actual 18020ms drift 20ms expected 19000ms actual 19021ms drift 21ms expected 20000ms actual 20022ms drift 22ms expected 21000ms actual 21023ms drift 23ms expected 22000ms actual 22023ms drift 23ms expected 23000ms actual 23024ms drift 24ms With this commit the test outputs java cp rxjava core build libs rxjava core 0 18 3 SNAPSHOT jar periodic expected 0ms actual 3ms drift 3ms expected 1000ms actual 1001ms drift 1ms expected 2000ms actual 2001ms drift 1ms expected 3000ms actual 3000ms drift 0ms expected 4000ms actual 4001ms drift 1ms expected 5000ms actual 5000ms drift 0ms expected 6000ms actual 6000ms drift 0ms expected 7000ms actual 7000ms drift 0ms expected 8000ms actual 8001ms drift 1ms expected 9000ms actual 9001ms drift 1ms expected 10000ms actual 10001ms drift 1ms expected 11000ms actual 11001ms drift 1ms expected 12000ms actual 12001ms drift 1ms expected 13000ms actual 13001ms drift 1ms expected 14000ms actual 14001ms drift 1ms expected 15000ms actual 15001ms drift 1ms expected 16000ms actual 16001ms drift 1ms expected 17000ms actual 17000ms drift 0ms expected 18000ms actual 18000ms drift 0ms expected 19000ms actual 19000ms drift 0ms expected 20000ms actual 20000ms drift 0ms expected 21000ms actual 21002ms drift 2ms expected 22000ms actual 22000ms drift 0ms expected 23000ms actual 23001ms drift 1ms expected 24000ms actual 24001ms drift 1ms','RxJava pull requests #1077 https netflixoss ci cloudbees com job RxJava pull requests 1077 FAILURE Looks like there s a problem with this pull request Very nice thanks @kirkshoop While considering this I though of something but I haven t played with this enough to know exactly how it will behave but if someone chooses an interval of 1ms and the work being done each time takes longer than 1ms what is the expected behavior We should never have concurrent execution If I understand correctly it will result in a negative delay and result in scheduling it immediately but obviously have drift From what I can tell it does the right thing and just delays rather than allow concurrent execution java public class periodic public static void main String args final Scheduler scheduler Schedulers immediate final Scheduler Worker w scheduler createWorker final long initial 100 final long period 100 final long start scheduler now initial w schedulePeriodically new Action0 long count 0 @Override public void call try Thread sleep 1500 catch InterruptedException e long tick scheduler now System out println String format expected dms actual dms drift dms count period tick start tick start count period count initial period TimeUnit MILLISECONDS expected 0ms actual 1503ms drift 1503ms expected 100ms actual 3009ms drift 2909ms expected 200ms actual 4511ms drift 4311ms expected 300ms actual 6012ms drift 5712ms expected 400ms actual 7513ms drift 7113ms expected 500ms actual 9015ms drift 8515ms Based on this I m merging this as it is safe in the degraded case while being better in the normal case work being less time than the interval Yes that was the behavior before and I kept it There were only two options and skipping a period seemed like the wrong policy to me The user supplies both the function and the period and so they own the behavior they can return immediately to skip and get back on track or just ensure that the period was sufficient to begin with On May 6 2014 at 9 11 AM Ben Christensen notifications@github com mailto notifications@github com wrote Very nice thanks @kirkshoop https github com kirkshoop While considering this I though of something but I haven t played with this enough to know exactly how it will behave but if someone chooses an interval of 1ms and the work being done each time takes longer than 1ms what is the expected behavior We should never have concurrent execution If I understand correctly it will result in a negative delay and result in scheduling it immediately but obviously have drift Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 1162#issuecomment 42323326 This is an excellent improvement I m working on something that does microsecond level scheduling and this change makes it work very accurately ######################################################################################## Step 10 Interval 111micros Rate 9000 s ######################################################################################## Total Success 315237 Error 0 Last 10s Success 9001 s Error 0 s Latency 50th 0 90th 0 99th 0 100th 0 Total Success 360280 Error 0 Last 10s Success 9000 s Error 0 s Latency 50th 0 90th 0 99th 0 100th 0 Total Success 405334 Error 0 Last 10s Success 9001 s Error 0 s Latency 50th 0 90th 0 99th 0 100th 0 Total Success 450373 Error 0 Last 10s Success 9001 s Error 0 s Latency 50th 0 90th 0 99th 0 100th 0 Without this change it isn t even close ######################################################################################## Step 10 Interval 111micros Rate 9000 s ######################################################################################## Total Success 239363 Error 0 Last 10s Success 6835 s Error 0 s Latency 50th 0 90th 0 99th 0 100th 0 Total Success 273742 Error 0 Last 10s Success 6869 s Error 0 s Latency 50th 0 90th 0 99th 0 100th 0 Total Success 308053 Error 0 Last 10s Success 6863 s Error 0 s Latency 50th 0 90th 0 99th 0 100th 0 Total Success 342820 Error 0 Last 10s Success 6901 s Error 0 s Latency 50th 0 90th 0 99th 0 100th 0',RxJava,true,false,false
32911854,'Fix defer for Java 8 type inference','Fixes https github com Netflix RxJava issues 1157','',RxJava,true,false,false
32918871,'JMH Perf Tests for Schedulers computation','','',RxJava,true,false,false
32964753,'Update according to review in issue #1159','cc @samuelgruetter','RxJava pull requests #1080 https netflixoss ci cloudbees com job RxJava pull requests 1080 SUCCESS This pull request looks good @benjchristensen could you wait for this PR ready and merge it before you release 0 18 3 RxJava pull requests #1082 https netflixoss ci cloudbees com job RxJava pull requests 1082 SUCCESS This pull request looks good RxJava pull requests #1083 https netflixoss ci cloudbees com job RxJava pull requests 1083 SUCCESS This pull request looks good RxJava pull requests #1084 https netflixoss ci cloudbees com job RxJava pull requests 1084 SUCCESS This pull request looks good',RxJava,true,false,false
32994204,'Scheduler Improvements 507','NewThread EventLoop scheduler improvements proposal NewThreadScheduler There is no need to have an innerSubscription there as the underlying Executor knows what tasks are in its queue and a shutdown will cancel them anyway In the original version I made a small mistake by leaving out an innerSubscription add s which was one of the main contribution to the speed improvements did not affect correctness EventLoopScheduler An EventLoopScheduler needs to track its tasks so it can selectively cancel them in the NewThreadScheduler Since an ELS worker is single threaded the addition and removal of the completed tasks are more like queue operations adding a last item and removing a first item in CompositeSubscription can be expensive even if the size is small due to the copying and state machine overhead SubscriptionQueue Therefore I ve built a special array based ringbuffer queue called SubscriptionQueue which can resize itself as needed similar to ArrayDeque but behaves like a composite and queued items can be unsubscribed at once and provides the usual cancellation policy When benchmarked with a simple loop of add remove pair it gives 532 Mops s whereas CompositeSubscription gives 16 Mops s It uses synchronized as generally one needs to synchronize the producer s of tasks with the completion of the tasks on the worker thread where the producer count is likely small The initial queue capacity is 8 which favors fast tasks and the array fits nicely into a typical 64 byte cache line One unique property is that it dequeues based on object identity and not the head of the queue The reason for this is that when there are multiple producers queueing their subscriptions might happen in different order than their tasks are scheduled i e the head of the queue points to s1 while t2 gets scheduled first Perf tests I did some perf testing with ComputationSchedulerPerf but I ran into some trouble the initial 512M memory for the benchmark doesn t seem to be enough especially on a 4 8 core machine Both the master and this PR goes really slow or fails with GC errors because the internal queues of the Executors get flooded with tasks Each task is about 650 byte and having tens of thousands queued up consumes lot of memory I run the perftests with 1300M which was enough although still pounding on the GC Btw I don t understand the perf code does the subscribeOn test do 1M one time subscription or subscribes to a stream of 1M elements If the latter what are the tasks that hammer the executor Master https gist github com akarnokd 1fe0fb74f896c48c61a8 Benchmark size Mode Samples Mean Mean error Units r s ComputationSchedulerPerf observeOn 1 avgt 5 1944 238 64 954 ns op r s ComputationSchedulerPerf observeOn 1024 avgt 5 119353 236 1968 424 ns op r s ComputationSchedulerPerf observeOn 1048576 avgt 5 129596502 875 11464347 421 ns op r s ComputationSchedulerPerf subscribeOn 1 avgt 5 1659 862 462 385 ns op r s ComputationSchedulerPerf subscribeOn 1024 avgt 5 4643038 650 39587231 914 ns op r s ComputationSchedulerPerf subscribeOn 1048576 avgt 5 317353 904 566003 080 ns op This proposal https gist github com akarnokd 6d9ba66761c5bdb8ecd7 Benchmark size Mode Samples Mean Mean error Units r s ComputationSchedulerPerf observeOn 1 avgt 5 1858 486 73 600 ns op r s ComputationSchedulerPerf observeOn 1024 avgt 5 117680 475 2305 467 ns op r s ComputationSchedulerPerf observeOn 1048576 avgt 5 129298288 453 14093401 564 ns op r s ComputationSchedulerPerf subscribeOn 1 avgt 5 839 078 293 626 ns op r s ComputationSchedulerPerf subscribeOn 1024 avgt 5 51253 754 150446 345 ns op r s ComputationSchedulerPerf subscribeOn 1048576 avgt 5 371325 179 692740 819 ns op The ObserveOn test benefits minimally from the changes For the 1 onSubscribe it drops to 840ns For the other sizes I suspect hectic GC overhead so I can t declare a winner Generally since we use a lot of AtomicXYZ classes they add 24 bytes to the memory footprint every time a Subscription is present In order to get rid of them one would need to replace it with volatile fields and Unsafe calls to get the CAS functionality back Benchmarked on an i7 920 @ 2 66GHz 4 8 hyperthreaded cores 6GB total RAM Windows 7 x64 Java 7u55 x64','@akarnokd you can use the atomic field updaters http normanmaurer me blog 2013 10 28 Lesser known concurrent classes Part 1 Thanks I barely remembered them I d go for them but I have doubts on their performance due to lot of security checks and how Android would behave I found this http cs oswego edu pipermail concurrency interest 2011 November 008407 html thread which says even Java 7 moved away Oh ok They use it in netty which also works on android IIRC Might be wirth giving a shot and comparing GC Also mem in your case will go down I ll continue experimenting with the memory footprint tomorrow the addition and removal of the completed tasks are more like queue operations I believe this also covers throttleLast and debounce use cases where we are unscheduling previously scheduled tasks correct I thought about this and found a very common case which makes this still slow and or a memory hog let s schedule a task T1 with a long delay then start scheduling immediate tasks Because the T1 is not removed from the head of the queue the dequeueing of subsequent tasks end up doing O n lookup In addition since the head pointer is pinned once the tail wraps around it will grow the queue I have a few ideas to resolve this have a CompositeSubscription track the delayed tasks and SubscriptionQueue track the immediate tasks If using the improvements from PR #1145 both sides should be performing well in SubscriptionQueue do a compaction when head tail size capacity and grow otherwise Unfortunately throttleLast and debounce fall into this problem as well If there are no other tasks on the scheduler both perform well If interleaved with other tasks they get slow and wasteful The resolution may help them both RxJava pull requests #1086 https netflixoss ci cloudbees com job RxJava pull requests 1086 SUCCESS This pull request looks good Did some changes and experiments Switching to AtomicReferenceFieldUpdater in CompositeSubscription along with the Set switchover logic made the class speed up from 15 6Mops s to 17 1Mops s while reducing the memory footprint of 1M scheduled tasks from 289 MB to 269 MB In addition scheduling 1M tasks with long delays takes 12 minutes in master and 12 seconds with this construct Benchmarking with 512M memory still takes very long therefore I quit most apps and gave 3GB to the benchmark The detailed results are here https gist github com akarnokd 7dc973e181e280230c7d r s ComputationSchedulerPerf observeOn 1 avgt 5 1942 807 61 622 ns op r s ComputationSchedulerPerf observeOn 1024 avgt 5 118349 757 347 097 ns op r s ComputationSchedulerPerf observeOn 1048576 avgt 5 127616477 514 11356451 968 ns op r s ComputationSchedulerPerf subscribeOn 1 avgt 5 966 550 475 269 ns op r s ComputationSchedulerPerf subscribeOn 1024 avgt 5 40487 316 249552 416 ns op r s ComputationSchedulerPerf subscribeOn 1048576 avgt 5 92865 282 351942 131 ns op The single call case got a tiny bit more expensive because the emission of a single item unsubscribes the worker with two subscription containers The memory consumption was measured via heap dump when this program pauses java public class CompositeSubscriptionMemoryOverhead public static void main String args throws IOException int n 1024 1024 Worker w Schedulers computation createWorker for int i 0 i n i if i 128 1024 0 System out println i w schedule Actions empty 1 TimeUnit DAYS System out print Press ENTER to quit System in read @akarnokd did you also check with your proposed Unsafe call Would be interesting how that changes in comparison to the atomic field updater I started out with Unsafe on CompositeSubscription and gave 17 2Mops s for add remove but the build started to complain about using it I guessed @benjchristensen wouldn t want that and the performance difference is so small it was not worth it I ll post a new PR to catch up with master',RxJava,true,false,false
33036107,'RxScala Let s add Monad and Applicative instance','Hi folks As I showed in my repo everpeace observable canbe monad https github com everpeace observable canbe monad Observable can be monad List like and applicative functor ZipList like As functional programming community proved monadic computation gives us really powerful syntax for composing transforming them I know Observable already provides many useful combinators However providing monad applicative instance could provide more powerful and intuitive syntax about composing transforming Observable to users like below And some useful operators provided by scalaz can be used e g operator scala The case evaluated as List like monad this is equivalent with Observable 3 4 6 8 for v Observable 1 2 w Observable 3 4 yield v w Observable 1 2 Observable 3 4 _ _ The case evaluated as ZipList like applicative this is equivalent with Observable 3 8 for v Observable 1 2 w Observable 3 4 yield v w Observable 1 2 Observable 3 4 _ _ Then I would be happy if I could hear opinions from RxScala contributors Would it be really useful if RxScala includes some functional typeclass instances If so what is the best way to contribute I think it would be better that we introduce rx lang scala scalaz package in language adaptors rxjava scala or new contrib project like rxjava scalaz in rxjava contrib directory','I also find foreach is missing cc @headinthebox @samuelgruetter @zsxwing Yeah Thanks for pointing out what is missing I recognize that some type class instances are missing for example traversable foldable and so on I am pleased to contribute these instances as well Let s list them Regarding foreach It is blocking so it s not in Observable but in BlockingObservable Theoretically it would also be possible to make a non blocking foreach but in C# and Java it s blocking and I think it wouldn t be a good idea to change the semantics And @everpeace your contributions are welcome just make sure that the main rxjava scala package has no dependency on scalaz @samuelgruetter Thanks for pointing out semantic gap issue I agree with your opinion I will add type class instances which preserve Observable s semantics So which is better do you think May I add a dependency to scalaz to rxjava scala Or another project in rxjava contrib is better I d say do another project the goal is to try tokeepthe core of Rx all flavored lean and mean and let people to chose if they want additional stuff and no depend cries on Scalaz KISS @headinthebox Thanks for leading a direction I should follow OK I will create a project rx scalaz or something in rxjava contrib folder I will take a week off in the next week So I will make PR around the end of this month Thanks',RxJava,false,false,false
33047741,'IOS Support','Are you interested in implementing Schedulers for iOS and OS X for applications using robovm','Yes I am So tell me how can I contribute What are the next steps I would more than happy to be part of this',RxJava,false,false,false
33050356,'Notice Slower Involvement For A Couple Days','Since there isn t another mechanism for communicating as targeted as the Github issues I m abusing it for a moment to let contributors know I ll be a little slower in reviewing things for the next few days as my 3rd child should be born tomorrow Thursday Friday I ll try and review the outstanding PRs before but don t know I ll be able to get them all handled Please continue as normal without me and I ll merge review release once my schedule permits','1 literally',RxJava,false,false,false
33053850,'fix to allow schedulePeriodic to work after 2262','Thinking further I realized that the schedulePeriodically in #1162 would begin to fail at Fri Apr 11 16 47 16 PDT 2262 If this is deemed too soon to fail then the solution in this commit will still be working in 292million years','RxJava pull requests #1085 https netflixoss ci cloudbees com job RxJava pull requests 1085 SUCCESS This pull request looks good I tend to prefer the existing simplicity I m not worried about any of this code existing in 2262 Is anyone else Yes this is a simple trade off between complexity and correctness I am content either way However a virtual time scheduler can fail today by making now return a larger millisecond value then can be represented in nanoseconds @akarnokd What do you think about this I m not particularly worried about this since other components might fail long before that date is reached I m more worried about the inability to cancel a concrete periodic schedule after the first invocation as the cancellation token is lost I m not particularly worried about this since other components might fail long before that date is reached Agreed',RxJava,true,false,false
33058134,'Marble diagram source file rx operators graffle is corrupted due to merge conflicts','The marble diagram source file at https raw github com wiki Netflix RxJava images rx operators graffle is corrupted due to a merge conflict during the latest commit git log 1 images rx operators graffle commit a7d73bcadf719bce2266f9fff17beebc2240c75a Merge c8c10b3 798c14c Date Tue May 6 10 01 58 2014 0700 Merge branch master of https github com Netflix RxJava wiki Conflicts images rx operators graffle images rx operators window6 png images rx operators window8 png It contains loads of conflict markers and thus fails to open in OmniGraffle','I ll try to check in a fix this morning Git hiccuped on me yesterday and mangled a few things and I m still trying to unwind the damage On Wed May 7 2014 at 11 37 PM rreimann notifications@github com wrote The marble diagram source file at https raw github com wiki Netflix RxJava images rx operators graffle is corrupted due to a merge conflict during the latest commit git log 1 images rx operators graffle commit a7d73bcadf719bce2266f9fff17beebc2240c75a Merge c8c10b3 798c14c Date Tue May 6 10 01 58 2014 0700 Merge branch master of https github com Netflix RxJava wiki Conflicts images rx operators graffle images rx operators window6 png images rx operators window8 png It contains loads of conflict markers and thus fails to open in OmniGraffle Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1171 David M Gross PLP Consulting Okay https raw github com wiki Netflix RxJava images rx operators graffleis now uncorrupted On Thu May 8 2014 at 8 40 AM PLP Consulting David Gross davgross@netflix com wrote I ll try to check in a fix this morning Git hiccuped on me yesterday and mangled a few things and I m still trying to unwind the damage On Wed May 7 2014 at 11 37 PM rreimann notifications@github com wrote The marble diagram source file at https raw github com wiki Netflix RxJava images rx operators graffleis corrupted due to a merge conflict during the latest commit git log 1 images rx operators graffle commit a7d73bcadf719bce2266f9fff17beebc2240c75a Merge c8c10b3 798c14c Date Tue May 6 10 01 58 2014 0700 Merge branch master of https github com Netflix RxJava wiki Conflicts images rx operators graffle images rx operators window6 png images rx operators window8 png It contains loads of conflict markers and thus fails to open in OmniGraffle Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1171 David M Gross PLP Consulting David M Gross PLP Consulting Opening the file works again thanks a lot',RxJava,false,false,false
33090554,'ObserveOn Change to batch dequeue','Using the same batch technique as in SerializedObserver to dequeue and play values I had to switch to synchronized because ConcurrentLinkedQueue doesn t support drain I run the scheduler perf test with it Result 1913 582 99 9 29 210 ns op Statistics min avg max 1905 303 1913 582 1922 427 stdev 7 586 Confidence interval 99 9 1884 373 1942 792 Result 64 277 546 99 9 734 360 ns op Statistics min avg max 64034 953 64277 546 64519 884 stdev 190 711 Confidence interval 99 9 63543 186 65011 906 Result 67 999 392 293 99 9 4715885 625 ns op Statistics min avg max 66777535 133 67999392 293 69525773 000 stdev 1224700 521 Confidence interval 99 9 63283506 668 72715277 918 Master for me was 1863 423 119 030 536 127 738 858 250 Appears to be a 2x speedup on 1024 and 1M items','RxJava pull requests #1088 https netflixoss ci cloudbees com job RxJava pull requests 1088 SUCCESS This pull request looks good Nice improvement What do you think of us getting a high performing non blocking queue implementation in RxJava core For example things similar to http high scale lib sourceforge net http psy lob saw blogspot com 2013 04 lock free ipc queue html and discussions in https groups google com forum # forum mechanical sympathy Everywhere we re currently using java util concurrent for queues or creating our own that involve synchronized we have opportunities for improvement I agree We need more performing queues and I ve been looking at options lately to get a few nanoseconds off of schedulers My thoughts so far on the subject Bounded vs unbounded most examples I saw was using bounded queues but we just can t replace our queues with bounded ones because we don t know how many producers there are and how many messages to cache in general many operators especially the schedulers may enqueue work items from the same thread and would deadlock if the queue is full Throughput vs latency it appears that most algorithms will come with a tuning parameter to make one or the other better but rarely both In general it might be possible to get an improvement on both in respect of the current implementation',RxJava,true,false,false
33093295,'RxScala Bug','scala def wrap T src Observable T Observable T Observable subscriber println subscribed subscriber add src subscribe x subscriber onNext x e subscriber onError e subscriber onCompleted works but this crashes scala def wrap T src Observable T Observable T Observable subscriber println subscribed subscriber add src subscribe subscriber','To be sure this works java public class ComeCrash public static T Observable T wrap Observable T source return Observable create Subscriber super T subscriber System out println Subscribed subscriber add source subscribe subscriber public static void main String args wrap Observable just 1 subscribe System out println Throwable printStackTrace System out println Done Closing as #1178 is merged',RxJava,false,false,false
33093963,'SubjectSubscriptionManager should be public','Hiding SubjectSubscriptionManager and making all Subject implementations final makes it hard to create subjects with custom behavior Please make this class public','SubjectSubscriptionManager was not designed to be used outside the subjects package changing it to support public usage would increase its overhead by a factor of 2 What kind of Subject behavior do you need Yes SubjectSubscriptionManager is very much an internal implementation detail and non trivial It is not something we want to make public if for no other reason than the fact that it would then never be able to be changed Most new Subject implementations can be built on top of existing such as PublishSubject using composition instead of inheritance so it would be good to know what use case can not be achieved through composition I have a use for a one and done subject where each subscriber gets a single item and then completes This single item is either the most recently received item in the past or if no items have been received yet it waits for the next one So it s sort of like BehaviorSubject subscribe s first except with no initial default item Can you think of a way to do this through composition It would seem to require access to the subscriber list and I m trying to avoid rewriting what s already done inside SubjectSubscriptionManager On May 8 2014 11 56 AM Ben Christensen notifications@github com wrote Yes SubjectSubscriptionManager is very much an internal implementation detail and non trivial It is not something we want to make public if for no other reason than the fact that it would then never be able to be changed Most new Subject implementations can be built on top of existing such as PublishSubject using composition instead of inheritance so it would be good to know what use case can not be achieved through composition Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1174#issuecomment 42575188 behaviourSubject drop 1 first I still want the first item but only if it came from the the source observable instead of BehaviorSubject s default value On May 8 2014 5 49 PM Dylan Sale notifications@github com wrote behaviourSubject drop 1 first Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1174#issuecomment 42615862 Make the default a sentinel then use a predicate with first to check it isn t that On my phone so sorry for the formatting java final Foo sentinel new Foo BehaviourSubject b BehaviourSubject create sentinel b first f f sentinel I ve considered adding BehaviorSubject create without a default for this case as I ve had to use the sentinel solution before and it s awkward Why not use asyncsubject AsyncSubject is only the last value after completed not last value and all subsequent have a use for a one and done subject where each subscriber gets a single item and then completes Oh Missed that part Yup that s AsyncSubject The difference is that I want the subscriber to complete after one item even though the source observable is still active On May 8 2014 6 55 PM Ben Christensen notifications@github com wrote Oh Missed that part Yup that s AsyncSubject Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1174#issuecomment 42620431 Sounds like AsyncSubject take 1 subscribe Sorry Publish or BehaviorSubject and take 1 Not AsyncSubject How about this java public class TakeOne static final class Client extends Subscriber Integer final int id public Client int id this id id @Override public void onNext Integer t System out printf d s n id t @Override public void onError Throwable e System out printf d s n id e @Override public void onCompleted System out printf d s n id Done public static void main String args PublishSubject Integer source PublishSubject create ConnectableObservable Integer intermediate source replay 1 intermediate connect Observable Integer result intermediate replay o o take 1 Client c1 new Client 1 result subscribe c1 source onNext 1 source onNext 2 Client c2 new Client 2 result subscribe c2 source onNext 3 Client c3 new Client 3 result subscribe c3 Client c4 new Client 4 result subscribe c4 source onNext 4 Client c5 new Client 5 result subscribe c5 prints 1 1 1 Done 2 2 2 Done 3 3 3 Done 4 3 4 Done 5 4 5 Done It may require PR #1175 to work correctly Also we seem to have found an use case for replay Func1 I ve considered adding BehaviorSubject create without a default for this case as I ve had to use the sentinel solution before and it s awkward 1 this would be great to have @akarnokd That seems to work thank you Though my unit tests for this implementation also pass when just using this intermediate take 1 subscribe c What is the reason for the replay Func1 call BehaviorSubject create is merged https github com Netflix RxJava blob master rxjava core src main java rx subjects BehaviorSubject java#L75 Anything else needed before closing this issue Looks like that should work On Tue May 20 2014 at 3 14 AM Ben Christensen notifications@github com wrote Anything else needed before closing this issue Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1174#issuecomment 43597727',RxJava,false,false,false
33126701,'Fixed synchronous ConnectableObservable connect problem','ConnectableObservable connect returns a Subscription and thus cannot be unsubscribed synchronously similar how take didn t work before the Subscriber changes This PR modifies the ConnectableObservable and its current implementation OperatorMulticast to extract the connection Subscription token before it is connected to the source Cancelling this extracted token makes sure the synchronous connection is unsubscribed The Rx NET version of the test case seemingly doesn t exhibit the problem I suspect it is the interplay of IDisposable s','RxJava pull requests #1089 https netflixoss ci cloudbees com job RxJava pull requests 1089 SUCCESS This pull request looks good',RxJava,true,false,false
33146187,'Add Observable endWith','I m using Observable startWith but would also like to use a new method Observable endWith say I suppose concat is not available because of static method with same signature after erasure The driver for me is that my code in java is heaps uglier without it Suppose I have source1 source2 and I want to do some stuff to source1 and then append source2 I have three options Use static concat java Observable concat source1 take 20 buffer 2 1 filter myFilter source2 Use startWith java source2 startWith source1 take 20 buffer 2 1 filter myFilter or use a new endWith method java source1 take 20 buffer 2 1 filter myFilter endWith source2 The last one is much clearer Am I overlooking something or can we can add this method to the api Perhaps a method like append is better because it might seem strange to see multiple concatenated endWiths java source1 endWith source2 endWith source3 or java source1 append source2 append source3','If we can t make concat overloads work the append idea is interesting and makes sense to me java public final static T Observable T concat Observable extends Observable extends T observables is the signature that prevents an extra overload for endWith behaviour Do you think the method name should pair nicely with startWith That is should we have a pair of methods startWith endWith or prepend append or some other pair I never understood why we don t have a concat as an instance method i e xs concat ys as in NET http msdn microsoft com en us library hh212146 v vs 103 aspx No need for alpha renamings like append or endswith A concat instance method would be nice Perhaps we could rename the clashing static concat Observable Observable method to concatAll or even to flatten Hmm flatten I realize is not a great choice because flatMap merges rather than concatenates Aha I see Java does not allow the same name for static and instance methods that s the price you pay for being able to call a static method on an instance Java allows the same name but not signature and additionally because of type erasure doesn t differentiate between concat Observable T and concat Observable Observable T any possibility of a rename of concat Observable Observable @benjchristensen Well the problem with removing that is that it matches the merge mergeDelayError switchOnNext signatures We now have concatWith as an instance method java public final Observable T concatWith Observable extends T t1 You can now write code like this java public static void main String args Observable Integer source1 Observable from 1 2 3 4 5 Observable Integer source2 Observable range 100 5 source1 take 20 buffer 2 1 filter l l size 2 map l l get 0 l get 1 concatWith source2 forEach System out println This outputs 3 5 7 9 100 101 102 103 104',RxJava,false,false,false
33149092,'GroupByUntil to use BufferUntilSubscriber','Matches groupBy behavior I still think throwing an error for non first subscribers is too harsh','RxJava pull requests #1090 https netflixoss ci cloudbees com job RxJava pull requests 1090 FAILURE Looks like there s a problem with this pull request I still think throwing an error for non first subscribers is too harsh What would you do differently that doesn t either require multicasting and re create the problem of losing messages or unbounded buffering and memory bloat to not lose messages I would implement a replayFirst and replayAll methods on the GroupedObservable and let the programmer decide The default behavior would be a simple publish The problem with the BufferUntilSubscriber is that there is no way to request a different behavior I think that would still require buffering everything as they could change their mind at any time and invoke replayAll Can you provide use cases where replayFirst and replayAll would be used Here is how I think of groupBy and the various challenges it has java o groupBy function skip 1 flatMap group if something return group map t do stuff else return group replayAll map t do stuff In this case publish is done on some replayAll done on some and 1 is skipped For the skipped one there is no way for us to know it was skipped or subscription is just being delayed BufferUntilSubscriber still doesn t have a good solution for this and will have a memory leak as noted in its comments java This currently has temporary unbounded buffers It needs to become bounded and then do one of two things 1 blow up and make the user do something about it 2 work with the backpressure solution still to be implemented such as co routines For the ones that are subscribed to under what circumstance would replayAll or replayFirst be used If suggests the developer is capturing the GroupedObservable s storing them and subscribing to them multiple times That just doesn t make sense inside a groupBy A GroupedObservable inside a groupBy should be subscribed to once inside the flatMap Like all other Observable s if it is intended to be shared the developer should use replay publish multicast s or whatever fits their use case Also if we put replayFirst and replayAll on GroupedObservable this means that every GroupedObservable has just been made into a ReplaySubject which should not be a requirement of a GroupedObservable It would help me if you could provide concrete examples of why replayFirst and replayAll would be helpful and how they wouldn t cause other problems like unbounded buffers that we also need to solve Unfortunately I can t give concrete use cases for this I have some expectation of correctness and behavior but I don t have real requirements coming from real world use I think the current BufferUntilSubscriber does what most users would expect when they concat or merge groups so let s leave it this way and put emphasis on auto connecting replay i e replayAll and publish i e the original publish behavior Okay I fully agree that BufferUntilSubscriber feels like a hack and we are definitely making trade offs My goal is to keep those hacks internal and not modify public APIs and allow us to improve over time as our ideas on this improve I didn t quite understand this part put emphasis on auto connecting replay i e replayAll and publish i e the original publish behavior Do you mean just in the documentation Do you mean just in the documentation I meant a replay and publish overload that auto connects instead of returning ConnectableObservable if we want such overloads instead of the longer publish refCount',RxJava,true,false,false
33157517,'Fix issue #1173','In Subscriber apply rx Subscriber asJavaObserver and asJavaSubscription will be set to null because the parent class will be initialized with asJavaSubscriber null #1173 This PR did the initialization again in the subclass','@headinthebox s example also inspires me that the inner Subscriber can not be unsubscribed from outside if RxScala does not provide a subscriber Subscriber Because subscriber Observer will create a new Subscriber but won t chain the Subscription in the outer Subscriber The test is testUnsubscribeForSubscriber cc @samuelgruetter RxJava pull requests #1096 https netflixoss ci cloudbees com job RxJava pull requests 1096 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1097 https netflixoss ci cloudbees com job RxJava pull requests 1097 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1110 https netflixoss ci cloudbees com job RxJava pull requests 1110 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1113 https netflixoss ci cloudbees com job RxJava pull requests 1113 FAILURE Looks like there s a problem with this pull request @samuelgruetter any suggestions about this one Waiting on feedback and confirmation I ll have a look over the weekend The problem is that the three vals asJavaObserver asJavaSubscription asJavaSubscriber defined in trait Subscriber are not in the right order It should first define asJavaSubscriber because the other two are defined in terms of asJavaSubscriber and initialization of vals is done sequentially Good catch RxJava pull requests #1124 https netflixoss ci cloudbees com job RxJava pull requests 1124 SUCCESS This pull request looks good thanks for staying on top LGTM @benjchristensen can you merge this Thanks',RxJava,true,false,false
33182471,'Add facilities for creating Observables from JavaFX events and Observabl','eValues Provides a Scheduler implementation ensuring execution in the JavaFX UI thread a Subscription implementation ensuring that un subscription happens in JavaFX UI thread an Observable factory method for observing UI events on JavaFX nodes an Observable factory method for observing value changes of a JavaFX ObservableValue Also the rxjava javafx is added to the gradle build','RxJava pull requests #1091 https netflixoss ci cloudbees com job RxJava pull requests 1091 FAILURE Looks like there s a problem with this pull request Close due to build error and incomplete test Will propose again later This will be super useful For subscribing on the UI thread there is subscribeon so you should ideally not need a special subscription for that',RxJava,true,false,false
33182512,'PublishSubject is broken','Can I ask someone to explain me why this code terminates without writing out anything PublishSubject String s PublishSubject create Subscription subscribe s replay 1 doOnNext new Action1 String @Override public void call String t1 System out println t1 subscribe s onNext hello While debugging I see that the subject has no subscribers True there are no direct subscribers but the replay creates a multicast connection','replay creates a ConnectableObservable which you need to call connect on otherwise it won t do anything java ConnectableObservable co s replay 1 co doOnNext v System out println v subscribe co connect s onNext hello Thank you that explains the operation And also shows that the connect is a must so it is not possible to chain the calls as I did Then what is the point of having replay return anything that resembles an Observable Or is there some autoconnect method too There isn t any simple operator for that though there is an enhancement request somewhere among the issues to add those variants The closest auto connect version is this java s replay o o 1 doOnNext subscribe Ugh this doesn t look good Especially in Java if that nop function has no static method creator Thanks again Note that if you think you need subjects there is a 99 chance you can find a more elegant solution that does not require subjects Really There isn t any simple operator for that There is refCount that does auto connect Thank you for the support I ll look at refCount At the same time I see that the API of replay is exactly the same as the NetRx version s So I guess the semantics is the same in both implementations But the documentation is very ambiguous in both places At least for me as a non native English speaker It says can be connected and disconnected It doesn t mention that nothing is going to happen until is is connected because it starts in disconnected state Nor does replay mention that it starts disconnected The modifier able in the ConnectAbleObserver feels like it s just an addition and doesn t change semantics of the Observer interface But this is not true and it leads to misuse of the API Probably an explicit note in the documentation about replay returning a disconnected by default Observer will help solve this confusion @headinthebox I know I usually try to avoid subjects However I have a two way causal chain in my case In one way goes the calculation result in the other way goes the cancellation It s possible to implement without subjects but it will not differ much from what subjects already provide and it would break the scope of my signals Currently every signal is used only inside a single object and it is pretty easy to follow it this way Also it makes debugging a lot easier But thanks for the note The wiki documentation is more explicit about the need to call connect https github com Netflix RxJava wiki Connectable Observable Operators On Fri May 9 2014 at 12 00 PM andrask notifications@github com wrote Thank you for the support I ll look at refCount At the same time I see that the API of replay is exactly the same as the NetRx version s So I guess the semantics is the same in both implementations But the documentation is very ambiguous in both places At least for me as a non native English speaker It says can be connected and disconnected It doesn t mention that nothing is going to happen until is is connected because it starts in disconnected state Nor does replay mention that it starts disconnected The modifier able in the ConnectAbleObserver feels like it s just an addition and doesn t change semantics of the Observer interface But this is not true and it leads to misuse of the API Probably an explicit note in the documentation about replay returning a disconnected by default Observer will help solve this confusion @headinthebox https github com headinthebox I know I usually try to avoid subjects However I have a two way causal chain in my case In one way goes the calculation result in the other way goes the cancellation It s possible to implement without subjects but it will not differ much from what subjects already provide and it would break the scope of my signals Currently every signal is used only inside a single object and it is pretty easy to follow it this way Also it makes debugging a lot easier But thanks for the note Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1180#issuecomment 42701498 David M Gross PLP Consulting @DavidMGross Adding that single line to the replay documentation would be enough to spare the headache with the returned connectable observer Your wish is my command https github com Netflix RxJava commit 50b618e426075ff3267788ccfd1c78c039234bab On Fri May 9 2014 at 1 08 PM andrask notifications@github com wrote @DavidMGross https github com DavidMGross Adding that single line to the replay documentation would be enough to spare the headache with the returned connectable observer Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1180#issuecomment 42708058 David M Gross PLP Consulting @DavidMGross You re awesome Instead of whining I should have done it Fortunately there is always next time in open source and I love it',RxJava,false,false,false
33183862,'Behavior subject time gap fix','This fix should make sure subscribing between two event emissions won t create a gap in the received events I had to implement my own subscription management to ensure the required coordination behavior Performance comparison for simple pass through behavior PublishSubject master 86 MOps s BehaviorSubject master 47 MOps s BehaviorSubject this 46 MOps s The relative slowness compared to PS is due the volatile write on each element and the additional 1MOps s is due to the subscription coordination','RxJava pull requests #1092 https netflixoss ci cloudbees com job RxJava pull requests 1092 SUCCESS This pull request looks good I had to implement my own subscription management to ensure the required coordination behavior Can this really not be done with SubjectSubscriptionManager Having it be different makes an already complicated set of logic now be implemented in two different ways Why would the others not benefit from the same improvements Its more like an augmentation than an improvement over the existing subject subscription management At first glance I d need to add 1 2 callback points to an already complicated SSM I can t say for sure until I try to reimplement the other Subjects and see what are the common points I d rather not proceed with this change until we know the implications across all of them It s hard enough working with Subjects without 2 slightly different implementations of the same thing Closing this as outdated See #1185 for the new proposal',RxJava,true,false,false
33186165,'Add facilities for creating Observables from JavaFX events and ObservableValues','Heavily inspired by the swing contrib Provides a Scheduler implementation ensuring execution in the JavaFX UI thread a Subscription implementation ensuring that un subscription happens in JavaFX UI thread an Observable factory method for observing UI events on JavaFX nodes an Observable factory method for observing value changes of a JavaFX ObservableValue Also the rxjava javafx is added to the gradle build','The build is failing on the bot Looking at the output it looks like the deployed jdk do not provide the javafx bits Every Oracle JDK 7u15 bundles JavaFX so I guess we are in one of those sitiations the bot s jdk is outdated the bot s jdk do no contains JavaFX as it is the case with openjdk somehow the javafx jars are not exported in the build Should the module gradle definition explicitly state dependency on JDK 7u15 RxJava pull requests #1093 https netflixoss ci cloudbees com job RxJava pull requests 1093 FAILURE Looks like there s a problem with this pull request Answering to headinthebox remark on the previous PR For subscribing on the UI thread there is subscribeon so you should ideally not need a special subscription for that Do subscribeOn guarantees that the __un__ subscription callback runs using the same scheduler as the OnSubscribe Func Do subscribeOn guarantees that the un subscription callback runs using the same scheduler as the OnSubscribe Func Based on previous discussions it has been considered that there may still be cases where unsubscribe could arrive from other threads See these discussions https github com Netflix RxJava pull 890 https github com Netflix RxJava pull 880#issuecomment 35163539 https github com Netflix RxJava pull 869 If you need unsubscribe to happen on a particular thread you can use unsubscribeOn I m trying to remember why subscribeOn can t do it re reading those previous posts to try and remember Should the module gradle definition explicitly state dependency on JDK 7u15 The build is using Java 7 If the version of Java 7 is old that will require more effort to resolve as we ll have to get CloudBees involved Hi @benjchristensen Thanks for your quick feedback If you need unsubscribe to happen on a particular thread you can use unsubscribeOn Do you think this responsibility should be left to the user code or enforced withing the Observable creation method In the swing module it is handled by the SwingObservable implementation to ensure thread safety and doesn t use unsubscribeOn',RxJava,true,false,false
33188981,'NotificationLite accept performance improvements','This is a proposal for speeding up the accept method i e reducing its latency Benchmark comparison direct onNext 488 MOps s master accept 378 MOps s this accept 477 MOps s i7 4770K JDK 1 8u5 x64','RxJava pull requests #1094 https netflixoss ci cloudbees com job RxJava pull requests 1094 SUCCESS This pull request looks good',RxJava,true,false,false
33200416,'BehaviorSubject concurrent subscription and sending is broken','BehaviorSubject should ensure that the last notification always reaches the subscriber When the subscription and sending happens concurrently there is a high probability that this property gets broken Test has been prepared that easily reproduces the error https gist github com andrask fc06abfd70daa6f91edb#file behaviorsubjectsubscribeandsendconcurrently java The test involves two threads 1 trying to subscribe 2 trying to send next These are carefully coordinated to allow real concurrent execution The test is that the subscriber must receive the sent value The issue almost certainly happens in a few hundred retries Note that with a Thread sleep 1 https gist github com andrask fc06abfd70daa6f91edb#file behaviorsubjectsubscribeandsendconcurrently java L41 the issue goes away Note that the test is something I distilled from what I saw in my production code There may be little issues with it but the concurrency problem certainly exists as it is reproducibly just by stepping through the code','Thanks for the test case I m currently improving the BehaviorSubject and the new code passes this test @andrask This has been merged to master if you can validate against that prior to release The tests in https gist github com andrask fc06abfd70daa6f91edb#file behaviorsubjectsubscribeandsendconcurrently java are passing for me Closing this out as it looks fixed Please re open if it s not and can be demonstrated I d still appreciate confirmation if you can @benjchristensen thank you for the notice I wanted to try today but got overwhelmed by other stuff I cloned the repo and started installing with gradlew install but the process stopped at a lib it couldn t download and I didn t have more time to debug the reason I ll try again tomorrow with different network settings I m sure the issue is with my setup Fortunately removing the current workaround from the code is quite easy so it will be simple to see whether this worked Sadly I use hystrix as well which makes it hard to apply the new RxJava version even if it comes out some time in the near future Thanks @andrask Hystrix 1 3 16 and Hystrix 1 4 should both be fully compatible with the current set of changes as both of those support RxJava 0 18 Since I work on both projects I m keeping Hystrix moving forward Is there anything specific about Hystrix Rx that isn t working well that I can solve I confirm that the new version works The combo works well I ll check again why I wasn t able to upgrade the last time I think I only upgraded RX and this is why it failed Thanks for confirming Yes Hystrix had to be upgraded to work It is no longer using any deprecated Rx code so should be safe as we re nearing the end of changes and almost to 1 0',RxJava,false,false,false
33215641,'Behavior subject time gap fix 2','Based on discussions in #1181 I ve unified the behavior among the Subjects BehaviorSubject doesn t seem to exhibit issue #658 and #1184 A second pair of eyes would be great to confirm the correctness and check if the removal of the CountDownLatch was the correct approach','RxJava pull requests #1095 https netflixoss ci cloudbees com job RxJava pull requests 1095 FAILURE Looks like there s a problem with this pull request Wow this is quite the change I need fresher eyes on this one so will come back to it Thank you very much for tackling this This is non trivial code so I may have missed something but this looks like excellent forward progress on what we had to add the functionality needed for BehaviorSubject and sharing the logic across all of the Subject impls Very nice work',RxJava,true,false,false
33273156,'Co Contra variance madness','Try to use the overload of mergeMap with 3 function with lambdas and you get the most beautiful error message ever in reality times 3 Error 32 24 java no suitable method found for mergeMap anonymous rx functions Func1 java lang String rx Observable extends java lang Void anonymous rx functions Func1 java lang Throwable rx Observable extends java lang Void respon ose method rx Observable R mergeMap rx functions Func1 super java lang String extends rx Observable extends R is not applicable cannot infer type variable s R actual and formal argument lists differ in length method rx Observable R mergeMap rx functions Func1 super java lang String extends rx Observable extends R rx functions Func1 super java lang Throwable extends rx Observable extends R rx functions Func0 extends rx Observable extends R is not applicable cannot infer type variable s R argument mismatch bad return type in lambda expression rx Observable java lang Void cannot be converted to extends rx Observable extends R method rx Observable U R mergeMap rx functions Func1 super java lang String extends rx Observable extends U rx functions Func2 super java lang String super U extends R is not applicable cannot infer type variable s U R actual and formal argument lists differ in length Maybe I have not tried we can tone done on the extends and super in the signature a bit to avoid nesting generic types which seems to confuse the Java compiler','Related https github com Netflix RxJava issues 1157 Have you figured out anything you want to do here I ll have another look Maybe now that Java is real the typechecker has improved',RxJava,false,false,false
33275427,'RxScala Schedulers','I think it is a mistake to use Unit Unit instead of Unit Any takers or I ll fix it later this week trait Worker extends Subscription private scala val asJavaWorker rx Scheduler Worker Schedules a cancelable action to be executed in delayTime def schedule action Unit Unit delayTime Duration Subscription this asJavaWorker schedule new Action0 override def call Unit action delayTime length delayTime unit Schedules a cancelable action to be executed immediately def schedule action Unit Unit Subscription this asJavaWorker schedule new Action0 override def call Unit action','The original implementation uses action Unit Do you think which one is better I prefer action Unit Unit would be even better One caveat to do recursive scheduling we might want to use the same method as in Java which does not seem to work with Unit def random seed Int Observable Double Observable subscriber val r Random new Random seed val inner rx lang scala schedulers NewThreadScheduler createWorker subscriber add inner inner schedule new Function Unit Unit override def apply unit Unit Unit val n r nextDouble subscriber onNext n inner schedule apply OK I ll take it and add some examples to test the signature Cool this is nice @zsxwing Is this done after merging that PR Yes already fixed',RxJava,false,false,false
33279195,'Fix issue #1187 and #1196','This PR fixed issue #1187 Although using action Unit will require the following odd codes when somebody wants to use Function0 directly Scala @Test def schedulerExample5 Unit val worker IOScheduler createWorker var no 1 val subscription worker schedule new Function0 Unit def apply Unit println s Hello no from Scheduler no 1 worker schedule apply 100 millis apply 1 seconds TimeUnit SECONDS sleep 2 subscription unsubscribe I think people rarely use Function0 directly in Scala So I chose action Unit finally schedulerExample4 is an more realistic example for recursive schedule This PR is a breaking change','cc @headinthebox @samuelgruetter Perhaps we should consider putting the work as the last curried argument worker schedulePeriodically println s Hello no from Scheduler no 1 initialDelay 1 seconds period 100 millis Would look very nice like this worker schedulePeriodically initialDelay 1 seconds period 100 millis println s Hello no from Scheduler no 1 RxJava pull requests #1098 https netflixoss ci cloudbees com job RxJava pull requests 1098 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1099 https netflixoss ci cloudbees com job RxJava pull requests 1099 FAILURE Looks like there s a problem with this pull request Yep This Looks better I always try to use that pattern with Unit RxJava pull requests #1100 https netflixoss ci cloudbees com job RxJava pull requests 1100 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1101 https netflixoss ci cloudbees com job RxJava pull requests 1101 FAILURE Looks like there s a problem with this pull request Also fixed #1196 in this PR RxJava pull requests #1107 https netflixoss ci cloudbees com job RxJava pull requests 1107 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1108 https netflixoss ci cloudbees com job RxJava pull requests 1108 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
33279491,'RxScala zip','Why keep this private I want it all the time Perhaps we can call it zipWith to match the Haskell name to avoid bikeshedding that it is not in Scala it should private def zip U R that Observable U selector T U R Observable R toScalaObservable R rx Observable zip T U R this asJavaObservable that asJavaObservable selector','@zsxwing and @headinthebox Want to discuss and finish this one @samuelgruetter explained the reason in this commit https github com Netflix RxJava commit 24e0bafacbaa7651fca3b4b2faffb0e78bd3c9e4 Scala collections do not have such a function and we want to be as close to Scala collections as possible I want it in we can have more operations than other collections have In fact we should have the union of Scala collections and Rx operators Scala does not have combineLatest either',RxJava,false,false,false
33287956,'Scheduler fixes and related improvements','A newer set of scheduler improvements Fixed schedulePeriodic to properly capture the Subscription of the repeated schedule calls to allow unsubscribing the periodic task without the need to unsubscribe the whole worker Fixed NewThreadScheduler to call shutdownNow to correctly cancel all pending tasks Removed innerSubscription from NewThreadScheduler because it was unnecessary and didn t even work Took CompositeSubscription from #1145 to improve on the add removal time of timed tasks with a help of a HashSet and atomic field updaters Added SubscriptionQueue that works like an ringbuffer and can add remove non delayed tasks faster than CompositeSubscription Reduced memory footprint of CompositeSubscription and ScheduledAction Modified EventLoopScheduler to track delayed and non delayed task Subscriptions separately Added a few final modifiers','RxJava pull requests #1102 https netflixoss ci cloudbees com job RxJava pull requests 1102 FAILURE Looks like there s a problem with this pull request Spent the time to review this today good set of changes but I found areas I d like to discuss with you some of which existed already I ll start adding them inline I was intrigued to see you start using AtomicFieldUpdater Have you found it makes a difference in object allocations I would imagine it would in the the high traffic objects I m closing this due to the distance from master and due to the increased need to remove any memory overhead and using lock free I ll post a separate PR for just the StampedSubscription to make sure a periodic action can be reliably unsubscribed Are you planning on continuing on evolving this Do you want to work together on a branch to review and optimize My head is full with branches from all the recent PRs and merges so I need to reaccomodate the master and where it is standing I think I ll do a complete overhaul including the scheduler and subscription optimizations i e I ll abandon this specific branch here Keep me in the loop on this I intend on starting to do profiling so I d like us to stay in touch so we don t go off on tangents from each other and waste time Perhaps we can start by using https github com Netflix RxJava issues 1204 to discuss and then link to branches PRs from there Sure',RxJava,true,false,false
33288903,'Fix attempt for OperatorPivotTest','This is an attempt to fix the lack of concurrency in the OperatorPivotTest testConcurrencyAndSerialization Since this fails mostly on the build server I ll try to minimize the attempts to not flood it','RxJava pull requests #1103 https netflixoss ci cloudbees com job RxJava pull requests 1103 FAILURE Looks like there s a problem with this pull request There is something wrong with JavaFX compilation rxjava contrib rxjava javafx src main java rx observables JavaFxObservable java 19 error package javafx beans value does not exist import javafx beans value ObservableValue I have commented out javafx until we resolve the compilation issue',RxJava,true,false,false
33312773,'ReplaySubject with time and size bounds','I ve implemented the bounded ReplaySubject variants and removed the old OperatorReplay CustomReplaySubject so the various Observable replay now use this version Note that this is based on the current SubjectSubscriptionManager and not my manager from PR #1185 I ve copied the ReplaySubjectConcurrencyTest to check the concurrency properties The bounded buffering is implemented via a doubly linked list where the back reference is a weak reference This allows keeping a reference to the latest Node for each replayState and once a Node is no longer indexed it will be removed by GC A concurrency review would be much appreciated','RxJava pull requests #1104 https netflixoss ci cloudbees com job RxJava pull requests 1104 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1105 https netflixoss ci cloudbees com job RxJava pull requests 1105 FAILURE Looks like there s a problem with this pull request Nice people will be happy to have all the functionality on ReplaySubject Should we wait until after https github com Netflix RxJava pull 1185 to rebase and merge this I have not yet reviewed this I d review and merge this first and go back to #1185 as it surely needs some rebase anyway Closing this as the master merge got messed up RxJava pull requests #1126 https netflixoss ci cloudbees com job RxJava pull requests 1126 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
33313897,'IllegalArgException when using SwingScheduler','I occasionally get this exception when using rx for Swing tasks I m not specifically using the SwingScheduler so I assume it s being used automatically Not sure if it s relevant but I currently have one observable using a delay of 20ms Exception in thread AWT EventQueue 0 java lang IllegalArgumentException The swing timer only accepts non negative delays up to 2147483647 milliseconds at rx schedulers SwingScheduler assertThatTheDelayIsValidForTheSwingTimer SwingScheduler java 139 at rx schedulers SwingScheduler access 100 SwingScheduler java 36 at rx schedulers SwingScheduler InnerSwingScheduler schedule SwingScheduler java 68 at rx Scheduler Worker 1 call Scheduler java 110 at rx schedulers SwingScheduler InnerSwingScheduler 1ExecuteOnceAction actionPerformed SwingScheduler java 83 at javax swing Timer fireActionPerformed Timer java 313 at javax swing Timer DoPostEvent run Timer java 245 at java awt event InvocationEvent dispatch InvocationEvent java 311 at java awt EventQueue dispatchEventImpl EventQueue java 744 at java awt EventQueue access 400 EventQueue java 97 at java awt EventQueue 3 run EventQueue java 697 at java awt EventQueue 3 run EventQueue java 691 at java security AccessController doPrivileged Native Method at java security ProtectionDomain 1 doIntersectionPrivilege ProtectionDomain java 75 at java awt EventQueue dispatchEvent EventQueue java 714 at java awt EventDispatchThread pumpOneEventForFilters EventDispatchThread java 201 at java awt EventDispatchThread pumpEventsForFilter EventDispatchThread java 116 at java awt EventDispatchThread pumpEventsForHierarchy EventDispatchThread java 105 at java awt EventDispatchThread pumpEvents EventDispatchThread java 101 at java awt EventDispatchThread pumpEvents EventDispatchThread java 93 at java awt EventDispatchThread run EventDispatchThread java 82','Do you have any periodic tasks i e using schedulePeriodic somewhere I had a delay in there but no periodic tasks I believe #1195 fixed this Please re open if it is still an issue',RxJava,false,false,false
33321804,'RxScala Schedulers II','The various factory methods in Scala for schedulers should not take i e scala def apply NewThreadScheduler new NewThreadScheduler rx schedulers Schedulers newThread should be scala def apply NewThreadScheduler new NewThreadScheduler rx schedulers Schedulers newThread The fact that java does nothave static properties should not force us to write in Scala','But if changing to def apply o observeOn NewThreadScheduler can not be compiled Need to write o observeOn NewThreadScheduler apply Comparing with it o observeOn NewThreadScheduler is more convenient I think it would work when you write schedulers NewThreadScheduler or not Not work type mismatch found rx lang scala schedulers NewThreadScheduler type required rx lang scala Scheduler o observeOn schedulers NewThreadScheduler subscribe OK guess we ll have to stick with what we have then @zsxwing and @headinthebox Does this still have outstanding work This can be closed Thanks @zsxwing',RxJava,false,false,false
33322888,'SwingScheduler allow negative schedule','Fix for issue #1193 The new schedulePeriodic may calculate negative delay times if the next task was already due This change will allow negative timing on the swing scheduler indicating an immediate schedule','RxJava pull requests #1106 https netflixoss ci cloudbees com job RxJava pull requests 1106 FAILURE Looks like there s a problem with this pull request I suggest adding some comments in the Scheduler schedule and Schedule schedulePeriodically about negative timing E g negative delay time should be regarded as 0 It would be helpful for anyone who wants to implement special Scheduler I ve added extra comments RxJava pull requests #1109 https netflixoss ci cloudbees com job RxJava pull requests 1109 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
33351560,'RxJava Schedulers III','The bindings for schedulers in RxScala are incomplete for instance schedulePeriodically and parallelism are missing','@zsxwing Is this done now after that merge Yes already fixed',RxJava,false,false,false
33430839,'initial rev of two experimental event loop schedulers','I created two new variations of EventLoopsScheduler BalancingEventLoopScheduler and ReroutingEventLoopScheduler These are currently experimental since they are not fully implemented for performance but are fully functional There are a couple of known problems and still evolving solutions However the ideas are concrete enough to garner discussion and feedback The objective of rebalancing workload when there is non trivial disparity in loads across cores is constrained by costs to both maintain state as well as to run rebalancing algorithms Especially while maintaining the contracts of event concurrency etc and minimizing synchronization for gathering state and rebalancing I also created a new JMH benchmark MultipleObserversOnOneBusyObservable java pardon the naming to help compare these two new variants with the existing scheduler Here s a description of the benchmark and the two new schedulers JMH Benchmark MultipleObserversOnOneBusyObservable java pre setup Input theArray Array of N numbers Array of schedulers schedlrIndex 0 EventLoopsScheduler 1 BalancingEventLoopScheduler 2 ReroutingEventLoopScheduler numObservers NUM_CORES 10 @GenerateMicroBenchmark runAll input for i 1 input numObservers if i 4 0 theO Observable from 1 2 3 4 5 else theO Observable from input theArray theO observeOn input scheduler schedlrIndex subscribe input blackhHole consume number pre Benchmark run on Ubuntu desktop Intel Xeon W3550 @ 3 7 GHz 8 Cores 40GB memory gradlew benchmarks Pjmh f 1 tu s bm thrpt wi 5 i 10 r 1 MultipleObserversOnOneBusyObservable Results pre N 50 Benchmark schedulerIndex Mode Samples Mean Mean error Units r s MultipleObserversOnOneBusyObservable runAll 0 thrpt 10 3460 543 50 047 ops s r s MultipleObserversOnOneBusyObservable runAll 1 thrpt 10 430 402 1 783 ops s r s MultipleObserversOnOneBusyObservable runAll 2 thrpt 10 3200 517 140 199 ops s N 500 Benchmark schedulerIndex Mode Samples Mean Mean error Units r s MultipleObserversOnOneBusyObservable runAll 0 thrpt 10 345 918 8 889 ops s r s MultipleObserversOnOneBusyObservable runAll 1 thrpt 10 366 105 11 945 ops s r s MultipleObserversOnOneBusyObservable runAll 2 thrpt 10 361 587 10 627 ops s N 5000 Benchmark schedulerIndex Mode Samples Mean Mean error Units r s MultipleObserversOnOneBusyObservable runAll 0 thrpt 10 36 383 1 698 ops s r s MultipleObserversOnOneBusyObservable runAll 1 thrpt 10 88 317 4 917 ops s r s MultipleObserversOnOneBusyObservable runAll 2 thrpt 10 37 533 0 951 ops s pre Note that the workload in this benchmark isn t such that there s a much rebalancing if any to do However we need to make sure that the variants do not degrade performance in that case Some observations ul li BalancingEventLoopScheduler does poorly for small N but does pretty well beyond a threshold li li RebalancingEventLoopScheduler ul li added logic to evaluate and maintain state 1 avgLatency per core 2 hot queue per core and still is able to do as good as the old EventLoopsScheduler That is there s near zero cost to maintaining that state li li Even if rebalancing proves costly and we evolve an algorithm later the result so far itself might be a good improvement over the current one if we just pause the hot Q and randomly pick another core li ul li ul Below I point out the problem area for each of the new schedulers Ideas feedback welcome h2 BalancingEventLoopScheduler h2 pre N worker threads are created 1 per core Each of N worker threads are assigned 0 or more worker queues to process One of the worker threads is assigned as the RebalancerThread for load balancing Scheduler createWorker creates a queue and assigns to one of the worker threads WorkerThread run act on Q transfers transferring queue in or out grab updated list of Qs totalLoad 0 for Q q theQlist q drainTo workList now currentTime for Action a workList a call load currentTime now totalLoad load maintain hotQueue name and load that has the highest load update current worker thread s hot queue if I am the RebalancerThread call rebalanceQs if totalLoad 0 did no work sleep a bit to prevent busy cpu PROBLEM would be nice to have a multi queue poll here to be called on all our Qs this sleep kills performance when work comes in relatively slowly rebalanceQs if did rebalance recently return get HotQueues from each core thread workers if none of them had a hot q return sort in increasing order hot Qs based on core thread worker s totalLoad and the qLoad for loadedWorker from end of sorted hot Q list for availableWorker from beginning of sorted hotQ list until loadedWorker if shouldRebalancePair loadedWorker availableWorker then move the hotQ from loadedWorker to availableWorker That is WorkerThread loadedWorker transferQueue theHotQ WorkerThread availableWorker shouldRebalancePair loadedWorker availableWorker if loadedWorker totalLoad loadedWorker hotQLoad availableWorker totalLoad loadedWorker hotQLoad return true return false pre h2 ReroutingEventLoopsScheduler h2 pre N worker threads are created 1 per core Each of N worker threads has a single thread executor ScheduledThreadPoolExecutor Scheduler createWorker creates a WorkerQueue and assigns to one of the worker threads could possibly make it pick the least loaded one that info is available based on the details below WorkerQueue schedule calls workerThread schedule on the currently assigned workerThread WorkerThread routinely schedules a house keeping action latencyEval into its schedulerService to note time it takes for it to get executed this measures latency WorkerThread schedule callerQId action wrap each runnable with increment counter to track #items increment per queue counter to track per queueId throughput queueCounts executor schedule wrapped runnable WorkerThread essentially maintains two numbers avgLatency and throughput overall perWorker WorkerThread latencyEval note latency currentTime latencyEvalLaunchTime if queueCounts size 1 maxQ queue from queueCounts with max number where number EPS threshold destination shouldReroute myWorkerIndex if desination 0 WorkerQueue maxQ rerouteTo destination shouldReroute sourceWorker ensure nobody else is rerouting right now or just did get avgLatencies for all workers as many as #Cores pick a worker with that can take sourceWorker s load based on latencies currently always return 1 effectively actual load balancing is turned off return picked worker WorkerQueue schedule action if am being rerouted initialize reroute put an ending marker action into current worker that notifies us of the last action handled we can use the new worker only after the last one sent to previous one completes if ending marker indicated switch worker to the new one move all actions in transfer queue to new worker else park action into a transfer queue Don t yet know how to manage subscriptions when parking actions PROBLEM It is functional though since actual rebalancing isn t happening Perhaps don t park actions just pause until ending marker comes through Subscriptions are managed just like before then The caller is then blocked until rebalancing finishes Which make be OK else worker schedule action pre','RxJava pull requests #1111 https netflixoss ci cloudbees com job RxJava pull requests 1111 FAILURE Looks like there s a problem with this pull request ComputationSchedulerPerf benchmark gives the below results for the new schedulers ReroutingEventLoopScheduler does as well or slightly better Where as BalancingEventLoopScheduler does particularly well when size is large And particularly bad when size 1 EventLoopsScheduler pre Benchmark size Mode Samples Mean Mean error Units r s ComputationSchedulerPerf observeOn 1 thrpt 10 563086 798 25871 172 ops s r s ComputationSchedulerPerf observeOn 1024 thrpt 10 14281 387 778 823 ops s r s ComputationSchedulerPerf observeOn 1048576 thrpt 10 9 395 0 395 ops s r s ComputationSchedulerPerf subscribeOn 1 thrpt 10 606335 405 18260 841 ops s r s ComputationSchedulerPerf subscribeOn 1024 thrpt 10 2837 930 5977 392 ops s r s ComputationSchedulerPerf subscribeOn 1048576 thrpt 10 465 407 1263 917 ops s pre BalancingEventLoopScheduler pre Benchmark size Mode Samples Mean Mean error Units r s ComputationSchedulerPerf observeOn 1 thrpt 10 160599 295 313744 479 ops s r s ComputationSchedulerPerf observeOn 1024 thrpt 10 29859 545 3200 789 ops s r s ComputationSchedulerPerf observeOn 1048576 thrpt 10 10 797 1 703 ops s r s ComputationSchedulerPerf subscribeOn 1 thrpt 10 147983 790 232792 870 ops s r s ComputationSchedulerPerf subscribeOn 1024 thrpt 10 204732 903 396749 424 ops s r s ComputationSchedulerPerf subscribeOn 1048576 thrpt 10 178373 333 394598 521 ops s pre ReroutingEventLoopScheduler pre Benchmark size Mode Samples Mean Mean error Units r s ComputationSchedulerPerf observeOn 1 thrpt 10 539078 418 19827 734 ops s r s ComputationSchedulerPerf observeOn 1024 thrpt 10 15291 973 920 172 ops s r s ComputationSchedulerPerf observeOn 1048576 thrpt 10 9 438 0 461 ops s r s ComputationSchedulerPerf subscribeOn 1 thrpt 10 727773 605 151442 955 ops s r s ComputationSchedulerPerf subscribeOn 1024 thrpt 10 4872 402 7036 646 ops s r s ComputationSchedulerPerf subscribeOn 1048576 thrpt 10 1876 875 3491 236 ops s pre One note please submit your PRs from a branch and not from your master Thanks I will take care of these two things Closing this out to reduce noise we will discuss this further in the future @spodila and I sit close to each other',RxJava,true,false,false
33443180,'Support for IOSSchedulers','IOSScheduler implementation for iOS for use with RoboVM','RxJava pull requests #1112 https netflixoss ci cloudbees com job RxJava pull requests 1112 FAILURE Looks like there s a problem with this pull request Welcome @ashleyj Thanks for the contrib I wasn t even aware Java could target iOS until this pull request Review the questions with @zsxwing and @akarnokd above and once you have all come to agreement I ll merge this for the next release RxJava pull requests #1230 https netflixoss ci cloudbees com job RxJava pull requests 1230 FAILURE Looks like there s a problem with this pull request @zsxwing I did initially plan on using org robovm apple dispatch DispatchQueue but it s not as flexible as using an NSOperationQueue The way I have it at the moment gives you the ability to cancel jobs say on an unsubscribe Still no unit tests it sucks and I hate to push code without tests but unfortunately there s no runner for it and it requires the simulator Hoping this will change in the near future RxJava pull requests #1231 https netflixoss ci cloudbees com job RxJava pull requests 1231 SUCCESS This pull request looks good RxJava pull requests #1232 https netflixoss ci cloudbees com job RxJava pull requests 1232 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
33483377,'rxjava string StringObservable from InputStream does not close InputStream','Would be nice if StringObservable from InputStream size closed the InputStream once finished with it Are there any obstacles to this being incorporated The same again for the StringObservable from Reader size line 62 https github com Netflix RxJava blob master rxjava contrib rxjava string src main java rx observables StringObservable java','I think it s better that leaving the user to close it Sometimes the user may need to reuse the stream And if the user wants to close it once the Observable finishes he can use using operator E g Java public void foo final InputStream i Observable using new Func0 Subscription @Override public Subscription call return Subscriptions create new Action0 @Override public void call try i close catch IOException e throw new RuntimeException e new Func1 Subscription Observable byte @Override public Observable byte call Subscription subscription return StringObservable from i I think this is best served by the practice of whoever opened it should close it The from InputStream approach means the Observable didn t open it and therefore shouldn t close it If it was from File then it is the Observable who opens it and should close it Thanks @zsxwing for the explicit example that s very helpful I expect that the use case where the user wants it closed will be common so for the convenience of the user I might make a pull request with additional methods like fromAndClose InputStream so that users don t need to implement all that using code I might make a pull request with additional methods like fromAndClose InputStream so that users don t need to implement all that using code I suppose we also miss some document about StringObservable from InputStream size or StringObservable from Reader size Observables returned by them can only be subscribed once They can not be used directly with repeat retry Thanks for the answers looks fine to close',RxJava,false,false,false
33502308,'Scheduler dispatch algorithm and tests','Implemented an event loop scheduler based on thread pinning and work stealing for #1149 In addition I ve merged #1197 added tests and fixed a few minor issues Here are the comparative benchmark results using the MultipleObserversOnOneBusyObservable JMH from #1197 Benchmark NUM_INTEGERS schedulerIndex Mode Samples Mean Mean error Units runAll 50 0 thrpt 10 3012 015 176 800 ops s runAll 50 1 thrpt 10 32 035 0 014 ops s runAll 50 2 thrpt 10 2537 292 201 377 ops s runAll 50 3 thrpt 10 2452 117 60 938 ops s runAll 500 0 thrpt 10 296 673 4 419 ops s runAll 500 1 thrpt 10 32 037 0 011 ops s runAll 500 2 thrpt 10 211 382 21 754 ops s runAll 500 3 thrpt 10 246 312 3 714 ops s runAll 5000 0 thrpt 10 27 458 0 083 ops s runAll 5000 1 thrpt 10 32 070 0 238 ops s runAll 5000 2 thrpt 10 27 718 0 343 ops s runAll 5000 3 thrpt 10 21 415 0 289 ops s where 0 is the current computation scheduler 1 is the balanced scheduler 2 is the rerouting scheduler and 3 is the pinning scheduler The reason for the 32 ops s throughput of the balanced scheduler seems to be due to the drain loop which made some self scheduling tests run extremely slow Adding the MAX_TIGHT_LOOPS improved on the test speed and the benchmark speed to 255 ops s I m not sure why it is that slow I haven t run the other perf test but run my own simple benchmark code one that observes a single item 1M times and the other observes 16M items once Results Algorithm Single Many Current 1970 ns item 117 ns item Balancing 30403 ns item 110 ns item Rerouting 1979 ns item 115 ns item Pinning 2122 ns item 140 ns item The reason for the extra slowness of my implementation is the use of LinkedBlockingDeque as I need the offerFirst but ConcurrentLinkedDeque is in Java 7 In addition the cost of waiting and parking is doubled','RxJava pull requests #1114 https netflixoss ci cloudbees com job RxJava pull requests 1114 SUCCESS This pull request looks good RxJava pull requests #1116 https netflixoss ci cloudbees com job RxJava pull requests 1116 SUCCESS This pull request looks good Second round of improvements Benchmark NUM_INTEGERS schedulerIndex Mode Samples Mean Mean error Units runAll 50 0 thrpt 10 3611 477 42 228 ops s runAll 50 1 thrpt 10 32 037 0 011 ops s runAll 50 2 thrpt 10 2657 672 189 995 ops s runAll 50 3 thrpt 10 3631 327 55 355 ops s runAll 500 0 thrpt 10 295 083 0 693 ops s runAll 500 1 thrpt 10 32 035 0 014 ops s runAll 500 2 thrpt 10 189 955 26 130 ops s runAll 500 3 thrpt 10 212 267 11 093 ops s runAll 5000 0 thrpt 10 26 923 0 030 ops s runAll 5000 1 thrpt 10 32 073 0 236 ops s runAll 5000 2 thrpt 10 27 728 0 413 ops s runAll 5000 3 thrpt 10 24 497 0 540 ops s runAll 50000 0 thrpt 10 2 632 0 019 ops s runAll 50000 1 thrpt 10 9 138 0 321 ops s runAll 50000 2 thrpt 10 2 738 0 129 ops s runAll 50000 3 thrpt 10 2 475 0 065 ops s For smaller number of elements my version gives comparable throughput but as the element size increases mine falls behind some percent My guess is that the work queue in the ScheduledThreadPool being an array gives much better cache locality than a CLQ The new latencies Algorithm Single Many Current 1900 ns item 120 ns item Balancing 30403 ns item 111 ns item Rerouting 1285 ns item 114 ns item Pinning 1496 ns item 118 ns item Here again I managed to get rid of 400 ns overhead in the single case and 20 ns in the many case I m closing this as it no longer merges I m not certain if this pinning stealing is worth pursuing further with refined data structures',RxJava,true,false,false
33510044,'takeUntil behavior when other observable terminates','Say I have two observables b source b b other b If I do a b source takeUntil other b should the source observable complete when b other b completes This appears to be the current behavior assuming that I m looking at it right The test cases also indicate that it s intentional but the docs msdn spec seem vague','Yes Source will be unsubscribed as soon as other emits anything onComplete onError or onNext Ah I see I didn t realize that onComplete and onError counted as emitting an item Thanks',RxJava,false,false,false
33530037,'Need Help with ReplaySubject having weird Interaction with custom operators','Hello I m writing some code that involves some of my custom operators that I have made Unfortunately I m getting into a situation where onComplete is never called for one of my Observables and I m having trouble figuring out why this is happening I believe this is a result of my operators not behaving well with the Replay subject though its hard for me to debug what is happening I ve created a contrived example of what I am doing below along with descriptions and code of my custom operators java @Test public void testReplay ListeningExecutorService pool MoreExecutors listeningDecorator new ThreadPoolExecutor 10 10 60L TimeUnit SECONDS new SynchronousQueue Runnable creates an Observable that emits integers via a pool calling a function final Observable Integer waitObs Observable just foo lift new OperatorFlatMapInPool Integer String CUSTOM OPERATOR new Func1 String Observable Integer @Override public Observable Integer call String s try Thread sleep 1000 catch InterruptedException e e printStackTrace return Observable just 1 pool replayable obseravble that emits ints from wait obs ConnectableObservable Integer intObs1 waitObs replay intObs1 connect replayable obseravble that emits ints from wait obs after being zipped with an observable that emits true Observable Integer intObs2 ObservableX flatZipWithFirstValue CUSTOM OPERATOR intObs1 Observable just true new Func2 Integer Boolean Observable Integer @Override public Observable Integer call Integer integer Boolean aBoolean return Observable just integer List Integer list Observable concat concat maps of yid guid phones intObs1 intObs2 toList toBlockingObservable first assertEquals 2 list size CUSTOM OPERATOR OperatorFlatMapInPool This will run the provided function for each incoming item on a thread in the provided pool we created this as a workaround for onSubscribe onObserve not working for some reason via this issue https github com Netflix RxJava issues 1139 CODE java public class OperatorFlatMapInPool R T1 implements Observable Operator R T1 final ListeningExecutorService pool final Func1 T1 Observable R func public OperatorFlatMapInPool Func1 T1 Observable R pFunc ListeningExecutorService pPool this pool pPool this func pFunc @Override public Subscriber super T1 call final Subscriber super R subscriber return new Subscriber T1 subscriber AtomicInteger itemsEmitted new AtomicInteger 0 AtomicBoolean completed new AtomicBoolean false AtomicBoolean errored new AtomicBoolean false @Override public void onCompleted completed set true if no mor items are being emitted and we arent working on any items currently then we are done if itemsEmitted get 0 subscriber onCompleted @Override public void onError Throwable e if errored getAndSet true subscriber onError e @Override public void onNext final T1 t1 itemsEmitted addAndGet 1 do function on another thread ListenableFuture Observable R result pool submit new Callable Observable R @Override public Observable R call throws Exception return func call t1 all done on same thread dont need atomic values Futures addCallback result new FutureCallback Observable R @Override public void onSuccess Observable R result threaded process finised subscribe to the result result subscribe new Subscriber R @Override public void onCompleted if no mor items are being emitted and we arent working on any items currently then we are done if itemsEmitted addAndGet 1 0 completed get subscriber onCompleted @Override public void onError Throwable e if errored getAndSet true subscriber onError e @Override public void onNext R r subscriber onNext r @Override public void onFailure Throwable t if errored getAndSet true subscriber onError t CUSTOM OPERATOR FlatZipWithFirstValue Flat map Zips each item emitted from the main observable with the first value emitted from the second observable via the provided function java public static T1 T2 R Observable R flatZipWithFirstValue final Observable T1 main final Observable T2 valueObs final Func2 T1 T2 Observable R func return valueObs first flatMap new Func1 T2 Observable R @Override public Observable R call final T2 t2 return main flatMap new Func1 T1 Observable extends R @Override public Observable extends R call T1 t1 return func call t1 t2','Hi This test passes for me with 0 18 3 and Guava 17 0 Thanks for validating this @akarnokd Closing due to inactivity please reopen if bug still exists as of version 0 20',RxJava,false,false,false
33561444,'AndroidObservable to hold weak reference to Activity or Fragment','bindActivity and bindFragment hold strong references to the Activity or Fragment thus requiring explicit unsubscription to avoid leaks This commit weakens that reference The observable chain should never be the owner of an Activity or Fragment so weakening the reference here should be safe An earlier version of bindActivity used weak references for both the Activity and the source Observable Weakening the reference to the Observable may be unsafe as the observable chain might be the owner of an anonymous source Observable This commit removes the need to explicitly unsubscribe as long as the final Subscriber holds only a weak reference to the Context i e View Activity or Fragment For example consider a class public class ClickableProperty extends Subscriber Boolean private final WeakReference View mViewRef public ClickableProperty View view mViewRef new WeakReference View view @Override public void onNext Boolean clickable View view mViewRef get if view null view setClickable clickable else unsubscribe @Override public void onCompleted ignore @Override public void onError Throwable e ignore The clickable property of a view can be safely bound to a boolean observable as follows without needing to explicitly unsubscribe in the Activity s onDestroy public class MainActivity extends Activity Button mButton protected void onCreate Bundle savedInstanceState setContextView R id activity_main mButton findViewById R id button Observable Boolean allowClicks GlobalStaticObservables allowClicks ClickableProperty clickableProperty new ClickableProperty mButton bindActivity this allowClicks subscribe clickableProperty protected void onDestroy nothing to do here Without weakening the Activity reference in bindActivity explicit unsubscription would still be needed to prevent Context leaks','Pinging @mttkay since I don t know if Github does that automatically here RxJava pull requests #1115 https netflixoss ci cloudbees com job RxJava pull requests 1115 FAILURE Looks like there s a problem with this pull request We used to do it this way and it inherently collides with the way Rx works by providing anonymous functions as closures If we were to hold a weak reference to such a function often being an inner class of an Activity or View and thus holding a strong reference to a Context it would immediately become eligible for garbage collection Since we cannot determine whether the subscriber is an Activity View or not since they will end up being wrapped in SafeSubscriber we cannot make this decision from within the operator Have a look at the discussion behind the development of OperatorConditionalBinding as well as it contains more information around this It used to be called OperatorWeakBinding because it did actually use weak references until we realized it s not gonna work In general I should add that after having worked with RxJava on Android for close to a year now I found myself ending up with a lot of compromises on my hands The nature of Android UI objects is bound to the strict and complex life cycle Android imposes on them and it doesn t fit well with the way Rx Java works I found that the library adds the most value on those layers that are below the UI but as soon as you enter UI and Activity territory you ll have to deal with rotation changes juggling subscriptions replaying view state etc You re swapping one area of complexity for another This commit is different OperatorWeakBinding held a weak reference to both the Activity or Fragment and the source Observable Of course a weak reference to the latter is unsafe for the reasons you mention This commit uses a weak reference only for the Activity or Fragment This is safe because the framework owns those objects and holds strong references to them while alive The Observable reference is still strong for the reasons you mention The original commit message explains this in more detail with an example use case Essentially though this doesn t by itself save the unsubscribe calls if the Observable or its closure holds a strong reference to the Activity or Fragment or View However it allows for judicious use of WeakReference s in the Observers to eliminate the need entirely Notice that in both the diff and the example code weak references are used only for classes explicitly owned by the framework i e Activity Fragment and View If I read the code correctly it only works in those cases where the subscriber holds no references to the Fragment or Activity whatsoever In any other case you re either explicitly or implicitly holding a strong reference to the Activity Fragment through the subscriber either because the Activity Fragment is the subscriber itself or more likely because it s an inner class so you gain nothing and you still have to unsubscribe to prevent a memory leak That said I m not sure I understand the use case here if you have a subscriber that does not reference the Activity or Fragment why use this operator to begin with It s meant to be used to bind sequences to screen objects Or maybe I m misunderstanding Can you post an example of how you re using it I think the point is you can make the subscriber have a weak reference to the activity fragment by making it say a static inner class with a WeakReference member see the original post for an example Perhaps making a generic WeakObserver abstract class that wraps a given activity fragment in a WeakReference would be good This could then be subclassed using static inner classes Something like on my phone so sorry for the formatting capitals errors abstract class WeakObserver T R implements Observer R WeakReference T thingRef Public WeakObserver T thing put it in thingRef Final Public void onNext R next If thingRef get null doNext thingRef get next Pubic abstract void doNext T thing R next same for complete and error This would make using these changes slightly less annoying That said my existing code just has an activity and fragment base class that has an add remove subscription method and unsubscribes at the appropriate times I find this works well but it does require care to always add subscriptions to it In other words you re managing a reference to the Activity How is that more convenient than calling unsubscribe in onDestroy In general I would find it confusing from an API perspective if there were some cases exceptional cases in fact where you don t have to unsubscribe An API should communicate a clear contract and in face of the above mentioned problems pretty much everyone see previous issues voted for simply letting the caller decide when it s time to release these references Don t get me wrong I d love to have this more automated I just think that this solution only shoots for the 10 of the cases it adds complexity to the implementation and needs to be documented as well I m just not convinced it s worth it Curious what others think @samueltardieu https github com samueltardieu @tehmou https github com tehmou @zsxwing https github com zsxwing @mironov nsk https github com mironov nsk On Fri May 16 2014 at 11 05 AM Dylan Sale notifications@github com wrote I think the point is you can make the subscriber have a weak reference to the activity fragment by making it say a static inner class with a WeakReference member see the original post for an example Perhaps making a generic WeakObserver abstract class that wraps a given activity fragment in a WeakReference would be good This could then be subclassed using static inner classes Something like on my phone so sorry for the formatting capitals errors abstract class WeakObserver T R implements Observer R WeakReference T thingRef Public WeakObserver T thing put it in thingRef Final Public void onNext R next If thingRef get null doNext thingRef get next Pubic abstract void doNext T thing R next same for complete and error This would make using these changes slightly less annoying That said my existing code just has an activity and fragment base class that has an add remove subscription method and unsubscribes at the appropriate times I find this works well but it does require care to always add subscriptions to it Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 1203#issuecomment 43311404 I used to think like @DylanSale However since you have to manage your UI components lifecycles anyway unsubscribing at the right place onPause onStop or onDestroy is easy to do and it removes the magic of sometimes unsubscribing when by change the garbage collector kicks in and there are no circular references @mttkay I don t like the idea of weak binding at all and I always manage all my subscriptions explicitly As @samueltardieu said it s not a big deal @DylanSale has it Managing a few subscriptions isn t a big deal but I m using RX for all the view properties and manual management is a huge amount of boilerplate Each subscription requires three lines a member declaration the subscription and an unsubscribe instead of just a single line I was using a home rolled subscription manager to reduce this boilerplate private SubcriptionManager mSubs protected void onCreate Bundle bundle mSubs new SubscriptionManager mSubs manage bindActivity this o1 subscribe s1 bindActivity this o2 subscribe s2 bindActivity this o3 subscribe s3 protected void onDestroy mSubs unsubscribeAll but this is still extra boilerplate Further I m using an MVC or MVVM or MVP pick your overloaded acronym with a single Activity and custom View s and ViewModels for most of my screens Similar to Square s Mortar Flow effort in some ways The models are retained across configuration changes and rebound to the new view instance I use RX for this data binding Android doesn t propagate lifecycle information to the View s so this has to be done manually for them to unsubscribe themselves yet more boilerplate and an extra view hierarchy traversal during a screen rotation My approach may not be the best way in the long run but rxjava android will be much more useful for UI binding a la ReactiveUI if we can work towards automated unbinding rather than just accepting the current state This commit lets users of rxjava android experiment with various methods of automated unbinding in their own apps without breaking or changing any existing functionality I d like to reiterate my last point from my previous comment This commit lets advanced users of rxjava android experiment with various approaches for automated unbinding in their own apps without breaking or changing any existing functionality The documentation can stay the same users must call unsubscribe or can be made more precise users should call unsubscribe Either way the salient point to new users is that subscriptions need to be managed Advanced users can experiment with GC based unsubscription but the docs don t need to mention this Let me also describe my other utility features that make GC based unsubscription feasible a library to expose all Android View setters as weakly bound Observer s Specifically rxFrom View functions return RxView objects that expose the view properties as Observer s E g rxView View returns an RxView with methods like RxView visibility returns Observer Integer and RxView clickable returns Observer Boolean rxView TextView returns an RxTextView extends RxView with additional methods like RxView text returns Observer extends CharSequence These Observer s hold only a WeakReference to the View allowing GC based unsubscription see the original commit message or @DylanSale s example a utility function to partially apply a Function or Action with weak binding of the first argument Sometimes you need to reference the View or Activity in the closure provided to an Observable combinator e g map or combineLatest This would create a strong reference to the Context The weakPartial methods solve this Instead of calling for example Observable map e myView translate e subscribe s call Observable map weakPartial v e v translate e myView subscribe s The function or action returned by weakPartial only holds a weak reference to the applied argument When called the actions do nothing if the reference has been GCed The functions return a default value if provided or null if the reference has been GCed As an example java public class MyLoginView extends LinearLayout @InjectView R id username TextView mUsername @InjectView R id login Button mLogin private boolean shouldCapitalize assume set via XML attribute in constructor @Override public void onFinishInflate ButterKnife inject this Called by Activity when the view hierarchy is inflated public void bind Activity activity MyLoginViewModel model show normalized username in textview bindActivity activity model username map weakPartial MyLoginView normalize this subscribe rxFrom mUsername text enable clicking of login button if username is not null or empty bindActivity activity model username map n n null n equals subscribe rxFrom mLogin clickable CharSequence normalize CharSequence name return shouldCapitalize Strings capitalize name name Judicious application of these two library features View properties exposed via weak observers and Context holding objects only referenced in combinator closures via weakPartial allows safe RX binding to the Android view hierarchy without explicit subscription management @mttkay What are your thoughts on bindActivity registering an Application ActivityLifecycleCallbacks that completes any bound Observables when the activity is destroyed For API 14 Maybe this has been discussed before AndroidObservables could register for lifecycle callbacks keep a static mapping from each Activity to its bound Observable wrappers call onComplete for each such Observable when the activity is destroyed Assuming SafeSubscribers completing should propagate an unsubscribe back up the observable chain I find those use cases very compelling Does this rxView wrapper exist already @DylanSale I ve got an internal version that I m using right now but it s not ready for prime time It needs to be filled out it s missing Views and properties that I don t use probably by writing a script to generate it from the Android API And it needs to be documented I m not sure when I ll first be able to make time to work on that but would like to sometime in the next month or so if someone else doesn t do it first @drbild It looks to me as if your SubscriptionManager can be replaced by a simple CompositeSubscription That s what we use whenever we have more than one subscriber and we want to unsubscribe them all at once As for the code sample you re using lambda expressions to map your observables These translate to anonymous inner classes that will hold a strong reference to the outer class the Layout in your case and by extension a strong reference to the Activity every View in Android strongly references the host Activity Even if you used WeakReferences to bind the view AND to bind your subscriber the observable will keep a strong reference to your mapping function and again would not allow that context reference to be cleared unless you unsubscribe That said I still don t see how the use of WeakReferences helps to prevent a memory leak here without additional instrumentation from the outside One thing that I pursued in the past but didn t succeed with is some form of reference counting using ReferenceQueue If we found a way to automatically unsubscribe whenever the GC decides that the context has become eligible for GC then we might solve the problem that way perhaps With regards to ActivityLifeCycleCallbacks in the case of Activities this would indeed help for API level 14 or above However in modern Android apps the role of Activities is typically reduced to being a mere screen container to hold fragments So whenever an app uses fragments you re stuck again since we would need an event whenever Fragment onDestroyView is called I don t think that event exists outside the fragment itself unfortunately Again don t read me wrong In theory I m all with you here I would love to have a reliable solution to this Unless I m missing something I just don t see how the changes proposed so far actually fix the problem One more thing to keep in mind whatever check we perform to test whether a context has gone dead it cannot be performed in an Rx notification onNext onCompleted etc since those notifications might arrive with a significant delay There s only 2 ways to actually address the issue receive an event from the framework outside the Rx call chain that we can listen for and unsubscribe from the sequence or do so from within the context that subscribed itself Since we haven t been successful so far to do 1 we settled on doing 2 @mttkay WIth regards to the your concern about the lambdas holding a strong reference this is not the case These lambdas do not capture any state from the enclosing class by using the weakPartial function and thus are translated into static instance methods or static inner classes See http cr openjdk java net briangoetz lambda lambda translation html I can confirm that my approach works fine with Retrolambda targeting 1 7 for Android as well My Activity s are GCed just fine Too bad Android doesn t have FragmentLifeCycleCallbacks as well Regardless of my opinions about them as opposed to custom views and view models with custom backstack management they are part of Android that is here to stay That s interesting thanks for sharing I was assuming you re using Java 6 and you just used short hand notation for readability I haven t used Retrolambda or even Java 8 on Android It says in the article that Java 8 lambdas are translated using invokeDynamic I believe Retrolambda translates to Java 7 byte code Considering that Dalvik isn t Java 7 compliant before KitKat how would that work on older devices It sounds like highly experimental territory but if you say you ve tested this and it did in fact work using that configuration that s very interesting As said above I was going into this discussion assuming Java 6 everywhere Perhaps we should extend the scope of this to include the other missing pieces like weakPartial so that all rxjava android users can benefit from this change I think Retrolambda can backport to 1 5 and 1 6 even by replacing invokedynamic I haven t done extensive tests with older Android devices but it works fine on several Jellybean devices I m fine with extending the scope We can shelve the pull request until one with all three pieces view properties weakPartial and weak bindActivity is ready There will likely need to be quite a bit of discussion around the appropriate APIs for the first piece sounds good thanks for looking into this @mttkay Should these changes be merged No not yet I think the outcome of the discussion is that we want proper support for users of Java 8 plus Retrolambda but to enable this goes beyond this PR as it needs a more holistic discussion around APIs I m all for pursuing this idea though David as a next step maybe we could set up a working sample project that uses some of the additional helpers you created This could be a good starting point to extract code into the library Let me know if I can help in any way Let s maybe keep this PR open until we ve nailed the next steps then go from there On May 20 2014 6 29 AM Ben Christensen notifications@github com wrote @mttkay https github com mttkay Should these changes be merged Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 1203#issuecomment 43585434 Matthias sounds good It ll be a few weeks I m overloaded for the rest of this month and will be on vacation for the first week of June that s fine no worries Closing this out due to inactivity when something is finalized please re submit',RxJava,true,false,false
33645134,'Profiling Memory Usage and Object Creation','We need to spend time profiling memory and object allocation and finding places where we can improve I would really appreciate help diving into this and finding problem areas Even if you don t fix them but just identity use cases operators etc that would be very valuable This is partly a result of the fact that in Netflix production we have seen an increase in YoungGen GCs since 0 17 x The areas to start should probably be Observable create Observable lift Subscriber CompositeSubscription map flatMap If you can or want to get involved in this please comment here so we all can collaborate together','The most likely source of garbage is the CompositeSubscription whenever a task is scheduled or a new merge source appears the state transition creates a new State object and copies the subscription array PR #1145 reduces the amount of garbage by switching to HashSet on a larger composite Since flatMap mergeMap merge needs to track the active inner subscriptions it uses a composite as well and would gain the same benefits The HashSet change shouldn t kick in though because these aren t generally large lists handful at most not hundreds I expect it s just far too many of them being created I ll also like to help out here since its crucial for our uses as well Thanks @daschl I d appreciate your help Profiling and identifying hot spots is what we need most right now I did some GC profiling of my test workloads and I d also like to nominate BlockingObservable it seems that especially in the single case its not optimized Observable subscribe for both Observer and Subscriber in my GC logs they take up 40 of the overall GC pressure The bad news is that i had to fall back out of Observables to plain execution on the hot code path aside from the overall wrapping observable because also using it in the path produces way too much garbage moving away from Rx in the hot code path got my throughput from 20 to 80 according to the GC logs and it correlates with my findings since I could not sustain constant IO throughput because of full GCs happening way too frequently Observable subscribe for both Observer and Subscriber Not surprised on this Were you able to identify what the garbage is I did some changes in my code and will re profile and post the results here so we get better measurements Here is a slightly older profile run which might give you a hint or two screen shot 2014 05 20 at 10 13 10 https cloud githubusercontent com assets 29086 3024320 a10a2a64 dff6 11e3 8f2c 3473bdfc7af7 png screen shot 2014 05 20 at 10 13 00 https cloud githubusercontent com assets 29086 3024319 a1096bba dff6 11e3 9c92 0177913e5c47 png We can definitely improve on the AtomicReference by using AtomicFieldUpdater The others will require more effort to analyze along with sample code to see what s triggering them I think that many AtomicReference come from mostly the CompositeSubscription instances I went back in history to 0 16 1 to compare performance of the basic map flatMap behavior and found that current master is faster This fits what I had expected of the work of the past couple months which means it s not an obvious glaring issue unless my test is completely flawed Here is the code for the test Branch 0 16 https github com benjchristensen RxJava blob 0 16 perf rxjava core src perf java rx usecases PerfTransforms java Master https github com benjchristensen RxJava blob performance rxjava core src perf java rx usecases PerfTransforms java ### Results #### 0 16 Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapTransformsUsingFrom 1 thrpt 5 2421210 583 68845 966 ops s r u PerfTransforms flatMapTransformsUsingFrom 1024 thrpt 5 1017 787 73 597 ops s r u PerfTransforms flatMapTransformsUsingJust 1 thrpt 5 2398541 067 90703 197 ops s r u PerfTransforms flatMapTransformsUsingJust 1024 thrpt 5 990 623 100 735 ops s r u PerfTransforms mapTransformation 1 thrpt 5 4020548 060 262841 500 ops s r u PerfTransforms mapTransformation 1024 thrpt 5 16205 747 352 618 ops s #### Master Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapTransformsUsingFrom 1 thrpt 5 3184873 133 172320 420 ops s r u PerfTransforms flatMapTransformsUsingFrom 1024 thrpt 5 9079 937 343 905 ops s r u PerfTransforms flatMapTransformsUsingJust 1 thrpt 5 3411785 677 73767 161 ops s r u PerfTransforms flatMapTransformsUsingJust 1024 thrpt 5 10860 963 294 309 ops s r u PerfTransforms mapTransformation 1 thrpt 5 7208334 997 703327 745 ops s r u PerfTransforms mapTransformation 1024 thrpt 5 18720 797 278 529 ops s ### GC On the master branch test I m seeing GC results like this Iteration 5 3189218 350 ops s GC wall time 5 001 secs GC time 0 047 secs GC 0 94 GC count 98 Iteration 5 9198 700 ops s GC wall time 5 002 secs GC time 0 048 secs GC 0 96 GC count 98 versus 0 16 Iteration 5 2420099 017 ops s GC wall time 5 000 secs GC time 0 046 secs GC 0 92 GC count 96 Iteration 5 993 867 ops s GC wall time 5 001 secs GC time 0 100 secs GC 2 00 GC count 212 ### Summary Unless I m mistaken current code is better similar GC behavior on Observable with 1 item better GC behavior with 1024 items higher ops second on all of the map flatMap tests I ll start profiling this and improve but this does not reveal the source of the problems seen Possibly it s related to schedulers or it s a specific operator I exercised map flatMap and thus merge Observable and Subscribe here to get the most fundamental ones The observeOn test shows the cost of scheduling particularly Observable s of a single item java @GenerateMicroBenchmark public void observeOn UseCaseInput input throws InterruptedException input observable observeOn Schedulers computation subscribe input observer input awaitCompletion r u PerfObserveOn observeOn 1 thrpt 5 457830 180 9943 221 ops s r u PerfObserveOn observeOn 1024 thrpt 5 14496 430 518 463 ops s Thus with an Observable of 1 item we can do 457k onNext second with an Observable of 1024 items we can do 14 8million onNext second 14 5k 1024 By the way all testing is just being done on my Mac laptop so these numbers are all relative and not representative of proper server hardware Converting from AtomicReference to AtomicReferenceFieldUpdater improved performance from this Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapTransformsUsingFrom 1 thrpt 5 3184873 133 172320 420 ops s r u PerfTransforms flatMapTransformsUsingFrom 1024 thrpt 5 9079 937 343 905 ops s r u PerfTransforms flatMapTransformsUsingJust 1 thrpt 5 3411785 677 73767 161 ops s r u PerfTransforms flatMapTransformsUsingJust 1024 thrpt 5 10860 963 294 309 ops s r u PerfTransforms mapTransformation 1 thrpt 5 7208334 997 703327 745 ops s r u PerfTransforms mapTransformation 1024 thrpt 5 18720 797 278 529 ops s to this Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapTransformsUsingFrom 1 thrpt 5 3459205 110 124790 906 ops s r u PerfTransforms flatMapTransformsUsingFrom 1024 thrpt 5 9225 037 604 720 ops s r u PerfTransforms flatMapTransformsUsingJust 1 thrpt 5 3639603 060 225599 038 ops s r u PerfTransforms flatMapTransformsUsingJust 1024 thrpt 5 11135 613 337 022 ops s r u PerfTransforms mapTransformation 1 thrpt 5 7264202 633 214787 109 ops s r u PerfTransforms mapTransformation 1024 thrpt 5 18795 790 713 668 ops s @benjchristensen I suppose the AtomicReferenceFieldUpdater mostly comes from less GC pressure is that why the raw throughput increases in your tests How did the GC wall time change If you want me to run a specific workload type of test let me know so we can compare results I ve been experimenting with FieldUpdaters and Unsafe for the SerializedObserver It seems that by using Unsafe directly and thus avoiding security checks and an indirection I can get about 8 10 more throughput The downsides are that it is scheduled to be removed standardized in future Java versions and platform dependence in terms of availability Should I pursue the Unsafe path @akarnokd since RxJava also runs on android I m not sure how good standard the support is there I know that the netty folks are having the same issues and they are wrapping those Unsafe calles in a PlatformDependent util class wrapping those Unsafe calles in a PlatformDependent util class This sounds like a valid approach for us As we mature Rx we ll want to squeeze as much performance out of it as we can while still remaining portable Testing with gradlew benchmarks Pjmh f 1 tu s bm thrpt wi 5 i 5 r 5 prof GC PerfTransforms ##### May 21st https github com Netflix RxJava commit 0efda073f1068b105478145904d788b2206d7c4e Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapTransformsUsingFrom 1 thrpt 5 4597237 797 227193 650 ops s r u PerfTransforms flatMapTransformsUsingFrom 1024 thrpt 5 12334 190 214 479 ops s r u PerfTransforms flatMapTransformsUsingJust 1 thrpt 5 4522036 147 216489 787 ops s r u PerfTransforms flatMapTransformsUsingJust 1024 thrpt 5 12293 223 321 573 ops s r u PerfTransforms mapTransformation 1 thrpt 5 9133316 230 303274 438 ops s r u PerfTransforms mapTransformation 1024 thrpt 5 19698 323 150 313 ops s ##### May 26th https github com Netflix RxJava commit a34cba2bcd96f99e3a0d193009a7ce25775a4ad2 Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapTransformsUsingFrom 1 thrpt 5 4367166 623 145506 857 ops s r u PerfTransforms flatMapTransformsUsingFrom 1024 thrpt 5 11382 233 425 976 ops s r u PerfTransforms flatMapTransformsUsingJust 1 thrpt 5 4468497 400 83649 115 ops s r u PerfTransforms flatMapTransformsUsingJust 1024 thrpt 5 11374 780 780 039 ops s r u PerfTransforms mapTransformation 1 thrpt 5 8851147 610 303583 393 ops s r u PerfTransforms mapTransformation 1024 thrpt 5 19649 227 1134 279 ops s According to these results we got slower though within mean error it appears so if not slower then no better Which Java version is this Java 6 intrinsics isn t as good as the newer versions Maybe the wip field in the merge operator causes more false sharing and needs padding Library Java JavaVirtualMachines jdk1 7 0_45 jdk Master branch with Library Java JavaVirtualMachines jdk1 8 0_05 jdk Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapTransformsUsingFrom 1 thrpt 5 4378589 533 109056 155 ops s r u PerfTransforms flatMapTransformsUsingFrom 1024 thrpt 5 10702 953 447 216 ops s r u PerfTransforms flatMapTransformsUsingJust 1 thrpt 5 4341206 933 184228 619 ops s r u PerfTransforms flatMapTransformsUsingJust 1024 thrpt 5 10961 550 545 574 ops s r u PerfTransforms mapTransformation 1 thrpt 5 8996983 320 226242 030 ops s r u PerfTransforms mapTransformation 1024 thrpt 5 19423 813 779 759 ops s Here is a simple test https gist github com benjchristensen 0e821794b0e510e0feed without JMH but using same coding pattern that shows significant increases in throughput from 0 16 0 17 0 18 current master branch for this code java public void mapTransformation UseCaseInput input throws InterruptedException input observable map i return String valueOf i map i return Integer parseInt i subscribe input observer input awaitCompletion ##### master Run 10 10 333 567 ops sec Run 11 10 235 100 ops sec Run 12 10 269 259 ops sec Run 13 10 170 560 ops sec Run 14 10 072 319 ops sec ##### Version 0 18 3 Run 10 7 973 782 ops sec Run 11 8 695 425 ops sec Run 12 8 283 768 ops sec Run 13 8 283 562 ops sec Run 14 8 270 888 ops sec ##### Version 0 17 6 using OnSubscribe Run 10 7 812 927 ops sec Run 11 7 632 713 ops sec Run 12 7 488 673 ops sec Run 13 7 975 944 ops sec Run 14 7 882 146 ops sec ##### Version 0 17 6 using OnSubscribeFunc Run 10 7 049 700 ops sec Run 11 7 175 042 ops sec Run 12 7 173 240 ops sec Run 13 7 069 685 ops sec Run 14 7 248 320 ops sec ##### Version 0 16 1 Run 10 4 765 899 ops sec Run 11 4 792 623 ops sec Run 12 4 709 982 ops sec Run 13 4 761 451 ops sec Run 14 4 769 627 ops sec Very good progress I ll get back to profiling from master next week I run some benchmarks with AtomicInteger and volatile int inside merge and it appears that JMH benchmark gives 10 more throughput with AtomicInteger Well that s odd and doesn t help much when two different ways of measuring are giving contradictory results We captured some profiling from a production instance and found evidence that suggests our atomic state machines are going to have to be changed or replaced The biggest allocation hotspot is creating rx Subscription from rx subscriptions CompositeSubscription State remove Subscription and rx subscriptions CompositeSubscription State add Subscription This accounts for approximately 104GB of total allocations within the profile 30 of total allocation There s also 1 5GB allocated for rx subjects SubjectSubscriptionManager State split pretty evenly from these 3 methods rx subjects SubjectSubscriptionManager State createNewWith SubjectSubscriptionManager SubjectObserver rx subjects SubjectSubscriptionManager State terminate rx subjects SubjectSubscriptionManager init Another 1 2GB of allocations for rx subjects SubjectSubscriptionManager SubjectObserver from 4 sources rx subjects SubjectSubscriptionManager State init boolean CountDownLatch SubjectSubscriptionManager SubjectObserver rx subjects SubjectSubscriptionManager State init java util Arrays copyOf Object int called by rx subjects SubjectSubscriptionManager State addObserver SubjectSubscriptionManager SubjectObserver rx subjects SubjectSubscriptionManager State removeObserver SubjectSubscriptionManager SubjectObserver Here s a list of top allocated rx objects that exceed 100MB numbers are in bytes rx Subscription 97 870 643 480 rx subjects SubjectSubscriptionManager State 1 624 120 080 rx subjects SubjectSubscriptionManager SubjectObserver 1 315 680 480 rx subscriptions Subscriptions 1 849 212 800 rx subscriptions CompositeSubscription State 837 518 872 rx subscriptions CompositeSubscription 641 083 960 rx observers SafeSubscriber 637 599 560 rx subjects SubjectSubscriptionManager SubjectObserver 618 721 656 rx Observable 30 585 739 968 rx operators SafeObservableSubscription 568 522 112 rx subjects SubjectSubscriptionManager 1 545 755 280 rx subjects ReplaySubject History 528 269 104 rx subjects ReplaySubject 443 043 720 rx Observable 395 292 296 rx operators OperatorMerge 1 InnerObserver 370 883 064 rx subjects ReplaySubject ReplayState 340 267 192 rx Observable 29 288 726 208 rx operators BlockingOperatorToFuture 2 288 463 944 rx subjects SubjectSubscriptionManager 281 230 064 rx subjects ReplaySubject 3 266 953 480 rx subjects ReplaySubject 2 260 071 464 rx operators BlockingOperatorToFuture 1 256 919 568 rx subjects SubjectSubscriptionManager 1 1 245 468 584 rx subjects ReplaySubject 1 238 637 944 rx operators OperatorCache 147 967 240 rx observers Subscribers 1 132 742 032 rx subscriptions BooleanSubscription 107 733 248 rx Observable 2 105 170 440 @benjchristensen Asked me to contribute a bit to this issue We ve been noticing some issues with RxJava 0 18 x through our use of Hystrix Let me setup our use case first to give you an idea of our usage pattern for this particular service We have a pretty standard public API think microservice single purpose that does about 200 s incoming calls and fans that out into 500 1000 command executions s This can burst to over 800 s incoming calls without warning The service is on a pretty modest deployment of c1 mediums but it s also sitting at about 20 CPU normally Since deploying Hystrix 1 3 16 w RxJava 0 18 2 our heaps that were previously steady sawtooths around 50 70mb have risen to over 150mb Additionally our CPU percentages really start to rise after a few days This appears to be linked to our latencyTotal_mean times deviating far from our latencyExecute_mean As you can see below the command is decreasing in ops s but the Hystrix overhead is rising This rise continues for about 5 days to where it s taking anywhere from 20 30ms of Hystrix overhead and the boxes are running near 80 90 CPU Command execution https lh3 googleusercontent com rUdmvgGkn0k U4ah34FBFdI AAAAAAAAALE amiC VBzbV4 s1600 download 282 29 png I took a heap dump of one of the production servers I can provide it on request but shown below is a piece I found interesting Subscription objects https lh5 googleusercontent com RoOTaW h358 U4aohtaU4lI AAAAAAAAALc 93tZ8ScAiG0 s1600 Screen Shot 2014 05 28 at 9 23 36 PM PNG Approximately 800K Subscriptions were present in the heap dump at the time which really smells off to me Even when I forced GCs they were sticking around See the below our heap usage was increasing over time Heap usage https lh4 googleusercontent com ZSx4hFVpVIg U4af1dMwdeI AAAAAAAAAK0 CXCMgBZM67I s1600 Screen Shot 2014 05 28 at 8 47 18 PM PNG I started looking at the CompositeSubscription used by Hystrix and really drilling into it ran across this CompositeSubscription array https dl dropboxusercontent com u 11103618 Screenshots rxjava compositesubscription png The subscription array on this has grown to 400K Perhaps this is an edge case but I believe that once it falls behind it really struggles to keep up This would explain the non linear jump in Hystrix overhead observed in the graph of the command execution time java State add Subscription s int idx subscriptions length Subscription newSubscriptions new Subscription idx 1 System arraycopy subscriptions 0 newSubscriptions 0 idx newSubscriptions idx s return new State isUnsubscribed newSubscriptions For every addition it s creating a brand new array and copying the new subscriptions into them Is there a reason behind that Removals then iterate the entire array and alloc a new array usually twice java State remove Subscription s if subscriptions length 1 subscriptions 0 equals s subscriptions length 0 return clear Subscription newSubscriptions new Subscription subscriptions length 1 int idx 0 for Subscription _s subscriptions if _s equals s was not in this composite if idx newSubscriptions length return this newSubscriptions idx _s idx if idx 0 return clear subscription appeared more than once if idx newSubscriptions length Subscription newSub2 new Subscription idx System arraycopy newSubscriptions 0 newSub2 0 idx return new State isUnsubscribed newSub2 return new State isUnsubscribed newSubscriptions I don t have a misbehaving instance at the moment but I d wonder if profiling would show lots of CPU time spent in remove Unless I m missing a key factor here I d think HashSet would be much more performant in this context for O 1 lookups removals I can t imagine that the overhead of the set entries would be more than memory copies At the very least an ArrayList would cut down on allocs copies Let me know if I m off base here I m very interested in helping resolve this issue Thanks for the details CompositeSubscription becomes very slow when it grows over the size of the cache line in the CPU and constant add remove is happening see #1145 Subscriptions 2 is perhaps the wrapper for Future which keeps a final reference to the Future object which generally shouldn t be a problem if its parent container is removing clearing it What is worrying is that there is an unsubscribed CompositeSubscription with a non empty array When unsubscribed CompositeSubscription should drop the entire array and don t accept any new additions Could you tell where that CompositeSubscription is embedded Got it In our use case we re doing a HystrixCommand#observe and passing the observable to java public static T ListenableFuture T toListenableFuture Observable T observable final SettableFuture T listenableFuture SettableFuture create final AtomicReference Subscription s new AtomicReference Subscription s set observable subscribe new Observer T @Override public void onCompleted @Override public void onError Throwable e listenableFuture setException e @Override public void onNext T args if listenableFuture isDone listenableFuture setException new IllegalStateException Observable should only have a single value else listenableFuture set args return listenableFuture This only happens 50 times a second per server CompositeSubscription is being used by HystrixContextScheduler#ThreadPoolWorker but from my investigation of the code it looks like these are recreated for each command invokation @benjchristensen am I right about this In my heap dump these 400 000 long arrays of Subscriptions seem to be actively being recycled and used so somehow those CompositeSubscription instances are sticking around I can t seem to identify where the ThreadPoolWorker instance might be getting reused though @Xorlev Thanks for the detailed post very helpful to have another set of clues beyond what we ve been seeing I d think HashSet would be much more performant in this context for O 1 lookups removals I can t imagine that the overhead of the set entries would be more than memory copies At the very least an ArrayList would cut down on allocs copies For the use cases we appear to be triggering definitely yes This is partially what @akarnokd was seeking to solve in https github com Netflix RxJava pull 1145 When we designed the current implementation of CompositeSubscription we used an atomic state machine as the expectation was that there should never be more than a handful of Subscription s added to it and we were trying to avoid mutable state needing to be protected by locks and that the extra object allocations to allow use of compareAndSet was okay Performance testing we ve done has shown this to be a win in the cases we ve been testing but obviously there are cases where this is breaking badly So we can pivot to using a mutable data structure protected by locks to avoid the object allocation such as this https gist github com benjchristensen 541c2dbb5fca94ee4155 but right now I m still trying to identify the use cases that are causing this What is worrying is that there is an unsubscribed CompositeSubscription with a non empty array When unsubscribed CompositeSubscription should drop the entire array and don t accept any new additions Could you tell where that CompositeSubscription is embedded This is an open question We see the same symptom in our production environment though not sure if it s an actual leak or just such high pressure that the GC can t keep up so it looks like they are leaking Researching further today HystrixContextScheduler#ThreadPoolWorker Yes that is just a thin wrapper around a real Scheduler used by Hystrix to copy state across threads It is allocated for each command these 400 000 long arrays of Subscriptions seem to be actively being recycled and used so somehow those CompositeSubscription instances are sticking around That is the key problem I m trying to find today I m going to focus on the Hystrix use cases since it s the one that triggers it Seems it is either a bug in how Hystrix is using Rx or it s triggering a bug or unexpected use case in Rx that we need to handle If it s helpful I also found this interesting which lead me down the path of investigating CompositeSubscription State Stack https dl dropboxusercontent com u 11103618 Screenshots rxjava subremoval png I can put the heap dump on Dropbox and email you a link if it d be helpful Ben That is helpful It points to looking at the EventLoopScheduler This is creating lots of ArrayList instances unnecessarily https github com Netflix RxJava blob 0 18 2 rxjava core src main java rx subscriptions CompositeSubscription java#L172 screen shot 2014 05 29 at 10 35 48 am https cloud githubusercontent com assets 813492 3120998 b281d270 e757 11e3 82f4 0c4fb645e6a7 png screen shot 2014 05 29 at 10 37 45 am https cloud githubusercontent com assets 813492 3121021 f843b5a8 e757 11e3 83c5 b18f251952d9 png replaystate arraylist object https cloud githubusercontent com assets 813492 3121057 4f67c9dc e758 11e3 8f4b 8e9e9c12372c png hystrix rx with 0 18 2 https cloud githubusercontent com assets 813492 3121117 ec086eae e758 11e3 9d54 43bb8b647199 png Those were from 0 18 2 now with Master plus a modified https gist github com benjchristensen 541c2dbb5fca94ee4155 CompositeSubscription we get this hystrix rx with master new compositesubscription https cloud githubusercontent com assets 813492 3121129 1ce1746c e759 11e3 918c 4d6e97c92dc2 png Here is evidence for need of work on ReplaySubject replaysubject 1 https cloud githubusercontent com assets 813492 3121171 8a1b7a6e e759 11e3 85bc 270167719e34 png replaysubject 2 https cloud githubusercontent com assets 813492 3121172 8cd26e02 e759 11e3 9544 70f900a80890 png replaysubject 3 https cloud githubusercontent com assets 813492 3121174 8f90fa46 e759 11e3 8680 898da7e2b3a9 png 0 18 2 map observeon https cloud githubusercontent com assets 813492 3121261 76d1a61c e75a 11e3 82c4 96e59ac1ddfa png master map observeon https cloud githubusercontent com assets 813492 3121263 7b1c9600 e75a 11e3 96a7 56e30df059cf png The Subscription issue is definitely being caused by the use of a Scheduler Here is some evidence subscription array when using scheduler https cloud githubusercontent com assets 813492 3121292 c1c39f54 e75a 11e3 97b9 5ba75cdb040b png Then the master branch with CompositeSubscription change screen shot 2014 05 29 at 10 58 09 am https cloud githubusercontent com assets 813492 3121303 d65be0fc e75a 11e3 8902 5f9ead818735 png The issue is definitely the CompositeSubscription as the following shows where it is master as it currently stands without my changes to CompositeSubscription master without changing compositesubscription https cloud githubusercontent com assets 813492 3121347 3f171634 e75b 11e3 9246 aff40bf88eeb png I ve added some logging to our production instances and discovered that the cause of large Subscription arrays we see in practice is caused by a prefetching operation which generates many 500 HystrixCommand s calls observe on them puts them in an ArrayList and finally calls Observable merge on this list to have a single place to listen for overall completion This seems like a valid case to support and any work which improves performance for large Subscription arrays would be a meaningful improvement I have submitted a pull request for this https github com Netflix RxJava pull 1281 We are testing the code in our environment shortly For anyone wanting to dig into this Java Flight Recorder has been very helpful and far better than the other profiling tools I ve used and tried for this Backporting to 0 18 x in https github com Netflix RxJava pull 1283 Superb work guys I ve held off on 18 x on Android as I noticed an increase in GC really glad you guys take this seriously Thanks @chrisjenx it looks like the most glaring issues are resolved and low hanging fruit taken care of There are a few other things for us to improve on but I think we ll release 0 19 early next week I would appreciate your feedback on whether you see an improvement I have also opened https github com Netflix RxJava issues 1299 to document our attempts on blocking vs non blocking implementations and to seek input from anyone who can provide better solutions @akarnokd Is there anything else that stands out to you that we should fix before closing this issue I ll continue doing some profiling but it seems the obvious ones are done We ll continue working on performance going forward and those can have their own issues and pull requests so if nothing else obvious stands out let s close this issue and not leave it open ended The history List in ReplaySubject since ArrayList uses more memory then actual items it might be worth compacting it on a terminal state one time but might be costly and run out of memory Alternatively it could use fixed increment expansion strategy Third option is to have a cache overload that passes in a capacity hint to reduce reallocation and wasted space I think that the object allocation penalty of resizing after a terminal event would be worse A cache overload that takes a capacity hint may be valuable particularly in the single item case where it could just a single volatile ref instead of an array I have opened a new issue for the cache overload https github com Netflix RxJava issues 1303 I m closing this issue out as I believe we have handled the most glaring problems and don t want this to be a never ending issue We will of course continue seeking to improve performance but let s use individual issues for each improvement problem we find Thanks everyone for your involvement on this one as it was rather significant and important @Xorlev and @daschl I would appreciate feedback once you ve had a chance to try the changes in the master branch or the portion that was backported to 0 18 4 to know if you see the improvements or still have issues @Xorlev In particular I d like to know if the issue you had was only the GC pressure or if you still see signs of a memory leak which I have not seen yet @benjchristensen Hystrix 1 3 16 w RxJava 0 18 4 has been in prod for about a day now I m happy to report a decrease in garbage and CPU usage in general I believe the pressure the suboptimal subscription removal was causing the leak like behavior @mattrjacobs s use case matches a few of our own fan out commands wait on all which is likely the source of the large numbers of subscriptions I ll keep an eye out for any similar issues that might crop up Thanks a lot for all the help and dedication to improving RxJava Excellent Thank you @Xorlev for the confirmation I ll release Hystrix 1 3 17 in a few days hopefully with RxJava 0 19 as a dependency and at least one performance optimization I found I can do in Hystrix directly',RxJava,false,false,false
33645598,'JMH and use of Blackhole','I was discussing JMH with @shipilev and he brought this to my attention while informing me our use of JMH may not be quite right http hg openjdk java net code tools jmh file 48d149ac3218 jmh samples src main java org openjdk jmh samples JMHSample_28_BlackholeHelpers java Opening this issue to track it and get our JMH input class improved https github com Netflix RxJava blob master rxjava core src perf java rx jmh InputWithIncrementingInteger java#L74','This should suffice dependencies perfCompile org openjdk jmh jmh core 0 5 3 perfCompile org openjdk jmh jmh generator annprocess 0 5 3 perfCompile org openjdk jmh jmh core 0 7 1 perfCompile org openjdk jmh jmh generator annprocess 0 7 1 perfCompile project and private CountDownLatch latch @Setup public void setup public void setup final BlackHole bh observable Observable create new OnSubscribe Integer @Override public void call Subscriber super Integer o @@ 55 7 55 6 @@ final BlackHole bh new BlackHole latch new CountDownLatch 1 observer new Observer Integer I know that this needs to be passed in but is it in this case because of DCE the hole itself would be removed rendering the other part dead too @shipilev Yes Blackhole itself is DCE d along with the computation it consumes With JMH 0 6 the attempt to instantiate Blackhole directly will throw http hg openjdk java net code tools jmh rev de0365d7e4d0 see the comment there for rationale Therefore if there are benchmarks which fail after updating the JMH version you know what to fix @shipilev alright staying cool Thanks @benjchristensen should I take this on Thanks @shipilev for the information Yes @daschl If you can take this on I d appreciate it While you are at it you may want to update to 0 7 2 Finished upgrading to 0 7 3',RxJava,false,false,false
33701373,'What should i use for thread pool execution in new api','What should i use for thread pool execution in new api For example all http request in android recommended to be executed on cached thread pool','Take a look at https github com Netflix RxJava issues 713#issuecomment 43292434 and https github com Netflix RxJava issues 1219 Another item of interest is https github com Netflix RxJava pull 1143 @lexer Please try out the implemented just merged in @1272 and let us know if it gives you what you need We are also still going to proceed with an improved IO Scheduler as per https github com Netflix RxJava issues 1140 The Schedulers io scheduler will now cache threads again due to the work in #1140 There is also a new ExecutorScheduler that you can access using Schedulers from Executor',RxJava,false,false,false
33706097,'Operator ObserveOn without queue','Now that the CPU IO Scheduler Worker is guaranteed to be run on the same thread do we need serialization and queueing in ObserveOn Since the worker already does the MPSC behavior there is no need to do it before that On the other hand if a worker is stalled ObserveOn batches up the work and we may avoid some overhead elsewhere Thoughts','That sounds like it should be okay and beneficial though I think we may want to leverage the code pattern from observeOn to implement ExecutorScheduler again https github com Netflix RxJava issues 1219 On this observeOn doesn t use the queue in order to achieve serialization it assumes sequential thread safe onNext as per the Rx contract I think you re right about the duplicative queueing though and that we can just create a Scheduler Worker and queue the work The only thing that will affect this design is when we do backpressure where we need to know the queue depth and size which observeOn currently knows If we re going to drop things into a Scheduler we d lose that knowledge unless we figure out a way to expose it Here is a prototype showing how observeOn uses the knowledge about the queue to work with the backpressure contract https github com benjchristensen RxBackpressure blob master rx bp prototype src main java rx operators OperatorObserveOn java#L167 A possibly related thing I have been thinking about is to have a synchronous version of observeOn that only hops threads but uses no queue The original schedulers were derived from http msdn microsoft com en us library System Windows Forms WindowsFormsSynchronizationContext_methods v vs 110 aspx but we never implemented a Send based version of ObserveOn only hops threads but uses no queue That would mean it must block the calling thread Why would we want this especially once #1000 is implemented I m moving this off of 0 19 0 as these are internal or additive and can come later Sometimes that is also a valid way to achieve back pressure say where without observeOn you d block the producer thread as well In that case is you just want to do something on a particular thread it seems natural that you can do that without introducing additional buffering @headinthebox Do you still want to pursue this If so what should it be called and where should it live Is this still wanted now that we have non blocking backpressure support Most definitively I think that is super useful for many event based situations where requesting makes little sense and where you do not want to buffer either My proposal would be to simply call it hop scheduler or hopOn since that is all it does or but that might make only send for NET folks send scheduler non blocking backpressure is a grandiloquence for async pull but opinions aside I think Rx should give developers a choice how they want to deal with back pressure As to where I think it should be a regular method on Observable On a related note I ve considered adding onBackpressureBlock similar to how we have onBackpressureDrop and onBackpressureBuffer grandiloquence Nice word usage But this operator is totally orthogonal to the other kind of backpressure not It only hops threads but does not decouple their speed wether or not you were push or partial pull',RxJava,false,false,false
33727328,'OperatorToObservableList use LinkedList to buffer the sequence s items','LinkedList has guaranteed constant insertion time when appending to the end of the list whereas ArrayList takes O 1 amortized since a reallocation might be necessary to insert further items Since no capacity was specified for the buffer on Hotspot this would cause the array to reallocate after the first 10 insertions on Android even after the first insertion since Android s ArrayList uses a default capacity of zero Since the buffer is copied to an ArrayList before emission subscriber performance when working with the list should remain unaffected Sorry for the import noise that s IntelliJ reformatting them every time I look at the file Refs #1141','RxJava pull requests #1117 https netflixoss ci cloudbees com job RxJava pull requests 1117 SUCCESS This pull request looks good Why do we copy it to a new ArrayList before emitting I agree that this change will be fine because of that but that seems odd Merging and will let future performance discussions handle that case Added comments in https github com Netflix RxJava issues 1218 to research this further Good question It was copied before and I assumed it was done so as to not leak the internal buffer to the subscriber Since it won t be modified after emission this shouldn t make any difference in practice though Copying it makes more sense now that the buffer is a LinkedList since for large sequences this would change access times for callers when using random access to elements Then again these are all hunches so I can t really say what the right thing to do is here For us it s highly unlikely that list sequences would be longer than a few dozen items so no harm either way On May 20 2014 6 15 AM Ben Christensen notifications@github com wrote Added comments in #1218 https github com Netflix RxJava issues 1218 to research this further Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 1208#issuecomment 43584846',RxJava,true,false,false
33730151,'Any reason FuncN is not parametrized on the input type','Current FuncN definition is only parametrized on the result type loosing type information regarding the input of the call method public interface FuncN R extends Function public R call Object args An implementer will most often cast the parameter in order to process it adequately Which can be tricky and ugly for arrays For example when using the varadic overload of CombineLatest a sequence List Observable Boolean Observable List Boolean looks like this Observable List Boolean sequence List Observable Boolean listOfObservableBools return Observable combineLatest listOfObservableBools new FuncN List Boolean public List Boolean call Object args Boolean Arrays copyOf args args length Boolean class Ewww return Arrays asList booleans It also prevents abstracting over the content type here Boolean as erasure disallows something like T class It is thus impossible to implement a generic version of this operator List Observable T Observable List T The solution IMHO is to add a type parameter to FuncN representing the type of the input parameter public interface FuncN T R extends Function public R call T args CombineLatest would go from public static final T R Observable R combineLatest List extends Observable extends T sources FuncN extends R combineFunction to public static final T R Observable R combineLatest List extends Observable extends T sources FuncN extends T extends R combineFunction making this and others usages possible Observable List T sequence List Observable T listOfObservableTs return Observable combineLatest listOfObservableTs new FuncN T List T public List T call T args return Arrays asList args Is there a technical reason for the current state of affair Thanks for your hard work and time','Is there a technical reason for the current state of affair Answering my own question As far as I can see having FuncN non parametrized on the input type was made to permits using combineLatest List FuncN in the implementations of the multiple parameter versions combineLatest Observable T1 Observable T2 Func2 T1 T2 R combineLatest Observable T1 Observable T2 Observable T3 Func3 T1 T2 T3 R through a transformation from Func 2 3 4 R to FuncN R looking like this public static T0 T1 T2 T3 R FuncN R fromFunc final Func4 super T0 super T1 super T2 super T3 extends R f return new FuncN R public R call Object args if args length 4 throw new RuntimeException Func4 expecting 4 arguments return f call T0 args 0 T1 args 1 T2 args 2 T3 args 3 Indeed in that case the parameters types might be heterogeneous and fallback to the lower denominator type Object before being cast back to their original type The FuncN type is used in places 3 that I m aware of where heterogeneous types are supported and there are more than 9 types supported by Func1 through Func9 These are combineLatest and zip both of which have strongly typed signatures up to 9 types Which is a simpler than messing with tuples If you need a function with more than 8 arguments you may want to apply for a job at MS Office http msdn microsoft com en us library microsoft office interop excel _workbook_members v office 15 aspx @headinthebox Not such a bad match after all a spreadsheet is nothing but a glorified UI for Observable streams FRP style Still even in a inadequate language like java compared to haskell or any lang with proper support and un currying I d favor tuples to List Object anyday I d favor tuples to List Object anyday Let s agree to disagree on this You are trading a lot of complexity for what some type safety In this case that is not worth the trouble Static types are nice when they work but they are just a means to an end not a goal you chase at any cost Like spice food',RxJava,false,false,false
33748108,'Add more operators to RxScala','Conflicts against #1178 too I will rebase once #1178 is merged to master cc @samuelgruetter','RxJava pull requests #1122 https netflixoss ci cloudbees com job RxJava pull requests 1122 SUCCESS This pull request looks good Nice examples in RxScalaDemo RxJava pull requests #1125 https netflixoss ci cloudbees com job RxJava pull requests 1125 SUCCESS This pull request looks good LGTM',RxJava,true,false,false
33773918,'Time and or size bounded ReplaySubject extensions','ReplaySubject with time and or size bounds I ve implemented this so that there is no need for a separate BoundedReplaySubject or CustomReplaySubject The previous PR was messed up a bit after the merge with main','RxJava pull requests #1127 https netflixoss ci cloudbees com job RxJava pull requests 1127 SUCCESS This pull request looks good Now that the other Subject PR has been merged can you want to rebase this and or make whatever changes you need for it to be in sync Sure I ll open a new branch and PR to keep things clean',RxJava,true,false,false
33790608,'CombineLatest overhaul proposal','As noted in #1209 the combineLatest Observable T1 Observable T2 Func overloads currently delegate their actual behavior to combineLatest List Observable FuncN To achieve this feat the Observables are aggregated into a List Observable Object loosing their content type in the process At the same time the user provided Func 1 2 3 is wrapped with a FuncN that reinstate the type through casting before applying the function This is quite elegant in term of code reuse but has at least the following disadvantages it introduces potentially dangerous runtime cast it prevents FuncN to be parametric on its input type as the list might be heterogenous Being bitten by the second point I devised typesafe alternatives to the overloads Here is roughly how it goes where X 2 combineLatestX being the overload taking X Observable arguments funcX being a function constructing a tuple of X elements do combineLatestX o1 oX funcX combineLatest2 oX combineLatestX 1 o1 oX 1 funcX 1 Values are the extracted from the tuple and passed to the user provided transformation As all the overloads where X 2 follow this pattern only an implementation of combineLatest2 is required The one provided bellow is quite naive and would benefit from your insight From now on combineLatest List Observable FuncN is free from the heterogeneous list constraint and can also be expressed as a recursive combination of combineLatest2 Below is a naive implementation of those ideas No though have been given to performance threading for now The tuples classes come from the java tuples library http www javatuples org Is this approach worth pursuing How could I compare performances relative to the current code Any remark comment Thanks for your time and energy anyway public static T1 T2 R Observable R combineLatest final Observable T1 o1 final Observable T2 o2 final Func2 T1 T2 R func return Observable create new Observable OnSubscribe R T1 val1 null T2 val2 null @Override public void call final Subscriber super R subscriber Subscription o1Subscription o1 subscribe new Action1 T1 @Override public void call T1 t1 val1 t1 if val2 null subscriber onNext func call val1 val2 Subscription o2Subscription o2 subscribe new Action1 T2 @Override public void call T2 t2 val2 t2 if val1 null subscriber onNext func call val1 val2 subscriber add Subscriptions from o1Subscription o2Subscription public static T1 T2 T3 R Observable R combineLatest Observable T1 o1 Observable T2 o2 Observable T3 o3 final Func3 T1 T2 T3 R func Observable Pair T1 T2 pairObservable combineLatest o1 o2 new Func2 T1 T2 Pair T1 T2 @Override public Pair T1 T2 call T1 integer T2 integer2 return new Pair T1 T2 integer integer2 return Observable combineLatest pairObservable o3 new Func2 Pair T1 T2 T3 R @Override public R call Pair T1 T2 integerIntegerPair T3 integer return func call integerIntegerPair getValue0 integerIntegerPair getValue1 integer public static T1 T2 T3 T4 R Observable R combineLatest Observable T1 o1 final Observable T2 o2 Observable T3 o3 Observable T4 o4 final Func4 T1 T2 T3 T4 R func Observable Triplet T1 T2 T3 tripletObservable combineLatest o1 o2 o3 new Func3 T1 T2 T3 Triplet T1 T2 T3 @Override public Triplet T1 T2 T3 call T1 t1 T2 t2 T3 t3 return new Triplet T1 T2 T3 t1 t2 t3 return Observable combineLatest tripletObservable o4 new Func2 Triplet T1 T2 T3 T4 R @Override public R call Triplet T1 T2 T3 objects T4 t4 return func call objects getValue0 objects getValue1 objects getValue2 t4 public static T1 T2 T3 T4 T5 R Observable R combineLatest Observable T1 o1 final Observable T2 o2 Observable T3 o3 Observable T4 o4 Observable T5 o5 final Func5 T1 T2 T3 T4 T5 R func Observable Quartet T1 T2 T3 T4 quartetObservable combineLatest o1 o2 o3 o4 new Func4 T1 T2 T3 T4 Quartet T1 T2 T3 T4 @Override public Quartet T1 T2 T3 T4 call T1 t1 T2 t2 T3 t3 T4 t4 return new Quartet T1 T2 T3 T4 t1 t2 t3 t4 return Observable combineLatest quartetObservable o5 new Func2 Quartet T1 T2 T3 T4 T5 R @Override public R call Quartet T1 T2 T3 T4 objects T5 t5 return func call objects getValue0 objects getValue1 objects getValue2 objects getValue3 t5 public static T1 T2 T3 T4 T5 T6 R Observable R combineLatest Observable T1 o1 final Observable T2 o2 Observable T3 o3 Observable T4 o4 Observable T5 o5 Observable T6 o6 final Func6 T1 T2 T3 T4 T5 T6 R func Observable Quintet T1 T2 T3 T4 T5 quintetObservable combineLatest o1 o2 o3 o4 o5 new Func5 T1 T2 T3 T4 T5 Quintet T1 T2 T3 T4 T5 @Override public Quintet T1 T2 T3 T4 T5 call T1 t1 T2 t2 T3 t3 T4 t4 T5 t5 return new Quintet T1 T2 T3 T4 T5 t1 t2 t3 t4 t5 return Observable combineLatest quintetObservable o6 new Func2 Quintet T1 T2 T3 T4 T5 T6 R @Override public R call Quintet T1 T2 T3 T4 T5 objects T6 t6 return func call objects getValue0 objects getValue1 objects getValue2 objects getValue3 objects getValue4 t6 public static T1 T2 T3 T4 T5 T6 T7 R Observable R combineLatest Observable T1 o1 final Observable T2 o2 Observable T3 o3 Observable T4 o4 Observable T5 o5 Observable T6 o6 Observable T7 o7 final Func7 T1 T2 T3 T4 T5 T6 T7 R func Observable Sextet T1 T2 T3 T4 T5 T6 sextetObservable combineLatest o1 o2 o3 o4 o5 o6 new Func6 T1 T2 T3 T4 T5 T6 Sextet T1 T2 T3 T4 T5 T6 @Override public Sextet T1 T2 T3 T4 T5 T6 call T1 t1 T2 t2 T3 t3 T4 t4 T5 t5 T6 t6 return new Sextet T1 T2 T3 T4 T5 T6 t1 t2 t3 t4 t5 t6 return Observable combineLatest sextetObservable o7 new Func2 Sextet T1 T2 T3 T4 T5 T6 T7 R @Override public R call Sextet T1 T2 T3 T4 T5 T6 objects T7 t7 return func call objects getValue0 objects getValue1 objects getValue2 objects getValue3 objects getValue4 objects getValue5 t7 public static T1 T2 T3 T4 T5 T6 T7 T8 R Observable R combineLatest Observable T1 o1 final Observable T2 o2 Observable T3 o3 Observable T4 o4 Observable T5 o5 Observable T6 o6 Observable T7 o7 Observable T8 o8 final Func8 T1 T2 T3 T4 T5 T6 T7 T8 R func Observable Septet T1 T2 T3 T4 T5 T6 T7 septetObservable combineLatest o1 o2 o3 o4 o5 o6 o7 new Func7 T1 T2 T3 T4 T5 T6 T7 Septet T1 T2 T3 T4 T5 T6 T7 @Override public Septet T1 T2 T3 T4 T5 T6 T7 call T1 t1 T2 t2 T3 t3 T4 t4 T5 t5 T6 t6 T7 t7 return new Septet T1 T2 T3 T4 T5 T6 T7 t1 t2 t3 t4 t5 t6 t7 return Observable combineLatest septetObservable o8 new Func2 Septet T1 T2 T3 T4 T5 T6 T7 T8 R @Override public R call Septet T1 T2 T3 T4 T5 T6 T7 objects T8 t8 return func call objects getValue0 objects getValue1 objects getValue2 objects getValue3 objects getValue4 objects getValue5 objects getValue6 t8 public static T1 T2 T3 T4 T5 T6 T7 T8 T9 R Observable R combineLatest Observable T1 o1 final Observable T2 o2 Observable T3 o3 Observable T4 o4 Observable T5 o5 Observable T6 o6 Observable T7 o7 Observable T8 o8 Observable T9 o9 final Func9 T1 T2 T3 T4 T5 T6 T7 T8 T9 R func Observable Octet T1 T2 T3 T4 T5 T6 T7 T8 octetObservable combineLatest o1 o2 o3 o4 o5 o6 o7 o8 new Func8 T1 T2 T3 T4 T5 T6 T7 T8 Octet T1 T2 T3 T4 T5 T6 T7 T8 @Override public Octet T1 T2 T3 T4 T5 T6 T7 T8 call T1 t1 T2 t2 T3 t3 T4 t4 T5 t5 T6 t6 T7 t7 T8 t8 return new Octet T1 T2 T3 T4 T5 T6 T7 T8 t1 t2 t3 t4 t5 t6 t7 t8 return Observable combineLatest octetObservable o9 new Func2 Octet T1 T2 T3 T4 T5 T6 T7 T8 T9 R @Override public R call Octet T1 T2 T3 T4 T5 T6 T7 T8 objects T9 t9 return func call objects getValue0 objects getValue1 objects getValue2 objects getValue3 objects getValue4 objects getValue5 objects getValue6 objects getValue7 t9 public static final T R Observable R combineLatest List extends Observable T sources final FuncList T extends R combineFunction Observable RecursiveList T recursivePairObservable collect sources iterator return recursivePairObservable map new Func1 RecursiveList T R @Override public R call RecursiveList T tRecursivePair List T ts toList tRecursivePair return combineFunction call ts public interface FuncList T R extends Function public R call List T args static class RecursiveList T final T head final RecursiveList T tail RecursiveList T t RecursiveList T list head t tail list private static final T List T toList RecursiveList T pairs ArrayList T res new ArrayList T RecursiveList T current pairs do res add current head current current tail while current null return res private static final T Observable RecursiveList T collect Iterator extends Observable T iterator if iterator hasNext return null Observable T head iterator next Observable RecursiveList T rec f iterator return rec null head map new Func1 T RecursiveList T @Override public RecursiveList T call T t return new RecursiveList T t null combineLatest head rec new Func2 T RecursiveList T RecursiveList T @Override public RecursiveList T call T t RecursiveList T tRecursivePair return new RecursiveList T t tRecursivePair','Hi First of all managing proper concurrency and termination condition in combineLatest is not trivial it has to wait for all sources to emit at least one value or detect if they terminated without any must forward exceptions should be null insensitive should terminate if all terminated Second chaining combineLatest operators adds multiple times the overhead of a single stride combineLatest depending on the depth which is undesired in general Third we tried to avoid tuples so far We will not bring in a 3rd party library to rxjava core Use of tuples is also a significant performance issue in Java because of object allocation In Java 9 it may become an option with value types http cr openjdk java net jrose values values 0 html Can you elaborate on the problems you re trying to solve it prevents FuncN to be parametric on its input type as the list might be heterogenous This is by design See next point it introduces potentially dangerous runtime cast For arities 1 9 this is not the case because the input guards the output thus we are only casting to the type that was passed in If you are using combineLatest or zip with 9 types then yes you lose type safety Are you trying to use combineLatest for 9 types Hi @akarnokd @benjchristensen Thanks for your quick feedbacks Note that I don t have major issue with the current implementation on a practical basis and happily use it heavily The exception being the FuncN call Object elem signature It enforces API users to do silly casts or worst copying when dealing with generic element type erasure See #1209 Can you elaborate on the problems you re trying to solve This proposal began as a way to make FuncN generic on its input type This required to remove the usage of combineLatest List Observable FuncN by the other overloads Thus they had to be re implemented and the proposed recursive approach seemed to be a good opportunity to ensure code reuse types preservation and runtime casts avoidance The latter being more of a theoretical matter of correctness certainly over weighted by the practical considerations you are expressing For arities 1 9 this is not the case because the input guards the output thus we are only casting to the type that was passed in Somehow downcasting to Object then upcasting to the proper type feels itchy managing proper concurrency and termination condition in combineLatest is not trivial Agreed Not feeling competent enough I decided to pass on these important details for the initial naive implementation it has to wait for all sources to emit at least one value The code above respects this constraint detect if they terminated without any must forward exceptions should be null insensitive should terminate if all terminated Not implemented Second chaining combineLatest operators adds multiple times the overhead of a single stride combineLatest depending on the depth which is undesired in general It might indeed but on the other hand runtime type checks casts are also quite expensive I d be if you guys could point me to a way to quantify the overhead benchmark in term of performance we tried to avoid tuples so far Use of tuples is also a significant performance issue in Java because of object allocation Can t deny this approach is more memory hungry As for avoiding tuples well they have the advantage of keeping type information in the absence of HLists We will not bring in a 3rd party library to rxjava core I concur the proposed implementation relies on java tuples for simplicity sake but if ever this change is considered for inclusion I guess it would need to include those types internally Somehow downcasting to Object then upcasting to the proper type feels itchy Yup but that s why Java itself is doing whenever generics are involved because is does type erasure It s my view that the code should be left as is Func1 Func9 provide type safe usage of combineLatest and FuncN is there for arities 10 which really shouldn t be happening but it s there if needed In those cases we have accepted that it is not type safe 1 for @benjchristensen',RxJava,false,false,false
33809637,'Another strategy was already registered even when using default','I ve been experimenting with rxjava debug One problem I ve run into is that I must set the observable execution hook before anything else or else I get Another strategy was already registered exception The exception seems off when RxJavaObservableExecutionHook is the hook being used in that case it feels like you should still be able to register a new hook if the default is just being used to cover','This was done to reduce the overhead as much as possible when hooks where not in use at all I ve toyed with the idea of submitting a PR for ComposableRxJavaObservableExecutionHook to allow late registration of as many hooks as you need @abersnaze If you do it should be a separate module and not part of core @dlew This is done for determinism A single plugin is registered during the entire lifecycle of an application This rule applies to all plugin types Otherwise caching thread safety and non deterministic behavior all become issues Alright that makes sense thanks',RxJava,false,false,false
33818590,'Retry with Predicate','Several people have expressed need for conditional retry behavior I suggest a new retry overload that simply takes a predicate that receives the Throwable java public final Observable T retry Func1 Throwable Boolean predicate This would allow deciding whether to retry based on the Throwable and or count which can be maintained by the Func1 Or we could use a Func2 and pass in the count java public final Observable T retry Func2 Integer Throwable Boolean predicate','Here is the type of thing that has to be done for conditional retries without this overload java import java util concurrent atomic AtomicInteger import rx Observable import rx Subscriber public class ConditionalRetry public static void main String args final AtomicInteger c new AtomicInteger Observable String oWithRuntimeException Observable create Subscriber super String s System out println Execution c get if c incrementAndGet 3 s onError new RuntimeException retryable else s onNext hello s onCompleted final AtomicInteger c2 new AtomicInteger Observable String oWithIllegalStateException Observable create Subscriber super String s System out println Execution c2 get if c2 incrementAndGet 3 s onError new RuntimeException retryable else s onError new IllegalStateException subscribe oWithRuntimeException subscribe oWithIllegalStateException public static void subscribe Observable String o o o materialize flatMap n if n isOnError if n getThrowable instanceof IllegalStateException return Observable just n else return Observable error n getThrowable else return Observable just n retry dematerialize o subscribe System out println t t printStackTrace Completed',RxJava,false,false,false
33826388,'RxJavaErrorHandler does not get invoked when onErrorResumeNext onErrorReturn are involved','The RxJavaErrorHandler only gets invoked in SafeSubscriber _onError ex Given the use of operators as of RxJava 0 17 x onErrors caught and handled by the onErrorResumeNext onErrorReturn patterns don t propagate out to SafeSubscriber and never get handled','One of solutions that we came up with was to add logic to onError methods to report the errors to the plugin before allowing the closure the chance to ignore them I m not a fan of this one because it could lead to double reporting of errors error new Exception onErrorResumeNext e concat just null error e Another idea was to wrap the invocation of all user code to handle exceptions in a consistent way across of the Rx codebase This would be a huge change and makes the assumption that the Rx code is prefect with regards to exception handling As an experiment I changed the signature of Func0 N and Action0 N to call throws Throwable and was greeted with thousands of errors There are lots of places where an operator invokes a closure without garding against it failing Now tracked by Pull Request #1306 Done in #1306',RxJava,false,false,false
33827211,'Exposing PublishSubject','All other subjects Async Behavior Replay have non private companion objects','RxJava pull requests #1128 https netflixoss ci cloudbees com job RxJava pull requests 1128 SUCCESS This pull request looks good',RxJava,true,false,false
33837005,'BehaviorSubject create','Add BehaviorSubject create without need for default See https github com Netflix RxJava issues 1174#issuecomment 42618353 for a discussion on this','Available in #1185 but it surely needs rebasing and syncing with the bounded ReplaySubject Available in #1185 but it surely needs rebasing and syncing with the bounded ReplaySubject Merged and available https github com Netflix RxJava blob master rxjava core src main java rx subjects BehaviorSubject java#L75',RxJava,false,false,false
33857260,'ToList copies entire list in onCompleted','Why does toList accumulate the contents in a List and then copy the entire list against before emitting inside onCompleted It seems wasteful and unnecessary since it shouldn t change again Is this protecting against misbehaving sources that continue emitting after onCompleted If so it would be cheaper to do boolean checks in onNext rather than copy the entire List https github com Netflix RxJava blob 3f039359c3f65c69e348197ef9c5fae24f943cb8 rxjava core src main java rx operators OperatorToObservableList java#L50 Secondarily to this what is the optimal data structure for this It was changed to LinkedList here https github com Netflix RxJava pull 1208 This is possibly better for small toList scenarios but worse for iterating when consuming the list due to non contiguous memory Perhaps a better internal list implementation other than LinkedList or ArrayList that gives us the contiguous memory and can grow as needed like ArrayList but doesn t grow unnecessarily or allocate more memory than needed in standard cases such as an Observable of length 1','Use Collections unmodifiableList I think toList only needs to emit an immutable list Perhaps a better internal list implementation other than LinkedList or ArrayList that gives us the contiguous memory and can grow as needed like ArrayList but doesn t grow unnecessarily or allocate more memory than needed in standard cases such as an Observable of length 1 I think which is better depends on the use case Is it worth to add a toList overload like toList Func0 extends List T listFactory Just for some background on why I made the change it wasn t due to the use of ArrayList per se but due to it using the default constructor which uses a platform dependent initial capacity Since on Android this capacity is zero the behavior was inefficient Done in https github com Netflix RxJava pull 1504',RxJava,false,false,false
33857506,'New ExecutorScheduler Implementation','It turns out a lot of people used ExecutorScheduler despite its problems #711 #713 We need to bring it back but in a way that is compliant with the contract This will mean that each Worker from the ExecutorScheduler will need to maintain it s own queue outside of the Executor similar to observeOn and then recurse on the Executor Only a single task per Worker can be scheduled enqueued on an Executor and when it completes then it should recurse pulling items from the Worker queue When the queue is empty it can stop processing When a new task is enqueued on the Worker then it can schedule against for execution on the Executor We will be working against the default behavior of the Executor but need to do that to maintain the single threaded contract of a Scheduler Worker','@benjchristensen you ve probably already investigated but does any of the quasar work help or the backported ForkJoin for JRE6 My understanding of ForkJoin is that it would still have the same need for us to manage a queue externally otherwise it will process the items on multiple threads concurrently if we put them into the ForkJoin queue @benjchristensen your right So idea I have at present Is you spawn a new SerialExecutor for each worker Pass in a Executor into the Scheduler Create Worker this creates a SerialExecutor that _sits on_ a Thread from the passed in Executor Process through all the actions blocking until the Worker completes Complete and return the Thread back to the pool Not sure if that would actually solve the problem but from my understanding is that we always need to serially execute queued up actions on any one worker That all sounds right except the blocking until the Worker completes part That would okay in Quasar but not with native threads It will need to behave like observeOn where it releases the thread think of it as an event loop and then reschedules back on a thread the next time it receives an onNext See observeOn here https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorObserveOn java#L98 @benjchristensen yeah OK that makes sense I still think it should be noted that people should try to avoid Executors where possible It should be a when you really have too I guess we need to make sure executing a tasks by the same worker shouldn t hop threads right I see a few problems Generally threads can die from executing non RxJava tasks and get replaced by fresh threads so thread hopping is more likely to occur than with the standard schedulers Since most executors use a single work queue work might be dequeued by any of the threads Even if a work item can tell where it should run one would need some mechanism to toss the work over to the target thread at which point task reordering can happen Maybe a write cursor and read cursor pairs may help plus each worker thread needs dedicated queue with every instance of Scheduler Worker assigned to it These queues may then be processed round robin Even if this worker thread affinity is established one would need constantly running tasks that poll these queues or blocking ones that get unblocked by yet another queue Since we don t know how many threads there are in the Executor it becomes difficult to schedule such processing routines if necessary and even so they will block out other tasks submitted from elsewhere to the same Executor Bottom line is in my opinion that there aren t any good ways to ensure worker affinity on an Executor whose internal threads and queueing we can t control As far as I am concerned the needs I have is I have to serialize all my Bluetooth Low Energy communications on Android and requests can come from multiple threads I d like my observables to be scheduled one after the other In cgeo https github com cgeo cgeo I do not want more than 5 or 10 concurrent HTTP download connections from Android as I download large images and the memory pressure will be too high if I download more of them at the same time Is there a way to achieve those two goals easily without an executor @samueltardieu This high jacks the issue somewhat but the Computation Scheduler only runs as many concurrent threads as there are cores on the device 2 4 for most Android Devices The whole point of the new Schedulers is that they execute in order which Executors are not guaranteed to do I would use either an IO or Trampoline Scheduler for your BTLE Comms Also remember to Bind the Observable if you re passing it off to the UI thread @mattias provided that one As for HTTP Either use Computation Scheduler or Your own Scheduler we solved the problem in Retrofit by using the Executor in the onSubscribe method See RxSupport https github com square retrofit blob master retrofit src main java retrofit RxSupport java There have been a few PRs proposing a Scheduler with fixed thread count and another with thread caching support The latter can be extended to put an upper limit on the active thread count if necessary But unfortunately these efforts are blocked on the enhancement quest to add load balancing to the base computation scheduler and the usual concerns about API size and features to expose I ve been fiddling with an idea for some time to ask for a contrib experimental module where all these outcasts and other stuff may be put @akarnokd I quite like that idea keep the main lib lean I m sure a _contrib concurrency_ would not be overkill I mean I always use Proguard so bloat isn t so much of an issue for me but it s great you guys are thinking about it All interested in this please try out the new implementation via Schedulers newExecutor as implemented by @akarnokd in https github com Netflix RxJava pull 1272 Should we rename Schedulers newExecutor to something else Reason I m asking is that it doesn t actually create a new Executor like newThread does It is a new Scheduler around a given Executor Perhaps it is instead Schedulers fromExecutor Executor e or just Schedulers executor Executor e I like Schedulers from Executor e @headinthebox 1 very consistent I believe this is done so closing out',RxJava,false,false,false
33859663,'Shorter naming for toBlockingObservable','Hi folks I m exposing Observables to my user and while this is awesome I m realistic and know that a lot of them will fall back to blocking immediately either because they are migrating their blocking codebases or they just can t handle it properly While I think how RxJava exposes blocking is good I think there is also room for improvement to make it shorter For example consider the following java Cluster cluster new CouchbaseCluster 127 0 0 1 Bucket bucket cluster openBucket toBlockingObservable single Document doc JsonDocument create hello JsonObject empty put Hello World bucket upsert doc toBlockingObservable single System out println bucket get hello toBlockingObservable single Especially if you are dealing a lot with just a single value something like await on the observable would be good or some shorter way alias name To be honest I m not sure if this is possible but I also thought about shipping a helper class which just wraps the calls like BlockingUtils observable single or something like this','@benjchristensen wdyt We specifically chose the explicit and long name toBlockingObservable so people are fully aware of what they re opting into We also consciously moved all of the blocking operators out of Observable into BlockingObservable so it is very clear what operators are blocking and which are not You can however use BlockingObservable from o which would be the same as BlockingUtils observable The await name isn t quite right as the method itself is not awaiting anything it s just giving access to the blocking methods that would await We could suggest to the broader group to alias something shorter like blocking or toBlocking to toBlockingObservable Then it would be like this java System out println bucket get hello blocking single @benjchristensen makes sense I really like blocking it is much more concise Can you bring that to a vote 1 for Alias toBlocking and toBlockingObservable @chrisjenx what do you think about just blocking @daschl I think it needs to remain clear that its is _to_ a blocking Observable as blocking to me implies its an operator which it is not @headinthebox @akarnokd @abersnaze @zsxwing Any issues with aliasing toBlocking for toBlockingObservable to keep it shorter toBlocking is fine with me toBlocking 1 I submitted a simple PR for this in case we get consensus I vote no strongly Autocomplete will type it for you And as Ben says it should be there as a blinking danger sign to war you that you are doing something unsafe That why in Haskell unsafePerformIO has such a long name If you want to make it shorter I propose BLOCKING all caps @headinthebox not sure I can follow While I can understand that it breaks the idea of async flows lots of applications sooner or later at the end of the chain will fall back to blocking so they can return it to a servlet or whatever I don t think we should make it hard on people sync programming is a legit concept even if it is not as powerful as Rx I also vote no BlockingObservable from is sufficient and avoids auto complete induced temptation Ideally if you need blocking it s in a single generic spot so it shouldn t even come up that often @daschl won this one We have deprecated toBlockingObservable in favor of toBlocking which is less annoying to use while still being clear and will better match the pattern with toParallel that will come one day when I get around to it See https github com Netflix RxJava pull 1233 for the change @benjchristensen thanks for taking care of it My users will appreciate it',RxJava,false,false,false
33863530,'Improved Documentation for onErrorFlatMap','We need to improve documentation for onErrorFlatMap as per discussion at https github com Netflix RxJava issues 1002#issuecomment 39266024','See https github com Netflix RxJava wiki Error Handling Operators#onerrorflatmap for the wiki version of the onErrorFlatMap docs That s a good explanation but it probably won t make sense to people who don t already understand Can you perhaps add an example such as how flatMap or merge prevent this from working How does this sound Note that you should apply onErrorFlatMap directly to the pathological source Observable and not to that Observable after it has been modified by additional operators as such operators may effectively renormalize the source Observable by unsubscribing from it immediately after it issues an error Below for example is an illustration showing how onErrorFlatMap will respond to two error generating Observables that have been merged by the merge operator Note that it will not react to both errors generated by both Observables but only to the single error passed along by merge image https cloud githubusercontent com assets 4491168 3030980 643aece4 e047 11e3 82a1 a736a8fe03cb png We are removing onErrorFlatMap https github com Netflix RxJava issues 1465',RxJava,false,false,false
33871867,'Simple way to pipe one observable into another','Hey folks I went through the documentation but couldn t find it but my gut feeling says it s there Also the ConnectableObservable does not that what I want I think In my code I have something like this java configProvider closeBuckets subscribe new Observer ClusterConfig @Override public void onCompleted request observable onCompleted @Override public void onError Throwable e request observable onError e @Override public void onNext ClusterConfig clusterConfig request observable onNext clusterConfig You can see that more or less I want to pipe all the stuff into a different observable Something like java configProvider closeBuckets subscribe request observable So I d like to subscribe with another observable if that makes sense','Looks you are describing Subject https github com Netflix RxJava wiki Subject @zsxwing I think you are right my observable is a subject anyway I just need to map my way through so that the types are good Thanks If you find yourself looking for a subject you are typically wrong Either there is an operator already or you can use observable create and subscribe to the outer observable inside that If you find yourself looking for a subject you are typically wrong I tend to use Subjects for dynamically attaching things to hot observables Specifically I have android activities and fragments that provide a UI that allows the user to edit the current values in the observable and then emits those edited values for other things to use It requires I have an observable from object creation so that other things may subscribe to the fragment when the fragment isn t fully attached to the activity yet and so can t access the hot observable directly It is kind of a reverse publish Rather than multi casting out it is multiple sub trees subscribing and unsubscribing to the hot observable in response to user input Is this wrong How do you solve the problem of needing to provide an observable from a class before any input observables have been given to it Is this just a fundamental structural problem It does feel messy and I have considered using switchOnNext but that ends up using a subject or recreating them with Observable create in order to fire an attached signal when the appropriate android callback occurs @DylanSale would help if you draw a marble system diagram or type signature of your scenario I have a vague idea of what you have in mind but want to make sure I know precisely what you are after Note that subjects make cold observables hot so if you already have a hot observable a subject is not making it hotter public static void main String args Integer integers 0 1 2 3 4 5 6 7 8 9 Observable Integer cold Observable from integers cold subscribe x System out println cold 0 x cold subscribe x System out println cold 0 x PublishSubject Object hot PublishSubject create hot subscribe x System out println hot 0 x cold subscribe hot hot subscribe x System out println hot 0 x try System in read catch IOException e e printStackTrace Essentially I am doing this my code uses generics properly I omitted them for brevity java public class MyFragment extends Fragment PublishSubject foo PublishSubject create public void onActivityCreated Bundle savedInstanceState super onActivityCreated savedInstanceState addSubscription getActivity getHotObservable map etc subscribe foo public Observable getOutputObservable return foo Some other code MyFragment frag new MyFragment then I add frag to the activity This happens async so at some point in the future onActivityCreated will be called but I want to use frag s observable here At this point frag has not been attached to the Activity so it has no input observable thus the need to have the subject there Without the subject getOutputObservable would be null and I d have to add extra code to know when the fragment has been attached and has set up its observable frag getOutputObservable filter func subscribe new Action1 etc',RxJava,false,false,false
33876482,'ReplaySubject enhancement with time and or size bounds','Reapplied the enhancements to bring size and or time bound ReplaySubject capabilities while exposing a single subject class i e no separate BoundedReplaySubject or CustomReplaySubject It now uses the renewed SubjectSubscriptionManager In addition I ve moved a confusing behavior from SubjectObserver into AsyncSubject where it belongs','RxJava pull requests #1130 https netflixoss ci cloudbees com job RxJava pull requests 1130 SUCCESS This pull request looks good Thank you for this refactor it looks like it was tedious Just a simple question above and then will merge',RxJava,true,false,false
33884716,'Implement shorter toBlocking as shorter alias for toBlockingObservable','Fixes #1220','RxJava pull requests #1131 https netflixoss ci cloudbees com job RxJava pull requests 1131 SUCCESS This pull request looks good I s this really causing you pain Autocomplete will type the few extra characters for you when reading code toBlockingObservable should stand out like a sore thumb DANGER @headinthebox actually not for me but for our users 99 of them are on blocking type applications and will need to call that often Even in unit tests it is very long and doesn t help with readability So I m all in for a shorter version I think toBlocking still sufficiently signals what is going on We don t need the Observable name everywhere people already know it s an Observable Also this is more similar to how we will likely someday implement toParallel which would return a ParallelObservable I wont block this Just want to make sure people understand that blocking defeats the purpose of Rx Yes it certainly does but what I ve found is that enabling an API with Rx is made far easier when we can give people who aren t ready to adopt async an easy way out An API can always go from async to sync but not sync to async so anything that removes roadblocks to getting async APIs in place is helpful I kind of wish we didn t have toBlockingObservable after this change but that s a massive breaking changes for a lot of codebases so I think we ll just live with the alias Should we deprecate toBlockingObservable and delete in a release or two or keep them both forever I guess so too many aliases indicate indecisiveness of the API designers Exactly Done in https github com Netflix RxJava pull 1233',RxJava,true,false,false
33900029,'Operator to let source observable keep emitting items even after it s unsubscribed','I have a use case where a source observable fetches an expensive resource that needs to be transformed and cached for future iterations java Observable range 0 10000 map n n n buffer 32 flatMap values cache values flatMap Observable from take 10 Observable range is a placeholder for the actual expensive observable In this case the source observable will be unsubscribed after take unsubscribes However I want the original observable to keep emitting items into the cache until it completes I know there is a cache operator but I don t want to keep the emitted items in memory since there could be a lot of them I initially posted my question in the group https groups google com forum # searchin rxjava vadim rxjava kEvpqmePDtU T11Ov1ee8TwJ','Can you explain a bit more I don t get what you are after You ask for 10 elements and once you get them everything gets cleaned up Sounds like you are asking for a deliberate space leak which I cannot imagine is the case Sure the source observable is a twitter API call to find followers Twitter rate limits the API call to 15 times in a 15 minute window That API returns up to 5000 users per call We provide an API that paginates through these after a filter is applied The pagination size is 10 This forces us to cache the results so we don t hit the rate limit In the example above I want to fetch the entire stream of followers filter them and put them in the cache for future pagination requests When the first 10 are available they should be returned to the user while the rest continue to populate the cache This might do what you want The publish method prevents the source from being unsubscribed I think java ConnectableObservable Integer p Observable range 0 10000 map n n n buffer 32 flatMap values cache values flatMap Observable from publish Observable Integer result p take 10 subscribe p connect That is correct until you disconnect @vadims do you do the caching in Rx or outside @davidmoten subscribe returns a Subscription instead of an Observable which I would need to continue the chain Here s a snippet java public Observable Integer getTwitterFollowers return Observable range 0 10000 map n n n buffer 32 flatMap values cache values flatMap Observable from take 10 public Observable User getFollowers return getTwitterFollowers flatMap twitterId lookupUserByTwitterId twitterId @GET public List User showFollowers return getFollowers toList toBlocking single I m not sure how to use publish in this case since I think the subscription takes place in showFollowers when I call single If I call connect in getTwitterFollowers then it will start emitting items before I had a chance to subscribe @headinthebox Caching is done outside Rx Redis You would publish you expensive resource and connect it when you have wired everything up Since what you want is stateful you want to cache side effects the code will be a bit imperative as well scala object Main def main args Array String Unit val xs ConnectableObservable Int Observable items 0 1 2 3 4 5 publish xs take 2 subscribe x println s a x xs take 5 subscribe x println s b x xs connect xs subscribe x println s c x readLine In the output below you see that a only gets a few elements but xs keeps pushing values at b but c is too late and in this run does not get any values a 0 b 0 a 1 b 1 b 2 b 3 b 4 I see that it works in a single method however I can t use it in a chain as shown above getTwitterFollowers is located in the TwitterService class getFollowers is located in the UserService class and showFollowers is located in the UserResource class Pass the context as parameters As I said you are trying to do something thatis noncompisitional so you will have to keep global state to side effect your global state I m not sure I understand where the global state is or what I can pass as parameters in my example above My current workaround is a custom operator that subscribes to the source observable and keeps forwarding notifications until it s ubsubscribed from However the unsubscribe is not forwarded to the source so it keeps emitting notifications which are silently ignored Is there anything wrong with this approach is there a way to do this cleanly using the existing operators if not is this use case common enough to be added to RxJava This sounds like the perfect candidate for a custom operator You may consider to push this behavior all the way in the binding of the twitter stream as an observable I assume you do that via create because it is an external property of your source Yep that s what I m doing Thanks for taking a look',RxJava,false,false,false
33903057,'Fix bug in zipWithIndex and set zip that selector public in RxScala','The function used in zipWithIndex is mutable which make the Observable cannot be reused Fixed it using zip 0 until Int MaxValue toObservable Make zip that selector public and rename to zipWith #1189 cc @headinthebox @samuelgruetter','RxJava pull requests #1132 https netflixoss ci cloudbees com job RxJava pull requests 1132 SUCCESS This pull request looks good Here are some tests that I did on commit 1e07ccc2bc95eb43b734f505b808c0f41d7cd344 scala passes @Test def testZipWithIndex2 val o Observable interval 100 millis map _ 100 take 3 zipWithIndex map _ _2 assertEquals List 0 1 2 o toBlockingObservable toList assertEquals List 0 1 2 o toBlockingObservable toList 100 CPU usage on all cores until I abort the test @Test def testZipWithIndex3 val o Observable interval 100 millis map _ 100 take 3 doOnEach println _ zipWithIndex map _ _2 assertEquals List 0 1 2 o toBlockingObservable toList assertEquals List 0 1 2 o toBlockingObservable toList fails as expected java lang AssertionError expected List 0 1 2 but was List 0 100 200 @Test def testZipWithIndex4 val o Observable interval 100 millis map _ 100 take 3 doOnEach println _ assertEquals List 0 1 2 o toBlockingObservable toList assertEquals List 0 1 2 o toBlockingObservable toList I don t know exactly what s happening but it looks like something weird s going on with testZipWithIndex3 @zsxwing can you reproduce this behavior If yes could you have a look what s going on here Weird testZipWithIndex3 passed on my machine both in IDEA and gradle CLI But I noticed a weird thing When I first ran testZipWithIndex2 IDEA was frozen about 140 seconds However the test still passed So I guess maybe some issue in scalac or IDEA causes 100 CPU usage Can you try to run tests in gradle CLI My test was on https github com Netflix RxJava commit 566e89282fe687a66571b6fe6c9a362f98238ee7 The problem is that as soon as we have several threads everything becomes non deterministic I made another test scala @Test def testZipWithIndex5 for i 1 to 10 val start System currentTimeMillis val o Observable interval 100 millis map _ 100 take 3 zipWithIndex map _ _2 assertEquals List 0 1 2 o subscribeOn NewThreadScheduler toBlockingObservable toList println s iteration took System currentTimeMillis start ms And I ran it on 566e89282fe687a66571b6fe6c9a362f98238ee7 in gradle CLI using the command gradlew language adaptors rxjava scala test info The output I got was this ant scalatest iteration took 349 ms ant scalatest iteration took 300 ms ant scalatest iteration took 1482 ms ant scalatest iteration took 300 ms ant scalatest iteration took 301 ms ant scalatest iteration took 301 ms ant scalatest iteration took 300 ms ant scalatest iteration took 301 ms ant scalatest iteration took 3438 ms ant scalatest iteration took 300 ms As you can see usually it takes about 3 100 millis as expected but sometimes it takes much longer I imagine this might be because the implementation of zipWithIndex feeds a lot of unused numbers to the zip Observer before the thread emitting onComplete and unsubscribing from the 0 until Int MaxValue Observable can do its job And if you replace the body of your zipWithIndex implementation by scala zip 0 until Int MaxValue toObservable doOnEach println _ you can see that this is indeed the case I get thousands of numbers printed I imagine this might be because the implementation of zipWithIndex feeds a lot of unused numbers to the zip Observer before the thread emitting onComplete and unsubscribing from the 0 until Int MaxValue Observable can do its job Agreed Maybe the best solution is getting mapWithIndex back to RxJava @benjchristensen Or maybe zipWithIterable such that the next item of the Iterable is produced only on demand instead of eagerly Or a zip operator with backpressure but afair this was considered impossible Or add scala def zip U other Iterable U Observable T U implemented using java public final T2 R Observable R zip Iterable extends T2 other Func2 super T super T2 extends R zipFunction and then use it to implement zipWithIndex',RxJava,true,false,false
33910496,'Version 0 19','The next release will be 0 19 Issues being tracked for it are in https github com Netflix RxJava issues milestone 7 page 1 state open','I think we re close to being able to release 0 19 0 and then allow further iteration on 0 19 x releases Is there anything outstanding that we must absolutely have done before 0 19 0 is released In particular any major performance work still outstanding any blocker bugs I m missing anything we should deprecate that we haven t already any breaking changes to core or language adaptors such as Scala Once 0 19 0 is released I intend on only one more round 0 20 x before we hit 1 0 Release Candidate as per plan here https github com Netflix RxJava issues 1001#issuecomment 44767941 @headinthebox @akarnokd I don t see anything blocking release of 0 19 0 Anything from your side or should I proceed I m good to go Go for it Alright I ll finish the release notes and release it Thanks Are we okay with the ChainedSubscription and CompositeSubscription signatures https github com Netflix RxJava tree master rxjava core src main java rx subscriptions Should we change ChainedSubscription to SubscriptionList In 0 18 x I did it as SubscriptionList so I think we should at least change to that ChainedSubscription is wrong Here is where this topic started being discussed https github com Netflix RxJava pull 1281#issuecomment 44588465 I ll hold off on releasing until we finalize this Pull request with SubscriptionList here https github com Netflix RxJava pull 1308 This matches what was released in 0 18 4 @benjchristensen convinced me we cannot use CompositeSubscription and have a subtype that supports removal So that s off the table Second best for me is simply Subsciptions but I doubt that will fly so maybe SubscriptionCohort a group of people banded together or treated as a group For me List implies some form of linearity and Set duplicate elimination Here is another option https github com Netflix RxJava pull 1309 I made SubscriptionList an internal implementation details and removed it from the public API so we can proceed with the release and expose it later if we want The CompositeException is not changed and I imagine we should leave it as is Just want to say a big thank you to all the contributors for this release It is totally awesome to see the pulse of RxJava @headinthebox 1 its awesome to see whats going on with the project makes me very confident I bet on the right horse for the next years to come',RxJava,false,false,false
33910705,'Git Reformats This File','','',RxJava,true,false,false
33912560,'Remove Ambiguous Subscribe Overloads with Scheduler','Fixes https github com Netflix RxJava issues 1116 These should never have been added the subscribeOn operator already provides this functionality','',RxJava,true,false,false
33912762,'Docs for Serialize','Looks like we can improve the javadocs for this java @since 0 17 public final Observable T serialize return lift new OperatorSerialize T','https github com Netflix RxJava commit 17529d01162b56024c571200b2e4f27744d03fef#diff 5ec494b927739f6fefe3a4d351a9dd05 Forces an Observable to make synchronous calls and to be well behaved p It is possible for an Observable to invoke its Subscribers methods asynchronously perhaps in different threads This could make an Observable poorly behaved in that it might invoke @code onCompleted or @code onError before one of its @code onNext invocations You can force such an Observable to be well behaved and synchronous by applying the @code serialize method to it p img width 640 src https raw github com wiki Netflix RxJava images rx operators synchronize png @return a @link Observable that is guaranteed to be well behaved and synchronous @see a href https github com Netflix RxJava wiki Observable Utility Operators#serialize RxJava Wiki serialize a @since 0 17 I wouldn t say it is forcing synchronous calls it s just that they can never be concurrent The implementation specifically allows async delivery and queues as necessary Whereas synchronize would synchronously block a thread serialize does not This forces the calls to be serialized non concurrent and thread safe memory visibility How does this sound Forces an Observable s emissions and notifications to be serialized and for it to obey the Rx contract in other ways p It is possible for an Observable to invoke its Subscribers methods asynchronously perhaps from different threads This could make such an Observable poorly behaved in that it might try to invoke @code onCompleted or @code onError before one of its @code onNext invocations or it might call @code onNext from two different threads simultaneously You can force such an Observable to be well behaved and sequential by applying the @code serialize method to it On Wed May 28 2014 at 11 36 AM Ben Christensen notifications@github com wrote I wouldn t say it is forcing synchronous calls it s just that they can never be concurrent The implementation specifically allows async delivery and queues as necessary Whereas synchronize would synchronously block a thread serialize does not This forces the calls to be serialized non concurrent and thread safe memory visibility Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1230#issuecomment 44447319 David M Gross PLP Consulting simultaneously concurrently It is OK to call onNext from two different threads just not concurrently Changes are committed thanks @DavidMGross',RxJava,false,false,false
33913096,'Operator Alias Share','As per discussion in #682','RxJava pull requests #1133 https netflixoss ci cloudbees com job RxJava pull requests 1133 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
33914304,'Adopt Limit and ForEach Java 8 Naming Conventions','As per discussion at https github com Netflix RxJava issues 678 Code now can look like this java Observable from 1 2 3 limit 2 forEach System out println as an alias to this java Observable from 1 2 3 take 2 subscribe System out println','RxJava pull requests #1134 https netflixoss ci cloudbees com job RxJava pull requests 1134 SUCCESS This pull request looks good',RxJava,true,false,false
33914640,'Deprecate toBlockingObservable in favor of toBlocking','As per discussion at https github com Netflix RxJava pull 1224#issuecomment 43658284 This will better match toParallel and is shorter to use while still being clear as to what is happening','RxJava pull requests #1135 https netflixoss ci cloudbees com job RxJava pull requests 1135 SUCCESS This pull request looks good',RxJava,true,false,false
33974838,'InterruptException with inline BlockingObservables','Not sure how I m the first one to see this But the BlockingObservable throws InterruptExceptions all the time The most simple example I can create to show this follows java @Test public void testBlockingInline final BlockingObservable Object blockingObservable BlockingObservable from Observable create new Observable OnSubscribe Object @Override public void call Subscriber super Object subscriber SystemClock sleep 50 subscriber onNext null subscriber onCompleted Subscriber Object subscriber mock Subscriber class Observable create new Observable OnSubscribe Object @Override public void call Subscriber super Object subscriber subscriber onNext new Object subscriber onCompleted doOnNext new Action1 @Override public void call Object o blockingObservable single subscribe subscriber verify subscriber times 1 onNext any verify subscriber times 1 onCompleted Removing or wrapping the blockingObservable in a try catch does fix but that kind of defeats the point Tested on 0 18 3 I have seen something similar on 0 17 x','Hi Could you post the full stacktrace of the InterruptedException @akarnokd java java lang RuntimeException java lang InterruptedException at rx exceptions Exceptions propagate Exceptions java 40 at rx operators BlockingOperatorToIterator 2 take BlockingOperatorToIterator java 94 at rx operators BlockingOperatorToIterator 2 hasNext BlockingOperatorToIterator java 72 at rx operators BlockingOperatorToIterator 2 next BlockingOperatorToIterator java 82 at rx observables BlockingObservable single BlockingObservable java 347 at retrofit RxSupportTest 4 call RxSupportTest java 168 at rx Observable 12 onNext Observable java 3682 at rx operators OperatorDoOnEach 1 onNext OperatorDoOnEach java 61 at retrofit RxSupport 2 run RxSupport java 47 at java util concurrent Executors RunnableAdapter call Executors java 511 at java util concurrent FutureTask run FutureTask java 266 at retrofit RxSupportTest QueuedSynchronousExecutor executeNextInQueue RxSupportTest java 211 at retrofit RxSupportTest QueuedSynchronousExecutor EnhancerByMockitoWithCGLIB 3c4bdde4 CGLIB executeNextInQueue 1 generated at retrofit RxSupportTest QueuedSynchronousExecutor EnhancerByMockitoWithCGLIB 3c4bdde4 FastClassByMockitoWithCGLIB 92199b2e invoke generated at org mockito cglib proxy MethodProxy invokeSuper MethodProxy java 216 at org mockito internal creation AbstractMockitoMethodProxy invokeSuper AbstractMockitoMethodProxy java 10 at org mockito internal invocation realmethod CGLIBProxyRealMethod invoke CGLIBProxyRealMethod java 22 at org mockito internal invocation realmethod FilteredCGLIBProxyRealMethod invoke FilteredCGLIBProxyRealMethod java 27 at org mockito internal invocation InvocationImpl callRealMethod InvocationImpl java 108 at org mockito internal stubbing answers CallsRealMethods answer CallsRealMethods java 36 at org mockito internal handler MockHandlerImpl handle MockHandlerImpl java 93 at org mockito internal handler NullResultGuardian handle NullResultGuardian java 29 at org mockito internal handler InvocationNotifierHandler handle InvocationNotifierHandler java 38 at org mockito internal creation MethodInterceptorFilter intercept MethodInterceptorFilter java 51 at retrofit RxSupportTest QueuedSynchronousExecutor EnhancerByMockitoWithCGLIB 3c4bdde4 executeNextInQueue generated at retrofit RxSupportTest testObservableRespectsBlockingOnNext RxSupportTest java 188 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 62 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at java lang reflect Method invoke Method java 483 at org junit runners model FrameworkMethod 1 runReflectiveCall FrameworkMethod java 45 at org junit internal runners model ReflectiveCallable run ReflectiveCallable java 15 at org junit runners model FrameworkMethod invokeExplosively FrameworkMethod java 42 at org junit internal runners statements InvokeMethod evaluate InvokeMethod java 20 at org junit internal runners statements RunBefores evaluate RunBefores java 28 at org junit runners ParentRunner runLeaf ParentRunner java 263 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 68 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 47 at org junit runners ParentRunner 3 run ParentRunner java 231 at org junit runners ParentRunner 1 schedule ParentRunner java 60 at org junit runners ParentRunner runChildren ParentRunner java 229 at org junit runners ParentRunner access 000 ParentRunner java 50 at org junit runners ParentRunner 2 evaluate ParentRunner java 222 at org junit runners ParentRunner run ParentRunner java 300 at org junit runner JUnitCore run JUnitCore java 157 at com intellij junit4 JUnit4IdeaTestRunner startRunnerWithArgs JUnit4IdeaTestRunner java 74 at com intellij rt execution junit JUnitStarter prepareStreamsAndStart JUnitStarter java 211 at com intellij rt execution junit JUnitStarter main JUnitStarter java 67 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 62 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at java lang reflect Method invoke Method java 483 at com intellij rt execution application AppMain main AppMain java 134 Caused by java lang InterruptedException at java util concurrent locks AbstractQueuedSynchronizer acquireInterruptibly AbstractQueuedSynchronizer java 1220 at java util concurrent locks ReentrantLock lockInterruptibly ReentrantLock java 335 at java util concurrent LinkedBlockingQueue take LinkedBlockingQueue java 439 at rx operators BlockingOperatorToIterator 2 take BlockingOperatorToIterator java 92 51 more @akarnokd Did you manage to replicate this I m sorry I was busy with something else I don t get an InterruptedException but an IllegalArgumentException because mocking a Subscriber doesn t set its inner CompositeSubscription If I replace that line with Observer Object subscriber mock Observer class the test passes on regular RxJava @akarnokd OK thats odd I even see it if I don t mock the Observer Subscriber But only 0 18 Will try to investigate more You can t mock a Subscriber You can instead mock Observer A common pattern in unit tests is like this java Observer String o mock Observer class TestSubscriber String ts new TestSubscriber o observable subscribe ts ts await ts assert assert o onNext 1 etc Closing out reopen if further questions or issues',RxJava,false,false,false
33975582,'Lock free MPSC queue based fast path serializing Observer','I ve rewritten the SerializedObserver to improve performance It is now lock free uses a multiple producer single consumer queue based on Netty s implementation and employs a fast path logic for single threaded write through Benchmarked by measuring how fast 500k integers can get through it if running 1 8 producers at the same time For a single threaded case master gives about 18 MOps s this implementation gives 36 MOps s would be 16 MOps s on the slow path For producers 2 master gives 5 5 MOps s and this gives 11 5 MOps s For 2 producers aka 1 producer 1 consumer master gives 4 5 MOps and this gives 8 5 MOps s The two new class PaddedAtomicInteger and MpscPaddedQueue will come in handy with other lock free structures such as Schedulers etc We may consider adding back the rx util or some other sub package to store these helper classes they don t need to be part of the public API but can be left public to enable cross package access internally Things I learned during the implementation It is worth padding the wip counter to fit a cache line so the constant cache thrashing won t affect the parent class other fields most likely Using FieldUpdaters saves space but sun misc Unsafe can add 8 10 more throughput To avoid platform issues I stayed with the FieldUpdaters Using getAndIncrement and decrementAndGet are intrinsified in Java 8 and are compiled to a single x86 instruction which generally outperforms any CAS loop Same is true for the getAndSet Padding out the tail in the MpscPaddedQueue again helps separate producers trashing on the tail and a consumer reading the head Without it the throughput would decrease by about 1 5 MOps s By adding the fast path logic the single threaded throughput increases by a factor of 2 since it avoids an unnecessary enqueue and dequeue and all associated volatile writes However if taking the fast path fails it incurs extra cost on the slow path for everyone else because of the 1 failed CAS at the start To fix this case I ve introduced a flag that enables and disables fast path To disable the fast path the active fast path checks if it was able to change wip to zero If not it means there was concurrent access and continues on the emission loop path but disables the fast path then on It is basically a detector for concurrent use Since such concurrent use may be transient the loop counts how many elements it had to emit an if it was only 1 or 2 it reenables the fast path This limit is the result of trying several values with the benchmark above The fast path logic has its weak spot in 2 producer case compared to a plain MPSC queue running in SPSC mode the latter gives about 11 MOps s which is better than this implementation s 8 5 MOps s In contrast the single treaded use for the plain MPSC is only 16 MOps s Both implementations perform the same if producers 2 Therefore I decided it is more worth having an implementation that is weak for 2 producers but otherwise is as good or outperforms the alternatives Note that if one knows the number of producers up front one can create a more specialized implementation but this is not the case with RxJava operators This may affect merge and co which serialize multiple sources Note however that if the source speed isn t that high as in the benchmark this implementation still provide less latency than the alternatives because the fast path would be most likely open if the source emission is interleaved','RxJava pull requests #1136 https netflixoss ci cloudbees com job RxJava pull requests 1136 SUCCESS This pull request looks good One additional node It is possible the JVM will eliminate the serialized part in the master s SerializedObserver and thus giving the througput of 40 100 MOps s I usually get this effect if I run the test with 2M values The 500k above was chosen to avoid this optimization Unfortunately one can t win against or replicate this behavior from within Java Your research on this is awesome I look forward to playing with this queue implementation and seeing it s performance compared to alternatives However this slows down the normal non contended use cases With MPSC r u PerfTransforms flatMapTransformsUsingFrom 1 thrpt 5 4093463 403 158457 270 ops s r u PerfTransforms flatMapTransformsUsingFrom 1024 thrpt 5 11767 693 252 340 ops s Master branch r u PerfTransforms flatMapTransformsUsingFrom 1 thrpt 5 4729230 173 99504 604 ops s r u PerfTransforms flatMapTransformsUsingFrom 1024 thrpt 5 12648 153 105 077 ops s Test using gradlew benchmarks Pjmh f 1 tu s bm thrpt wi 5 i 5 r 5 prof GC PerfTransforms flatMapTransformsUsingFrom I don t think SerializedObserver is the right candidate for non blocking lock free due to the reasons we discussed a couple months ago in https github com Netflix RxJava pull 999 and https github com Netflix RxJava pull 962 particularly this conclusion The queue and lock model performs well in the non contended case and under contention despite not being a very elegant solution and requiring the use of mutex locks for the state changes but it does not hold the locks during notification This applies in this case because we are NOT exchanging events between threads we are actively trying to not do that A high performance queue particularly of the lock free kind will make great sense however in places such as observeOn and or Scheduler implementations where it has a producer thread and a consumer thread such as discussed in https github com Netflix RxJava pull 1190 https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorObserveOn java#L64 https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorZip java#L237 https github com akarnokd RxJava blob a5b8a75a51f65aa95ebf0653763f483cc5f49c60 rxjava core src main java rx subscriptions SubscriptionQueue java I suggest we get this queue and counter into rx internal util and start performance testing them as replacements everywhere we re using a queue I would for now leave SerializedObserver alone as we spent a lot of time on that before with at least 3 different implementations and came to the conclusion that the JVM can do a better job for that use case than we can Here is my branch where I merged this PR and moved the code into rx internal util along with a README file https github com benjchristensen RxJava tree serializer mpsc https github com benjchristensen RxJava tree serializer mpsc rxjava core src main java rx internal util By the way I ll spend more time testing the contended cases Don t close this PR I m not done reviewing it all The JVM can remove a synchronized block if it detects a single threaded use I can t compete with that by using atomics This is a tradeoff scenario get very fast synchronous behavior or get double throughput in contended case If we value the fast synchronous behavior more then there is no need to go atomic just make sure we don t use wait notify I know that we determined that in #1190 If we re going to change the decision on what tradeoff to make then we need to go back and revisit why we made the decision we did The expected common case is when there is not contention because of how flatMap is done everywhere I think we need a broader set of use cases to determine which direction the tradeoff should be made This was automatically closed as I merged the queue implementation We still need to finish discussing the SerializedObserver part I have my doubts now Some simple benchmarks show improvements other jmh benchmarks don t Without industrial use cases I think synchronized constructs are enough because if either low contention or single thread use In the latter JVM optimizations will always win For example I tried double checked locking with Composite and barely got 10Mops s The current version gives 1 3Gops s if run within a 100k loop long enough I think if in doubt let s just not outsmart the JVM Here is an adhoc conversation on Twitter with some experts in this https twitter com benjchristensen status 472362740510494721 I d like to improve our perf testing and have cases for uncontended normal occasional contention and highly contended and test it in a few places I ll do the upgrade of JMH today so we have the latest code Once I have those in place I ll put it out there for review and guidance For what it is worth I find the statemachine approach leads to hard to read code so if there is no obvious win I d go for simple',RxJava,true,false,false
33977784,'CompositeSubscription with atomic field updater','This PR is aimed at #1204 to reduce unnecessary memory overhead in frequently used classes This change in CompositeSubscription saves about 24 bytes per instance In addition the field updaters may be faster by about 8 15 for small adds and removals I ve changed the implementation of unsubscribe to use getAndSet which leverages platform intrinsics and is usually compiled to a single instruction this makes unsubscribing a tiny bit faster and thus reducing latency in benchmarks that only pass on single element around','RxJava pull requests #1137 https netflixoss ci cloudbees com job RxJava pull requests 1137 SUCCESS This pull request looks good',RxJava,true,false,false
33979047,'SafeSubscriber memory reduction','For #1204 This saves 24 bytes per instance','RxJava pull requests #1138 https netflixoss ci cloudbees com job RxJava pull requests 1138 SUCCESS This pull request looks good Thanks I think we probably should do this all over I haven t merged my change to CompositeSubscription yet so that needs to be done as well Oh you already have a PR for CompositeSubscription as well @akarnokd @benjchristensen why was there a change from boolean to int There is no AtomicBooleanFieldUpdater and the nearest thing is an AtomicIntegerFieldUpdater Since classes are padded to 4 8 byte boundaries anyway moving from 1 byte boolean to 4 byte integer is no extra overhead oh I just checked you are right that explains a lot but I have no clue why they didn t add that',RxJava,true,false,false
33979303,'Should rescheduling buffer with time work','I have a simple test @Test public void t1 throws InterruptedException final AtomicLong ret new AtomicLong final PublishSubject Long num PublishSubject create num buffer 100 TimeUnit MILLISECONDS subscribeOn Schedulers computation subscribe new Action1 List Long @Override public void call List Long list for Long l list if l 3 System out println l l num onNext l 1 else ret set l num onNext 1L Thread sleep 1000 Assert assertEquals 3 ret get The if I remove the subscribeOn invocation then everything works well With the scheduleOn the Action never runs Is this the expected behavior','SubscribeOn will delay the subscription to the buffered num and thus miss the first 1L from the PublishSubject If you give it some time before the num onNext 1L it passes Yes this is just a race condition PublishSubject is hot which means it will send the event through even if the subscribeOn is still in the process of subscribing even if just microseconds which means the 1L gets dropped on the floor with no subscribers When using PublishSubject it is always easy to end up with race conditions You can see the race condition by putting this in there java Thread sleep 1 num onNext 1L That works about 2 3s of the time on my machine Changing it to sleep 2 works all the time @akarnokd I don t think there is anything we can do about this is there We can t use BufferUntilSubscriber as that would mean we re subscribing to the origin on the calling thread rather than the given Scheduler I think this really is just a side effect of PublishSubject being hot @andrask Using PublishSubject is generally for one of two scenarios 1 Multicasting and subscribers come and go and just pick up wherever they can but with no expectation of guaranteed delivery prior to subscription 2 Multicasting to a defined set of subscribers who receive all data from the start This is done generally with the publish operator uses multicast under the covers that returns a ConnectableObservable that you call connect on once all Subscriber s have subscribed so that you control the race condition and when to start the data flowing In other words if you need to guarantee delivery of the data from the start you ll want to use a regular Observable create so it s cold and starts on subscription or something like a ReplaySubject or ensure all subscriptions are in place before starting to emit data to PublishSubject I feel like there are a lot of ambiguous methods in the API without reading every bit of the javadoc And in this case asynchronously subscribed is still not something I would understand without @akarnokd s explanation I m trying hard not to use PublishSubject but there are a vegillion cases when for example I need to provide an Observable that the outside world can use but the events are sent into it from a completely different part of the class where I have no clue about the subscribers I ve been thinking about this a lot but cannot figure out a better solution For a more concrete example let s say I have a lifecycle signal that I use to send the state that the object has just got in This signal is completely independent from the execution of the business logic and I have to have a way to send to it while the logic is running The trivial solution is to use a BehaviorSubject and show only the Observable interface for the outside world What else could I do I d highly appreciate if you could share some better solution here a lot of ambiguous methods in the API without reading every bit of the javadoc Can you provide examples of what is problematic and how you would improve change them I d highly appreciate if you could share some better solution here It really depends on what you re trying to do In the example you gave it sounds like a BehaviorSubject or ReplaySubject would be perfect as it guarantees delivery even if they subscribe after the event and you re not sending enough data to worry about a memory leak with ReplaySubject and BehaviorSubject never has that issue The use of PublishSubject and ReplaySubject both require consideration On PublishSubject it is easy to lose data think of it as a hot data flow and there is no guarantee anyone will ever receive the data but it s also never going to cause a memory leak Using ReplaySubject on the other hand allows you to ensure delivery and act like a cold data source so each Subscriber gets all data from the start or within the time count criteria you give it but you then must consider the memory leak in the unbounded case I ll keep on opening issues when I find something confusing Thank you for your help I really appreciate it',RxJava,false,false,false
33990100,'Update docs for apply and add an example','Try to solve #1076 @vchekan any suggestion cc @headinthebox @samuelgruetter','RxJava pull requests #1139 https netflixoss ci cloudbees com job RxJava pull requests 1139 SUCCESS This pull request looks good RxJava pull requests #1140 https netflixoss ci cloudbees com job RxJava pull requests 1140 SUCCESS This pull request looks good RxJava pull requests #1145 https netflixoss ci cloudbees com job RxJava pull requests 1145 SUCCESS This pull request looks good LGTM ditto',RxJava,true,false,false
34002718,'Observable from Func0 Enumeration','dealing with HttpServletRequest API that returns Enumeration s and want to get out of there as fast a possible The Func0 emulates the Iterable interface so subsequent subscribes get a fresh Enumeration','I don t think we should add from overloads that use Func because type erasure will make it so we can t have more than 1 of these and it doesn t seem like Func0 Enumeration is worth being the only one Why can t this be like the Iterable one and just be java public final static T Observable T from Enumeration extends T enumeration RxJava pull requests #1141 https netflixoss ci cloudbees com job RxJava pull requests 1141 SUCCESS This pull request looks good Just curious why does Java have Enumeration and Iterable These interfaces look isomorphic @headinthebox I think it mostly came down to they didn t like the method names because they could have added Enumerable as an equivalent to Iterable I don t think I ve ever had a good reason to call or implement the remove method on the Iterator http docs oracle com javase 8 docs technotes guides collections designfaq html#a8 @benjchristensen I could see that you wouldn t want to commit to that Another problem is that Func0 and Iterable are both SAM types so java 8 wouldn t be able to disambiguate I could rename it to fromEnumeration Func0 Enumeration enumerable What do you think RxJava pull requests #1142 https netflixoss ci cloudbees com job RxJava pull requests 1142 SUCCESS This pull request looks good RxJava pull requests #1149 https netflixoss ci cloudbees com job RxJava pull requests 1149 FAILURE Looks like there s a problem with this pull request Another problem is that Func0 and Iterable are both SAM types so java 8 wouldn t be able to disambiguate This isn t an issue if it s not inside a function If it s a strong type the SAM issue doesn t apply For example this works fine java import java util ArrayList import java util Enumeration import java util Hashtable import java util Vector public class Java8OverloadTest public static void main String args from new ArrayList from new Vector elements from new Hashtable elements public static T void from Iterable T i System out println from iterable public static T void from Enumeration T e System out println from enumeration This emits from iterable from enumeration from enumeration RxJava pull requests #1152 https netflixoss ci cloudbees com job RxJava pull requests 1152 SUCCESS This pull request looks good Closing as I don t want this in core Fine with a contrib module to let it mature We can always add to core in the future very soon we can never take away',RxJava,true,false,false
34013260,'Errors not being delivered in Android Scheduler','I m running into intermittent cases when using AndroidSchedulers mainThread which is just a wrapper around AndroidSchedulers handerThread where the onError event is not being delivered to the main thread I have a gist showing my logs https gist github com vinc3m1 dc9232653a22f8f2d900 It seems the onError event is propagated all the way up until observeOn AndroidSchedulers mainThread After which in some seemingly random cases it s not delivered And the cause appears to be that innerSubscription is reporting itself to be unsubscribed So my main questions are 1 Should we even be doing the isUnsubscribed check on innerSubscription if we already have handler removeCallbacks runnable to handle unsubscribe events 2 Should innerSubscription be reporting isUnsubscribed true when nothing else is unsubscribing from it Also I m using rather complex combination of map flatmap and combineLatest upstream is it possible that some combinations of these are causing innerSubscription to be unsubscribed','Ok dug into it a bit further looks like unsubscribe is being called on the Worker immediately after the onError is posted to the Handler thread This means if the Handler doesn t execute the Runnable fast enough innerSubscription isUnsubscribed will be true and no message delivered I can see this being useful for delayed subscriptions where no further messages should be delivered after unsubscribing but technically all messages are delayed if the main thread gets blocked long enough I m not sure how the non Andorid schedulers handle this looks like unsubscribe is being called on the Worker immediately after the onError is posted to the Handler thread I feel there is some operator may handle unsubscribe incorrectly Could you provide the operators you are using so that we can review them Just found you already provided them map flatmap and combineLatest also nest doOnNext subscribeOn but I think #1242 is the only place where unsubscribe is handled incorrectly or do you think there s more to it than that Fixed in 0 19',RxJava,false,false,false
34032079,'Android HandlerThreadScheduler fix closes #1241','Some events are not delivered due to race condition around the check to innerSubscription isUnsubscribed in the posted runnable It s currently possible for the Handler thread to be delayed enough that innerSubscription becomes unsubscribed and causing the action not to run After cross checking the code with NewThreadScheduler it seems that the expected behavior is to continue to run the action even if the inner parent subscription is unsubscribed and only stop when the outer subscription is unsubscribed which is already happening with handler removeCallbacks runnable This fixes #1241','RxJava pull requests #1143 https netflixoss ci cloudbees com job RxJava pull requests 1143 SUCCESS This pull request looks good Thanks @vinc3m1 for debugging and fixing this It looks like a correct change to me and the comparison with NewThreadScheduler seems legit @zsxwing Since you ve been involved with the Android code and schedulers can you review this as well @akarnokd Since you are involved in a review of schedulers right now can you also glance at this java if isUnsubscribed return I think the above codes is necessary or worker unsubscribe can not cancel the scheduled actions However I think a better approach is java if innerSubscription isUnsubscribed don t schedule we are unsubscribed return Subscriptions empty handler postDelayed runnable unit toMillis delayTime Subscription s Subscriptions create new Action0 @Override public void call handler removeCallbacks runnable innerSubscription add s return s 1 to what @zsxwing proposed The unsubscribed check should happen before the schedule but not inside the runnable I can make the appropriate changes to the PR RxJava pull requests #1150 https netflixoss ci cloudbees com job RxJava pull requests 1150 SUCCESS This pull request looks good I ve looked at #1241 and it seems this is the artifact of the observeOn What happens is that the onError e is scheduled to be executed but right after it a SafeSubscriber is immediately unsubscribing the entire chain and thus cancelling the delivery of the scheduled error By removing the isUnsubscribed check from the runnable it is still likely removeCallbacks succeeds and the action is never run A possible fix would be for the observeOn to schedule the unsubscription of the inner worker instead of calling it immediately This allows delivering all undelayed events to be run before the unsubscription However I don t see the full effect of this change right now What about if creating a new Subscription rather than chaining them here https github com Netflix RxJava blob e6ae50b279b224d0560772e147e48397623b1693 rxjava core src main java rx operators OperatorObserveOn java#L68 Here https gist github com akarnokd 0c4dd0961328c0002e4f is the revised ObserveOn that should let undelayed actions before the unsubscribe run before letting the unsubscribe happen I haven t done this in PR because of it would conflict with #1246 @akarnokd s solution looks like it should work Should I close this PR for now or wait until you open a new one after the conflict is resolved Since this PR just makes the issue happen less likely I suppose this can be closed Let s discuss further options in #1241',RxJava,true,false,false
34050380,'Remove Subscription Wrapper from Observable subscribe','Remove Subscription Wrapper from Observable subscribe Performance increase from 7 7m to 8 8m ops second Before Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms mapTransformation 1 thrpt 5 7714453 187 362218 633 ops s r u PerfTransforms mapTransformation 1 thrpt 5 7527144 767 497816 471 ops s After Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms mapTransformation 1 thrpt 5 8853534 333 183494 242 ops s r u PerfTransforms mapTransformation 1 thrpt 5 8806958 403 452595 219 ops s Test can be run using gradlew benchmarks Pjmh f 1 tu s bm thrpt wi 5 i 5 r 5 prof GC PerfTransforms mapTransformation','',RxJava,true,false,false
34050743,'Observable from T using Observable just T','For code like Observable from 1 Improve performance from 3 9m to 4 5 m ops second Before r u PerfTransforms flatMapTransformsUsingFrom 1 thrpt 5 3923845 687 46657 660 ops s r u PerfTransforms flatMapTransformsUsingFrom 1024 thrpt 5 8924 953 1983 161 ops s r u PerfTransforms flatMapTransformsUsingFrom 1 thrpt 5 3623228 857 490894 492 ops s r u PerfTransforms flatMapTransformsUsingFrom 1024 thrpt 5 9176 330 923 929 ops s After Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapTransformsUsingFrom 1 thrpt 5 4052364 587 100971 234 ops s r u PerfTransforms flatMapTransformsUsingFrom 1024 thrpt 5 11682 783 496 656 ops s Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapTransformsUsingFrom 1 thrpt 5 4700583 987 77742 037 ops s r u PerfTransforms flatMapTransformsUsingFrom 1024 thrpt 5 12588 803 58 935 ops s Using this test gradlew benchmarks Pjmh f 1 tu s bm thrpt wi 5 i 5 r 5 prof GC PerfTransforms flatMapTransformsUsingFrom','RxJava pull requests #1144 https netflixoss ci cloudbees com job RxJava pull requests 1144 SUCCESS This pull request looks good',RxJava,true,false,false
34051508,'Migrate All Atomic to Atomic FieldUpdater','We ve already migrated the ones in CompositeSubscription and SafeSubscriber but we should probably migrate them everywhere since we should avoid the object allocation when we can and this is an easy way to do so','I started working on this Most cases can be rewritten but sometimes we use AtomicReferences as shared state variables between two classes so they can t be inlined This is done enough',RxJava,false,false,false
34073599,'Moved to atomic field updaters','Replaced the AtomicBoolean AtomicInteger AtomicLong and AtomicReference instances with volatile fields and field updaters to save on memory and allocation Unfortunately the Clojure test chunk_test clj test chunk fails and I don t know why since I don t understand what it is supposed to do It appears numbers get lost somehow','RxJava pull requests #1146 https netflixoss ci cloudbees com job RxJava pull requests 1146 FAILURE Looks like there s a problem with this pull request I ve been digging into the failure case and it seems something in the Clojure wrapper calls the merger s Subscriber onCompleted multiple times which is a violation of the observer contract The call comes from chunk clj 68 This looks like a great set of changes however huge amounts of code have been touched so it s making it really hard to review this Most of the changes seem to be formatting changes is that the case If so can you prevent that so as to simplify the review This is 1800 lines of code to review Whenever I use fix indent in Netbeans this is the result few spaces added here few spaces removed there But only a fraction is just formatting changes Adding w 1 ignores whitespace changes and seems to make it a bit better https github com Netflix RxJava pull 1246 files w 1 @vinc3m1 octocat nice hidden feature What do you think needs to be changed before merging Do any of the lazySet uses concern you after reviewing them again Ah I see you just reverted the use of lazySet I think that s a good step for now until we can prove those better but I think it s worth us looking at those more going forward particularly in hot code paths RxJava pull requests #1154 https netflixoss ci cloudbees com job RxJava pull requests 1154 FAILURE Looks like there s a problem with this pull request Let s be on the safe side for now the fact that it works on x86 doesn t mean it works properly on other platforms Hmm we need to figure out that clojure test failure @daveray Can you help us understand what s going on It s not obvious why anything this PR changes should affect a single test in Clojure code What I could understand is that the chunk_test clj creates an Observable which invokes onNext after a random delay It seems this observable emits onCompleted several times The reason this fails now because merge is changed to match the other mergeXYZ behavior by counting down a wip in both the outer and inner subscribers For normal behaving sources it makes sure the last one to reach wip 0 will call onCompleted on the actual The previous merge didn t do this it set a completed flag and checked for wip 0 I suspect this oddity came from this problematic test and its misbehaving observable I can revert the merge behavior to make that test work again and allow merging this PR but we need to fix that test and have merge implement the correct onCompleted behavior RxJava pull requests #1155 https netflixoss ci cloudbees com job RxJava pull requests 1155 SUCCESS This pull request looks good Thanks for reverting that change Submit that as a separate request',RxJava,true,false,false
34092013,'Add zip iterable selector to RxScala','Add zip iterable selector to RxScala Use zip iterable selector to reimplement zipWithIndex to resolve the issue mentioned in #1226 cc @samuelgruetter','RxJava pull requests #1147 https netflixoss ci cloudbees com job RxJava pull requests 1147 SUCCESS This pull request looks good For zipping with an Observable we have scala def zip U that Observable U Observable T U def zipWith U R that Observable U selector T U R Observable R So to be consistent the signatures for zipping with an Iterable should be scala def zip U that Iterable U Observable T U def zipWith U R that Iterable U selector T U R Observable R And you could add a good and bad example to RxScalaDemo Bad zips an Observable interval with an infinite Observable and thus the same happens as with the previous zip version and good zips Observable interval with an infinite Iterable Agreed I ll wait until a go ahead to merge this as it seems there are additions to make Already updated RxJava pull requests #1151 https netflixoss ci cloudbees com job RxJava pull requests 1151 SUCCESS This pull request looks good We should wait with this until https github com Netflix RxJava issues 1253 is fixed Is this now ready to merge since #1253 is merged Yes it delegates to the Java one',RxJava,true,false,false
34108474,'Fixed testConcurrentOnNextFailsValidation','The two instructions need to be swapped to make sure woken up awaiters see the error reliably','RxJava pull requests #1148 https netflixoss ci cloudbees com job RxJava pull requests 1148 SUCCESS This pull request looks good',RxJava,true,false,false
34129902,'RxScala bindings for mergeMap and concatMap missing','bindings for mergeMap are missing in RxScala In fact I would rather not expose mergeXXX in scala and just overload flatXXX The default way to flatten Rx streams is merging Bindings for concatMap are missing as well these should be added as themselves','Seems to be duplicate of #1250 Closing as duplicate',RxJava,false,false,false
34130441,'RxScala bindings for mergeMap and concatMap are missing','bindings for mergeMap are missing in RxScala In fact I would rather not expose mergeXXX in scala and just overload flatXXX The default way to flatten Rx streams is merging Bindings for concatMap are missing as well these should be added as themselves','Was this completed in #1304 Looks like it to me closing https github com Netflix RxJava pull 1304',RxJava,false,false,false
34132204,'RxScala mergeMap and concatMap bindings missing','Bindings for mergeMap and concatMap are missing in RxScala My proposal is to merge mergeMap and flatMap','@zsxwing Can you get these in soon before 0 19 Otherwise we can pick them up in 0 19 1 By the way mergeMap was created as an alias after discussion with you when we created concatMap and switchMap The idea was to have map functions for each of merge concat and switch but that flatMap is the term everyone uses for mergeMap so both would exist It seems you feel differently now Should we deprecate mergeMap in rxjava core and remove it when we hit 1 0RC Totally inconsistent I know but I like to have all the aliases in RxJava core but for the Scala bindings it feels more natural to only have flatMap and drop the mergeMap alias But as I say this is totally irrational and I would be OK to have all @zsxwing Can you get these in soon before 0 19 Otherwise we can pick them up in 0 19 1 @benjchristensen this one will not be a breaking change in RxScala So both are good to me @zsxwing Any preference We can always add mergeMap later but once we put it in as an alias for flatMap it is in forever Speaking as a user of RxScala and Scala I would say just to have flatMap since that s what a Scala user would expect Anything inherit in the missing mergeMap functions that would make that confusing @headinthebox I mean now there is only a flatMap method in RxScala so we can add other methods to RxScala at any time without breaking anything Never mind Already sent a PR to add them #1304',RxJava,false,true,true
34152233,'RxScala BooleanSubscription is inaccessible','scala private scala object BooleanSubscription def apply BooleanSubscription new BooleanSubscription new rx subscriptions BooleanSubscription There s no way to create it I believe this object should be public','As Subscription has the same interface of BooleanSubscription now BooleanSubscription is deprecated Correct Has this been resolved',RxJava,false,false,false
34158477,'OperatorZipIterable does not unsubscribe from source','OperatorZipIterable does not unsubscribe from its source as illustrated by this example java Action1 String printer new Action1 String @Override public void call String t1 System out println t1 Func1 Integer String squareStr new Func1 Integer String @Override public String call Integer t1 System out println Omg I m calculating so hard t1 t1 t1 t1 return t1 t1 @Test public void test Observable Integer o Observable from 1 2 3 4 5 Iterable String it Arrays asList a b c d e o map squareStr zip it concat2Strings take 2 subscribe printer which outputs Omg I m calculating so hard 1 1 1 1 a Omg I m calculating so hard 2 2 4 4 b Omg I m calculating so hard 3 3 9 Omg I m calculating so hard 4 4 16 Omg I m calculating so hard 5 5 25 The last 3 lines should not be there','The inner subscriber is not chained with the outer I ll post a PR to fix the issue shortly That Pr is merged so is this fixed Yes closing',RxJava,false,false,false
34159478,'ZipIterable unsubscription fix','For issue #1253','RxJava pull requests #1153 https netflixoss ci cloudbees com job RxJava pull requests 1153 SUCCESS This pull request looks good',RxJava,true,false,false
34202913,'possible unsubscribe hang bug though may be due to my own custom operators','Hello I m running into an issue where it appears as onComplete never gets called for a chaining I ve created I think something gets unsubscribed somewhere and thats why onComplete never happens though i may be totally off I ve figured out that be removing my OperatorReplaySafegaurd operator it works but I m not sure why an was hoping somebody could give me some insight Can somebody help me understand why this hang is happening and why removing my safeSubscriber operator fixes it My test hangs when run and looks like the following The custom operators are defined below Any help would be greatly appreciated java @Test public void test2 final ListeningExecutorService executorService MoreExecutors listeningDecorator new ThreadPoolExecutor 10 10 60L TimeUnit SECONDS new SynchronousQueue Runnable final ConnectableObservable Tuple Integer Integer replayObs Observable just new Tuple 1 2 replay replayObs connect String a replayObs lift new OperatorReplaySafegaurd Tuple Integer Integer lift new OperatorFlatMapInPool String Tuple Integer Integer new Func1 Tuple Integer Integer Observable String @Override public Observable String call Tuple Integer Integer tuple try Thread sleep 200L catch InterruptedException e e printStackTrace return Observable empty executorService isEmpty flatMap new Func1 Boolean Observable String @Override public Observable String call Boolean aBoolean return Observable String empty toBlockingObservable lastOrDefault foo assertEquals foo a OperatorReplaySafegaurd This was an operator I created to safegaurd the replay object from calling onComplete multiple times due to a bug that existed in rxjava a few months ago via #1105 It has since been fixed but i never got around to removing this operator Removing this from the code appears to make it work but I m interested in know why it works with out it so I can confirm this is in fact what is causing the bug instead of aggravating the bug java public class OperatorReplaySafegaurd T implements ConnectableObservable Operator T T @Override public Subscriber super T call Subscriber super T subscriber return new SafeSubscriber subscriber OperatorFlatMapInPool This is operator to allow you to run a single function on a thread in a pool and then return back to main thread once finished Atm Schedulers don t allow pools and I m not sure its possible to get this single Fn on thread behavior from Schedulers onSubscribe OnObserve so I made it myself It functions well but I suspect my possible naivate of rxJava Threads may be causing some bugs here java public class OperatorFlatMapInPool R T1 implements Observable Operator R T1 final ListeningExecutorService pool final Func1 T1 Observable R func public OperatorFlatMapInPool Func1 T1 Observable R pFunc ListeningExecutorService pPool this pool pPool this func pFunc @Override public Subscriber super T1 call final Subscriber super R subscriber return new Subscriber T1 subscriber AtomicInteger itemsEmitted new AtomicInteger 0 AtomicBoolean completed new AtomicBoolean false AtomicBoolean errored new AtomicBoolean false @Override public void onCompleted completed set true if no mor items are being emitted and we arent working on any items currently then we are done if itemsEmitted get 0 subscriber onCompleted @Override public void onError Throwable e if errored getAndSet true subscriber onError e @Override public void onNext final T1 t1 itemsEmitted addAndGet 1 do function on another thread ListenableFuture Observable R result pool submit new Callable Observable R @Override public Observable R call throws Exception return func call t1 all done on same thread dont need atomic values Futures addCallback result new FutureCallback Observable R @Override public void onSuccess Observable R result threaded process finised subscribe to the result result subscribe new Subscriber R @Override public void onCompleted if no mor items are being emitted and we arent working on any items currently then we are done if itemsEmitted addAndGet 1 0 completed get subscriber onCompleted @Override public void onError Throwable e if errored getAndSet true subscriber onError e @Override public void onNext R r subscriber onNext r @Override public void onFailure Throwable t if errored getAndSet true subscriber onError t','Hi SafeSubscriber eagerly calls unsubscribe internally so if you move the onCompleted call to another thread via observeOn or any other form of cancellable schedule it may never reach it In addition SafeSubscriber is usually meant for the final wrapper on a chain and not as intermediate between two operators due to this eager unsubscribe Yup thank @akarnokd Maybe we should write design guidelines for operator implementers what do you think @DavidMGross I could see that coming in handy I ve got a brief write up about lift in the docs now but a more comprehensive best practices section for operator implementers might come in handy What are some things that you think would be important to cover in such guidelines On Fri May 23 2014 at 7 58 PM headinthebox notifications@github com wrote Yup thank @akarnokd https github com akarnokd Maybe we should write design guidelines for operator implementers what do you think @DavidMGross https github com DavidMGross Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1255#issuecomment 44075975 David M Gross PLP Consulting For starters I think it would be great to have an updated rxJava version of http blogs msdn com b rxteam archive 2010 10 28 rx design guidelines aspx in the wiki we often refer to this as the constitution of Rx Here s a first pass I could use some help in assembling a list of things these guidelines should cover https github com Netflix RxJava wiki Implementing Your Own Operators On Sat May 24 2014 at 11 07 AM headinthebox notifications@github com wrote For starters I think it would be great to have an updated rxJava version of http blogs msdn com b rxteam archive 2010 10 28 rx design guidelines aspxin the wiki we often refer to this as the constitution of Rx Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1255#issuecomment 44094868 David M Gross PLP Consulting Did this ever get resolved Do we need to discuss further and or solve any problems I think we can close The wiki page on how to implement a custom operator probably should have a section about backpressure concerns once I wrap my head around the subject sufficiently to write one On Thu Jul 24 2014 at 2 07 AM headinthebox notifications@github com wrote I think we can close Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1255#issuecomment 49984284 David M Gross PLP Consulting Yes we ll need to add quite a bit about backpressure I owe you answers on that and examples I m focused on getting the code releasable and then can help with that',RxJava,false,false,false
34230427,'Merge not terminating buggy','report was wrong','',RxJava,false,false,false
34231107,'Ambiguity in Observable create in Java 8','The following Java 8 code leads to a compiler error because of the deprecated Observable create OnSubscribeFunc T method Specifically I get this _reference to create is ambiguous both method T create rx Observable OnSubscribe T in rx Observable and method T create rx Observable OnSubscribeFunc T in rx Observable match_ java public static Observable Status twitterObservable return Observable create subscriber final TwitterStream twitterStream new TwitterStreamFactory getInstance twitterStream addListener new StatusAdapter public void onStatus Status status if subscriber isUnsubscribed twitterStream cleanUp subscriber onNext status public void onException Exception ex subscriber onError ex twitterStream sample Am I missing something I must say I find the documentation of RxJava somewhat lacking It only covers a few basic examples for creating Observables mostly with Observable from and only gives examples in one or a couple of languages mostly Groovy it seems It s the different language intricacies that make it difficult to make proper use of RxJava','Hi This is a known bug with javac overload resolution doesn t account for the lambda return type being void Update 8u20 should resolve this soon It will also go away once we delete the deprecated create overload What would you suggest to be added to the documentation I appreciate the criticism but it would be more helpful if you provide examples of what you were looking for and couldn t find Thanks for the answers This is the actual javac bug https bugs openjdk java net browse JDK 8029718 for future reference For now I ll just do a cast to force the compiler to acknowledge the right overload that seems to work And then I ll just have to wait for either a RxJava release with the @deprecated method removed or Java 8u20 With regards to the documentation at first I thought I was in error with the way I was using Observable create in Java 8 and I had no way to check if that was the case because the documentation https github com Netflix RxJava wiki Creating Observables#create only provides an example in _Groovy_ I was left wondering if I missed some implementation intricacy specific to Java 8 What I would like is that those example code snippets were to be provided in each supported JVM lang a bit like the Apache Spark documentation is doing http spark apache org examples html Furthermore it would be great if there would be some more comprehensive real world examples on how to use RxJava Maybe a tutorial of some kind where you actually build something small using RxJava that those example code snippets were to be provided in each supported JVM lang We are working on that it would be great if there would be some more comprehensive real world examples Not sure the docs are the right place for that Google is your friend Not sure the docs are the right place for that Google is your friend It should be my friend that is but surprisingly little comprehensive examples and or tutorials are to be found using Google especially no recent ones I did find your lessons on using RX in the Reactive Programming course on Coursera very useful though so thanks for that The API seems to have changed quite a bit since then though If you want real examples look at things like http weareadaptive com blog 2014 05 05 everything is a stream IMO the docs should have small snippets only and don t try to pretend anything real world Real world code is not a good medium to convey basic principles because all the real world aspects it needs to deal with Thanks for the example I think documentation could and maybe should have both There should be a part of the documentation where basic principles are explained like on the wiki right now but with snippets in all supported languages and a part where a more comprehensive working example is portrayed and a part where a more comprehensive working example is portrayed We take pull requests Note there are plenty of those examples around if you search in various Rx implementations across languages I will see if I can cook up some examples once I have a better handle on stuff Jafar has this nice interactive tutorial for Rx in JavaScript http jhusain github io learnrx index html Those are fantastic but not real world We want to achieve the same thing as Spark is doing and are working towards that Right now my focus is on getting 1 0 out the door and over time the plan is for the broader Rx community to come together to unify our documentation and examples Sounds great Closing out as the root problem will be solved when we delete the deprecated code or Java 8 fixes itself',RxJava,false,false,false
34238581,'RxScala Subscription add with block expression','final def add s Subscription Unit asJavaSubscriber add s asJavaSubscription add final def add s Unit Unit So you can write s add blah blah','I ll take a stab at this issue cool',RxJava,false,true,false
34240539,'Deadlock with recursive chain','In RxJava RxScala the following example prints 0 and then is dead scala val delay BehaviorSubject 0 val nats delay observeOn rx lang scala schedulers NewThreadScheduler doOnEach n delay onNext n 1 nats subscribe n println n Whereas in Rx NET the equivalent program works just fine and prints 0 1 2 C# var delay new BehaviorSubject int 0 var nats delay ObserveOn CurrentThreadScheduler Instance Do n delay OnNext n 1 nats Subscribe Console WriteLine','This works java public class RecursiveDeadlock public static void main String args throws Exception BehaviorSubject Integer delay BehaviorSubject create 0 Observable Integer nats delay observeOn Schedulers newThread doOnEach Observers create n delay onNext n 1 Throwable printStackTrace System out println Done nats subscribe System out println Throwable printStackTrace System out println DONE Thread sleep 1000 Prints a few thousand numbers before terminating This doesn t terminate but prints continuously java public static void main String args throws Exception BehaviorSubject Integer delay BehaviorSubject create 0 Observable Integer nats delay observeOn Schedulers trampoline doOnEach Observers create n delay onNext n 1 Throwable printStackTrace System out println Done nats subscribe System out println Throwable printStackTrace System out println DONE Thread sleep 1000 Note the use of Schedulers trampoline which should be the equivalent of CurrentThreadScheduler Instance tried the other schedulers as well sorry for leaving different ones in the samples But this does not work BehaviorSubject Integer delay BehaviorSubject create 0 Observable Integer nats delay observeOn Schedulers trampoline doOnNext n delay onNext n 1 nats subscribe System out println Throwable printStackTrace System out println DONE System in read This prints a bunch of numbers for me using master but can t terminate it with pressing Enter because it runs in the main thread and the read call is never reached I m using 18 3 Could be either the sequence gap bug or a reentrancy problem with BehaviorSubject @akarnokd Are you digging into this already Is this important to get into 0 19 0 or can it come in a 0 19 x release I never experienced the issue with master @headinthebox can you test your case with master This works for me java BehaviorSubject Integer delay BehaviorSubject create 0 Observable Integer nats delay observeOn Schedulers trampoline doOnNext n delay onNext n 1 nats subscribe System out println so does this java BehaviorSubject Integer delay BehaviorSubject create 0 Observable Integer nats delay observeOn Schedulers newThread doOnNext n delay onNext n 1 nats toBlocking forEach System out println Closing out as it looks solved reopen if it is still an issue with 0 20',RxJava,false,true,true
34259556,'Fix the bug that BlockingObservable singleOrDefault doesn t call unsubscribe','BlockingObservable singleOrDefault doesn t call unsubscribe when throws IllegalArgumentException Sequence contains too many elements testSingleOrDefaultUnsubscribe proves this bug','RxJava pull requests #1156 https netflixoss ci cloudbees com job RxJava pull requests 1156 SUCCESS This pull request looks good',RxJava,true,false,false
34261280,'Merge with Netflix','','RxJava pull requests #1157 https netflixoss ci cloudbees com job RxJava pull requests 1157 SUCCESS This pull request looks good',RxJava,true,false,false
34261331,'Merge from Netflix','','RxJava pull requests #1158 https netflixoss ci cloudbees com job RxJava pull requests 1158 SUCCESS This pull request looks good',RxJava,true,false,false
34261346,'Merge from Netflix','','',RxJava,true,false,false
34346284,'ObserveOn scheduled unsubscription','Proposed fix for #1241 Some operators eagerly unsubscribe the chain in case of an error however this may prevent the delivery of the onError if it is run through the observeOn operator as the worker gets unsubscribed and may or may not reach the point where it emits the onError in the other thread This change will schedule the unsubscription along with the event delivery and thus ensure that all events sent to observeOn prior to unsubscription will be delivered in the new thread Note that this change makes the unsubscription delayed and if event processing is slow in the new thread it may take a while to happen the original version just dropped any unprocessed work and thus was faster to terminate','RxJava pull requests #1159 https netflixoss ci cloudbees com job RxJava pull requests 1159 SUCCESS This pull request looks good I m not sure this conforms with the guidelines for unsubscribe or not cc @headinthebox Note guideline 4 4 in particular the last bold line 4 4 Assume a best effort to stop all outstanding work on Unsubscribe When unsubscribe is called on an observable subscription the observable sequence will make a best effort attempt to stop all outstanding work This means that any queued work that has not been started will not start Best effort in this case means that the observation of the error is matter of chance This affects MergeDelayError as well so you d only see a broken chain but not the reason for the failure nor a completion event This is a though one My reading is that the rul applies to user code subscriptions If in user code you write val s source subscribe and then call s unsubscribe you are not going to wait for outstanding work However when inside source there is an because of an error I think it is reasonable to expect that the onError bubbles up to the outside subscriber and does not get dropped because of internal unsubscriptions As @akarnokd mentions otherwise onError becomes a game a chance So do you recommend merging this change @headinthebox This is a real gray area and not fully covered by specifications Should we make it drop all onNext skip filter them but iterate through the entire queue to allow for an onError if it is queued for delivery It is a gray area indeed I d say just let the queue drain but don t add new notifications otherwise xs observeOn s subscribe will behave very different from xs subscribe when errors happen Then I m merging this',RxJava,true,false,false
34377366,'Add more operators to RxScala','The commits explain this PR In addition the reason that I changed window closings Observable Any to window boundary Observable Any is window boundary Observable Any can support both two overloads window Observable U and window Func0 _ Observable _ TClosing in RxJava','cc @samuelgruetter @headinthebox RxJava pull requests #1160 https netflixoss ci cloudbees com job RxJava pull requests 1160 FAILURE Looks like there s a problem with this pull request Thanks @zsxwing Probably a good idea to look for more places where we can use and curry it as the last parameter but I guess there are not that many places to do that if anay The code looks fine to me Can t see quickly howthe cloudbees failure connected to the code in this pull request though The two Java methods java public final TClosing Observable Observable T window Func0 extends Observable extends TClosing closingSelector public final U Observable Observable T window Observable U boundary have very different semantics and both of them are useful and should be present in the RxScala Since we cannot have an overload which takes an Observable Any and one which takes an Observable Any we should use Observable Any or rename one of the functions The same applies to buffer and we should keep buffer and window consistent Of course main pitfall of T have very different semantics In RxJava it s public OperatorWindowWithObservable Func0 extends Observable extends U otherFactory this otherFactory otherFactory public OperatorWindowWithObservable final Observable U other this otherFactory new Func0 Observable U @Override public Observable U call return other Looks can cover these two use cases Any difference I miss I just noticed that this window method does not what it should do When I tried to use it I got a java lang ClassCastException rx operators BufferUntilSubscriber cannot be cast to java lang Long Can you please rewrite this method from scratch No idea what I was thinking when I wrote this method And can you also add an example to RxScalaDemo OK RxJava pull requests #1162 https netflixoss ci cloudbees com job RxJava pull requests 1162 SUCCESS This pull request looks good Looks can cover these two use cases Any difference I miss I think the javadoc does not correspond to the implementation Probably a good idea to look for more places where we can use and curry it as the last parameter but I guess there are not that many places to do that if anay The only place I found is buffer Already updated it Cool RxJava pull requests #1173 https netflixoss ci cloudbees com job RxJava pull requests 1173 SUCCESS This pull request looks good @DavidMGross could you help improve the javadoc for buffer Func0 extends Observable extends TClosing bufferClosingSelector and window Func0 extends Observable extends TClosing closingSelector The current docs are misleading Func0 is actually only called once to generate an Observable which is used to determined the boundary of each window buffer Also the marble diagrams Thank you Will do On Wed May 28 2014 at 8 43 AM Shixiong Zhu notifications@github com wrote @DavidMGross https github com DavidMGross could you help improve the javadoc for buffer Func0 extends Observable extends TClosing bufferClosingSelector and window Func0 extends Observable extends TClosing closingSelector The current docs are misleading Func0 is actually only called once to generate an Observable which is used to determined the boundary of each window buffer Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 1265#issuecomment 44424293 David M Gross PLP Consulting Is this ready for merging Looks good to go to me IMHO it makes more sense to say that the javadoc is correct but the implementation of window Func0 is wrong For future reference here s the current javadoc that I think is correct java Returns an Observable that emits windows of items it collects from the source Observable The resulting Observable emits connected non overlapping windows It emits the current window and opens a new one when the Observable produced by the specified @code closingSelector emits an item The @code closingSelector then creates a new Observable to generate the closer of the next window p img width 640 src https raw github com wiki Netflix RxJava images rx operators window1 png @param closingSelector a @link Func0 that produces an Observable for every window created When this Observable emits an item @code window emits the associated window and begins a new one @return an Observable that emits connected non overlapping windows of items from the source Observable when @code closingSelector emits an item @see a href https github com Netflix RxJava wiki Transforming Observables#wiki window RxJava Wiki window a public final TClosing Observable Observable T window Func0 extends Observable extends TClosing closingSelector Returns an Observable that emits non overlapping windows of items it collects from the source Observable where the boundary of each window is determined by the items emitted from a specified boundary governing Observable p img width 640 src https raw github com wiki Netflix RxJava images rx operators window8 png @param U the window element type ignored @param boundary an Observable whose emitted items close and open windows @return an Observable that emits non overlapping windows of items it collects from the source Observable where the boundary of each window is determined by the items emitted from the @code boundary Observable public final U Observable Observable T window Observable U boundary @headinthebox @benjchristensen what do you think I think java public final A B Observable Observable T window Func0 extends Observable extends A firstClosingSelector Func1 super T extends Observable extends B closingSelector is better However from MSDN http msdn microsoft com en us library hh229909 v vs 103 aspx the current implementation in RxJava is same as Rx Net',RxJava,true,false,false
34398536,'Collection of tiny issues detected by IntelliJ IDEA','Observable lift parameter lift not documented pivot parameter groups not documented merge duplicate @return range if start count Integer MAX_VALUE condition is always false dematerialize @throws Throwable not declared by method as far as I can see it throws OnErrorNotImplementedException range elementAt forEach duplicate @throws IllegalArgumentException unsafeSubscribe parameter subscriber not documented subscribe hook onSubscribeError r throws r not the result of hook ThrowObservable @return a reference to the subscription on void method RxJavaObservableExecutionHook onSubscribeStart typo in parameter name observableInsance CompositeException messagePrefix not used more to come','range if start count Integer MAX_VALUE condition is always false Good catch Should be start Integer MAX_VALUE count Thanks @orangy for referencing these Thanks @zsxwing for fixing that item and @DavidMGross for fixing Javadoc issues Please continue submitting PRs to fix these and similar issues as they are found I believe these are all done',RxJava,false,false,false
34420624,'Fix to future cancellation','Right now Observable from Future f emits onError CancellationException when f starts out in a cancelled state This change makes Observable from f emit nothing at all','Mmm not sure if that is better I think it makes more sense to call onError in that case Why do you think being silent is better RxJava pull requests #1161 https netflixoss ci cloudbees com job RxJava pull requests 1161 SUCCESS This pull request looks good My understanding of the Rx contract was that an outer unsubscribe should cause downstream emissions to stop whenever possible I encountered a case where Observable zip Observable empty Observable from future func was emitting onError CancellationException Zip loops through the Observables and on the onCompleted from the first Observable unsubscribed from the 2nd Observable thereby cancelling the underlying future The onError then gets propagated out of the zip I think the question is more about the semantics of zip than of from Future Zip should stop whenever one of the sources completes I must admit that the error behavior is underspecified In NET pseudo notation where is successful termination and error zipping one sequence that terminates normally with a sequence that terminates with an error will wait until the second sequence produces the next value before terminating 1 zip 1 x y x y 1 1 whereas using 18 3 for samples I stick to the released version may be changed in master since there were a lot of changes to zip this returns 1 1 In 18 3 when you delay successful completion zip waits for the successful termination before terminating 1 zip 1 x y x y 1 1 So there is definitively a difference here but in any case I d separate that from from The CancelationException is not a real error Its more of an onComplete because it is the only way the get can stop without returning data I agree with @abersnaze I don t find it intuitive that calling Observable from on f below could ever emit onError Future Integer f new FutureTask Integer new Callable Integer @Override public Integer call throws Exception return 3 An onError should never occur as a result of unsubscribe being called on an Observable RxJava pull requests #1177 https netflixoss ci cloudbees com job RxJava pull requests 1177 SUCCESS This pull request looks good Can you please rebase this so it can be merged It conflicts now Done in https github com Netflix RxJava pull 1291',RxJava,true,false,false
34437605,'Cursor observable for Android','Change version of scala to newest 2 11 for properly work and gradle execution Add CursorObservable for observing android cursor changes','RxJava pull requests #1163 https netflixoss ci cloudbees com job RxJava pull requests 1163 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1167 https netflixoss ci cloudbees com job RxJava pull requests 1167 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1168 https netflixoss ci cloudbees com job RxJava pull requests 1168 FAILURE Looks like there s a problem with this pull request It seems like cloudbees says about core tests failure I can not understand why There is no problems on my machine cc @mttkay @zsxwing Why update scala to 2 11 Could you revert the change of scala version Even if you have compelling reasons it s better that updating scala version in another PR so that we can discuss it there @zsxwing Should I create two new PR or just revert my changes in build gradle and create new about new scala Besides a few style things I commented on I think this looks like a good solution to lifting queries to a ContentProvider into an observable call chain I have a general question though maybe more for @benjchristensen is there a general policy for adding new functionality to the library I d be a bit wary by adding stuff that s only used by a single product We re moving away from ContentProviders in our app so I probably won t be able to give this a shot in practice any time soon I think it would be good if someone could incorporate this into their app and give first hand feedback Also I would definitely want to see tests added before landing this @zsxwing Should I create two new PR or just revert my changes in build gradle and create new about new scala Maybe you can just override the commits in this PR The following commands can help you clean up this PR shell git checkout cursor observable git reset HEAD 2 git checkout language adaptors rxjava scala build gradle git add rxjava contrib rxjava android src main java rx android observables CursorObservable java git commit amend git push force your_remote_repository_name cursor observable RxJava pull requests #1171 https netflixoss ci cloudbees com job RxJava pull requests 1171 SUCCESS This pull request looks good Thank you but I m already had some fail with it use HEAD 5 instead of HEAD 4 and add CursorObservable java to DavidMGross s commit I ll fix it soon RxJava pull requests #1172 https netflixoss ci cloudbees com job RxJava pull requests 1172 SUCCESS This pull request looks good May be it will be good to add tests for CursorObservable and create new PR without my stupid fails',RxJava,true,false,false
34438961,'Fix the bug that int overflow can bypass the range check','Fix the bug mentioned in #1266','RxJava pull requests #1164 https netflixoss ci cloudbees com job RxJava pull requests 1164 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1165 https netflixoss ci cloudbees com job RxJava pull requests 1165 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1166 https netflixoss ci cloudbees com job RxJava pull requests 1166 SUCCESS This pull request looks good',RxJava,true,false,false
34442471,'Rename OperatorMulticast and OperatorMulticastSelector','Was looking at the source of OperatorMulticast https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorMulticast java and OperatorMulticastSelector https github com Netflix RxJava blob master rxjava core src main java rx operators OperatorMulticastSelector java and neither implements Operator Is a rename in order here or are they going to be made into Operator s soonish','They can t be operators because they need to be ConnectableObservable s I think the naming is just stuck so they don t stand out of the other OperatorXYZ classes Btw there are a bunch of OperatorXYZ which implement OnSubscribe only yet they are called Operator Yep you re quite right of the 93 Operator classes in the operator package roughly 22 do not implement Operator This is a lot of hiding though perhaps some are candidates to implement Operator in the near future Why not rename everything that is not an Operator and not a candidate for conversion to Operator Might prompt a new package or two to contain these beasts In the case of the classes above I d prefer to see them as ConnectableObservableMulticast and ConnectableObservableMulticastSelector Here s a quick list might have missed some OperatorAmb java public final class OperatorAmb T implements OnSubscribe T OperatorCache java public final class OperatorCache T implements OnSubscribe T OperatorCombineLatest java public final class OperatorCombineLatest T R implements OnSubscribe R OperatorDefer java public final class OperatorDefer T implements OnSubscribe T OperatorDelay java public final class OperatorDelay T implements OnSubscribe T OperatorDelay java public static final class Emitter T implements OnSubscribe T Action0 OperatorDelaySubscription java public final class OperatorDelaySubscription T implements OnSubscribe T OperatorDelayWithSelector java public final class OperatorDelayWithSelector T U V implements OnSubscribe T OperatorGroupJoin java public final class OperatorGroupJoin T1 T2 D1 D2 R implements OnSubscribe R OperatorJoin java public final class OperatorJoin TLeft TRight TLeftDuration TRightDuration R implements OnSubscribe R OperatorMulticast java public final class OperatorMulticast T R extends ConnectableObservable R OperatorMulticastSelector java public final class OperatorMulticastSelector TInput TIntermediate TResult implements OnSubscribe TResult OperatorParallelMerge java public final class OperatorParallelMerge OperatorRefCount java public final class OperatorRefCount T implements OnSubscribe T OperatorReplay java public final class OperatorReplay OperatorSequenceEqual java public final class OperatorSequenceEqual OperatorSkip java public final class OperatorSkip T implements Observable Operator T T OperatorTakeUntil java public final class OperatorTakeUntil OperatorTimerOnce java public final class OperatorTimerOnce implements OnSubscribe Long OperatorTimerPeriodically java public final class OperatorTimerPeriodically implements OnSubscribe Long OperatorToMap java public static final class DefaultToMapFactory K V implements Func0 Map K V OperatorToMultimap java public static final class DefaultToMultimapFactory K V implements Func0 Map K Collection V OperatorToMultimap java public static final class DefaultMultimapCollectionFactory K V OperatorToObservableFuture java public class OperatorToObservableFuture OperatorUsing java public final class OperatorUsing T Resource extends Subscription implements OnSubscribe T These operators are considered internal implementation and unless you are a hard core rxjava core developer you don t need to worry about what is in rx operators Many of these operators don t implement Operator because the behavior they need to perform can only be done while in OnSubscribe call there is no one to pass a Subscriber further up since they behave basically as sources The ones that implement OnSubscribe could be renamed from Operator to OnSubscribe More importantly though these should never be relied upon publicly They are not part of the public API and can change at any time even once we hit 1 0 So I don t have hard core understanding of the rxjava code base but I m using it on a a lot of projects at work and to develop with rxjava I very frequently dig small holes into the source code to understand what I m using and I use the source as a cookbook I can t imagine developing with the library without the source code Given that I d like to see those spades called spades to minimize a bit of possible confusion e g why is Observable create being called with an Operator what overload is that Happy to knock up a pull request if this has support I m okay with a change that makes the OnSubscribe implementations start with OnSubscribe So that this is clean please do not mix any other changes with it just renaming those 20 files that should start with OnSubscribe instead of Operator Example OperatorAmb OnSubscribeAmb @akarnokd Do you have an issue with this It seems to be clearer and matches the intent of of classes such as OnSubscribeRange and OnSubscribeFromIterable already there LGTM For me using Operator as prefix is simpler so no need to remember the base interface for each operator I d even drop the prefix but I guess that would just complicate auto complete in IDEs These classes are internal and referenced from a single place Observable so I m fine either way I think we should either give them a completely generic prefix I can t think of one right now or make the OnSubscribe and Operator prefix consistent as suggested in this issue The generic prefix idea is not attractive to me because I lose visibility at a glance of what types the classes are I end up in the same place as I am now Dropping the prefix would do the job if we moved non operators out of the operator package to an onsubscribe package My preference at the moment is Operator OnSubscribe I m fine with you changing the prefixes if you want to contribute that Sounds good Now that we have rx internal should we move rx operators to rx internal operators alongside rx internal util This way it is very clear that these are internal and not part of the public API Fine with me Sounds good Sounds good On 31 May 2014 03 33 headinthebox notifications@github com wrote Sounds good Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1270#issuecomment 44677574 I ll make this change',RxJava,false,false,false
34444143,'Operator Retry with predicate','Operator Retry with predicate 1 overload for Issue #1214 The Func1 version is simply named retry the Func2 version is named retryIf due to lack of ideas and because to avoid overload resolution issues I also had to open up the OperatorRetryTest classes a bit','RxJava pull requests #1169 https netflixoss ci cloudbees com job RxJava pull requests 1169 SUCCESS This pull request looks good Thanks for implementing this Should we just keep one of those two instead of both so we don t have to deal with the naming overload issue I don t know which one to keep Probably the one that includes attempts This is the advanced use case for retry so it should probably provide both attempts and error It just feels awkward to need to come up with a new name just so we can have one with attempts and one without @headinthebox Do you have an opinion on this Agree with @benjchristensen If you are using this one you should know what you are doing RxJava pull requests #1176 https netflixoss ci cloudbees com job RxJava pull requests 1176 SUCCESS This pull request looks good Thanks @akarnokd and @headinthebox for the review',RxJava,true,false,false
34450683,'ExecutorScheduler to wrap an Executor','For issue #1219 and #1206 This implementation should conform with the Scheduler contract except it is not possible to avoid thread hopping don t worry the tasks execute serially but maybe not on the same physical thread Few open improvement possibilities Usage of MpscLinkedQueue once available A better performing subscription container for this kind of queue drain task tracking instead of CompositeSubscription Ability to remove a Subscription from a CompositeSubscription without it calling unsubscribe on the removed Subscription la MultipleAssignmentSubscription set','RxJava pull requests #1170 https netflixoss ci cloudbees com job RxJava pull requests 1170 SUCCESS This pull request looks good Thanks @akarnokd for this Looks good for a first cut The trade offs thread hopping are expected and why we won t use this as a default for anything and agreed on possible improvements but those can come later',RxJava,true,false,false
34494855,'RxJava Android Retrofit Issue','This is to track an issue in https github com square retrofit issues 463 when using the RxJava AndroidScheduler The bug is shown here https github com jdreesen retrofit rxjava failure example Can someone who works on the rxjava android code take a look at this please','Do you think this is related to https github com Netflix RxJava issues 1241 In which case we re just waiting on @akarnokd s fixes to observeOn I don t know but those fixes are part of 0 19 0 which was just released so it could be tested to find out I just tried with 0 19 0 and it seems to work now Great that simplifies this pursuit Does that mean https github com square retrofit issues 463 is solved by 0 19 0 Upgrading to 0 19 0 should be easy no breaking changes in rxjava core Sorry for the delay I ve been very busy the last days As far as I can tell the issue is solved by 0 19 0 I haven t seen any problems in my failure demo or in my private project for now So I think this issue can be closed Thx for RxJava it s a great and impressive library square retrofit#463 is now closed so I think this issue can be closed as well',RxJava,false,false,false
34500745,'JavaFX Building on CloudBees','We are unable to build the JavaFX module on CloudBees I have looked at the CloudBees config and all it shows is Oracle JDK 1 7 latest screen shot 2014 05 28 at 12 51 40 pm https cloud githubusercontent com assets 813492 3110118 b7b88eac e6a1 11e3 907c 167e5fd1fd99 png cc @amazari','It looks like we need a Gradle plugin for this to work http speling shemnon com blog 2013 10 29 javafx gradle plugin 0 dot 4 0 released We can t yet upgrade to using Java 8 as that doesn t work with anything Scala related until Gradle 2 and Java 7 doesn t automatically work for JavaFX This means I can t include this in the 0 19 release until someone figures out how to make it build with Gradle You can try fix classpath with that maven plugin http zenjava com javafx maven fix classpath html',RxJava,false,false,false
34501079,'Fix Encoding Formatting','The encoding on these files is not liked by Git and it is forcing them to be updated cc @akarnokd As you may want to look at your setup this happens somewhat often on commits from you I believe it is related to these gitattribute settings # Set default behaviour in case users don t have core autocrlf set text auto # Explicitly declare text files we want to always be normalized and converted # to native line endings on checkout java text groovy text scala text clj text txt text md text # Denote all files that are truly binary and should not be modified png binary jpg binary','I m sorry I sometimes forget to set the file encoding to LF on my Windows machine Netbeans doesn t allow this to be set as default',RxJava,true,false,false
34503586,'Re submission of CachedThreadScheduler','Merged in the latest from the master branch and refactored some internals in CachedThreadScheduler to better match the latest Scheduler changes Aimed at solving #1140','RxJava pull requests #1174 https netflixoss ci cloudbees com job RxJava pull requests 1174 SUCCESS This pull request looks good Those should be final as well I sometimes add them in one PR forget to add them in another and at the end a third PR gets merged without it I plan to do another cleanup round before 1 0 so hopefully final will be applied uniformly RxJava pull requests #1175 https netflixoss ci cloudbees com job RxJava pull requests 1175 SUCCESS This pull request looks good Testing with this code java public static void main String args Observable timer 0 10 TimeUnit MILLISECONDS take 100 flatMap i return Observable just i subscribeOn Schedulers io map t try Thread sleep 10 catch Exception e e printStackTrace return t Thread currentThread toBlocking forEach System out println Without this pull request it creates 100 threads 0 Thread RxNewThreadScheduler 1 5 main 1 Thread RxNewThreadScheduler 2 5 main 2 Thread RxNewThreadScheduler 3 5 main 3 Thread RxNewThreadScheduler 4 5 main 4 Thread RxNewThreadScheduler 5 5 main 5 Thread RxNewThreadScheduler 6 5 main 6 Thread RxNewThreadScheduler 7 5 main 7 Thread RxNewThreadScheduler 8 5 main 8 Thread RxNewThreadScheduler 9 5 main 9 Thread RxNewThreadScheduler 10 5 main 10 Thread RxNewThreadScheduler 11 5 main 11 Thread RxNewThreadScheduler 12 5 main 12 Thread RxNewThreadScheduler 13 5 main 13 Thread RxNewThreadScheduler 14 5 main 14 Thread RxNewThreadScheduler 15 5 main 15 Thread RxNewThreadScheduler 16 5 main 16 Thread RxNewThreadScheduler 17 5 main 17 Thread RxNewThreadScheduler 18 5 main 18 Thread RxNewThreadScheduler 19 5 main 19 Thread RxNewThreadScheduler 20 5 main 20 Thread RxNewThreadScheduler 21 5 main 21 Thread RxNewThreadScheduler 22 5 main 22 Thread RxNewThreadScheduler 23 5 main 23 Thread RxNewThreadScheduler 24 5 main 24 Thread RxNewThreadScheduler 25 5 main 25 Thread RxNewThreadScheduler 26 5 main 26 Thread RxNewThreadScheduler 27 5 main 27 Thread RxNewThreadScheduler 28 5 main 28 Thread RxNewThreadScheduler 29 5 main 29 Thread RxNewThreadScheduler 30 5 main 30 Thread RxNewThreadScheduler 31 5 main 31 Thread RxNewThreadScheduler 32 5 main 32 Thread RxNewThreadScheduler 33 5 main 33 Thread RxNewThreadScheduler 34 5 main 34 Thread RxNewThreadScheduler 35 5 main 35 Thread RxNewThreadScheduler 36 5 main 36 Thread RxNewThreadScheduler 37 5 main 37 Thread RxNewThreadScheduler 38 5 main 38 Thread RxNewThreadScheduler 39 5 main 39 Thread RxNewThreadScheduler 40 5 main 40 Thread RxNewThreadScheduler 41 5 main 41 Thread RxNewThreadScheduler 42 5 main 42 Thread RxNewThreadScheduler 43 5 main 43 Thread RxNewThreadScheduler 44 5 main 44 Thread RxNewThreadScheduler 45 5 main 45 Thread RxNewThreadScheduler 46 5 main 46 Thread RxNewThreadScheduler 47 5 main 47 Thread RxNewThreadScheduler 48 5 main 48 Thread RxNewThreadScheduler 49 5 main 49 Thread RxNewThreadScheduler 50 5 main 50 Thread RxNewThreadScheduler 51 5 main 51 Thread RxNewThreadScheduler 52 5 main 52 Thread RxNewThreadScheduler 53 5 main 53 Thread RxNewThreadScheduler 54 5 main 54 Thread RxNewThreadScheduler 55 5 main 55 Thread RxNewThreadScheduler 56 5 main 56 Thread RxNewThreadScheduler 57 5 main 57 Thread RxNewThreadScheduler 58 5 main 58 Thread RxNewThreadScheduler 59 5 main 59 Thread RxNewThreadScheduler 60 5 main 60 Thread RxNewThreadScheduler 61 5 main 61 Thread RxNewThreadScheduler 62 5 main 62 Thread RxNewThreadScheduler 63 5 main 63 Thread RxNewThreadScheduler 64 5 main 64 Thread RxNewThreadScheduler 65 5 main 65 Thread RxNewThreadScheduler 66 5 main 66 Thread RxNewThreadScheduler 67 5 main 67 Thread RxNewThreadScheduler 68 5 main 68 Thread RxNewThreadScheduler 69 5 main 69 Thread RxNewThreadScheduler 70 5 main 70 Thread RxNewThreadScheduler 71 5 main 71 Thread RxNewThreadScheduler 72 5 main 72 Thread RxNewThreadScheduler 73 5 main 73 Thread RxNewThreadScheduler 74 5 main 74 Thread RxNewThreadScheduler 75 5 main 75 Thread RxNewThreadScheduler 76 5 main 76 Thread RxNewThreadScheduler 77 5 main 77 Thread RxNewThreadScheduler 78 5 main 78 Thread RxNewThreadScheduler 79 5 main 79 Thread RxNewThreadScheduler 80 5 main 80 Thread RxNewThreadScheduler 81 5 main 81 Thread RxNewThreadScheduler 82 5 main 82 Thread RxNewThreadScheduler 83 5 main 83 Thread RxNewThreadScheduler 84 5 main 84 Thread RxNewThreadScheduler 85 5 main 85 Thread RxNewThreadScheduler 86 5 main 86 Thread RxNewThreadScheduler 87 5 main 87 Thread RxNewThreadScheduler 88 5 main 88 Thread RxNewThreadScheduler 89 5 main 89 Thread RxNewThreadScheduler 90 5 main 90 Thread RxNewThreadScheduler 91 5 main 91 Thread RxNewThreadScheduler 92 5 main 92 Thread RxNewThreadScheduler 93 5 main 93 Thread RxNewThreadScheduler 94 5 main 94 Thread RxNewThreadScheduler 95 5 main 95 Thread RxNewThreadScheduler 96 5 main 96 Thread RxNewThreadScheduler 97 5 main 97 Thread RxNewThreadScheduler 98 5 main 98 Thread RxNewThreadScheduler 99 5 main 99 Thread RxNewThreadScheduler 100 5 main With this pull request it uses only 2 threads 0 Thread RxCachedThreadScheduler 1 5 main 1 Thread RxCachedThreadScheduler 2 5 main 2 Thread RxCachedThreadScheduler 1 5 main 3 Thread RxCachedThreadScheduler 2 5 main 4 Thread RxCachedThreadScheduler 1 5 main 5 Thread RxCachedThreadScheduler 2 5 main 6 Thread RxCachedThreadScheduler 1 5 main 7 Thread RxCachedThreadScheduler 2 5 main 8 Thread RxCachedThreadScheduler 1 5 main 9 Thread RxCachedThreadScheduler 2 5 main 10 Thread RxCachedThreadScheduler 1 5 main 11 Thread RxCachedThreadScheduler 2 5 main 12 Thread RxCachedThreadScheduler 1 5 main 13 Thread RxCachedThreadScheduler 2 5 main 14 Thread RxCachedThreadScheduler 1 5 main 15 Thread RxCachedThreadScheduler 2 5 main 16 Thread RxCachedThreadScheduler 1 5 main 17 Thread RxCachedThreadScheduler 2 5 main 18 Thread RxCachedThreadScheduler 1 5 main 19 Thread RxCachedThreadScheduler 2 5 main 20 Thread RxCachedThreadScheduler 1 5 main 21 Thread RxCachedThreadScheduler 2 5 main 22 Thread RxCachedThreadScheduler 1 5 main 23 Thread RxCachedThreadScheduler 2 5 main 24 Thread RxCachedThreadScheduler 1 5 main 25 Thread RxCachedThreadScheduler 2 5 main 26 Thread RxCachedThreadScheduler 1 5 main 27 Thread RxCachedThreadScheduler 2 5 main 28 Thread RxCachedThreadScheduler 1 5 main 29 Thread RxCachedThreadScheduler 2 5 main 30 Thread RxCachedThreadScheduler 1 5 main 31 Thread RxCachedThreadScheduler 2 5 main 32 Thread RxCachedThreadScheduler 1 5 main 33 Thread RxCachedThreadScheduler 2 5 main 34 Thread RxCachedThreadScheduler 1 5 main 35 Thread RxCachedThreadScheduler 2 5 main 36 Thread RxCachedThreadScheduler 1 5 main 37 Thread RxCachedThreadScheduler 2 5 main 38 Thread RxCachedThreadScheduler 1 5 main 39 Thread RxCachedThreadScheduler 2 5 main 40 Thread RxCachedThreadScheduler 1 5 main 41 Thread RxCachedThreadScheduler 2 5 main 42 Thread RxCachedThreadScheduler 1 5 main 43 Thread RxCachedThreadScheduler 2 5 main 44 Thread RxCachedThreadScheduler 1 5 main 45 Thread RxCachedThreadScheduler 2 5 main 46 Thread RxCachedThreadScheduler 1 5 main 47 Thread RxCachedThreadScheduler 2 5 main 48 Thread RxCachedThreadScheduler 1 5 main 49 Thread RxCachedThreadScheduler 2 5 main 50 Thread RxCachedThreadScheduler 1 5 main 51 Thread RxCachedThreadScheduler 2 5 main 52 Thread RxCachedThreadScheduler 1 5 main 53 Thread RxCachedThreadScheduler 2 5 main 54 Thread RxCachedThreadScheduler 1 5 main 55 Thread RxCachedThreadScheduler 2 5 main 56 Thread RxCachedThreadScheduler 1 5 main 57 Thread RxCachedThreadScheduler 2 5 main 58 Thread RxCachedThreadScheduler 1 5 main 59 Thread RxCachedThreadScheduler 2 5 main 60 Thread RxCachedThreadScheduler 1 5 main 61 Thread RxCachedThreadScheduler 2 5 main 62 Thread RxCachedThreadScheduler 1 5 main 63 Thread RxCachedThreadScheduler 2 5 main 64 Thread RxCachedThreadScheduler 1 5 main 65 Thread RxCachedThreadScheduler 2 5 main 66 Thread RxCachedThreadScheduler 1 5 main 67 Thread RxCachedThreadScheduler 2 5 main 68 Thread RxCachedThreadScheduler 1 5 main 69 Thread RxCachedThreadScheduler 2 5 main 70 Thread RxCachedThreadScheduler 1 5 main 71 Thread RxCachedThreadScheduler 2 5 main 72 Thread RxCachedThreadScheduler 1 5 main 73 Thread RxCachedThreadScheduler 2 5 main 74 Thread RxCachedThreadScheduler 1 5 main 75 Thread RxCachedThreadScheduler 2 5 main 76 Thread RxCachedThreadScheduler 1 5 main 77 Thread RxCachedThreadScheduler 2 5 main 78 Thread RxCachedThreadScheduler 1 5 main 79 Thread RxCachedThreadScheduler 2 5 main 80 Thread RxCachedThreadScheduler 1 5 main 81 Thread RxCachedThreadScheduler 2 5 main 82 Thread RxCachedThreadScheduler 1 5 main 83 Thread RxCachedThreadScheduler 2 5 main 84 Thread RxCachedThreadScheduler 1 5 main 85 Thread RxCachedThreadScheduler 2 5 main 86 Thread RxCachedThreadScheduler 1 5 main 87 Thread RxCachedThreadScheduler 2 5 main 88 Thread RxCachedThreadScheduler 1 5 main 89 Thread RxCachedThreadScheduler 2 5 main 90 Thread RxCachedThreadScheduler 1 5 main 91 Thread RxCachedThreadScheduler 2 5 main 92 Thread RxCachedThreadScheduler 1 5 main 93 Thread RxCachedThreadScheduler 2 5 main 94 Thread RxCachedThreadScheduler 1 5 main 95 Thread RxCachedThreadScheduler 2 5 main 96 Thread RxCachedThreadScheduler 1 5 main 97 Thread RxCachedThreadScheduler 2 5 main 98 Thread RxCachedThreadScheduler 1 5 main 99 Thread RxCachedThreadScheduler 2 5 main Thanks @jbripley for this Thanks for all the pointers @akarnokd I ve learned a lot about both thread safe Java and how the Scheduler code in RxJava works You are welcome',RxJava,true,false,false
34509710,'FuncN generic varargs parameter','As mentioned 1 2 it would be nice for Observable zip iterable funcn to handle iterables of the same type without having to go about casting the object to an integer for making something like this to work java List Observable Integer iterable Arrays asList Observable from 1 Observable from 2 Observable from 3 Observable List Integer observable Observable zip iterable Arrays asList Making FuncN R into FuncN T R kind of snowballed on me as I reached the OperatorZip Zip which seems to be needing the Object type 1 https twitter com benjchristensen status 471312995352457219 2 https gist github com torgeir bdfffbdfdc8ed98056b8#file statistics java L25 L26','I missed this issue being opened do you want to pick this up again Sure though I m off for holidays for a couple of weeks now so I m a little of the radar I believe these Object arrays was where I stumbled https github com Netflix RxJava blob master rxjava core src main java rx internal operators OperatorZip java#L177 L286',RxJava,false,false,false
34511692,'Performance ReplaySubject and ConcurrentHashMap hashCode','We are seeing this show up a lot in our thread dumps while analyzing performance as part of #1204 It suggests an inefficiency in our hashcode impl or very large data structures are being hashed This is caused by the use of cache ajp bio 0 0 0 0 8009 exec 273 daemon prio 10 tid 0x00007f14ec031800 nid 0x5c22 runnable 0x00007f1433b76000 java lang Thread State RUNNABLE at java lang Object hashCode Native Method at java util concurrent ConcurrentHashMap hash ConcurrentHashMap java 333 at java util concurrent ConcurrentHashMap put ConcurrentHashMap java 1125 at rx subjects ReplaySubject 1 call ReplaySubject java 79 at rx subjects ReplaySubject 1 call ReplaySubject java 71 at rx subjects SubjectSubscriptionManager 1 call SubjectSubscriptionManager java 53 at rx subjects SubjectSubscriptionManager 1 call SubjectSubscriptionManager java 47 at rx Observable unsafeSubscribe Observable java 6111 at rx operators OperatorCache call OperatorCache java 68 at rx operators OperatorCache call OperatorCache java 43 at rx Observable subscribe Observable java 6178 at com netflix hystrix HystrixCommand CachedObservableOriginal 1 call HystrixCommand java 912 at com netflix hystrix HystrixCommand CachedObservableOriginal 1 call HystrixCommand java 908 at rx Observable subscribe Observable java 6178 at com netflix hystrix HystrixCommand CachedObservableResponse 1 call HystrixCommand java 960 at com netflix hystrix HystrixCommand CachedObservableResponse 1 call HystrixCommand java 956 at rx Observable subscribe Observable java 6178','We use the default hashCode implementation What version is this stacktrace from Does it have the caughtUp flag Besides maybe the use of replayState CHM is not necessary and the index can go directly into SubjectObserver Sorry that would have been helpful This is from 0 18 2 The ReplaySubject is the default behavior of using cache This obviously does not test the new ReplaySubject since 0 18 3 and unreleased Okay So the usage pattern is that lots of subscribers subscribe to a terminated cache get the data and leave In that case there is no need to put the SubjectSubscriber into the map because it won t stay anyway A lot has changed since 0 18 2 3 so I m closing this out I have not seen this in perf testing I m doing I ll leave it to performance work going forward to isolate issues',RxJava,false,false,false
34512263,'Schedulers plugin seems to have the wrong granularity','At the moment implementing a non default scheduler requires me to implement computation io and newThread from scratch This might be appropriate for some cases but in my specific case I just want access to the Action in the schedule method If the Schedulers plugin gave me an onSchedule hook I could use all of the Schedulers default setup but decorate the actual scheduling I m about to start working on a PR that would change the Schedulers plugin model from supplying an entire set of schedulers to decorating an Action via an onSchedule hook','Is this going to be additive so it can come at any time or does it require breaking changes This one has to be additive We will still need to provide the ability for replacing schedulers wholesale to support use cases like Quasar I m working on a PR right now and will submit it for review shortly',RxJava,false,false,false
34570924,'Unbounded Buffer for Time Gap Issue','To solve the time gap issue #844 we have accepted having an unbounded buffer https github com Netflix RxJava blob master rxjava core src main java rx operators BufferUntilSubscriber java#L32 This is a preferable tradeoff to non deterministic data loss and easier to explain to people It can however kill a system if a GroupedObservable is filtered skipped and emits a large amount of data to it We need a mechanism such as auto unsubscribe if more than n elements are emitted and it s not consumed nuanced so probably not wanted emit an error if more than n elements are emitted and not consumed clear and forces the developer to do something about it Likely the contract needs to be that when using groupBy every GroupedObservable needs to be subscribed to even if it s with take 0 to signal that group is being purposefully ignored This would apply anywhere this use case occurs','Am I right that this means the explanation at https github com Netflix RxJava wiki Transforming Observables#groupby and groupbyuntil is now unnecessary inaccurate Note that when groupBy or groupByUntil splits up the source Observable into an Observable that emits Observables it begins to emit items from the source Observable onto these emitted Observables immediately That is to say it does not wait for any Subscribers to subscribe So if you want to ensure that you see all of the items that are emitted on these new Observables you should take care to subscribe to them right away On Thu May 29 2014 at 9 41 AM Ben Christensen notifications@github com wrote To solve the time gap issue #844 https github com Netflix RxJava issues 844 we have accepted having an unbounded buffer https github com Netflix RxJava blob master rxjava core src main java rx operators BufferUntilSubscriber java#L32 This is a preferable tradeoff to non deterministic data loss and easier to explain to people It can however kill a system if a GroupedObservable is filtered skipped and emits a large amount of data to it We need a mechanism such as auto unsubscribe if more than n elements are emitted and it s not consumed nuanced so probably not wanted emit an error if more than n elements are emitted and not consumed clear and forces the developer to do something about it Likely the contract needs to be that when using groupBy every GroupedObservable needs to be subscribed to even if it s with take 0 to signal that group is being purposefully ignored This would apply anywhere this use case occurs Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1280 David M Gross PLP Consulting Yes it s now inaccurate I think we should clearly define in the groupBy and friends Javadoc and wiki that every GroupedObservable must be subscribed to though That doesn t mean invoking subscribe literally but that filtering them out will result in memory leaks and that each GroupedObservable needs something done to it even if it s take 0 I like the take 0 idea better than dropping stuff on the floor which you can never recover New explanation from wiki Note that when groupBy or groupByUntil splits up the source Observable into an Observable that emits GroupedObservables each of these GroupedObservables begins to buffer the items that it will emit upon subscription For this reason if you ignore any of these GroupedObservables you neither subscribe to it or apply an operator to it that subscribes to it this buffer will present a potential memory leak For this reason rather than ignoring a GroupedObservable that you have no interest in observing you should instead apply an operator like take 0 to it as a way of signalling to it that it may discard its buffer and from the javadocs em Note em A @link GroupedObservable will cache the items it is to emit until such time as it is subscribed to For this reason in order to avoid memory leaks you should not simply ignore those @code GroupedObservable s that do not concern you Instead you can signal to them that they may discard their buffers by applying an operator like @link #take @code 0 to them On Thu May 29 2014 at 10 59 AM headinthebox notifications@github com wrote I like the take 0 idea better than dropping stuff on the floor which you can never recover Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1280#issuecomment 44563078 David M Gross PLP Consulting I like those javadoc changes I see it s already been added to the code thanks @DavidMGross so I m closing this out Backpressure changes do not affect this as backpressure would only be able to stop the entire source stream not an individual child',RxJava,false,false,false
34583565,'Reduce Subscription Object Allocation','### Changes rewrite of CompositeSubscription and added ChainedSubscription significant reduction in object allocations details on research available at https github com Netflix RxJava issues 1204 ##### Atomic State Machine Mutation Locks The CompositeSubscription implementation was changed from using an atomic state machine to using locks The state machine requires immutable State that is swapped using CAS This means an object allocation is needed each time It now uses locks to protect mutable state so very few objects are created ##### ChainedSubscription The CompositeSubscription requires support of randomly removing a Subscription via the remove method The Subscriber type does not expose this so can be optimized There is now a ChainedSubscription that is used by Subscriber instead This allows using a LinkedList or ArrayList rather than HashSet as random access is never needed This provides a slight performance boost and reduces memory usage 1 minute test shows 16 5GB allocation for Composite versus 14 4GC for Chained ### Allocation Comparison This shows Java Flight Recorder output from master without these changes master without changing compositesubscription https cloud githubusercontent com assets 813492 3122035 66ea4e22 e762 11e3 8915 5aead429e120 png This shows object allocation after changing CompositeSubscription master with new compositesubscription ong https cloud githubusercontent com assets 813492 3122195 9f3641bc e764 11e3 930f 845efc99b84a png ### Throughput Comparison Testing this code java public void mapTransformation UseCaseInput input throws InterruptedException input observable map i return String valueOf i map i return Integer parseInt i subscribe input observer input awaitCompletion ##### Rx 0 16 1 Run 10 2 879 355 ops sec Run 11 3 236 245 ops sec Run 12 4 468 275 ops sec Run 13 3 237 293 ops sec Run 14 4 683 840 ops sec ##### Rx 0 17 6 using OnSubscribeFunc Run 10 3 621 876 ops sec Run 11 6 702 412 ops sec Run 12 7 401 924 ops sec Run 13 6 653 359 ops sec Run 14 5 834 305 ops sec ##### Rx 0 17 6 using OnSubscribe Run 10 3 320 053 ops sec Run 11 4 520 795 ops sec Run 12 7 107 320 ops sec Run 13 5 089 058 ops sec Run 14 5 534 034 ops sec Run 10 4 930 966 ops sec Run 11 6 119 951 ops sec Run 12 7 062 146 ops sec Run 13 6 514 657 ops sec Run 14 6 369 426 ops sec ##### Rx 0 18 3 using OnSubscribe Run 10 4 178 854 ops sec Run 11 4 446 420 ops sec Run 12 5 458 515 ops sec Run 13 8 006 405 ops sec Run 14 7 849 293 ops sec Run 10 4 145 936 ops sec Run 11 6 553 079 ops sec Run 12 7 645 259 ops sec Run 13 7 385 524 ops sec Run 14 7 830 853 ops sec ##### Rx 0 19 master CompositeSubscription state machine Run 10 10 576 302 ops sec Run 11 10 518 786 ops sec Run 12 10 554 646 ops sec Run 13 10 314 063 ops sec Run 14 10 666 439 ops sec ##### Rx 0 19 master CompositeSubscription with synchronized HashSet Run 10 9 949 060 ops sec Run 11 10 122 379 ops sec Run 12 10 018 032 ops sec Run 13 10 072 522 ops sec Run 14 10 132 636 ops sec ##### Rx 0 19 master ChainedSubscription with synchronized ArrayList Run 10 11 086 351 ops sec Run 11 10 932 426 ops sec Run 12 11 002 431 ops sec Run 13 10 888 620 ops sec Run 14 11 157 227 ops sec Run 10 9 371 192 ops sec Run 11 9 829 169 ops sec Run 12 10 139 005 ops sec Run 13 10 099 785 ops sec Run 14 10 017 631 ops sec ##### Rx 0 19 master ChainedSubscription with synchronized LinkedList Run 10 10 619 431 ops sec Run 11 11 063 293 ops sec Run 12 11 001 463 ops sec Run 13 11 054 243 ops sec Run 14 10 898 826 ops sec Run 10 10 075 465 ops sec Run 11 9 780 716 ops sec Run 12 9 885 134 ops sec Run 13 9 584 143 ops sec Run 14 10 000 700 ops sec','Grrr some unit tests are failing Fixed the failing unit tests silly mistake Thanks @akarnokd for getting involved in this I agree we can further optimize this For example I think we should look at the data structure from https github com Netflix RxJava pull 1235 Anyone have a better name than ChainedSubscription before this gets released and is permanent forever SubscriptionList and SubscriptionSet perhaps I like SubscriptionSet Do you have a different take on how to solve #1204 based on the findings I ve posted there What the difference with CompositeSubscription For immediate results using plain Set and List based composites is okay We need to recheck the operators and use the appropriate one For the schedulers an MPSC based queue still creates a lot of garbage my SubscriptionQueue based on a ringbuffer avoids this issue at the expense of synchronization instead of atomics For even less allocation on the new composites we would need to implement a more light weight HashSet e g a linear probing hashset although we would lose the benefits from the Java 8 HashMap enhancements RxJava pull requests #1179 https netflixoss ci cloudbees com job RxJava pull requests 1179 SUCCESS This pull request looks good Aside from the extra dependency Disruptor seems like it would be a pretty decent model for the SubscriptionQueue It would be interesting to see if it d perform well non contending cases vs the MPSC queue Disruptor s RingBuffer is bounded so you d need to either set it to a decent size or parametrize the schedulers In addition it is prone to deadlock because the reader may put new tasks into the queue in case of a recursive schedule For even less allocation on the new composites we would need to implement a more light weight HashSet Agreed if we can come up with one that is better For the schedulers an MPSC based queue still creates a lot of garbage my SubscriptionQueue based on a ringbuffer avoids this issue at the expense of synchronization instead of atomics Yes I want to get those changes pulled in before we release For immediate results using plain Set and List based composites is okay We can evaluate the MPSC queue to replace these before releasing We need to recheck the operators and use the appropriate one Yes I only migrated the ones that directly injected a CompositeSubscription into Subscriber Talking with @headinthebox he was wondering if we should remove the remove clear methods from CompositeSubcription and leave that the default and have a more specific implementation for the few places needing remove functionality I m averse to a breaking change of that kind even though we re pre 1 0 as we re so late in the game that breaking changes are really painful What do you think Anyone else have an opinion on this The two signatures are java SubscriptionA public synchronized boolean isUnsubscribed public void add final Subscription s public void remove final Subscription s public void clear public void unsubscribe java SubscriptionB public synchronized boolean isUnsubscribed public void add final Subscription s public void unsubscribe The SubscriptionB signature is the one most people probably need when they think of CompositeSubscription RxJava pull requests #1180 https netflixoss ci cloudbees com job RxJava pull requests 1180 SUCCESS This pull request looks good RxJava pull requests #1181 https netflixoss ci cloudbees com job RxJava pull requests 1181 SUCCESS This pull request looks good I never used clear and can t see a need for it What I usually need is a remove variant that doesn t unsubscribe the subscription removed Usually this comes into play when a scheduled action is finished and needs to remove itself from the tracking composite or a multi stage scheduling happens Wouldn t the only use case SubscriptionB be for an entirely linear Observable chain does not use merge zip groupBy Wouldn t the only use case SubscriptionB be for Which is almost all the time The merge operator for example will add a SubscriptionA to the SubscriptionB This way the right data structure is used in the right places Should we deprecate remove and clear on CompositeSubscription in 0 18 x and leave something else to have the remove capability Merging then we can bike shed over naming before releasing 0 19 @akarnokd There are several things as discussed above that we can improve here let s pick them up in separate pull requests and coordinate them with https github com Netflix RxJava pull 1235',RxJava,true,false,false
34597091,'utility function for creating observables for closeable resources','#1199 the answer to the issue was nagging at me when I tried to recommend it recently I think @zsxwing s solution was ok but would fail if there were repeated subscriptions to the observable returned I created a utility function on StringObservable to make it easier to use using for objects that implement the AutoCloseable interface PS I made a breaking change to arguments of join Observable Object to join Observable String and added a Observable String toString Observable Object to make up for it PPS I made a UnsafeFunc0 R scoped to this class but I would like to have UnsafeFunc N in the rx functions packages and have Func N extends UnsafeFunc N Makes it clear to the compiler that we don t expect the code the user s are giving us to always work This also helps the users because they don t have to always fill their closures with try catch blocks new FileReader file vs try return new FileReader file catch Exception e throw new RuntimeException e','RxJava pull requests #1182 https netflixoss ci cloudbees com job RxJava pull requests 1182 SUCCESS This pull request looks good RxJava pull requests #1186 https netflixoss ci cloudbees com job RxJava pull requests 1186 SUCCESS This pull request looks good Can someone else involved in StringObservable review this please Also this needs to be rebased now as it collides with another change that was merged RxJava pull requests #1191 https netflixoss ci cloudbees com job RxJava pull requests 1191 FAILURE Looks like there s a problem with this pull request whoops bad merge RxJava pull requests #1192 https netflixoss ci cloudbees com job RxJava pull requests 1192 SUCCESS This pull request looks good @davidmoten can you take a look yep will do I see your point about the advantage when writing lambdas Could you equivalently have a utility function that wrapped the lambda to do the wrapping with a RuntimeException as in toRuntimeException new FileReader file If it works you might get your code brevity back without your changes being necessary ah I just looked up java 8 lambdas and checked exceptions and I see my suggestion has no legs Righto so I ve tested the handling of lambdas and checked exceptions in java 8 and I can see this is a handy utility It s a really interesting idea to then extend FuncN from UnsafeFuncN and I can see this would work The more extreme implementation would be to add throws Exception to the definition of FuncN Perhaps the enforced try catch in writing Operators that call FuncN will be worth the abbreviation for rxjava users What would steer us away from this My only concern then is really the name because Funcs are inherently unsafe as there is nothing in the contract for a Func that says it can t throw a RuntimeException or Error The alternative is something yuk like FuncCanThrowCheckedException How about CheckedFunc I agree that I would like to see CheckedFunc used in core where ever an RuntimeException from a Func is caught and pushed down to onError The reasoning is that if the implementation is already wrapping calls with a try catch then let the Func throw whatever it wants Do you see an impediment to changing the signature of FuncN to include throws Exception Adding to FuncN directly would be too much It forces operator implementations to always wrap exceptions even if they don t care about propagating RuntimeExceptions up the call stack there s the tradeoff I suppose between operator implentations and users using java 8 lambdas with rx operators In theory there d be more of the latter right I m thinking about Observable map in particular and the plethora of java methods that throw checked exceptions Would be nice to make lambda usage cleaner The map operator explicit does a try catch around the Func1 call so that would be a candidate for switching to CheckedFunc1 if we did map I d be tempted to do it everywhere Might have to do an inventory of where Func is used in the Operators',RxJava,true,false,false
34599497,'Reduce Subscription Object Allocation','significant reduction in object allocations details on research available at https github com Netflix RxJava issues 1204','Backporting from the 0 19 work on master for 0 18 x as this is a major performance fix that we and others need RxJava pull requests #1183 https netflixoss ci cloudbees com job RxJava pull requests 1183 FAILURE Looks like there s a problem with this pull request Those are non deterministic test failures fixed I believe on the master branch Fantastic enhancement @benjchristensen Brought my run time processing 112 million records from over an hour down to 5 minutes',RxJava,true,false,false
34601731,'Manual merge of Lock free MPSC queue based','Pulling in the MPSC queue from https github com Netflix RxJava pull 1235 Leaving out the SerializedObserver change until further analysis Getting this data structure in as we likely want to use it in other places Moved it into rx internal util and added a README so it is very clear this is an internal package and not part of the public API','RxJava pull requests #1184 https netflixoss ci cloudbees com job RxJava pull requests 1184 SUCCESS This pull request looks good RxJava pull requests #1185 https netflixoss ci cloudbees com job RxJava pull requests 1185 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
34623041,'Observable timer 1 TimeUnit SECONDS emits nothing','but Observable timer 1 TimeUnit SECONDS Schedulers immediate emits a 0 and complete conforming to javadoc rxjava version 0 18 4','Schedulers run on a daemon thread so a simple program such as this java public class TimerImmediate public static void main String args Observable timer 1 TimeUnit SECONDS subscribe System out println quits before the 1 second ellapses @akarnokd the javadoc http netflix github io RxJava javadoc rx Observable html#timer 28long 20java util concurrent TimeUnit 29 doesnot say there is a scheduler involved UTSL public final static Observable Long timer long initialDelay long period TimeUnit unit return timer initialDelay period unit Schedulers computation That said it is a good idea to document all operators that have a default scheduler cc @DavidMGross Can you review the text at https github com Netflix RxJava wiki Scheduler#default schedulers for rxjava observable operators for accuracy completeness Default Schedulers for RxJava Observable operators Some Observable operators in RxJava have alternate forms that allow you to set which Scheduler the operator will use for at least some part of its operation For these operators if you do not set the Scheduler the operator will use the default computation Scheduler Other operators do not have a form that permits you to set their Schedulers Some of these like startWith empty error from just merge and range do not use a Scheduler A few others use particular schedulers as in the following table operatorSchedulerparallelMergecurrentThreadrepeatcurrentThreadtimeInterval immediatetimestampimmediate https github com Netflix RxJava wiki Scheduler#using schedulers On Fri May 30 2014 at 6 47 AM headinthebox notifications@github com wrote UTSL public final static Observable Long timer long initialDelay long period TimeUnit unit return timer initialDelay period unit Schedulers computation That said it is a good idea to document all operators that have a default scheduler cc @DavidMGross https github com DavidMGross Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1285#issuecomment 44652084 David M Gross PLP Consulting You may look at master for the right schedulers that are used for instance java public static T Observable Observable T parallelMerge final Observable Observable T source final int parallelObservables return parallelMerge source parallelObservables Schedulers immediate where the docs say currentThread Apart from that love it I think this is a more complete list I ve also annotated the javadocs for each operator Default Schedulers for RxJava Observable operators Some Observable operators in RxJava have alternate forms that allow you to set which Scheduler the operator will use for at least some part of its operation Others do not operate on any particular Scheduler or operate on a particular default Scheduler Those that have a particular default Scheduler include operatorSchedulerbuffer timespan computationbuffer timespan count computationbuffer timespan timeshift computationdebounce timeout unit computationdelay delay unit computationdelaySubscription delay unit computationintervalcomputationparallelcomputationparallelMergeimmediate repeattrampolinereplay time unit computationreplay buffersize time unit computationreplay selector time unit computation replay selector buffersize time unit computationretrytrampoline sample period unit computationskip time unit computation skipLast time unit computationtake time unit computation takeLast time unit computationtakeLast count time unit computation takeLastBuffer time unit computationtakeLastBuffer count time unit computationthrottleFirstcomputationthrottleLastcomputation throttleWithTimeoutcomputationtimeIntervalimmediatetimeout timeoutSelector immediatetimeout firstTimeoutSelector timeoutSelector immediate timeout timeoutSelector other immediatetimeout timeout timeUnit computationtimeout firstTimeoutSelector timeoutSelector other immediate timeout timeout timeUnit other computationtimercomputationtimestamp immediatewindow timespan computationwindow timespan count computation window timespan timeshift computation https github com Netflix RxJava wiki Scheduler#using schedulers On Fri May 30 2014 at 10 30 AM headinthebox notifications@github com wrote You may look at master for the right schedulers that are used for instance public static T Observable Observable T parallelMerge final Observable Observable T source final int parallelObservables return parallelMerge source parallelObservables Schedulers immediate where the docs say currentThread Apart from that love it Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1285#issuecomment 44677248 David M Gross PLP Consulting Documentation improved',RxJava,false,false,false
34624149,'Rename some Operator classes to OnSubscribe as per #1270','See discussion in issue #1270 Numerous classes in the rx operator package are not implementations of Operator but are actually implementations of OnSubscribe The classes have been renamed in this pull request Excuse me not squashing commits looked complicated after doing a pull from upstream in the middle','RxJava pull requests #1187 https netflixoss ci cloudbees com job RxJava pull requests 1187 SUCCESS This pull request looks good',RxJava,true,false,false
34629025,'ReplaySubject remove replayState CHM and related SubjectObserver changes','For issue #1204 This change should help avoid CHM garbage although boxed Integers will still fly around In addition I moved the NotificationLite around to make room for the index I ve also removed the callback onAdd in PublishSubject because it was unnecessary','RxJava pull requests #1188 https netflixoss ci cloudbees com job RxJava pull requests 1188 SUCCESS This pull request looks good Awesome I ll try this against the tests I was doing This looks like it does improve performance and object allocation When using my Hystrix tests I get this new Run 10 208 720 ops sec Run 11 209 834 ops sec Run 12 209 217 ops sec Run 13 208 026 ops sec Run 14 211 303 ops sec old Run 10 153 523 ops sec Run 11 162 289 ops sec Run 12 162 347 ops sec Run 13 159 153 ops sec Run 14 160 194 ops sec new Run 10 572 909 ops sec Run 11 568 987 ops sec Run 12 572 521 ops sec Run 13 571 594 ops sec Run 14 572 979 ops sec old Run 10 487 791 ops sec Run 11 491 292 ops sec Run 12 480 598 ops sec Run 13 484 517 ops sec Run 14 489 212 ops sec Old old https cloud githubusercontent com assets 813492 3133353 f35b4b52 e818 11e3 9b56 1f0435bddb70 png New new https cloud githubusercontent com assets 813492 3133355 f7332434 e818 11e3 9f6a 28c0594833c5 png Now I need to go give Hystrix some love too as there are some obvious things to go solve there Thanks @akarnokd for getting to this so quickly',RxJava,true,false,false
34638412,'Ensure StringObservable from does not perform unnecessary read','An extra check is useful to check for unsubscription because as is even StringObservable from InputStream first performs two reads and the second read may block Added another check just before the InputStream read and simplified the initialization of n','RxJava pull requests #1189 https netflixoss ci cloudbees com job RxJava pull requests 1189 SUCCESS This pull request looks good',RxJava,true,false,false
34661978,'Schedulers from Executor','As per decision at https github com Netflix RxJava issues 1219#issuecomment 44454729','',RxJava,true,false,false
34662595,'Upgrade to JMH 0 7 3','As per https github com Netflix RxJava issues 1205','',RxJava,true,false,false
34663019,'Check unsubscribe within observable from future','Right now Observable from Future f emits onError CancellationException when f starts out in a cancelled state This change makes Observable from f emit nothing in this case and also when an unsubscribe occurs during a Future get that results in an Exception','RxJava pull requests #1190 https netflixoss ci cloudbees com job RxJava pull requests 1190 SUCCESS This pull request looks good',RxJava,true,false,false
34668722,'Observer reference is not released on unsubscribe','With the following code http pastebin com VUZ5aApe and using the latest version of rxjava 0 18 4 rotations should result in the activity calling unsubscribe on my subscription This should release the reference to my observer which should in turn release the reference to my activity However the memory tests I ve done show that as I rotate the phone my activity count keeps going up which means the reference to my activity is not being released let me know if the pastebin expires for some reason I ll get something back up','Can someone who has worked with Android and the AndroidScheduler take a look at this please This should release the reference to my observer which should in turn release the reference to my activity Thread sleep 10000 will block the Observable so that unsubscribe can not release the reference to the observer at once Did the number of activity decrease after a few seconds I changed it to Thread sleep 500 and even after a few minutes the activity count did not go down @fdoyle just another question How do you monitor the activity count Even if an activity has no reference it may still in memory if GC does not free its memory Can you force a GC and then check it again I m monitoring the activity count with adb shell dumpsys meminfo com lacronicus rxjavaleaktest app And after forcing a GC on the process with android debug monitor the activity count remains high 10 after as many rotations Has anyone else been able to confirm that this is an issue I m worried about using rxjava in any of my projects until this is resolved Anyone that works on Android able to comment on this Seems your long running task never finishes @fdoyle sorry that I forgot this one In your code the anonymous Subscriber will hold the Activity reference Because your long running task never finishes the Subscriber will always be used and never be released Finally neither the Subscriber or the Activity object can be recycled I feel that calling unsubscribe not clearing the reference to the Subscription until the task finishes is non obvious and could bite a lot of people working on Android Is there a reason for this design decision Is there a way to rewrite the example so that the Activity is not leaked while the task is running @fdoyle @evant AndroidObservable fromActivity should avoid leaking your Activity @evant Just don t bind your activity to the subscription which is done through the inner class in the example @dpsm Do you mean AndroidObservable bindActivity fromActivity is deprecated @dpsm From the javadoc of AndroidObservable fromActivity Currently this is equivalent to calling code observeOn AndroidSchedulers mainThread code but this behavior may change in the future so it is encouraged to use this wrapper instead So I guess not @evant @devisnik I meant AndroidObservable bindActivity This helper will schedule the given sequence to be observed on the main UI thread and ensure that no notifications will be forwarded to the activity in case it is scheduled to finish Is there any reason the reference to the Subscription is kept at all though This would be a problem for non Android uses too @dpsm 1 Yes that one voids the reference on the next notification won t help in the example here though So there is no way for an activity or inner class of an activity to safely subscribe to an observable @fdoyle I guess the issue here is that SubscriptionList and other Subscription implementations of unsubscribe do not clear the references to their child subscriptions after invoking unsubscribe on them @dpsm Yeah And I d argue that this is a larger bug not scoped to just Android because of that When unsubscribe is called on a Subscription it is done and nothing should be holding on to it any longer and thus it and everything it contains can be garbage collected So what is holding the reference to the outer Subscription or Subscriber after it is unsubscribed @benjchristensen in the example above OperatorMap while invoking Func1 call from another thread context bound to a GC root holds a strong reference to the downstream chain of subscribers which ends at the Activity which is in turn subscribed to the observable @JakeWharton the interesting thing is that CompositeSubscription has a clear method Apparently not used at all Not sure why wouldn t a subscription clear it s children when unsubscribed @fdoyle I guess you d have to do something like this until we have a better solution @Override protected void onCreate Bundle savedInstanceState super onCreate savedInstanceState setContentView R layout activity_main s Observable from 1 observeOn Schedulers io map new myMapFunction observeOn AndroidSchedulers mainThread lift new WeakSubscriptionOperator Integer subscribe new Action1 Integer @Override public void call Integer integer Toast makeText MainActivity this lol Toast LENGTH_SHORT show private static class WeakSubscriptionOperator T implements Observable Operator T T @Override public Subscriber super T call final Subscriber super T child return new WeakSubscriptionSubscriber T child private static class WeakSubscriptionSubscriber T extends Subscriber T private final WeakReference Subscriber super T mWeakReference private WeakSubscriptionSubscriber final Subscriber super T child mWeakReference new WeakReference Subscriber super T child child add this @Override public void onCompleted final Subscriber super T subscriber mWeakReference get if isUnsubscribed subscriber null subscriber onCompleted @Override public void onError Throwable throwable final Subscriber super T subscriber mWeakReference get if isUnsubscribed subscriber null subscriber onError throwable @Override public void onNext T t final Subscriber super T subscriber mWeakReference get if isUnsubscribed subscriber null subscriber onNext t You will have to hold an explicit reference to Action1 in your Activity right That way it will only get collected when the activity is yeah I was thinking that as well It s a solution but a cumbersome one at best @benjchristensen is there any reason why we would not want to clear the children subscription references after unsubscribing them Not sure why wouldn t a subscription clear it s children when unsubscribed Because the assumption is that the Subscription is no longer being held and will be freed for garbage collection Calling Subscription unsubscribe signals a terminal state for that Subscription https github com Netflix RxJava blob master rxjava core src main java rx subscriptions CompositeSubscription java#L117 Thus once it is called there is no reason for that Subscription to be held and it will be freed for garbage collection along with all of its children is there any reason why we would not want to clear the children subscription references after unsubscribing them No specific reason just that it shouldn t be needed since the Subscription Subscriber itself should also be freed for garbage collection after it is unsubscribed I still don t understand what is holding a reference to the Subscription Subscriber after it is unsubscribed @benjchristensen the problem in this example is that the map function never returns Therefore the subscriber used in the map operator won t be recycled I created a sample project that simply creates an Observable that runs forever and subscribes to it I then ran it rotated my phone once and took a heap dump Opening it MAT shows 2 instances of MyActivity and when I do a Merge Shortest Path to GC Roots with one of them I get text Class Name Ref Objects Shallow Heap Ref Shallow Heap Retained Heap java lang Thread @ 0x428861f0 RxCachedThreadScheduler 1 Thread 1 80 200 4 472 Java Local rx internal operators OperatorObserveOn ObserveOnSubscriber @ 0x42882370 1 40 200 56 observer rx observers SafeSubscriber @ 0x42881980 1 24 200 288 actual rx Observable 26 @ 0x42881118 1 24 200 152 val onNext me tatarka rxjavaleak MyActivity 2 @ 0x42880960 1 16 200 16 this 0 me tatarka rxjavaleak MyActivity @ 0x4285a420 1 200 200 1 368 sample project https github com evant RxJavaLeak main activity https github com evant RxJavaLeak blob master app src main java me tatarka rxjavaleak MyActivity java hprof https github com evant RxJavaLeak raw master rxleak hprof the subscriber used in the map operator won t be recycled It shouldn t be if map never finished If it never finishes it isn t unsubscribed Why would it ever be expected to if it is an infinite Observable I then ran it rotated my phone once and took a heap dump I m sorry but I don t do Android development so I the implication of rotation doesn t mean much to me Is the issue that the Activity itself is maintained forever and it has a reference to the Subscription https github com evant RxJavaLeak blob master app src main java me tatarka rxjavaleak MyActivity java#L31 If so just null out the reference here https github com evant RxJavaLeak blob master app src main java me tatarka rxjavaleak MyActivity java#L51 or use something like takeUntil to trigger the unsubscribe when onDestroy happens instead of storing the reference as an instance variable Rotating the device means that the Activity is destroyed and a new one is created It does not matter that the Activity has a reference to the subscription because when the Activity is destroyed the system will no longer hold a reference to it The problem is that the subscription is keeping a hold of the Activity because something up the chain is keeping a reference to it A verified nulling out the reference to the subscription no change The issue is not the reference to the subscription it s the subscription reference to the observer action If the Activity is garbage collected then the only thing in here that would hold a reference is the static infinite Observable and that s to be expected if it s infinite and doesn t obey the unsubscribe It is unicast so each time it is subscribed to it will start and run forever if you re wanting it to be multicast and support being subscribed to by many things then it needs to be published via publish Please explain the use case of observableThatNeverCompletes as the current example is definitely a leak if it is going to be subscribed to more than once as it will never complete even when unsubscribed from Obviously an observable that never completes is not useful I m using it to make the memory leak more clear Think of it as any task that takes some time to complete Yes the Observable will never be garbage collected but the Activity should be Calling unsubscribe on the subscription should remove the reference between the subscription and the observable Make the Observable so it obeys the unsubscribe I want to know what memory leak exists if everything is being garbage collected and the Observable is correctly completing When the Observable completes then yes everything gets garbage collected But this means that there is still a reference to the Activity from the time it gets destroyed to when the Observable completes This is an issue because you can be running an arbitrarily long process before you are even able to check isUnsubscribed say a network call that takes several seconds and the old Activity cannot be garbage collected until it finishes java import rx Subscriber import rx Subscription import rx schedulers Schedulers public class UnsubscribeObservable private static rx Observable Void observable rx Observable create new rx Observable OnSubscribe Void @Override public void call Subscriber super Void subscriber System out println Observable starting while subscriber isUnsubscribed try Thread sleep 5 catch InterruptedException e e printStackTrace System out println unsubscribed so exiting public static void main String args try Subscription s1 observable observeOn Schedulers computation subscribeOn Schedulers newThread subscribe Subscription s2 observable observeOn Schedulers computation subscribeOn Schedulers newThread subscribe Thread sleep 1000 s1 unsubscribe Thread sleep 1000 s2 unsubscribe Thread sleep 1000 catch Exception e e printStackTrace This emits Observable starting Observable starting unsubscribed so exiting unsubscribed so exiting If the observableThatNeverCompletes never completes then it will just keep being subscribed to and you ll accumulate Subscribers Observables and Threads there is still a reference to the Activity from the time it gets destroyed to when the Observable completes That is correct This is an issue Yes this is the issue If this is by design I m curious as to why and I feel it should be more clearly explained in the documentation It s not consciously done one way or another it s just never been considered an issue as a Subscriber Observable pair is connected and are all discarded after a terminal event whether that be onError onCompleted or unsubscribe I feel it should be more clearly explained in the documentation I m not sure what there is to explain It is all correctly garbage collected after the terminal event That said it s easy enough to optimize this so it more quickly releases in your use case we can just null out the subscription reference after this line https github com Netflix RxJava blob master rxjava core src main java rx internal util SubscriptionList java#L88 Go ahead and submit a PR and I ll merge it I m glad we finally came to an understanding This is a particular issue on Android because we are dealing with limited memory and an Activity can potentially tie up a lot of resources Keeping it around any longer than necessary can quickly become a problem Sure sorry it took me so long to understand I thought we were talking about an actual memory leak rather than just a delay between unsubscribe being invoked and a possibly slow termination of the Observable then releasing things Also remember I work on server apps where we have 20GB heaps haha no worries Being in different domains makes us focus on different things We have to get along with only 20 30MB Yeah sorry about that Perhaps there should be another word for it since memory leaks do generally always refer to permanently lost memory On Android though even temporarily lost memory is a big deal Hey sorry for chiming in late Only was made aware of this ticket today Binding observables to Android Activities has been a long standing pain that we haven t completely solved yet but there s ways to mitigate it from your end as well In general try to get any help from the framework you can get when it comes to dealing with Activity life cycle One obvious thing to do here is to simply not bind observables to Activities directly especially when they re expected to be long running or even never ending In the presentation layer you can use retained fragments instead since they have their context reference managed by the framework for you Since a retained fragment survives rotation changes by definition your problem ceases to exist Here s a common pattern that we use throughout our presentation layer class SomeFragment extends Fragment @Inject ClassThatProvidesObservable observableProvider private Observable observable private Subscription sub Subscriptions empty void onCreate depending on where it takes its arguments from might as well do in the constructor or have it injected observable observableProvider provideObservable replay void onViewCreated subscription observable subscribe viewSubscriber void onDestroyView subscription unsubscribe When going through a rotation change Android will destroy the fragment s views but not the instance itself That gives you an opportunity to detach yourself from the observable and re subscribe when all views are back under the new context Using replay or cache ensures that work in flight will either get picked up or if it had completed during detachment be re emitted directly Firing an endless observable from the UI sounds like a genuinely bad idea to me anyhow If you re thinking about providing some sort of producer observable you should probably put it on a background Service and place results on an event bus we ve written an event bus based purely on RxJava Subject s There s a GH project as well which aims to bind observables to Activities through Android s LoaderManager based on the same idea I suppose i e letting the framework do the heavy lifting I haven t personally used it though so can t comment further Another related problem is that with a recent release of RxJava I d have to check when exactly it happened OperatorObserveOn now schedules the call to unsubscribe on the respective scheduler This poses a problem when using the approach above since where previously you would detach from the observable and have your views destroyed in a serial fashion there is now a race condition where observeOn posts the call to unsubscribe to the main looper meaning unsubscribe is called after Android destroys all views and rogue notifications may arrive in your view subscriber that will crash the app I believe there is a fix coming but I haven t had a chance to test it yet @mttkay the fix for the issue above is already merged See #1409 @mttkay Yep those are very good suggestions on how to work with rxjava on Android I m aware of the issues surrounding binding observables to activities If you are talking about rxloader https github com evant rxloader I actually wrote that It uses a fragment with retaininstancestate as well as some weak reference trickery to get around the issue described here As rxjava is becoming popular on Android I m seeing lots of people use it in ways that risk leaking memory so any thing we can do directly in the library helps On Jul 12 2014 10 19 AM David Sobreira Marques notifications@github com wrote @mttkay https github com mttkay the fix for the issue above is already merged See #1409 https github com Netflix RxJava pull 1409 Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1292#issuecomment 48813549 another word for it A term that may work for this is memory pressure we use it for example when allocating too many objects that causes excessive GCs and performance impact In a low memory environment such as Android memory pressure can be caused by too much object allocation or holding objects longer than they need to including things like allowing something to be promoted through generations rather than collected in younggen @evant and @fdoyle For the long running Observable that may run longer than the Activity are those doing IO If so doesn t interrupting them work For example java import rx Subscriber import rx Subscription import rx schedulers Schedulers public class UnsubscribeObservable private static rx Observable Void observable rx Observable create new rx Observable OnSubscribe Void @Override public void call Subscriber super Void subscriber System out println Observable starting Thread currentThread while subscriber isUnsubscribed try Thread sleep 50000 catch InterruptedException e System err println Interrupted so exiting return System out println unsubscribed so exiting public static void main String args for try Subscription s1 observable observeOn Schedulers computation subscribeOn Schedulers io subscribe Subscription s2 observable observeOn Schedulers computation subscribeOn Schedulers io subscribe Thread sleep 1000 s1 unsubscribe Thread sleep 1000 s2 unsubscribe Thread sleep 1000 catch Exception e e printStackTrace This outputs the following and does not wait for 50 seconds before unsubscribing Observable starting Thread RxCachedThreadScheduler 2 5 main Observable starting Thread RxCachedThreadScheduler 1 5 main Interrupted so exiting Interrupted so exiting Observable starting Thread RxCachedThreadScheduler 1 5 main Observable starting Thread RxCachedThreadScheduler 2 5 main Interrupted so exiting Interrupted so exiting Observable starting Thread RxCachedThreadScheduler 1 5 main Observable starting Thread RxCachedThreadScheduler 2 5 main Interrupted so exiting Interrupted so exiting Observable starting Thread RxCachedThreadScheduler 2 5 main Observable starting Thread RxCachedThreadScheduler 1 5 main Interrupted so exiting Interrupted so exiting Observable starting Thread RxCachedThreadScheduler 1 5 main Observable starting Thread RxCachedThreadScheduler 2 5 main Interrupted so exiting Interrupted so exiting IO should behave similarly as long as the IO library isn t catching and ignoring interrupts Yes that works correctly which is good because it will catch many cases where this is an issue I still want to try nulling out the subscription though to better handle cases where either the operation is uninterruptible or not implemented correctly I m not seeing any downsides to doing it On Jul 12 2014 12 20 PM Ben Christensen notifications@github com wrote @evant https github com evant and @fdoyle https github com fdoyle For the long running Observable that may run longer than the Activity are those doing IO If so doesn t interrupting them work For example import rx Subscriber import rx Subscription import rx schedulers Schedulers public class UnsubscribeObservable private static rx Observable Void observable rx Observable create new rx Observable OnSubscribe Void @Override public void call Subscriber super Void subscriber System out println Observable starting Thread currentThread while subscriber isUnsubscribed try Thread sleep 50000 catch InterruptedException e System err println Interrupted so exiting return System out println unsubscribed so exiting public static void main String args for try Subscription s1 observable observeOn Schedulers computation subscribeOn Schedulers io subscribe Subscription s2 observable observeOn Schedulers computation subscribeOn Schedulers io subscribe Thread sleep 1000 s1 unsubscribe Thread sleep 1000 s2 unsubscribe Thread sleep 1000 catch Exception e e printStackTrace This outputs the following and does not wait for 50 seconds before unsubscribing Observable starting Thread RxCachedThreadScheduler 2 5 main Observable starting Thread RxCachedThreadScheduler 1 5 main Interrupted so exiting Interrupted so exiting Observable starting Thread RxCachedThreadScheduler 1 5 main Observable starting Thread RxCachedThreadScheduler 2 5 main Interrupted so exiting Interrupted so exiting Observable starting Thread RxCachedThreadScheduler 1 5 main Observable starting Thread RxCachedThreadScheduler 2 5 main Interrupted so exiting Interrupted so exiting Observable starting Thread RxCachedThreadScheduler 2 5 main Observable starting Thread RxCachedThreadScheduler 1 5 main Interrupted so exiting Interrupted so exiting Observable starting Thread RxCachedThreadScheduler 1 5 main Observable starting Thread RxCachedThreadScheduler 2 5 main Interrupted so exiting Interrupted so exiting IO should behave similarly as long as the IO library isn t catching and ignoring interrupts Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1292#issuecomment 48816648 I m not seeing any downsides to doing it Nor do I Let s make the change against both the 0 19 x branch and master Do you want to do the pull requests I still want to try nulling out the subscription though to better handle cases where either the operation is uninterruptible or not implemented correctly IMHO looks there is no way to solve it Any instance of anonymous inner class created in an activity instance will keep an reference to the activity implicitly E g the map function in this example It does not finish so the map function must be referred in some place and then the activity reference in the map function cannot be released I cannot find any way to release this reference in the map function Actually I think this is not a RxJava issue The problem is due to the anonymous inner class in Java I can write the following code that leaks the activity without RxJava java public class SomeActivity extends Activity @Override protected void onCreate Bundle savedInstanceState super onCreate savedInstanceState new Thread new Runnable this instance will keep the reference to the outer activity @Override public void run while true Some long running task start In summary if some operation may run too long we should avoid to use any anonymous class that may keep an reference to the activity implicitly such as @mttkay s suggestion I still firmly believe clearing the observer action reference upon unsubscribe is a win despite that fact Sorry I ve been away from my computer so I haven t had the chance to send a pull request yet I just tried building rxjava locally and I m getting Artifact com jcraft jsch 0 1 44 1@jar not found Since it s a simple enough change I don t mind if someone else does it That artifact issue sounds like your m2 maven caches are corrupted I still firmly believe clearing the observer action reference upon unsubscribe is a win despite that fact I doubt that if clearing the subscriber reference can help much I suppose anonymous inner functions are very common when using RxJava Is it true in your case No idea if this change will help as per the ongoing discussion but I ve merged in the change and will release in 0 19 7 https github com Netflix RxJava pull 1440 @benjchristensen I m afraid that #1440 changes nothing It does not clear the subscriber reference Here is my commit to fix it https github com zsxwing RxJava commit 647ab76c0b7bb0ce46b7ec658b4cc753d08df06c However I don t like it because actual becomes volatile and will impact the performance since actual onNext is called very frequently IMO any anonymous inner function storing the activity reference will make the effect of clearing the subscriber reference useless I still doubt if it s worth to do it Please note that I have updated the link to the commit @zsxwing with your changes the observable sequence does not reference anything after unsubscribe so I am not sure I follow any anonymous inner function storing the activity reference will make the effort to clear the subscriber reference useless @dpsm this is an example to show it java public class MainActivity extends Activity Subscription s this represents a long running background action shouldn t have a reference to the activity private static class myMapFunction implements Func1 Integer Integer @Override public Integer call Integer integer int x 1 while x 1 try Thread sleep 10000 catch InterruptedException e e printStackTrace return 1 @Override protected void onCreate Bundle savedInstanceState super onCreate savedInstanceState setContentView R layout activity_main s Observable from 1 observeOn Schedulers io map new Func1 Integer Integer @Override public Integer call Integer integer this Func1 will store a reference to the activity Because this method does not finish the activity reference will not be cleared int x 1 while x 1 try Thread sleep 10000 catch InterruptedException e e printStackTrace return 1 observeOn AndroidSchedulers mainThread subscribe new Action1 Integer @Override public void call Integer integer Toast makeText MainActivity this lol Toast LENGTH_SHORT show @Override protected void onStop super onStop if s null s unsubscribe @zsxwing in the example above with your changes the map operator having unreferenced the downstream subscriber will no longer bind the last subscriber and the action in the activity to a GC root the thread that runs the map function and points to the operator I mean there is a reference to the outer activity in the anonymous Func1 implicitly because the Func1 is created in the activity And Func1 will not finish so GC cannot recycle the Func1 and the activity java new Func1 Integer Integer @Override public Integer call Integer integer this Func1 will store a reference to the activity Because this method does not finish the activity reference will not be cleared int x 1 while x 1 try Thread sleep 10000 catch InterruptedException e e printStackTrace return 1 @zsxwing I was referring to the original example where the functions is a static inner class In your example there is really nothing we can do in order to fix that container object reference @dpsm I prefer to keep consistent Otherwise people may be confused about why anonymous subscribers created in the activity can work but anonymous functions created in the activity will leak the activity But the difference is long running operation as an anonymous class vs a short running one I think that is a clear enough distinction Also it s clear that your anonymous class is keeping a reference to what it is inside but less clear that it s also keeping a reference to the Observable IMHO both @benjchristensen @zsxwing changes are valid and address the original issue with the static inner class scenario The case where the Action is a non static anonymous inner class and there is a long running operation such as in the example is nothing we can do within the library @evant I think people won t write a long running function in the real code It s usually a long running Observable That s the root of this problem If we apply any anonymous function action or subscriber created in the activity on the long running Observable it will leak the activity E g java public class MainActivity extends Activity Subscription s @Override protected void onCreate Bundle savedInstanceState super onCreate savedInstanceState setContentView R layout activity_main s new LongRunningObservable observeOn Schedulers io map new Func1 Integer Integer @Override public Integer call Integer integer this Func1 will store a reference to the activity If LongRunningObservable does not finish the activity reference will not be cleared return integer 1 observeOn AndroidSchedulers mainThread subscribe new Action1 Integer @Override public void call Integer integer Toast makeText MainActivity this lol Toast LENGTH_SHORT show @Override protected void onStop super onStop if s null s unsubscribe IMO I feel both subscriber and function are same They are just some operations applied on the long running Observable I had the impression that the above changes would fix this case as well Are you saying they don t Can that not be fixed as easily not at all If so then I agree that the differences there could be confusing For the examples in https github com Netflix RxJava issues 1292#issuecomment 49035941 there is nothing we can do within the library For the example in https github com Netflix RxJava issues 1292#issuecomment 49043380 I m not sure if it can be fixed But it s definitely not an easy one Well then I do agree A half solution to this is probably not a good idea I wouldn t mind spending the time looking at what would need to be done to fix that second case Any conclusions here',RxJava,false,false,false
34671524,'Fix and Update JMH Perf Tests','The tests were wrong and re using a single Subscriber instance which meant they weren t really testing much Same with the CountDownLatch which meant they weren t waiting if async Added several SerializePerf and PerfTransform tests','',RxJava,true,false,false
34672280,'rx operators rx internal operators','Move rx operators to rx internal operators for clarity that these can change at any time and are not part of the public API Discussed at https github com Netflix RxJava issues 1270#issuecomment 44668606','Would it make sense to create a similar rx internal schedulers package and move out some of the re used code from Scheduler inner classes Like NewThreadScheduler RxThreadFactory or NewThreadScheduler NewThreadWorker @akarnokd do you have an opinion on this I m assuming that the meaning of internal for rxjava users will be that may suffer breaking changes in any version not recommended for direct use I m not using them directly myself but it strikes me that one of the advantages of the Operator interface will be lost to users and that is composability Do we want to take this away from users I m assuming that the meaning of internal for rxjava users will be that Those 2 bullet points are correct The Operator itself though is not internal it s rx Observable Operator so is completely available to them What type of composability are you concerned with I can t think of any reason why users would need to use the Operator classes directly Would it make sense to create a similar rx internal schedulers package and move out some of the re used code from Scheduler inner classes I m open to that Seems to make sense Internal scheduler package is okay with me We may move The SubjectSubscriptionManager as well and make static inner classes normal classes In addition I would consider moving Schedulers static methods directly into Scheduler Subscribers static methods into Subscriber perhaps even Subject newAsync company This should match the way Java 8 added Stream of instead of Streams or StreamUtils Unfortunately without static interface methods Observer and Subscription can t be unified this way Ok I ll make a pull request request that creates the rx internal schedulers package and move what I feel is appropriate there Thinking of moving RxThreadFactory to rx internal util though since it s not really Scheduler specific My issue is that if I want to create my own Operator that is the composition of other operators then in the implementation of the Operator interface I can write for instance java public class MyOperator T implements Operator T @Override public Subscriber super T call final Subscriber super T subscriber return operator1 call operator2 call operator3 call subscriber If the Operator classes are marked as internal then this implies that I should not instantiate my operator1 operator2 operator3 classes from the internal package The ability to be able to easily construct Operators from others is also discussed in #983',RxJava,true,false,false
34681290,'Change void accept to boolean accept','As per a change @akarnokd did elsewhere with accept2 method','RxJava pull requests #1193 https netflixoss ci cloudbees com job RxJava pull requests 1193 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
34689228,'Move re used internal Scheduler classes to their own package','As discussed in #1294','RxJava pull requests #1194 https netflixoss ci cloudbees com job RxJava pull requests 1194 SUCCESS This pull request looks good Thanks',RxJava,true,false,false
34694385,'RxScala rxjava scalaz providing some type class instances','Introduced rxjava scalaz project This project provides some type class instances for Observable _Monoid_ br Observable obviously forms a monoid in terms of concatenation _Functor Applicative Monad MonadPlus_ br Observable can be a Stream like Monad and can be MonadPlus as well as Monoid _Traverse Foldable_ br Observable can be Stream like traversable Please note that the operations for the instance is blocking calls etc About testing property based tests are applied by Scalaz s ScalaCheck binding For getting started please refer to rx java scala scalaz examples RxScalazDemo or README md ### Sample Usages scala import scalaz _ Scalaz _ import rx lang scala Observable import rx lang scala scalaz _ Observable items 1 2 Observable items 3 4 Observable items 1 2 3 4 Observable items 1 2 _ 1 Observable items 2 3 Observable items 1 2 @ Observable items 3 4 _ _ Observable items 4 5 5 6 1 Observable Observable items 1 Observable items 3 i Int Observable items i 1 Observable items 4 _My original proposal is #1167_','RxJava pull requests #1195 https netflixoss ci cloudbees com job RxJava pull requests 1195 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1196 https netflixoss ci cloudbees com job RxJava pull requests 1196 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1197 https netflixoss ci cloudbees com job RxJava pull requests 1197 SUCCESS This pull request looks good RxJava pull requests #1202 https netflixoss ci cloudbees com job RxJava pull requests 1202 SUCCESS This pull request looks good Looks good to me just holding off on merge release for a few days for build server reasons Once we split RxScala into its own top level project this looks like it would make sense to be a contrib module of it Am I correct in that Looks good to me just holding off on merge release for a few days for build server reasons Thanks OK I m looking forward to it Once we split RxScala into its own top level project this looks like it would make sense to be a contrib module of it Am I correct in that Definitely By the way the plan splitting RxScala was new to me I m glad to hear about when it would be occured I hope to have it done in the next month or two Once 0 20 goes out with #1000 done then we are ready to move to 1 0 Release Candidates and split the project up Good news Thanks Yes I think backpressure is really nice capability which provides more flexible flow controllability to users So this is merged into trunk but I had issues with the Netflix build system that releases to Maven Central It had issues with this Artifact org scalaz scalaz core_2 10 7 0 4@jar not found I couldn t figure it out so let 0 19 2 go without this module and am waiting on someone who knows this stuff better than I helping me Sorry for inconvenience Please go ahead without this module But I m not sure why this error happens either It s something with the Netflix build server because it works fine from CloudBees and my local dev machine It s something with the Netflix build server because it works fine from CloudBees and my local dev machine @benjchristensen Did you or any other guys get any progress on this issue I would be very happy if you would revert the commit fe83a31943713db5ad5c011155a34b79850abc14 by the next release If there is something I could help please free to tell me Thanks It is now released in 0 19 6 @benjchristensen I really appreciate it',RxJava,true,false,false
34695804,'Remove Bad Perf Test','this just stresses scheduling and at this throughput creates massive garbage and tests the wrong thing','',RxJava,true,false,false
34696180,'Explore Blocking vs Non Blocking Solutions','This is to document and explore blocking vs non blocking solutions for a couple use cases particularly the SerializedObserver and CompositeSubscription which are hot code paths in most use of Rx Thus far the synchronized blocking implementations have won and are currently being used Despite using synchronized the locks are not held while emitting notifications only for mutating internal data structures A key consideration is that object allocations must be kept low The atomic state machine pattern has been attempted on both of these and is elegant but was a massive performance problem with CompositeSubscription due to some valid edge use cases with merge that result in hundreds of subscriptions being added to the data structure via CompositeSubscription add and each time performing a state transition with object allocation Following are details on the use cases the current implementation alternates that have been attempted and performance results from JMH tests The intent of this is to document what has been attempted thus far and seek improvements from anyone who can provide better solutions ### SerializedObserver Use Case Serialize onNext onError onCompleted calls from multiple threads to be sequential but without synchronizing and blocking threads Current https github com Netflix RxJava blob master rxjava core src main java rx observers SerializedObserver java Discussions https github com Netflix RxJava pull 962 Migrate from SynchronizedObserver to SerializedObserver https github com Netflix RxJava pull 999 New Implementation of SerializedObserver https github com Netflix RxJava pull 1235 Lock free MPSC queue based fast path serializing Observer Alternate implementations queue and counter https github com benjchristensen RxJava blob serialize implementations rxjava core src main java rx observers SerializedObserverViaQueueAndCounter java queue and lock https github com benjchristensen RxJava blob serialize implementations rxjava core src main java rx observers SerializedObserverViaQueueAndLock java state machine https github com benjchristensen RxJava blob serialize implementations rxjava core src main java rx observers SerializedObserverViaStateMachine java mpsc queue https github com akarnokd RxJava blob 5d7d73c313561b1c7907149e424c75f9b735c9c7 rxjava core src main java rx observers SerializedObserver java #### Performance tests gradlew benchmarks Pjmh f 1 tu s bm thrpt wi 5 i 5 r 2 prof GC OperatorSerializePerf ###### Current Code locks Benchmark size Mode Samples Mean Mean error Units r o OperatorSerializePerf noSerializationSingleThreaded 1 thrpt 5 9147601 034 161223 124 ops s r o OperatorSerializePerf noSerializationSingleThreaded 1000 thrpt 5 63030 725 932 700 ops s r o OperatorSerializePerf serializedSingleStream 1 thrpt 5 6789538 763 309465 333 ops s r o OperatorSerializePerf serializedSingleStream 1000 thrpt 5 41906 794 612 458 ops s r o OperatorSerializePerf serializedTwoStreamsHighlyContended 1 thrpt 5 117164 007 1082 505 ops s r o OperatorSerializePerf serializedTwoStreamsHighlyContended 1000 thrpt 5 5720 975 79 089 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1 thrpt 5 79689 194 10539 604 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1000 thrpt 5 9885 341 162 358 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1 thrpt 5 66193 041 2044 815 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1000 thrpt 5 1 000 0 001 ops s Benchmark size Mode Samples Mean Mean error Units r o OperatorSerializePerf noSerializationSingleThreaded 1 thrpt 5 8956346 449 247041 560 ops s r o OperatorSerializePerf noSerializationSingleThreaded 1000 thrpt 5 60983 831 2705 618 ops s r o OperatorSerializePerf serializedSingleStream 1 thrpt 5 6483372 239 478251 023 ops s r o OperatorSerializePerf serializedSingleStream 1000 thrpt 5 40401 985 1894 673 ops s r o OperatorSerializePerf serializedTwoStreamsHighlyContended 1 thrpt 5 113009 060 8700 709 ops s r o OperatorSerializePerf serializedTwoStreamsHighlyContended 1000 thrpt 5 5657 256 113 035 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1 thrpt 5 80699 653 1103 641 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1000 thrpt 5 9784 149 129 939 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1 thrpt 5 62955 830 5319 780 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1000 thrpt 5 1 001 0 001 ops s Benchmark size Mode Samples Mean Mean error Units r o OperatorSerializePerf noSerializationSingleThreaded 1 thrpt 5 8972393 281 92105 068 ops s r o OperatorSerializePerf noSerializationSingleThreaded 1000 thrpt 5 61767 456 4635 081 ops s r o OperatorSerializePerf serializedSingleStream 1 thrpt 5 6762871 582 105388 190 ops s r o OperatorSerializePerf serializedSingleStream 1000 thrpt 5 41700 990 573 994 ops s r o OperatorSerializePerf serializedTwoStreamsHighlyContended 1 thrpt 5 119134 905 1695 909 ops s r o OperatorSerializePerf serializedTwoStreamsHighlyContended 1000 thrpt 5 5578 557 118 692 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1 thrpt 5 79847 519 1111 056 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1000 thrpt 5 9633 304 67 996 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1 thrpt 5 65096 602 8175 233 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1000 thrpt 5 1 001 0 001 ops s ###### MPSC Queue https github com akarnokd RxJava blob 5d7d73c313561b1c7907149e424c75f9b735c9c7 rxjava core src main java rx observers SerializedObserver java Benchmark size Mode Samples Mean Mean error Units r o OperatorSerializePerf noSerializationSingleThreaded 1 thrpt 5 8565745 644 136623 557 ops s r o OperatorSerializePerf noSerializationSingleThreaded 1000 thrpt 5 62273 804 932 786 ops s r o OperatorSerializePerf serializedSingleStream 1 thrpt 5 5532175 536 268394 630 ops s r o OperatorSerializePerf serializedSingleStream 1000 thrpt 5 32014 042 389 324 ops s r o OperatorSerializePerf serializedTwoStreamsHighlyContended 1 thrpt 5 116615 249 1125 473 ops s r o OperatorSerializePerf serializedTwoStreamsHighlyContended 1000 thrpt 5 5214 520 76 467 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1 thrpt 5 81013 059 503 497 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1000 thrpt 5 11146 029 190 870 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1 thrpt 5 65785 641 3118 842 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1000 thrpt 5 1 001 0 000 ops s It completely hung once at this point # Benchmark rx operators OperatorSerializePerf serializedTwoStreamsHighlyContended # Parameters size 1000 # Warmup Iteration 1 3894 833 ops s # Warmup Iteration 2 4742 937 ops s # Warmup Iteration 3 5213 280 ops s # Warmup Iteration 4 5204 942 ops s # Warmup Iteration 5 Building rxjava core benchmarks Benchmark size Mode Samples Mean Mean error Units r o OperatorSerializePerf noSerializationSingleThreaded 1 thrpt 5 9035236 321 49071 888 ops s r o OperatorSerializePerf noSerializationSingleThreaded 1000 thrpt 5 62164 804 1621 105 ops s r o OperatorSerializePerf serializedSingleStream 1 thrpt 5 5510291 830 130335 497 ops s r o OperatorSerializePerf serializedSingleStream 1000 thrpt 5 31604 221 412 042 ops s r o OperatorSerializePerf serializedTwoStreamsHighlyContended 1 thrpt 5 119747 703 6565 816 ops s r o OperatorSerializePerf serializedTwoStreamsHighlyContended 1000 thrpt 5 5284 436 141 163 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1 thrpt 5 78662 632 6427 553 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1000 thrpt 5 10301 191 76 694 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1 thrpt 5 65663 355 650 831 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1000 thrpt 5 1 000 0 001 ops s ###### queue and counter https raw githubusercontent com benjchristensen RxJava serialize implementations rxjava core src main java rx observers SerializedObserverViaQueueAndCounter java Benchmark size Mode Samples Mean Mean error Units r o OperatorSerializePerf noSerializationSingleThreaded 1 thrpt 5 9014619 003 266968 607 ops s r o OperatorSerializePerf noSerializationSingleThreaded 1000 thrpt 5 62025 534 1849 124 ops s r o OperatorSerializePerf serializedSingleStream 1 thrpt 5 5181915 426 74251 781 ops s r o OperatorSerializePerf serializedSingleStream 1000 thrpt 5 26907 478 838 085 ops s r o OperatorSerializePerf serializedTwoStreamsHighlyContended 1 thrpt 5 115841 328 7085 982 ops s r o OperatorSerializePerf serializedTwoStreamsHighlyContended 1000 thrpt 5 3519 087 44 103 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1 thrpt 5 78310 523 2349 554 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1000 thrpt 5 15448 549 208 165 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1 thrpt 5 65511 070 2865 242 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1000 thrpt 5 1 001 0 002 ops s Benchmark size Mode Samples Mean Mean error Units r o OperatorSerializePerf noSerializationSingleThreaded 1 thrpt 5 9038960 672 225036 084 ops s r o OperatorSerializePerf noSerializationSingleThreaded 1000 thrpt 5 61285 414 1517 393 ops s r o OperatorSerializePerf serializedSingleStream 1 thrpt 5 5282333 173 33819 691 ops s r o OperatorSerializePerf serializedSingleStream 1000 thrpt 5 26874 371 676 982 ops s r o OperatorSerializePerf serializedTwoStreamsHighlyContended 1 thrpt 5 116821 651 355 230 ops s r o OperatorSerializePerf serializedTwoStreamsHighlyContended 1000 thrpt 5 3014 738 32 780 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1 thrpt 5 77487 923 7870 801 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1000 thrpt 5 15935 005 183 188 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1 thrpt 5 65613 851 1626 122 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1000 thrpt 5 1 001 0 001 ops s ##### state machine https github com benjchristensen RxJava blob serialize implementations rxjava core src main java rx observers SerializedObserverViaStateMachine java Benchmark size Mode Samples Mean Mean error Units r o OperatorSerializePerf noSerializationSingleThreaded 1 thrpt 5 9024112 277 252796 553 ops s r o OperatorSerializePerf noSerializationSingleThreaded 1000 thrpt 5 62634 243 692 609 ops s r o OperatorSerializePerf serializedSingleStream 1 thrpt 5 5072529 757 559158 810 ops s r o OperatorSerializePerf serializedSingleStream 1000 thrpt 5 28205 652 1331 276 ops s r o OperatorSerializePerf serializedTwoStreamsHighlyContended 1 thrpt 5 117760 487 1335 254 ops s r o OperatorSerializePerf serializedTwoStreamsHighlyContended 1000 thrpt 5 2940 177 142 803 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1 thrpt 5 77375 785 1846 881 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1000 thrpt 5 14915 986 52 520 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1 thrpt 5 65454 647 1180 502 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1000 thrpt 5 1 001 0 001 ops s Benchmark size Mode Samples Mean Mean error Units r o OperatorSerializePerf noSerializationSingleThreaded 1 thrpt 5 9181625 881 168356 673 ops s r o OperatorSerializePerf noSerializationSingleThreaded 1000 thrpt 5 61764 749 2122 126 ops s r o OperatorSerializePerf serializedSingleStream 1 thrpt 5 5198346 930 26264 589 ops s r o OperatorSerializePerf serializedSingleStream 1000 thrpt 5 27750 351 387 544 ops s r o OperatorSerializePerf serializedTwoStreamsHighlyContended 1 thrpt 5 116131 546 385 778 ops s r o OperatorSerializePerf serializedTwoStreamsHighlyContended 1000 thrpt 5 2889 275 19 016 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1 thrpt 5 80562 609 483 455 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1000 thrpt 5 14967 866 38 010 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1 thrpt 5 65010 172 4866 039 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1000 thrpt 5 1 000 0 001 ops s ### CompositeSubscription SubscriptionList Use Case A Subscription implementation that allows the following add Subscription to maintain a list allows anybody to register a Subscription to be invoked when the parent is unsubscribed isUnsubscribed often checked on every onNext in a tight loop unsubscribe can be invoked once and will mark isUnsubscribed to true and call unsubscribe on all subscriptions added via add remove Subscription some use cases need the ability to randomly remove a Subscription for example merge and flatMap which uses merge This means that the list of subscriptions is multiple writes a single read at unsubscribe at the end The boolean isUnsubscribed is ready many times modified once Current CompositeSubscription https github com Netflix RxJava blob master rxjava core src main java rx subscriptions CompositeSubscription java Current ChainedSubscription https github com Netflix RxJava blob master rxjava core src main java rx subscriptions ChainedSubscription java will be renamed Discussions https github com Netflix RxJava issues 1204 Profiling Memory Usage and Object Creation https github com Netflix RxJava pull 1281 Reduce Subscription Object Allocation Alternate implementations old state machine implementation https github com Netflix RxJava blob 96b06f9b509ada79f687769e078ff6338e172655 rxjava core src main java rx subscriptions CompositeSubscription java this implementation has massive object allocation overhead in use cases with high numbers of add Subscription such as Observable merge hundreds of observables MPSC Queue AtomicInteger https github com benjchristensen RxJava blob subscription list mpsc rxjava core src main java rx subscriptions ChainedSubscription java #### Performance tests gradlew benchmarks Pjmh f 1 tu s bm thrpt wi 5 i 5 r 2 prof GC PerfTransforms ###### Current Code locks Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapNestedMapFilterTake 1 thrpt 5 2377403 232 282360 735 ops s r u PerfTransforms flatMapNestedMapFilterTake 1024 thrpt 5 18 114 1 069 ops s r u PerfTransforms flatMapTransforms 1 thrpt 5 3454607 756 66000 511 ops s r u PerfTransforms flatMapTransforms 1024 thrpt 5 6886 044 296 528 ops s r u PerfTransforms mapTransformation 1 thrpt 5 9550369 422 531491 534 ops s r u PerfTransforms mapTransformation 1024 thrpt 5 22381 038 1982 025 ops s Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapNestedMapFilterTake 1 thrpt 5 2477980 676 38870 454 ops s r u PerfTransforms flatMapNestedMapFilterTake 1024 thrpt 5 18 144 0 399 ops s r u PerfTransforms flatMapTransforms 1 thrpt 5 3409322 430 279971 071 ops s r u PerfTransforms flatMapTransforms 1024 thrpt 5 7202 920 62 409 ops s r u PerfTransforms mapTransformation 1 thrpt 5 9812382 788 127551 622 ops s r u PerfTransforms mapTransformation 1024 thrpt 5 20796 145 423 822 ops s ###### State Machine https github com Netflix RxJava blob 96b06f9b509ada79f687769e078ff6338e172655 rxjava core src main java rx subscriptions CompositeSubscription java Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapNestedMapFilterTake 1 thrpt 5 2650383 791 59582 156 ops s r u PerfTransforms flatMapNestedMapFilterTake 1024 thrpt 5 18 488 1 374 ops s r u PerfTransforms flatMapTransforms 1 thrpt 5 3982900 628 180306 660 ops s r u PerfTransforms flatMapTransforms 1024 thrpt 5 9971 926 1109 674 ops s r u PerfTransforms mapTransformation 1 thrpt 5 8822681 747 1122775 549 ops s r u PerfTransforms mapTransformation 1024 thrpt 5 20515 869 1050 781 ops s Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapNestedMapFilterTake 1 thrpt 5 2653860 015 63234 344 ops s r u PerfTransforms flatMapNestedMapFilterTake 1024 thrpt 5 18 757 0 086 ops s r u PerfTransforms flatMapTransforms 1 thrpt 5 4202696 749 83003 981 ops s r u PerfTransforms flatMapTransforms 1024 thrpt 5 10614 418 653 295 ops s r u PerfTransforms mapTransformation 1 thrpt 5 9085576 828 129279 777 ops s r u PerfTransforms mapTransformation 1024 thrpt 5 21140 253 255 681 ops s ###### MPSC Queue AtomicInteger https github com benjchristensen RxJava blob subscription list mpsc rxjava core src main java rx subscriptions ChainedSubscription java Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapNestedMapFilterTake 1 thrpt 5 2019274 611 145557 313 ops s r u PerfTransforms flatMapNestedMapFilterTake 1024 thrpt 5 18 804 0 321 ops s r u PerfTransforms flatMapTransforms 1 thrpt 5 2940738 978 195628 878 ops s r u PerfTransforms flatMapTransforms 1024 thrpt 5 6579 659 354 893 ops s r u PerfTransforms mapTransformation 1 thrpt 5 8251868 663 329307 181 ops s r u PerfTransforms mapTransformation 1024 thrpt 5 19585 648 1757 210 ops s Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapNestedMapFilterTake 1 thrpt 5 2076835 599 50885 475 ops s r u PerfTransforms flatMapNestedMapFilterTake 1024 thrpt 5 18 664 0 224 ops s r u PerfTransforms flatMapTransforms 1 thrpt 5 2966236 565 68297 522 ops s r u PerfTransforms flatMapTransforms 1024 thrpt 5 6062 189 407 268 ops s r u PerfTransforms mapTransformation 1 thrpt 5 8289577 407 535983 353 ops s r u PerfTransforms mapTransformation 1024 thrpt 5 19542 094 1389 693 ops s','This issue is related to #1204 where CompositeSubscription was found to be a major problem for object allocation and the implementation was changed This issue is related to #1204 where CompositeSubscription was found to be a major problem for object allocation and the implementation was changed If anyone wants to offer alternative implementations please ensure that 2 requirements are met obviously beyond passing all functional unit tests 1 It performs better in the JMH performance tests than what s currently in use see above for how to execute them 2 It does not cause excessive object allocation This is not as easy to identity in benchmarking The best tool I know of right now is Java Flight Recorder It can be fast in the JMH test but fail the object allocation requirement like the CompositeSubscription state machine implementation Here is a resource for us to explore https github com JCTools JCTools tree master jctools core src main java org jctools There is my hybrid composite in #1145 As for the hang my guess is the lazySet that may overwrite a terminal state indicator but it seems its performance isn t good enough anyway A lot has been done and we now have rx internal util and rx internal until unsafe for various optimized data structures Closing this out as this was a very generic issue and has served its purpose A lot has been done and we now have rx internal util and rx internal until unsafe for various optimized data structures Closing this out as this was a very generic issue and has served its purpose',RxJava,false,false,false
34704383,'RxScala Add convenience method for adding unsubscription callback','Implements enhancement detailed in #1258','RxJava pull requests #1198 https netflixoss ci cloudbees com job RxJava pull requests 1198 SUCCESS This pull request looks good RxJava pull requests #1199 https netflixoss ci cloudbees com job RxJava pull requests 1199 SUCCESS This pull request looks good RxJava pull requests #1200 https netflixoss ci cloudbees com job RxJava pull requests 1200 SUCCESS This pull request looks good',RxJava,true,false,false
34709677,'RxScala Add convenience method for adding unsubscription callback','Implements enhancement detailed in #1258 Now with less git screw ups','RxJava pull requests #1201 https netflixoss ci cloudbees com job RxJava pull requests 1201 SUCCESS This pull request looks good LGTM @headinthebox Does this achieve what you wanted in #1258 and should it be merged Thanks @zsxwing for the review and @jbripley for doing this Yup',RxJava,true,false,false
34719710,'improve variable names in OperatorGroupBy','renamed childObserver to child as is now a Subscriber gps to group _gps to _group gps implies multiple but is not','RxJava pull requests #1203 https netflixoss ci cloudbees com job RxJava pull requests 1203 SUCCESS This pull request looks good',RxJava,true,false,false
34721743,'cache with capacity hint overload','Provide a cache int capacity overload that acts as a hint for memory allocation Ideally it should also allow for an optimization with ReplaySubject when the capacity is 1 so it can use a simple object reference to store the single value and not allocate an array If more than 1 is received then it would obviously have to switch to using an array but there are many case such as Hystrix that would benefit from this change','I m not sure how to approach changing UnboundedReplayState ReplayState as both complete and error methods will force to change from single value to array I missed the discussion with @jbripley #1338 This is done good enough for now as of #1393 which was merged',RxJava,false,false,false
34780440,'Add flatMap and concatMap to RxScala','For #1251 cc @headinthebox @samuelgruetter','RxJava pull requests #1204 https netflixoss ci cloudbees com job RxJava pull requests 1204 SUCCESS This pull request looks good',RxJava,true,false,false
34793019,'Checked Exceptions','This pull request makes the Rx user s code cleaner removes the necessity for wrapping all checked Exception s with RuntimeException s is not a breaking change lets the compiler help us find places where we ve made mistakes It s benefit is more obvious in Java 8 before try return new FileReader file catch IOException e throw new RuntimeException e after new FileReader file I made a new set of interfaces Func 0 9 N Checked and Action 0 9 N Checked The original Func 0 9 N and Action 0 9 N now extend from the checked version but remove the throws Exception Anywhere an observable operator already invokes Func s or Action s and already wraps that call in the try catch to handle Throwables than the checked version can be woven through I ve also included a sample change where I used Func1Checked for Observable map f','I don t really like the idea of having all of these extra Action Function types and don t think the issue is common enough to warrant this RxJava pull requests #1205 https netflixoss ci cloudbees com job RxJava pull requests 1205 SUCCESS This pull request looks good @abersnaze why don t you just define a static function Checked Funci f Funci that wraps it for you Then you can just call Checked new FileReader file A little more work but I actually like that it is more explicit The signature of the utility function would be Func0 checked Func0Checked func Would still need all of the new types and you would none of the benefits I was proposing it would simply be Func0 checked Func0 f return wrap f all you want I m pretty sure that won t compile because the body of the Func0 passed in would need to be wrapped try catch to not throw an exception before before being passed into checked Like this checked try return new FileReader file catch IOException e throw new RuntimeException e We could write utilities in Functions like static Func0 R throwAsRuntime Func0Checked R define Func0 checked Func0 f return try return f catch IOException e throw new RuntimeException e then simply use checked new FileReader file That should work or not Already had some discussion in #1282 and I made the same suggestion as @headinthebox I can t trial at the moment but would somebody give it a shot So the suggestion to just wrap the lambda that throws a checked exception with a static method called checked does work in java 8 java package java8test import java io IOException import rx Observable import rx functions Func1 public class Test public interface Func1Checked A B B call A a throws Exception public static A B Func1 A B checked Func1Checked A B func1 return a try return func1 call a catch Exception e throw new RuntimeException e public static void main String args throws IOException Exception Observable just 1 map checked x if x 3 throw new Exception boo return x 2 subscribe x System out println x I suppose you would have to write static overloads of checked for all the Func types and its companion interface Func Checked as well but its pretty clean and means that the Observable api is unchanged A class containing the static checked methods and the companion interfaces might be worth addding Excuse the runaround on this one @abersnaze I m new to java 8 and is not part of the work platform so took me a while to get around to it Exactly use the power of higher order functions to your advantage @abersnaze the code by @davidmoten was precisely what i had in mind With @davidmoten solution would still have the extra Func types but without the benefits of points 2 and 4 I think number 4 is particularly interesting in that we ve been seen an increased number of issues related to exceptions and how the are handled Point 4 depends on your point of view I find checked exceptions pretty invasive coming from C# and not having checked exceptions is one of the main attractors of Scala for me Static typing is a dial some people like it all the way to the left some like it all the way to the right For me personally checked exception are a step too far If you want to enforce checked exceptions I think it is pretty elegant to be opt in and write Checked x x I would deviate from convention and use uppercase to make it stand out If this can be done additively in a contrib module I suggest that but modifying the core to support this is too much clutter for little gain',RxJava,true,false,false
34812599,'Hooked RxJavaPlugins errorHandler up within all operators that swallow onErrors','Otherwise the only onErrors visible to RxJavaPlugins errorHandler plugin are the ones which propagate all the way to SafeSubscriber','RxJava pull requests #1206 https netflixoss ci cloudbees com job RxJava pull requests 1206 SUCCESS This pull request looks good @benjchristensen The goal of this pull request is to make the minimal set of calls to the plugin that ensures each onError is seen by the plugin handler at least once In this case I think it s fine to let the ErrorHandler see the CompositeException and handle all errors contained within I just removed the plugin code from the mergeDelayError operator to that effect RxJava pull requests #1208 https netflixoss ci cloudbees com job RxJava pull requests 1208 SUCCESS This pull request looks good',RxJava,true,false,false
34817277,'testNotificationDelay Attempt at determinism','Trying to make this deterministic I think it was possible for scheduling in the Executor to cause different threads to be used even when queueing happened This forces the same thread to be used as it is different Executors','',RxJava,true,false,false
34818968,'ChainedSubscription SubscriptionList','This matches the name decided upon in 0 18 4','RxJava pull requests #1207 https netflixoss ci cloudbees com job RxJava pull requests 1207 SUCCESS This pull request looks good We went with #1309 instead',RxJava,true,false,false
34833448,'Hide ChainedSubscription SubscriptionList from Public API','Instead of adding this type to the public API it hides it as an internal implementation detail and does not expose it via the Subscriber constructor If we want to expose it later we can figure out a proper name and do so This also changes operator implementations to not inject a SubscriptionList but instead just create the Subscriber and use it directly','RxJava pull requests #1209 https netflixoss ci cloudbees com job RxJava pull requests 1209 SUCCESS This pull request looks good Like I agree with this variant Great thanks for the review RxJava pull requests #1210 https netflixoss ci cloudbees com job RxJava pull requests 1210 SUCCESS This pull request looks good',RxJava,true,false,false
34855178,'MpscPaddedQueue does not pad correctly','The padding should be done with a 3 class hierarchy like I explained in this issue https github com netty netty pull 2529 Also you may want to use 128 bytes for padding as some newer HW use 128 bytes cache lines','@normanmaurer you mean to avoid DCE @daschl DCE Dead Code Elimination @daschl nope reordering fields Check https github com netty netty pull 2529#commitcomment 6535582 A PR is welcome @akarnokd sure will do later today Would be nice to get the iterator implementation as well so we can completly replace ConcurrentLinkedQueue with this class Our Mpsc queue was not meant to be a replacement for CLQ just to be a simple offer poll for serializing between threads i e observeOn SerializedObserver custom Scheduler Ah wasn t aware of that Completed in https github com Netflix RxJava pull 1359 Anyone have opinions of the code from https github com JCTools JCTools tree master jctools core src main java org jctools queues I ve been playing with them on another branch and they seem good I ask here as it relates to the same type of issues @benjchristensen I can really recommend @nitsanw s queues Would be very interested in being added as a dependency code should be on maven in the next few week in version 0 1 @nitsanw I hope we can keep RxJava without dependencies @daschl @normanmaurer @benjchristensen I appreciate we all want to make user s life easier which is why a my lib name all jar is a nice way to publish your artifact It s easy enough to support via maven build The current practice of copying and pasting randomly old versions of dependencies seems worse IMHO imagine a bug in version X fixed in version Y which version did RxJava use Ultimately there is nothing I can or wish to do to stop people you are always welcome to copy my code if that s how you roll @daschl @normanmaurer @benjchristensen JCTools now includes an unbounded MPSC https github com JCTools JCTools blob master jctools core src main java org jctools queues MpscLinkedQueue java The algorithm is the same as the one followed by Rx Netty The class layout is different as both head tail node references are fields of the main data structure From re reading the code in Rx Netty I believe you suffer from false sharing as the writes to the tail field invalidate the cache line holding the reference to the PaddedReference to head Also note the queue class fields are themselves not padded leading to potential false sharing between the queue and it s neighbors Thanks for submitting a fix for this @nitsanw in https github com Netflix RxJava pull 1374',RxJava,false,false,false
34914687,'Tiny integration test change','It s a tiny change I ve been following this project for a while as a hobby also want to contribute to it Currently I am going through test cases to learn Found some tiny problems as we are testing concat we should care not only the total number of elements but also the sequences Creating this request mainly want to make sure I am writing commiting code to the correct place Let me know if there is any problem Best Regards Mingtao','RxJava pull requests #1211 https netflixoss ci cloudbees com job RxJava pull requests 1211 SUCCESS This pull request looks good Thanks for getting involved and improving these tests',RxJava,true,false,false
34936313,'0 19 Potential Leak in CompositeSubscription with Executor','Hey folks doing performance tests with 0 19 did bring up something interesting check this out on a 4gig heap screen shot 2014 06 04 at 09 34 22 https cloud githubusercontent com assets 29086 3170620 b521b63c ebba 11e3 890b 7aa2ff0ad02f png 96 of my heap are taken up by the CompositeSubscription I m running a workload like this that is fetching docs out of the server but here for example without any docs so they are not found to not mess with object decoding in the benchmark java List GetRequest keys new ArrayList GetRequest 1024 for int i 0 i 1024 i keys add new GetRequest key i bucket while true final CountDownLatch latch new CountDownLatch 1 Observable from keys flatMap new Func1 GetRequest Observable @Override public Observable GetResponse call GetRequest s return cluster send s toList doOnCompleted new Action0 @Override public void call latch countDown subscribe try latch await catch InterruptedException e e printStackTrace Looking into the CompositeSubscription the dump makes sense since it uses a HashSet which is internally backed by a HashMap Another hint might be that they seem to be hanging around in the executor screen shot 2014 06 04 at 09 44 16 https cloud githubusercontent com assets 29086 3170721 249c1376 ebbc 11e3 880a 2c1270080f30 png Not sure if there is a leak somewhere I m assuming since 95 are reachable in the heap dump but it is causing unbearable pressure on the test system In case you wonder about the workload its around 100k ops s until it goes nuts since GC takes up all time','pinging @akarnokd and @benjchristensen let me know if you need more info from that heap dump it s quite large That thing prevents me from testing the new 0 19 perf improvements since it dominates it all Hmm it could be me scheduling too much stuff but the hanging around so long doesn t make sense to me I ll do further investigations and then reopen if I have news Okay reopened this because I think I m either misusing it completely or there is indeed something wrong with freeing stuff Let me give you some context I m writing those requests into a netty channel but if channel isWritable returns false indicating a overload on the writer side I push it back into a response RingBuffer Now in my handler there I basically say since I got a request in there I need to reschedule it so that it will be retried but lets do it with a backoff since doing it right now might now have any value So what I m doing is java Schedulers computation createWorker schedule new Action0 @Override public void call cluster send request 10 TimeUnit MILLISECONDS Which means after 10 MS push the request again into the request RingBuffer so it will go into the request path again I think this is where all those objects come from but shouldn t they be cleaned up at some point Or do I need to do something special to indicate they can be freed The send method returns immediately Any idea on how to approach this differently if I m misusing the system You create a worker for each reschedule action which creates a lot of subscriptions to track stuff If you don t do any other computation there you could reuse an existing worker maybe from Schedulers newThread so it doesn t disrupt the computation threads that much @akarnokd thanks how do you mean If I change the code to Schedulers newThread createWorker I immediately run out of memory since it cant create more threads Cache the worker returned from Schedulers newThread createWorker and use that @akarnokd I get more or less the same heap dump too much subscriptions and hash sets created Maybe I need to use my own HashedWheelTimer or so to reschedule those ops Looks like the overhead to track this stuff in RxJava is too much @akarnokd but on the other hand why are they sticking around for so long If you look at my test case I wait until the 1024 return so they went through correctly which means they should be removed from the worker already They are still keeping around I need a heapdump for further investigation Could you create a smaller program I could run on my own accompanied by a dump @akarnokd I ll try to come up with something self contained but it might take a while I ll ping you once I have it Okay One drawback with this HashSet based composite is that the HashSet grows and never shrinks When I was researching #1145 many sources indicated that there is no good way to establish a shrink policy on java Collection classes However we could introduce a simple policy in which the HashSet is recreated with default capacity if the composite reaches 0 size Unfortunately HashMap doesn t expose the underlying table s capacity so we could avoid constant recreation in case the size changes back and forth between 0 and some small value That code also is never cleaning up the Worker that is created Here is a simple example to show how the Worker needs to be registered for cleanup https github com Netflix RxJava blob master rxjava core src main java rx internal operators OperatorRepeat java#L76 If this is CPU bound then the computation scheduler is the right one More threads can t help get more CPU time If it s doing IO then you should use the IO scheduler which caches threads as opposed to the NewThreadScheduler that creates a new one every time @benjchristensen maybe the worker cleanup is the right pointer this could very well be the issue since the stuff is sticking around forever and never get cleaned up @benjchristensen sorry I don t get the sample where do I need to register the worker to be cleaned up Here is some code that may point the direction java Worker worker Schedulers computation createWorker worker schedule new Action0 @Override public void call do stuff 10 TimeUnit MILLISECONDS somewhere this needs to be called worker unsubscribe ObserveOn schedules the unsubscribe https github com Netflix RxJava blob master rxjava core src main java rx internal operators OperatorObserveOn java#L79 here is a Subscriber for registering it Subscriber s new TestSubscriber s add worker when the Subscriber is unsubscribed the Worker will also be shut down s unsubscribe The assumption is that your code is using the Scheduler within an operator or Observable chain somewhere and thus has a Subscriber it can register itself with So inside an Operator you would take the Subscriber you receive and register your worker with it subscriber add worker Here is an example of when the Worker is created and registered with a Subscriber https github com Netflix RxJava blob master rxjava core src main java rx internal operators OperatorObserveOn java#L77 The repeat example also creates the Worker then immediately registers it via Subscriber add https github com Netflix RxJava blob master rxjava core src main java rx internal operators OperatorRepeat java#L74 @benjchristensen would it make sense to cache the worker and then pass all the calls in this one or does this screw up the semantics @benjchristensen especially if I schedule 100 tasks immediately to be executed in 10ms would it be like 10ms 10ms 10ms or would all 100 be executed in 10ms from now I think if its the former then I need to go with multiple workers since that would be pretty bad for throughput The Worker is a single queue that ties itself to a single thread so ensure sequential execution the Observable contract Also it participates in the subscription lifecycle unsubscribe Since I don t know where you re using the Scheduler caching it may be okay but only if it represents a single stream of data and you re okay being pinned to a single thread for every generally you would want each Observable to have its own Worker so they are scheduled independently See here for how it schedules itself onto an event loop https github com Netflix RxJava blob master rxjava core src main java rx schedulers EventLoopsScheduler java#L68 If you re wanting parallel execution a Scheduler Worker will never give that It is exactly the opposite behavior of a Worker whose purpose is to schedule work sequentially and comply with the Observable contract Parallel execution is done by splitting into multiple Observables such as parallel and we re considering a ParallelObservable with a small number of operators like map that would be allowed to run concurrently If you schedule 100 tasks on a single Worker to be done in 10ms the worker will wait 10ms then wake up and run the 100 tasks sequentially on the same thread To add to @benjchristensen s advice you typically need not to work at the level of schedulers In fact I often use http netflix github io RxJava javadoc rx Observable html#repeat rx Scheduler to just create a stream of turns and continue in regular Rx land @headinthebox this part of the code is imperative it is handler which gets notified by the LMAX Disruptor All it has to do is pass the message to another method I hope someone could tell me how to use this properly since I don t use it as part of observables Currently I have this which doesn t work obviously and still creates massive amounts of garbage as reported java private void scheduleForRetry final CouchbaseRequest request final AtomicReference Subscription subscription new AtomicReference Subscription subscription set worker schedule new Action0 @Override public void call cluster send request subscription get unsubscribe 10 TimeUnit MILLISECONDS That code doesn t work properly but I don t see a way to unsubscribe properly once the code ran Th e worker is a cached Schedulers computation createWorker Note that the cluster send method is more or less instantaneous it just publishes into a ringbuffer and is done with it That code will only unsubscribe the single action you scheduled which is already completing by the time you invoke it If you want to unsubscribe the entire worker you need to call worker unsubscribe I think it would help to step back to what you re trying to do In the original code example where cluster send is being invoked is that method blocking If so you could just use subscribeOn Schedulers io and it would handle it for you Can you provide a sample Gist that is self contained without Couchbase code that I can run and provide suggestions on @benjchristensen okay here is something self contained java @Test public void foo throws Exception Scheduler Worker worker Schedulers io createWorker while true for int i 0 i 1000 i worker schedule new Action0 @Override public void call 10 TimeUnit MILLISECONDS Thread sleep 10 If you run this and use something like YourKit you can see that old gen is growing like crazy If you increase the heap size with a higher young ratio it just delays the effect I think this shows that its not getting unsubscribed the question is just whats going on Looks like this here screen shot 2014 06 06 at 06 48 48 https cloud githubusercontent com assets 29086 3196758 eec440a4 ed35 11e3 9cf1 859cadf53a66 png I run the test above and what I see is on my machine with Java 8 is that OldGen slowly fills up and is not collected at all What happens is that the ScheduledAction and related objects get promoted to the OldGen but they become unreachable after 10 ms anyway and just using up space until a full GC happens @akarnokd correct do you have any idea what we can do about that I know it s against how GCs predict it would be used it just sticks around for so long to be promoted to old and then needs to be collected pretty bad use case You could increase the YoungGen space size in this particular case so it won t get filled within 10 15ms and objects will probably die before they need to be promoted from survivor space @akarnokd I also thought about using a CMS since that could help with the gc pauses in the old gen I ll see what I can tune GC wise but ideally we don t generate that much garbage even if that means for me I need to down another route like using a timer from Netty or so Closing this out as I believe it was solved but more importantly because 0 20 has changed enough that memory allocation and collection all needs to be profiled again so we should use new issues for it Reopen if there is something further to discuss on this thread @benjchristensen sounds good thanks I think its anyway how I do the retry queues and I gotta rework that part entirely I ll reopen if I find specific other areas that could be improved cheers',RxJava,false,false,false
34940969,'No isCompleted or isErrored methods on Observable','Hey folks I was currently running into the situation where I just needed a quick check if my observable is already done and in particular failed but I wondered why this is not exposed on the Observable is there any specific reason my code was like java if observable isCompleted rescheduleIt','If you need this your code is probably too imperative But more importantly it makes no sense for cold observables like Observable range 1 10 because that is never completed Assuming observable is hot you can implement it yourself by doing scala var isCompleted false val s observable subscribe x e isCompleted true if isCompleted rescheduleIt Note it is dangerous to rely on since there is a race condition if isCompleted now it can become completed right here so you will reschedule anyhow rescheduleIt @headinthebox thanks my observable in this case is hot The approach here the request which contains the response observable can get redistributed and retried but the ringbuffer could back it off with a backpressure exception making it fail I d like to now if it has failed before rescheduling it again How about using doOnCompleted @akarnokd I think I ll go with something simpler I can fix that in a different place It s just something I need to wrap my head around in general I guess but thanks for the clarification closing then If an Observer Subscriber receives and onCompleted or onError or doesn t want to any more onNext for any other reason then it should unsubscribe from the Subscription In a way isUnsubscribed on the Subscription Subscriber can be used as a proxy for isComplete isError Nice catch @abersnaze',RxJava,false,false,false
34943747,'Operator Repeat with Func1','Currently we have 2 x 2 overloads of the operator repeat repeat indefinitely and repeat a certain number of times Would it make sense to create an overload where the operator takes a predicate to determine if the repeat should happen or not Observable repeat Func1 Integer Boolean predicate where the function receives the repeat count so far We have similar logic available to retry for the error case but I don t have any particular use case to back the need for this new overload','Can see that is useful but I guess you mean Observable repeat T value Func1 Integer Boolean predicate Also maybe better to take a Long instead of Integer I came up with a neat idea for a more generic retry signature Observable T retry Func1 Observable Throwable Observable func The func would receive an Observable that onNexts a Throwable each time the source Observable terminates unsuccessfully The returned Observable from the func should onComplete or onError when the whole retry should stop with an onComplete or onError respectively Then func could apply any Observable operations to the error observable get any retry behavior that they want To retry for a duration by using the timeout operator exceptions exceptions timeout 1 TimeUnit SECOND or limit the retries by count by using take n exceptions exceptions take n last flatMap e Observable error e I forgot to say that maybe instead of the func getting an Obersvable of Throwable it could get an Observable of Notification where each notification is the terminal notification In the case of repeat its a stream of onCompleted notifications and in retry it is of onError notifications Would love to play with that just keeping a count seems very restrictive and you can build that using your proposal The proposal from @abersnaze looks quite powerful though it is a breaking change on the retry design we just released since we can t have 2 methods each with a single function argument All of these are now in the code so closing this',RxJava,false,false,false
34944398,'DoOnEach variant to invoke the custom observer after the main observer','Currently the doOnEach operator and all the other doOnXYZ variants invoke the supplied callback observer before the main event is delivered For example if I need to wait for the completion of the stream but that stream does work in its onCompleted method e g toList that stream isn t really completed when I receive the callback from doOnCompleted Would it make sense to create a second set of operators that invoke the supplied callback observer after the main observer delivered the event Names could be doOnEachAfter doOnCompletedAfter etc','@akarnokd more like doAfterOnCompleted or doAfterOnEach right Right There is doOnTerminate that happens before and then finallyDo that happen after the onComplete or onError Thus it sounds like you want finallyDo What do you need that finallyDo doesn t provide finallyDo takes only an Action0 I d like one that takes an Observer that is called after the main event delivery finallyDo doesn t distinguish between how the stream was terminated Do we need a new operator for this or can this be defined using lift when you need it Seems not a common enough thing to make the API surface even larger I can implement almost any operator for myself but can t be sure if such operator is useful or not for anybody else using RxJava hence this question If you want to submit a PR with these additions I see no harm in this being added',RxJava,false,false,false
34961722,'Add the rest operators to RxScala','This PR added the rest operators to RxScala However I think some operators in rxjava math rxjava string such as min max average are worth to add to RxScala What do you think @headinthebox @samuelgruetter','RxJava pull requests #1212 https netflixoss ci cloudbees com job RxJava pull requests 1212 SUCCESS This pull request looks good If we put them in a different package as extension methods I m fine Then you can bring them into scope them as you wish Thanks @samuelgruetter and @zsxwing I ll review this in depth tomorrow morning RxJava pull requests #1217 https netflixoss ci cloudbees com job RxJava pull requests 1217 SUCCESS This pull request looks good I gave up the idea that converting Map K Seq V to Map K Collection V It s much more complicated than I thought Directly implementing toMultimap in RxScala looks much easier I will rewrite toMap in another PR as it s a breaking change RxJava pull requests #1218 https netflixoss ci cloudbees com job RxJava pull requests 1218 SUCCESS This pull request looks good RxJava pull requests #1222 https netflixoss ci cloudbees com job RxJava pull requests 1222 SUCCESS This pull request looks good RxJava pull requests #1233 https netflixoss ci cloudbees com job RxJava pull requests 1233 SUCCESS This pull request looks good But then I think RxScalaDemo should clearly explain that obs subscribe onNext obs foreach onNext and for e obs onNext e are exactly the same Added subscribeExample for this I added it at the beginning of RxScalaDemo so that people can easily notice it RxJava pull requests #1244 https netflixoss ci cloudbees com job RxJava pull requests 1244 SUCCESS This pull request looks good Overrode the last commit to fix the typos RxJava pull requests #1251 https netflixoss ci cloudbees com job RxJava pull requests 1251 SUCCESS This pull request looks good LGTM Thank you @zsxwing Thanks @zsxwing @benjchristensen can you merge this then I can make a pass over it so see if there is any fine tuning left',RxJava,true,false,false
34967807,Unzip,'Hi Is it possible to add Unzip which could reverse the operation of zip if you pass in the right function The return types are constrained to what can be legally based into zip Suminda','The return type would have to be Observable Tuple T1 T2 or Tuple Observable T1 Observable T2 and RxJava currently avoids defining it s own Tuple types Ideally it should be Tuple Observable T1 Observable T2 but since you avoid Tuples why not arrive at what ever you passed into zip if you have zip followed unzip with the right transformations Do you mean something like R unzip Func1 T T1 select1 Func1 T T2 select2 Func2 Observable T1 Observable T2 R makeTuple Why don t you subscribe two subjects to the same source observable That seems the easiest and most direct solution Sounds like publish but one has to connect only after the required amount of subscribers arrived because otherwise you lose events I ve got this so far final ConnectableObservable T subject source publish final AtomicInteger count new AtomicInteger 0 Object r makeTuple call Observable defer new Func0 Observable T1 @Override public Observable T1 call if count incrementAndGet 2 subject connect return subject map select1 Observable defer new Func0 Observable T2 @Override public Observable T2 call if count incrementAndGet 2 subject connect return subject map select2 @akarnokd thanks for adding this important detail of course you should guard this with a publish also because you want to share the values Having said you you should be able to recover the original with zip unzip combination this will not be the typical use case This is just a sanity check to see it the implementation is right Say you are calculating which produces multiple results and each result needs to be consumed separately Not sure that I understand you if I zip two streams say 1 2 3 4 and 5 6 7 8 into 0 0 0 0 how can you get back the two original streams From calculating which produces multiple results and each result needs to be consumed separately it seems that you can use just publish and consume the stream multiple times You have to zip it into 1 5 to be reversible and then you can get back 1 and 5 OK then publish should work fine for you I think Not exactly though You can build the functionality around this We could build a function around this but it s easy enough to implement in your code by composing existing operators look at the pull request for example code of the different ways to do this Closing out due to inactivity and because there are valid alternatives',RxJava,false,false,false
34968790,'Joins Only plan upto 3 implemented in RxJava but Rx has 16','Is it possible to have larger plans for joins Also besace it is not is the core concerned about how optimised the implementation is','That 3 was tedious to implement and there was no one at the time who needed it or understood its use case If you try to zip together about 16 streams in different combinations like DAG you will see how useful this is Ideally there should a lot more than 16 as you will be dealing with a large number of streams to coordinate between in some cases One problem is that the operator requires a function callback with that arity but we have only up to Func9 I didn t understand the operator enough so I could try with FuncN there might be no good way to generalize to any arity with FuncN Adding the remaining 4 9 arity version is mostly mechanical one could always use Rx NET as cheat sheet but writing tests is cumbersome I b be really surprised any human can patterns over more than 3 streams by hand because of the combinatorial explosion Are you generating the code I certainly didn t I saw Rx NET use code generators on this I m not sure if we have anything similar available with Gradle and or annotation processing Then stop at 9 and N When you have more function arity then add accordingly Up to 9 was added closing out',RxJava,false,false,false
34969817,'Joins Or OrWithDefault','Hi One area that is not looked into in creating Joins in Rx is how to deal with situation when one of the streams has an input and you want to update your processing based on it but using previous values for the other streams which is waiting for the next value Also you might want to indicate the particular stream does not have a value in some cases by providing a default This might be useful in a non Joins context also hence and or combinators And combine when all inputs are there Or combine when at least on input is there Sequence then sequence from different streams in order i e if A has a value then a followed by b from B Suminda','There s combineLatest https github com Netflix RxJava wiki Combining Observables#combinelatest though it wouldn t help with the problem of a participant observable that hasn t emitted any values yet You could use startWith https github com Netflix RxJava wiki Combining Observables#startwith to prepend some hasn t started yet token to those observables and then detect this in your combineLatest combine function On Wed Jun 4 2014 at 8 28 AM Suminda Dharmasena notifications@github com wrote Hi One area that is not looked into in creating Joins in Rx is how to deal with situation when one of the streams has an input and you want to update your processing based on it but using previous values for the other streams which is waiting for the next value Also you might want to indicate the particular stream does not have a value in some cases by providing a default This might be useful in a non Joins context also hence and or combinators And combine when all inputs are there Or combine when at least on input is there Sequence then sequence from different streams in order i e if A has a value then a followed by b from B Suminda Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1319 David M Gross PLP Consulting The main idea of proposing this is that you can impliment all the patterns in https github com Netflix RxJava wiki Combining Observables as Plans The plans can be further composed This is a lot more flexible when dealing with function calls when the number of combinations are large and the possible combination are dynamic You might need and or merge and a way to delay the errors And is like zip Or is combineLatest Must think through how the rest should fit in Main thing is once you have a Pattern Object you can create others with different combination by adding them and creating new Pattern Objects Once all of the Patterns are in place then you start processing Imagine you have n items and some cases you have to select r out of this to zip or combine or perform some other operation These combination are again combined in the next level Imagine you are using a DAG as way to compute If you are to code all the possible combination your code blows up in size and complexity which is increasing very rapidly So for very dynamic use cases with large number of possible combination which feed into other combination using static function call to do this is not elegant and not very understandable after a few weeks The process of composing streams and calculation itself should be composable The joins patterns are in a separate contribution module In the NET world as well in RxJava they are not much used We d be delighted @sirinath if you would hack on those One problem with the join patterns for me was that it is usually hard to predict which plan will take which value zip and combineLatest is much clearer Should be simple Every time a new value arrives all patters are matched top to bottom first one wins Having a pattern object to pass around and work with is much easier when you get going with it Mostly this would have not caught on since the functionality is limited You should be able to express what ever you do with rest of Rx using this I am sure this will be what would be used Rx give the flexibility to compose streams Extending this would give the power to compose the composition and also further optimise all the combinations and transformation Absolutely that s why we added join patterns to Comega and When to Rx Seems like you have some kind of advanced API DSL in mind for composing join patterns Go for it I assume you are aware of things like http en wikipedia org wiki Join calculus Closing out as conversation died off If there is code to propose please open a pull request for a contrib module',RxJava,false,false,false
34973272,'Joins Plan Optimiser','Hi For large number of composable joins you might need a plan optimiser Though in a different context http stratosphere eu has such an optimiser Suminda','@sirinath the join patterns are modelled after Haskell style pattern matching they are matched top to bottom To optimize patterns you would have to put in more restrictions Instead of doing optimizer magic yourselff you should look at Claudio s efficient implementation of the joins library http research microsoft com en us um people crusso papers cb pdf Also following links some additional papers too https github com VesaKarvonen Hopac Also worthwhile looking at the project also to get some ideas Also a optimiser would be more efficient than hand composing the transformations and combinations Also it can optimise this against workload and resource availability @headinthebox and @sirinath Is there anything about this that requires further discussion Not from my side This would be an interesting VC funded project I m closing this out as this feels out of scope for RxJava itself @sirinath if you want to propose and lead a contrib module or a sibling project I d be interested in that',RxJava,false,false,false
34976665,'Ensuring Runnables posted with delay to a Handler are removed when unsub','scribed This patch ensures the delayed runnables posted to a Handler are properly removed when Subscription unsubscribe is called on the Observable The original code returns the subscription from schedule but is not used by the callers who instead add the Worker itself as a subsciption Signed off by David Marques dpsmarques@gmail com','cc @akarnokd @zsxwing for review please Thanks @dpsm for the contribution and fixes RxJava pull requests #1213 https netflixoss ci cloudbees com job RxJava pull requests 1213 SUCCESS This pull request looks good Generally the entire schedule Action0 long TimeUnit is incorrect 1 it has to return a valid subscription that cancels the submitted action this PR returns an empty subscription which won t even cancel a direct schedule 2 the action should to monitor its own cancellation token instead of the worker s overall subscription 3 it has to track scheduled tasks this is covered in this PR 4 it has to remove completed tasks from the tracking structure in this PR without it the scheduler leaks subscriptions until terminated You need to introduce a new class similar to ScheduledAction which is itself a runnable and a Subscription you can add it to the tracking composite and it can remove itself from the very same composite on completion you can return it as the Subscription token and it can check itself before executing the actual action RxJava pull requests #1214 https netflixoss ci cloudbees com job RxJava pull requests 1214 SUCCESS This pull request looks good RxJava pull requests #1221 https netflixoss ci cloudbees com job RxJava pull requests 1221 SUCCESS This pull request looks good The changes are now fine with me @zsxwing LGTM @mttkay Are you okay with these changes and their impact on Android RxJava pull requests #1241 https netflixoss ci cloudbees com job RxJava pull requests 1241 SUCCESS This pull request looks good 1 @benjchristensen given everyone s approval when could we get it into master I am new to the project and want to contribute a lot more specially in the android side of things Is there anywhere I can read about the roadmap or some idea on release process SNAPSHOT builds etc Thanks @benjchristensen given everyone s approval when could we get it into master I am new to the project and want to contribute a lot more specially in the android side of things Is there anywhere I can read about the roadmap or some idea on release process SNAPSHOT builds etc Thanks You can read about the roadmap here https github com Netflix RxJava issues 1001 The plan is to split RxAndroid out into it s own top level project at http github com ReactiveX RxAndroid in the next month or two',RxJava,true,false,false
34978073,'Missing javadoc comments','I ve gone through those parts of the source code that are reflected in the rxjava core javadocs and flagged those parts of the javadoc comments that are missing or that need attention In those areas where I felt confident enough to fill in the gaps myself I have done so but that still leaves some gaps unfilled If you are the implementer or if you have the necessary expertise could you review the files on this list for missing javadocs I ve flagged the areas that need help with @warn tags That tag is not part of the javadoc standard so it triggers a javadoc compilation warning Please remove those tags from the areas that you fix subscriptions MultipleAssignmentSubscription java set and get subjects Subject java class description subjects TestSubject java all javadocs missing exept class description which seems copy pasted observers Observers java class description observers Subscribers java class description observers TestSubscriber java awaitTerminalEvent awaitTerminalEventAndUnsubscribeOnTimeout getLastSeenThread exceptions Exceptions java all javadocs missing exceptions OnErrorThrowable java class description getValue OnNextValue inner class Notification java createOnCompleted Observable java cache multicast toList Subscriber java add','Tagging folks who can likely help with some of this @akarnokd MultipleAssignmentSubscription Subscribers Observable cache @benjchristensen onErrorThrowable Exceptions TestSubject Subject MultipleAssignmentSubscription TestSubscriber Subscriber MpscPaddedQueue Notification Observers Subscribers ExecutorScheduler OperatorGroupByUntil BufferUntilSubscriber NotificationLite Observable cache multicast toList @jbripley NewThreadWorker ScheduledAction @samuelgruetter Notification Some of this has gone internal and therefore may not need as much javadoc attention but the rest need a look toList looks OK to me multicast is pretty crazy it is really a helper function for other forms of multicasting like publish and publishLast so I don t think it is super important or even possible to improve the description I even doubt people are using the raw version outside the core library for Subscriber add you can say The subscription to add copy paste from CompositeSubscription For Subscribers you can copy and paste the doc comments from Subscriptions i e something like Helper methods and utilities for creating and working with @link Subscriber objects For observers Observers java same as Subscribers helper methods Subject java something like Represents an object that is both an observable sequence as well as an observer Good catch surprised this has been without a doc comment for so long subscriptions MultipleAssignmentSubscription java set sets the underlying subscription get retrieves the underlying subscription We should also mention that is multipleassignmentsubscription is already unsubscribed setting a new subscription causes it to be immediately to be unsubscribed On Subscriber add the description of the function says that it registers an unsubscribe callback does the subscription passed in as a parameter need to be initialized in any particular way to serve as a callback How does that subscription detect the unsubscribe callback Or is the description incomplete and this function does more than register an unsubscribe callback That s sloppy language identifying a subscription with public void unsubscribe Closing this out as it s been quiet a while @DavidMGross If any remaining issues need assistance open specific issues for each item and assign to the applicable person New issues for remaining javadoc related needs #1508 #1509 #1510 #1511 #1512',RxJava,false,true,true
34990471,'Need a variation on throttle that does not throttle first item','Scenario is I have a screen that has a search field and the search requires making a web service call We do not want to do a search on each character that is typed so we use throttle on the Observable from the search field so that we only process it after they stop typing The issue is when we initially create the screen and subscribe to the Observable on the search field the very first value is also throttled Resulting in an initial delay before retrieving results Would like a way to pass a parameter to throttle telling it that the very first item after subscription should not be delayed','You can build this from the existing operators Just split the stream into the first and rest and throttle the rest val ys xs publish _xs Observable Int _xs take 1 _xs WhateverThrottleYouWant I came up with the following construct java public class ThrottleNotFirst public static void main String args throws Exception for int firstWait 0 firstWait 2 firstWait PublishSubject String source PublishSubject create PublishSubject Observable String immediates PublishSubject create Observable Observable String first source take 1 observeOn Schedulers io map s Observable just First s delay 100 TimeUnit MILLISECONDS Observable Observable String rest source skip 1 debounce 100 TimeUnit MILLISECONDS Schedulers io map s Observable just Rest s delay 100 TimeUnit MILLISECONDS Observable merge first rest subscribe immediates Observable String result Observable switchOnNext immediates result subscribe System out println Throwable printStackTrace System out println Done System out println Typed One source onNext One if firstWait 1 System out println Waiting after one Thread sleep 300 source onNext Two source onNext Three Thread sleep 300 System out println I realize that there are ways to work around it but it would be much more convenient to just have an overload with an extra parameter to specify whether to delay the first value after subscription Then the next person wants the second value delayed and the third one every other value Rx is a library that provides you with primitives that you can combine together to get what you want Every additional operator makes the library overweight and age faster Ideally the primitives are tricky to implement correctly and efficiently look for instance at merge but on top of that you plug things together like Lego bricks That s the power of Rx My biggest nightmare is that Rx turns into a framework like Angular that is floor wax desert topping and hair gel Based on answer from @headinthebox I m closing this out Here is another similar example bufferedDebounce of how a specific use case is accomplished by composing operators https gist github com benjchristensen e4524a308456f3c21c0b',RxJava,false,false,false
35014088,'TrampolineScheduler Unsubscribe','Unsubscribing should prevent new additions to a Worker but not prevent already scheduled work and definitely not affect other Workers using the same thread by modifying the ThreadLocal as it was doing See the unit test for details of how unsubscribing 1 Worker could prevent work from being done on a completely separate Worker','',RxJava,true,false,false
35027591,'PREVIEW 1 Backpressure Subscriber Producer ObserveOn','This is the first round of dev on backpressure and not even close to final I am publishing as PR for collaboration cc @headinthebox @abersnaze @akarnokd 2 unit tests are failing as the sources don t yet support backpressure There are stray printlns throughout code still I have not yet attempted merge though I have a general strategy in mind It is most likely my next thing to work on I have not looked at performance impact at all All names and object models are open to change I ve got Atomic uses that need to become FieldUpdaters Several TODOs showing where improvements need to be made such as a proper ring buffer implementation What to look at Subscriber the request and setProducer methods OnSubscribeFromIterable OperatorObserveOn RxSpscRingBuffer Work to do the subscribeOn operator needs to decorate setProducer to compose the scheduling of starting up the Producer again merge backpressure operators such as onBackpressureDrop onBackpressureBuffer onBackpressureUnsubscribe onBackpressureSample Throttle etc unit tests for various use cases performance and memory allocation testing prove with Netty channels determine if there are any use cases that will kill this for example the filter operator must take request into account otherwise when it filters out events they won t propagate and then request may never get called again and the chain hangs there are likely other scenarios like take and some I m concerned are nuanced','Ack RxJava pull requests #1215 https netflixoss ci cloudbees com job RxJava pull requests 1215 FAILURE Looks like there s a problem with this pull request Note to myself need to spend more time on the TrampolineScheduler in this The TrampolineScheduler is going to be used far more with backpressure to avoid stack overflows on the use of request n and it revealed problems I fixed some already in the master branch This PR includes others Specifically need to confirm that unsubscribing a TrampolineScheduler Worker terminates the queued items on that Worker but does not affect the items scheduled in the ThreadLocal queue for other workers The parallel test indicates the subjects require some rework Unfortunately they would need to extend both Observable and Subscriber in order to support setProducer to avoid being wrapped by the SafeSubscriber that hides the backpressure information Subjects won t support backpressure by definition they are hot A hot stream is the same as creating an Observable of a hot stream like stock prices or mouse events These are where the onBackpressure methods will come in as a user will have to choose what to do They could choose to drop buffer whatever Maybe revisit subjects as HasA subscriber I needed this in a sample recently Sorry I don t quite understand what do you mean by that RxJava pull requests #1225 https netflixoss ci cloudbees com job RxJava pull requests 1225 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1226 https netflixoss ci cloudbees com job RxJava pull requests 1226 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1243 https netflixoss ci cloudbees com job RxJava pull requests 1243 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1254 https netflixoss ci cloudbees com job RxJava pull requests 1254 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1256 https netflixoss ci cloudbees com job RxJava pull requests 1256 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1259 https netflixoss ci cloudbees com job RxJava pull requests 1259 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1260 https netflixoss ci cloudbees com job RxJava pull requests 1260 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1262 https netflixoss ci cloudbees com job RxJava pull requests 1262 FAILURE Looks like there s a problem with this pull request Replaced by https github com Netflix RxJava pull 1351',RxJava,true,false,false
35032004,'Added overload for retry to accept a Func1 Obs Obs','Implemented a new overload for Retry operator that accepts a Func1 Observable Notification Observable for determining retry behavior and reimplemented the existing retry overloads in terms of the new overload I intend for this change to allow for implementing clean up logic on notification of a failure prior to the retry behavior as well as expressive functional retry logic','RxJava pull requests #1216 https netflixoss ci cloudbees com job RxJava pull requests 1216 FAILURE Looks like there s a problem with this pull request This is for #1314 RxJava pull requests #1223 https netflixoss ci cloudbees com job RxJava pull requests 1223 SUCCESS This pull request looks good RxJava pull requests #1229 https netflixoss ci cloudbees com job RxJava pull requests 1229 SUCCESS This pull request looks good RxJava pull requests #1236 https netflixoss ci cloudbees com job RxJava pull requests 1236 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1237 https netflixoss ci cloudbees com job RxJava pull requests 1237 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1238 https netflixoss ci cloudbees com job RxJava pull requests 1238 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1239 https netflixoss ci cloudbees com job RxJava pull requests 1239 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1240 https netflixoss ci cloudbees com job RxJava pull requests 1240 FAILURE Looks like there s a problem with this pull request @benjchristensen please comment review RxJava pull requests #1261 https netflixoss ci cloudbees com job RxJava pull requests 1261 FAILURE Looks like there s a problem with this pull request On first pass it seems like a good change I just need to wrap my head around it all by writing some code against it Also need to figure out if it s okay to remove retry Func2 Integer Throwable Boolean predicate I m not a fan of breaking changes this late in the game Is this generic enough to call something like recurse and have repeat and retry built off of it Cloud bees failure seems transient I don t quite understand the use of this operator It looks a bit convoluted and adds a bunch of layers and wrappings @benjchristensen the PR does reimplement repeat and retry in one new common operator code We called it RedoOperator for lack of a better term @akarnokd The key to understanding this is that the observable returned by the Func1 controls when the operator subscribes to the source observable Each onNext from the control observable translates to one subscription to the source observable When the control observable terminates with onError or onComplete that is used as the terminal state of the output observable Now that I think about it the the control observable might be easier if it was Observable and not Observable Notification It is a bit complicated but but rather an expressing what you want with tons of overloads it can be done observable operator chains @headinthebox do you have any input on this change This new way of handling repetition should subsume all prior existing overload use cases of retry and repeat I m not sure that I have a strong opinion on the API of the control loop func and I m looking for input @stealthcode and @abersnaze Like @benjchristensen says it would be super useful to see a gist with some sample code i e old vs nw and what you could not do before In general I agree that retry is very primitive and that there is room for change Makes sense @headinthebox If look to top of RedoOperator java you ll see static methods that implement retry and repeat with infinite and finite limits It s probably hard to see through all the boilerplate @abersnaze @stealthcode Yes I find it rather hard to judge the API from those examples The type of the notification handler is pretty funky and does not appear in similar form in other places public static T Observable T retry Observable T source Func1 super Observable extends Notification extends Observable extends Notification notificationHandler Scheduler scheduler Just being able to define the existing functions is not enough so that s why I ask for a couple of small samples that show the expressive power of the operator For example can it express exponential backoff where you retry after n f n f f n seconds etc RxJava pull requests #1322 https netflixoss ci cloudbees com job RxJava pull requests 1322 FAILURE Looks like there s a problem with this pull request @akarnokd no problem writing up the gist was a good exercise and as a result I changed the notificationHandler to return Observable I am not sure that this is the best way to implement but it should get my point across https gist github com stealthcode 51c9527ed3a541e4f6e9 RxJava pull requests #1323 https netflixoss ci cloudbees com job RxJava pull requests 1323 FAILURE Looks like there s a problem with this pull request Thanks This precisely why I think this operator needs more bake time as a result I changed the notificationHandler to return Observable Who knows when we do the next example the signature will change again @headinthebox that was a very minor change in terms of this pull request I felt that it was too restrictive as @abersnaze also mentions Do you have any comments on the gist RxJava pull requests #1328 https netflixoss ci cloudbees com job RxJava pull requests 1328 FAILURE Looks like there s a problem with this pull request We are trying to close down the API so we at this point the bar for new operators is really high And the API is already really large In the NET version we has experimental operators that were under consideration for future versions so people could kick the tires The only downside in Java is that these would have to be static methods or operators that you can lift To go back to the sample given the amount of code it has I am not sure that this new operator makes life much easier than writing from scratch If you look at the diff from the original OperatorRetry to OperatorRedo you can see that this functionality is not easily achieved as a roll your own Given that the fundamental repeat and retry overloads still exist and are untouched and the only change in API is that we have removed an arguably superfluous retry Func2 Integer Throwable Boolean predicate I think the cost in API change is worth considering Also the code from the example is verbose deliberately but as @akarnokd suggested I wrote it demonstrating the functional versatility Still contemplating this one and discussing with @headinthebox I would however like to figure out a solution for retry repeat that allows back off delays and other such logic This solution does enable that We need to ensure the signature is something we are happy with forever though Agreed but I am not sure so I vote to start with this as a static method to see how it holds in real use and then add it later of course we will have to find another name but that is easy compared to getting the semantics we want The only thing I m concerned about with waiting is whether we plan on replacing the existing signature with this new one or someone keeping them both If we want to keep both this new one would need a different name than retry as it would collide with this https github com Netflix RxJava blob master rxjava core src main java rx Observable java#L5871 java public final Observable T retry Func2 Integer Throwable Boolean predicate return nest lift new OperatorRetryWithPredicate T predicate Yup we should find a new name I m pretty sure we can find a nice one if we dig a bit RxJava pull requests #1381 https netflixoss ci cloudbees com job RxJava pull requests 1381 FAILURE Looks like there s a problem with this pull request This branch can be merged with the ProducerIntToLong branch see pull request #1423 to be successfully merged to master Also note that I have added back the Func2 overload without problems A new name may not be necessary But if you think a new name is necessary I propose retryWhen and repeatWhen RxJava pull requests #1388 https netflixoss ci cloudbees com job RxJava pull requests 1388 SUCCESS This pull request looks good As the various issues I commented on are fixed I d like this to be rebased into a new PR with a single commit please Done via #1470 Done via #1470',RxJava,true,false,false
35045794,'Join patterns extension for 4 9 and N arity joins','Issue #1318 I made some potential breaking changes made classes final made most methods protected or package private','RxJava pull requests #1219 https netflixoss ci cloudbees com job RxJava pull requests 1219 SUCCESS This pull request looks good RxJava pull requests #1220 https netflixoss ci cloudbees com job RxJava pull requests 1220 FAILURE Looks like there s a problem with this pull request Wow that s a lot of typing Since this is a contrib module that you primarily manage I m assuming it s all good and merging',RxJava,true,false,false
35053725,Tuples,'For languages with Tuples use the native Tuple For use in other languages it might be worth introducing Tuples Also you should be able to pass Tuple to call in function which will further delegate this to the other call Also factory methods from collection which have been currently use in its place and being able to convert back to these structures Also to make sure none of what exits breaks and have the current alternatives if someone wants to avoid it altogether This would also be a compromise those who might not like the idea Also may be you can take this up in reactive streams so there is uniform tuple handling in different implementations','From what I understand RxJava does not want to introduce types to the package which I can totally understand So you can either use a language which supports them or create your own its pretty easy to do I admit that I ve been adding them to my own library as well since sometimes a Tuple2 is helpful I don t see the point of anything more than 3 4 with Java since that just gets complicated and value objects should be favoured instead An interesting read on this subject from Guava can be found here https code google com p guava libraries wiki IdeaGraveyard#Tuples_for_n_ _2 Generally we are avoiding tuples and similar things for reasons such as yet more custom types that should instead be provided by the language you re using object allocation overhead without value types on the JVM makes them costly generally better to just map into the final type you want rather than go via Tuple and then another type later this is unfortunately why materialize and the Notification type are less useful on the JVM than it could be due to the performance impact different platforms libraries and languages have various solutions already and we don t want to compete with those In short we try and add as few types as absolutely possible So why all the Func and Action types Because for those we didn t really have a choice We needed functional interfaces of some kind that we could target and the JVM offered nothing we could use Why did we do arities up to 9 It s totally arbitrary Even 9 seems silly in most cases Where does one stop We chose 9 Guava argues for going beyond 2 https code google com p guava libraries wiki IdeaGraveyard#Functions Predicates_for_n_ _2_inputs OK No worries',RxJava,false,false,false
35054359,'Making Joins Dynamic','Current implementation is very much static This might need re thinking to make this more dynamic as new stream connections open and close May be this can be done in multiple stages 1 Improve Current Static version 2 Build basic optimiser knowing the streams will not change 3 Add dynamic framework 4 Build a optimiser for this In Netflix context if the dynamic version is build this can be used for 1 CEP 2 Build and dynamically optimise the compositions transformation dataflow graph for the full reactive infrastructure fingers crossed might be orders magnitude faster than hand coded combinations and compositions','@sirinath What is your desired outcome of this issue cc @headinthebox Based on the variety of issues you have filed about joins are you interested in contributing to the rxjava joins https github com Netflix RxJava tree master rxjava contrib rxjava joins module',RxJava,false,false,false
35082089,'Adding an unzip operator to split 1 observable into N observables','This isn t ready for merging but should work for #1317 It s a naive implementation that bases the N observables off of ReplaySubject of the source','RxJava pull requests #1224 https netflixoss ci cloudbees com job RxJava pull requests 1224 SUCCESS This pull request looks good RxJava pull requests #1228 https netflixoss ci cloudbees com job RxJava pull requests 1228 SUCCESS This pull request looks good I ve changed the implementation to support unzipping an infinite Observable and it wasn t as easy as unzipping a finite stream with a replay subject It s implemented very much like multicast where there is a publish subject internally and on the Nth subscribe the ConnectableObservable is connected to let data flow to all of the sub observables at the same time without loosing data I m going to make this the official unzip implementation because the finite implementation easy for user to compose out of existing operators public static T R R unzipFinite Observable T source FuncN R unzipFunc final Func1 T selectFuncs Observable T cached source cache Object observables new Observable selectFuncs length for int i 0 i selectFuncs length i observables i cached map selectFuncs i return unzipFunc call observables one of you @headinthebox @akarnokd @sirinath want to review the code while I work on the javadocs I do question the actual use cases of this operator do we have any I don t understand the need for this why not simply use publish setup all mappings as necessary then connect to the source Or use public final R Observable R publish Func1 super Observable T extends Observable R selector Here is that implementation that @akarnokd talked about ConnectableObservable T connectable source publish Object observables new Observable selectFuncs length for int i 0 i selectFuncs length i observables i connectable map selectFuncs i R r unzipFunc call observables do stuff to subscribe the sub observables in R here connectable connect @headinthebox Using publish selector would lead to the unzip being an Observable Tuple Observable T1 Observable T2 which I guess isn t so bad Any sub observables not subscribed wouldn t register an subscriber with the subject I ll close the pull request because there seems to be enough alternatives to adding a new operator',RxJava,true,false,false
35117160,'Map flatMap Improvements','Following map flatMap mergeMap I am not sure whether this is needed on merge map Someone more familiar with this function can decide overloads and additions may be a good to have 1 Take n items from the stream and pass to Func n Can be a overload to map 2 Pre flatten any nested structure for types emitted by zip buffer and window and then pass it to Func N like in 1 above Have a option to recursively flatten to n levels separate function 3 If nesting structure is a types emitted by zip buffer and window and size of the item to match N in Func N test for 1st item and pass it to Func n else fall back to 2 above with 1 level of flattening separate function or overload of 2 if level is not specified','Above may be a over kill Following may be better 1 Have overloads for map family function with Func n 0 level of flattening 2 Have an overload with a level parameter which flattens before not after like in flat map any flattenable type not limited to observables or streams and pass to Func n 1 use buffer to get N at a time then compose with map to invoke a Func of N 2 can be done with merge if you have a nested structure recursive merging is not type safe sounds like too many overloads that can easily be done with composition @sirinath What is the use case As @abersnaze points out this sounds like buffer sure there you get a list instead of an argument list but if you really want you can locally transform T R to T R or window Note that in general in Rx when you focus on count you are missing time Which is often more interesting R So whenever you think N things also think for N ticks If it does not for both count and time goto R I think you guys are right on this on second thoughts What is needed is a delegate generator for iterators and streams E g static FuncN to arr func1 to give wrapped function of arity 1 The area that needs improvements is Func What are your thoughts on the following Func should have toArity1 Should have pipeForward pipeBackwards chainForward chainBackwards which calls toArity1 followed by pipe 1 or chain 1 Should have pipeForwardN pipeBackwardsN chainForwardN chainBackwardsN where N is the arity of the next function Should have from which takes a data structure collection streams etc passes it to function with the particular arity To be honest this sounds overly complex to me How does it reduce N args to 1 Pipe sounds like Obersvable map and chain like a subject This needs a bit of think through N to 1 is through tupling May be Erik might have a suggestion on this can be implemented elegantly @sirinath I like functions because of their simplicity the only thing you can do with them is apply them to arguments And without pattern matching and value types tuples are not very useful Lastly it is always better to leave things out http en wikipedia org wiki IPhone than to add loads of features http en wikipedia org wiki Windows_Mobile I agree with you totally on the above but doing the application is boiler plate which keeps repeating a lot Boilerplate is not very coder friendly Developer friendliness should rank above all else in my thinking @sirinath and @headinthebox Is there anything concrete to pursue here',RxJava,false,false,false
35120459,'IOSSchedulers for RoboVM','Added support for IOSchedulers for RoboVM I haven t added unit tests as 1 they can t be automated 2 they require the simulator It sucks I know and I m working on a way to automate this Apologies for the double PR had to rebranch','RxJava pull requests #1234 https netflixoss ci cloudbees com job RxJava pull requests 1234 SUCCESS This pull request looks good RxJava pull requests #1270 https netflixoss ci cloudbees com job RxJava pull requests 1270 SUCCESS This pull request looks good RxJava pull requests #1271 https netflixoss ci cloudbees com job RxJava pull requests 1271 SUCCESS This pull request looks good RxJava pull requests #1272 https netflixoss ci cloudbees com job RxJava pull requests 1272 SUCCESS This pull request looks good Thanks I ll get to this in the near future',RxJava,true,false,false
35160226,'Merge pull request #1 from Netflix master','Remote sync','RxJava pull requests #1235 https netflixoss ci cloudbees com job RxJava pull requests 1235 SUCCESS This pull request looks good',RxJava,true,false,false
35188776,'OperatorTake and others use of mutating non volatile fields','I d love some clarification on this issue Given say this observable java Observable range 1 1000 observeOn Schedulers computation take 500 why is the count in OperatorTake https github com Netflix RxJava blob master rxjava core src main java rx internal operators OperatorTake java not protected from access from multiple threads with the keyword volatile or using an AtomicInteger','Because the contract of an Observable is that is does not receive concurrent invocations of any on methods Anything producing data to it must either naturally be single threaded or serialize itself This allows an a Observer Subscriber to always write code that assumes single threaded behavior Thanks Ben I m happy with it not receiving concurrent invocations but is there not still the problem of the visibility of the count variable to the different threads I didn t think you needed concurrency to have a visibility problem just multiple threads On 7 Jun 2014 08 53 Ben Christensen notifications@github com wrote Because the contract of an Observable is that is does not receive concurrent invocations of any on methods Anything producing data to it must either naturally be single threaded or serialize itself This allows an a Observer Subscriber to always write code that assumes single threaded behavior Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1334#issuecomment 45391971 If multiple threads are invoking onNext then it is the responsibility of the Observable to ensure it is thread safe and that covers visibility This is why serialize exists if an Observable can not handle it itself So in my example serialize would be called between observe on and take On 7 Jun 2014 09 42 Ben Christensen notifications@github com wrote If multiple threads are invoking onNext then it is the responsibility of the Observable to ensure it is thread safe and that covers visibility This is why serialize exists if an Observable can not handle it itself Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1334#issuecomment 45394426 No you don t need it as each of those operators conforms to the Rx contract There is only 1 thread in your code ever invoking OperatorTake a single thread from the Scheduler computation event loop pool You should never have to use serialize unless you come across an Observable that does not comply with the contract I did see that when I tested that but didn t understand how the computation scheduler reused the same thread I expected to see different threads hitting the take I ll have to look closer at how the scheduler works That sounds very nifty I can say that I have seen multiple threads hitting my custom operator downstream of a parallel Is this expected behaviour On 7 Jun 2014 09 48 Ben Christensen notifications@github com wrote No you don t need it as each of those operators conforms to the Rx contract There is only 1 thread in your code ever invoking OperatorTake a single thread from the Scheduler computation event loop pool Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1334#issuecomment 45394706 ah woops I see my misunderstanding with the Scheduler it draws one thread from the pool of course I should have rephrased the question to use a parallel java Observable range 1 1000 parallel take 500 Yes with parallel it is expected to have multiple threads call onNext to take in your example It is thread safe in take due to it serializing the output via merge https github com Netflix RxJava blob master rxjava core src main java rx internal operators OperatorParallel java#L69 which does synchronization volatile that ensure visibility across threads Great Ben that will improve performance for my use case now that I can use non volatile mutable fields On 7 Jun 2014 10 24 Ben Christensen notifications@github com wrote Yes with parallel it is expected to have multiple threads call onNext to take in your example It is thread safe in take due to it serializing the output via merge https github com Netflix RxJava blob master rxjava core src main java rx internal operators OperatorParallel java#L69 which does synchronization volatile that ensure visibility across threads Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1334#issuecomment 45396112 All queries answered thanks',RxJava,false,false,false
35209810,'Bump build tools to 19 1 and android plugin to 0 11','This is to make the project compatible with Android Studio 0 6 x the latest release','RxJava pull requests #1242 https netflixoss ci cloudbees com job RxJava pull requests 1242 SUCCESS This pull request looks good',RxJava,true,false,false
35231154,'RxScala Add the rest missing methods to BlockingObservable','Some comments about this PR Changed the constructor from BlockingObservable T private scala val asJava rx observables BlockingObservable _ T to BlockingObservable T private scala val o Observable T so that we can implement logic in BlockingObservable Avoided to use toIterable to implement Option and OrElse because if some exception happens we can not unsubscribe the underlying Observable by Iterable at once cc @headinthebox @samuelgruetter','RxJava pull requests #1245 https netflixoss ci cloudbees com job RxJava pull requests 1245 SUCCESS This pull request looks good RxJava pull requests #1246 https netflixoss ci cloudbees com job RxJava pull requests 1246 SUCCESS This pull request looks good RxJava pull requests #1252 https netflixoss ci cloudbees com job RxJava pull requests 1252 SUCCESS This pull request looks good LGTM In this context why call toList something else I think we should have both toList and toSeq def toSeq Observable Seq T Observable jObsOfListToScObsOfSeq asJavaObservable toList Observable Seq T SI 7818 The reason why I changed toList to toSeq is that if RxJava gives us a java util List we want to convert it to something Scala ish without copying it and there s no non copying conversion from java util List to scala collection immutable List but there s a non copying conversion from java util List to scala collection mutable Buffer which is a subtype of scala collection Seq See JavaConversions http www scala lang org api current index html#scala collection JavaConversions for what conversions are possible I agree that having a toList method would be good but if we want to do it efficiently we should not implement it in terms of the Java toList and convert it to a Scala List by copying but we should implement toList in Scala using a scala collection mutable ListBuffer which provides constant time append and constant time toList RxJava pull requests #1275 https netflixoss ci cloudbees com job RxJava pull requests 1275 SUCCESS This pull request looks good Is this ready to be merged and released in 0 19 1 Is this ready to be merged and released in 0 19 1 imo yes @samuelgruetter Will you take adding proper toList and rename toList to toSeq @benjchristensen Sorry missed this yesterday So ready for 0 19 2 or do you want another change @headinthebox @headinthebox I m sorry I don t have time right now for toList toSeq I m leaving for Oregon http www cs uoregon edu research summerschool summer14 index html OK ill fix it over the weekend @headinthebox do you have time for this If no I can take it @zsxwing I won t say no to that go for it RxJava pull requests #1284 https netflixoss ci cloudbees com job RxJava pull requests 1284 SUCCESS This pull request looks good I added toSeq to BlockingObservable and deprecated toList I think toList is not necessary since people can always call toList on a Seq @headinthebox what do you think Honestly I actually don t care to much about toBlocking that is useful for small samples but other than than you should not use it If you look at Iterable T there is a whole bunch of toXXX and it it is those that I was after with toList except that of course in the context of Rx this returns an Observable List T So to make a long answer short I really want def toList Observable List T Note that if we would be pedantic one could argue its should be be toList in this case but that is probably too subtle a distinction scala def to Col _ Col A def toArray Array A def toBuffer B A Buffer B def toIndexedSeq immutable IndexedSeq A def toIterable Iterable A def toIterator Iterator A def toList List A def toMap T U Map T U def toParArray ParArray T def toSeq Seq A def toSet B A immutable Set B def toStream immutable Stream A def toString String def toTraversable Traversable A de toVector Vector A @headinthebox I removed the previous commit about toSeq and toList of BlockingObservable Since these toXXX methods are about Observable I think this PR can be merged now I will open another PR to add these toXXX ones to Observable RxJava pull requests #1285 https netflixoss ci cloudbees com job RxJava pull requests 1285 SUCCESS This pull request looks good',RxJava,true,false,false
35232924,'Make Future receive NoSuchElementException when the BlockingObservable is empty','Now Future get will return null if there is a single null in the BlockingObservable or it is empty People cannot distinguish between these two cases This PR has 2 breaking changes Throw an NoSuchElementException rather than returning null when the BlockingObservable is empty Change the exception from IllegalStateException to IllegalArgumentException when the BlockingObservable emits more than one items This is because I used single directly','RxJava pull requests #1247 https netflixoss ci cloudbees com job RxJava pull requests 1247 SUCCESS This pull request looks good RxJava pull requests #1248 https netflixoss ci cloudbees com job RxJava pull requests 1248 SUCCESS This pull request looks good RxJava pull requests #1249 https netflixoss ci cloudbees com job RxJava pull requests 1249 SUCCESS This pull request looks good',RxJava,true,false,false
35236655,'Add capacity hint version of Observable cache','Special case in ReplaySubject for create 1 to optimize for single emitted value Add unit tests for Observable cache 1 and ReplaySubject create 1 @benjchristensen is this the kind of solution you wanted for #1303','RxJava pull requests #1250 https netflixoss ci cloudbees com job RxJava pull requests 1250 SUCCESS This pull request looks good RxJava pull requests #1253 https netflixoss ci cloudbees com job RxJava pull requests 1253 SUCCESS This pull request looks good RxJava pull requests #1273 https netflixoss ci cloudbees com job RxJava pull requests 1273 SUCCESS This pull request looks good I m still not convinced the SingleItemReplayState is necessary since the purpose is to replay usually 2 values from a terminated ReplaySubject the ReplaySubject create 2 should suffice Otherwise consider using AsyncSubject as cache that supports exactly one onNext and onCompleted value This is the type of solution I m looking for but similar to @akarnokd I d like to spend more time playing with this before merging The key benefit of cache 1 is that we should be able to be far more efficient particularly in memory allocation However it s just a hint so we need to be able to fallback to a normal ReplaySubject if we receive more than 1 item unless instead of a hint we treat it as a bounded limit like cache only one item either the first or last I imagine it should be whatever the last item is in which case AsyncSubject is the solution I tried a perf test on this and it performs worse than the current one Benchmark nextRuns Mode Samples Score Score error Units r s ReplaySubjectPerf subscribeAfterEventsCount1 1 thrpt 5 4851118 717 561278 363 ops s r s ReplaySubjectPerf subscribeAfterEventsCount1 1000 thrpt 5 32461 932 4136 545 ops s r s ReplaySubjectPerf subscribeAfterEventsCount1 1000000 thrpt 5 29 969 5 547 ops s r s ReplaySubjectPerf subscribeAfterEventsUnbounded 1 thrpt 5 5177308 813 130344 185 ops s r s ReplaySubjectPerf subscribeAfterEventsUnbounded 1000 thrpt 5 39856 921 668 839 ops s r s ReplaySubjectPerf subscribeAfterEventsUnbounded 1000000 thrpt 5 39 072 0 681 ops s r s ReplaySubjectPerf subscribeBeforeEventsCount1 1 thrpt 5 3958112 525 53502 627 ops s r s ReplaySubjectPerf subscribeBeforeEventsCount1 1000 thrpt 5 33241 946 298 936 ops s r s ReplaySubjectPerf subscribeBeforeEventsCount1 1000000 thrpt 5 31 592 1 468 ops s r s ReplaySubjectPerf subscribeBeforeEventsUnbounded 1 thrpt 5 4096432 046 66617 860 ops s r s ReplaySubjectPerf subscribeBeforeEventsUnbounded 1000 thrpt 5 37350 668 1490 841 ops s r s ReplaySubjectPerf subscribeBeforeEventsUnbounded 1000000 thrpt 5 34 084 5 556 ops s Not merging this right now as the performance difference isn t significant enough within error thresholds for the added complexity One thing I haven t checked for is if the object allocation benefit is worth this Yeah I think less object allocations would be the only thing making this worthwhile Doing a smaller PR that just adds the capacity hint version of cache and forwarding that to the ReplaySubject might be a good idea though The only question is if cache 1 would make the ReplaySubject s capacity hint 1 or 2 2 probably makes most sense as a value and a terminal event is probably safe to assume Oh I missed that you already added the cache capacity hint method I guess the question about ReplaySubject capacity still stands though I guess the question about ReplaySubject capacity still stands though I think the only thing left to look at is whether we can optimize for reducing object allocations if we receive only 1 onNext a terminal event and whether it s worth it ArrayList 1 is already quite optimized but does have some extra overhead Not sure it s enough to matter though The complexity here is that because it is ReplaySubject and cache 1 is just a hint not the equivalent of take 1 we must be capable of growing if we do receive more than 1 Sorry if i wasn t clear I was just thinking that if cache 1 would produce two objects onNext terminal event in the common case If we simply do ReplaySubject 1 which becomes ArrayList 1 wouldn t there always be one array relocation when the terminal event happen Since both onNext values and the terminal event is stored in the same array',RxJava,true,false,false
35282265,'RxScala onErrorFlatMap','Why is the signature so weird def onErrorFlatMap U T resumeFunction Throwable Option Any Observable U','Do you mean U T or resumeFunction Throwable Option Any Observable U Throwable Option Any It s OnErrorThrowable in RxJava OnErrorThrowable actually is a tuple of error value However some error may be not associated with a value So here I used Option Any I d used a property of type Option Any so you can get at it via a real name instead of _2 and stay closer to RxJava but don t think it is such a big deal',RxJava,false,false,false
35287259,RxScala,'I thought we agreed to keep create to avoid confusion i e for those that watch the Coursera course and all @deprecated Use apply T Subscriber T Unit instead 0 17 0','Looks RxJava will remove create final OnSubscribeFunc T f in 1 0 So implement it in RxScala Since we cannot have both I think it is acceptable to use the same as RxJava create T f Subscriber T Unit It is really the meme Observable create that is important 1',RxJava,false,false,false
35287553,'RxScala Publish','It seems we cannot swap and curry the arguments of def publish U T R selector Observable U Observable R initialValue U Observable R since that causes ambiguity with def publish U T initialValue U ConnectableObservable U Interestingly NET does not have publish with a function and initial value','Looks like there s nothing we can do here https issues scala lang org browse SI 2383 But maybe swap order initialValue as first arg selector as second I was hoping to make type inference flow such that we don t need to write a type for the lambda parater Swapping them will not help with that I actually don t remember where we got that signature from in Java core Is there anything more to do for this or should we close it Keep it open Still experimenting to make this not require a type',RxJava,false,false,false
35288337,'RxScala Unit Unit','I found three places where there is a single argument of type Unit Should we replace those by Unit finallyDo doOnCompleted doOnTerminate','I think so I was actually a bit confused by the current definitions since nothing else I ve used in Scala worked with callbacks blocks the way it s currently defined Closing since the PR has been merged',RxJava,false,false,false
35303665,'RxScala mysterious comment in source','The source has a few occurrences of XXX Are they there for a reason i e magic trick to make the Scala compiler run twice as fast or just leftovers','I believe they are from @DavidMGross as placeholder for where Javadocs need work That s what I thought I m not going to jinx @DavidMGross Nope not my doing The placeholders I ve been adding lately are taking the form @warn some work needs done right about here I haven t added anything like XXX And I haven t been doing much of anything with the source inside of RxScala of course I could have used GIT powers to check that OK I ll eliminate them',RxJava,false,false,false
35315829,'schedulePeriodically cannot be unsubscribed from','The subscription returned by schedulePeriodically is automatically marked as unsubscribed when the first run terminates after queuing the next event As a result the periodic event cannot be unsubscribed from once the first call happens as unsubscribe will now be a no op as isUnsubscribed is true Example in the Scala REPL with the Java bindings for RxJava 0 19 scala import rx _ import rx functions _ import rx schedulers Schedulers import java util concurrent TimeUnit val s Schedulers io createWorker schedulePeriodically new Action0 override def call println In call 1 1 TimeUnit SECONDS s isUnsubscribed Here s isUnsubscribed returns false However if you wait one second it will return true and s unsubscribe will not do anything and the constant display will continue every second','',RxJava,false,false,false
35327891,'RxScala Simplify doOnCompleted Terminate finallyDo callback usage','As mentioned in #1342','RxJava pull requests #1255 https netflixoss ci cloudbees com job RxJava pull requests 1255 SUCCESS This pull request looks good LGTM Just mark this is a breaking change and should wait until 0 20 Is it really a breaking change I can t test it fully right now but both new and old code should work with this new signature Scala val o List red green blue toObservable doOnTerminate println terminate val o List red green blue toObservable doOnTerminate println terminate Sorry Never realized both two have the same signature in the JVM byte code until I used javap to take a look today',RxJava,true,false,false
35346941,'CombineLatestTests Refactorting','I am refactoring rxjava core test cases by adding some instance variables into CovarianceTest s several classes I found there is something unexpected @Test public void testCovarianceOfCombineLatest Observable HorrorMovie horrors Observable from new HorrorMovie 1L new HorrorMovie 2L Observable CoolRating ratings Observable from new CoolRating 1 new CoolRating 2 Observable Movie CoolRating Result combineLatest horrors ratings combine toBlocking forEach action Observable Media Rating ExtendedResult combineLatest horrors ratings combine toBlocking forEach extendedAction Observable Media Rating Result combineLatest horrors ratings combine toBlocking forEach action Observable Media Rating ExtendedResult combineLatest horrors ratings combine toBlocking forEach extendedAction Func2 Media Rating ExtendedResult combine new Func2 Media Rating ExtendedResult @Override public ExtendedResult call Media m Rating r return new ExtendedResult m r Action1 Result action new Action1 Result @Override public void call Result t1 assertEquals 2L t1 getMedia getId assertEquals 2 t1 getRating getRate Action1 ExtendedResult extendedAction new Action1 ExtendedResult @Override public void call ExtendedResult t1 assertEquals 2L t1 getMedia getId assertEquals 2 t1 getRating getRate The first assertion is always true while the second one is sometimes true sometimes false Will it be a potential bug','Find more test cases here OnSubscribeCombineLatestTest java close this issue',RxJava,false,false,false
35356842,'Allow use of the returned subscription to cancel periodic scheduling','The documentation for schedulePeriodically indicates that the returned subscription can be used to unsubscribe from the periodic action or to unschedule it if it has not been scheduled yet That was the case only before the first action took place and it was then impossible to unsubscribe using the given subscription although unsubscribing the worker did work This fixes #1344','RxJava pull requests #1257 https netflixoss ci cloudbees com job RxJava pull requests 1257 SUCCESS This pull request looks good This new version contains a fixed fix by @akarnokd RxJava pull requests #1258 https netflixoss ci cloudbees com job RxJava pull requests 1258 SUCCESS This pull request looks good Thank you',RxJava,true,false,false
35361621,'RxScala Recursive scheduling','Should we add support for recursive scheduling in RxScala The signature def schedule action Unit Subscription is very elegant for single shot work but recursive scheduling https github com Netflix RxJava wiki Scheduler is less nice','',RxJava,false,false,false
35374554,'buffer timespan timeshift raises IllegalArgumentException for timeshift 1 second','I m on 0 16 The following code will throw an IllegalArgumentException scala val obs Observable interval 100 milliseconds buffer 3 seconds 500 milliseconds obs rx lang scala Observable Seq Long rx lang scala JavaConversions anon 1@6f6b1731 scala obs subscribe x println x rx exceptions OnErrorNotImplementedException at rx Observable 25 onError Observable java 6805 at rx observers SafeSubscriber _onError SafeSubscriber java 124 at rx observers SafeSubscriber onError SafeSubscriber java 93 at rx Observable 2 call Observable java 280 at rx Observable 2 call Observable java 268 at rx Observable subscribe Observable java 7076 at rx Observable protectivelyWrapAndSubscribe Observable java 5396 at rx Observable subscribe Observable java 6796 at rx lang scala Observable class subscribe Observable scala 132 at rx lang scala JavaConversions anon 1 subscribe JavaConversions scala 53 at init console 14 at clinit console at init console 7 at clinit console at print console at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 57 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at java lang reflect Method invoke Method java 606 at scala tools nsc interpreter IMain ReadEvalPrint call IMain scala 734 at scala tools nsc interpreter IMain Request loadAndRun IMain scala 983 at scala tools nsc interpreter IMain loadAndRunReq 1 IMain scala 573 at scala tools nsc interpreter IMain interpret IMain scala 604 at scala tools nsc interpreter IMain interpret IMain scala 568 at scala tools nsc interpreter ILoop reallyInterpret 1 ILoop scala 756 at scala tools nsc interpreter ILoop interpretStartingWith ILoop scala 801 at scala tools nsc interpreter ILoop command ILoop scala 713 at scala tools nsc interpreter ILoop processLine 1 ILoop scala 577 at scala tools nsc interpreter ILoop innerLoop 1 ILoop scala 584 at scala tools nsc interpreter ILoop loop ILoop scala 587 at scala tools nsc interpreter ILoop anonfun process 1 apply mcZ sp ILoop scala 878 at scala tools nsc interpreter ILoop anonfun process 1 apply ILoop scala 833 at scala tools nsc interpreter ILoop anonfun process 1 apply ILoop scala 833 at scala tools nsc util ScalaClassLoader savingContextLoader ScalaClassLoader scala 135 at scala tools nsc interpreter ILoop process ILoop scala 833 at scala tools nsc MainGenericRunner runTarget 1 MainGenericRunner scala 83 at scala tools nsc MainGenericRunner process MainGenericRunner scala 96 at scala tools nsc MainGenericRunner main MainGenericRunner scala 105 at scala tools nsc MainGenericRunner main MainGenericRunner scala Caused by java lang IllegalArgumentException at java util concurrent ScheduledThreadPoolExecutor scheduleAtFixedRate ScheduledThreadPoolExecutor java 562 at rx schedulers ExecutorScheduler schedulePeriodically ExecutorScheduler java 75 at rx operators ChunkedOperation TimeBasedChunkCreator init ChunkedOperation java 579 at rx operators OperationBuffer 7 onSubscribe OperationBuffer java 360 at rx Observable 1 call Observable java 235 at rx Observable 1 call Observable java 231 at rx Observable 2 call Observable java 272 35 more Looking at the implementation of the scheduler the error is raised when the argument is less than zero So there appears to be a problem causing the timeshift to be rounded down If you change the timeshift to 1 second or larger it works fine','Good catch thanks for pointing it out The implementation uses timespan unit convert which is wrong because it might do rounding Appears several times in Observable scala Which is why I proposed to have public final Observable List T buffer long timespan long timeshift TimeUnit unit take two time units One for the timespan one for the timeshift Having just one is like having exchangeRate decimal from decimal to Currency unit Is someone going to fix anything about this and what is considered the right fix In RxScala it s fine to pursue new signatures but in Java we have already debated this and decided to stay with the Java contention of a single TimeUnit for the method I ll double check all uses of timespan in the scala bindings',RxJava,false,false,false
35446039,'Baseline Performance Tests','Start of suite of general performance tests for comparing overall changes','RxJava pull requests #1263 https netflixoss ci cloudbees com job RxJava pull requests 1263 SUCCESS This pull request looks good',RxJava,true,false,false
35449124,'Backpressure 3 Merge ObserveOn Not Production Ready','Here is a snapshot of working on backpressure This is NOT production ready and I m not all that happy with it right now bad performance pivot and parallel operators seem broken concurrency bugs with merge I think bad algorithm in merge need to replace data structures lists queues apparent memory leak in observeOn with Schedulers computation that causes JMH tests to fail on it gradlew benchmarks Pjmh f 1 tu s bm thrpt wi 5 i 5 r 2 prof GC rx usecases Master branch v0 19 Benchmark size Mode Samples Mean Mean error Units r u PerfBaseline forLoopConsumption 1 thrpt 5 379615485 594 15379754 350 ops s r u PerfBaseline forLoopConsumption 1024 thrpt 5 328864 473 18187 666 ops s r u PerfBaseline iterableViaForLoopConsumption 1 thrpt 5 253622547 509 27125669 781 ops s r u PerfBaseline iterableViaForLoopConsumption 1024 thrpt 5 188193 794 10372 260 ops s r u PerfBaseline iterableViaHasNextConsumption 1 thrpt 5 338153673 244 13436554 726 ops s r u PerfBaseline iterableViaHasNextConsumption 1024 thrpt 5 299124 445 28327 383 ops s r u PerfBaseline observableConsumption 1 thrpt 5 31394747 471 781746 789 ops s r u PerfBaseline observableConsumption 1024 thrpt 5 245864 811 6657 154 ops s r u PerfObserveOn observeOnComputation 1 thrpt 5 391499 859 18397 563 ops s r u PerfObserveOn observeOnComputation 1024 thrpt 5 13328 636 306 077 ops s r u PerfObserveOn observeOnImmediate 1 thrpt 5 21230728 918 892820 007 ops s r u PerfObserveOn observeOnImmediate 1024 thrpt 5 251638 525 3525 681 ops s r u PerfObserveOn observeOnNewThread 1 thrpt 5 21527 805 2739 158 ops s r u PerfObserveOn observeOnNewThread 1024 thrpt 5 10020 191 188 225 ops s r u PerfTransforms flatMapInt 1 thrpt 5 3564189 441 39217 324 ops s r u PerfTransforms flatMapInt 1024 thrpt 5 7093 382 179 934 ops s r u PerfTransforms flatMapNestedMapFilterTake 1 thrpt 5 2292314 964 137546 825 ops s r u PerfTransforms flatMapNestedMapFilterTake 1024 thrpt 5 17 375 0 430 ops s r u PerfTransforms mapIntStringInt 1 thrpt 5 9653977 591 122946 457 ops s r u PerfTransforms mapIntStringInt 1024 thrpt 5 19772 989 1649 906 ops s r u PerfTransforms mapPassThru 1 thrpt 5 19220291 170 1408394 928 ops s r u PerfTransforms mapPassThru 1024 thrpt 5 202820 081 27896 934 ops s With backpressure changes Benchmark size Mode Samples Mean Mean error Units r u PerfBaseline forLoopConsumption 1 thrpt 5 357110005 600 40841385 201 ops s r u PerfBaseline forLoopConsumption 1024 thrpt 5 323485 335 12560 808 ops s r u PerfBaseline iterableViaForLoopConsumption 1 thrpt 5 250763283 151 41052831 579 ops s r u PerfBaseline iterableViaForLoopConsumption 1024 thrpt 5 184443 933 17732 768 ops s r u PerfBaseline iterableViaHasNextConsumption 1 thrpt 5 328354319 566 20021232 226 ops s r u PerfBaseline iterableViaHasNextConsumption 1024 thrpt 5 295521 735 60981 106 ops s r u PerfBaseline observableConsumption 1 thrpt 5 9523326 320 1946455 684 ops s 9 5m vs 31 3m r u PerfBaseline observableConsumption 1024 thrpt 5 84990 974 4275 619 ops s r u PerfObserveOn observeOnComputation 1 thrpt 5 367281 334 88162 113 ops s 367k vs 391k r u PerfObserveOn observeOnComputation 1024 thrpt failed ran out of memory apparently see below r u PerfObserveOn observeOnImmediate 1 thrpt 5 7411354 828 1380680 011 ops s 7 4m vs 21 2m r u PerfObserveOn observeOnImmediate 1024 thrpt 5 83914 883 6175 528 ops s r u PerfObserveOn observeOnNewThread 1 thrpt 5 21795 495 696 339 ops s 21 7k vs 21 5k r u PerfObserveOn observeOnNewThread 1024 thrpt 5 15361 160 1052 314 ops s 15 3k vs 10k r u PerfTransforms flatMapInt 1 thrpt 5 1194526 066 91077 184 ops s 1 2m vs 3 6m r u PerfTransforms flatMapInt 1024 thrpt 5 1799 220 70 146 ops s r u PerfTransforms flatMapNestedMapFilterTake 1 thrpt 5 858432 448 135990 002 ops s 858k vs 2292k r u PerfTransforms flatMapNestedMapFilterTake 1024 thrpt 5 45 345 1 928 ops s 17 vs 45 something is wrong here on both r u PerfTransforms mapIntStringInt 1 thrpt 5 4433584 545 1336597 807 ops s 4 4m vs 9 6m r u PerfTransforms mapIntStringInt 1024 thrpt 5 17271 313 881 956 ops s r u PerfTransforms mapPassThru 1 thrpt 5 6098106 967 526635 319 ops s 6 1m vs 19 2m r u PerfTransforms mapPassThru 1024 thrpt 5 81472 209 5419 922 ops s r u PerfObserveOn observeOnComputation with size 1024 Iteration 1 1052 083 ops s GC wall time 2 952 secs GC time 2 945 secs GC 99 76 GC count 3 Iteration 2 161 619 ops s GC wall time 2 766 secs GC time 2 765 secs GC 99 96 GC count 3','RxJava pull requests #1264 https netflixoss ci cloudbees com job RxJava pull requests 1264 SUCCESS This pull request looks good @akarnokd If you have time and are interested in wading into the deep end on this one I d appreciate your involvement There are some very non trivial things here and I think it would be far better for us to work together and anyone else who wants to be involved rather than me keep it private and work towards solving them all by myself There are LOTS of things wrong with this code as I state in all of my comments above but I wanted to get the base functionality end to end to prove the APIs and flow of data which is more or less in place now I m sure there are functional bugs somewhere that I ve missed and I have not yet done zip but merge is the key one we need solved so I d like to focus on nailing that down and solving the problems I ve documented above and determining if we can get performance inline with 0 19 in the fast path cases where backpressure is not needed I migrated from ArrayBlockingQueue to SpscArrayQueue from the JCTools project and got good performance increases for RxSpscRingBuffer Using ArrayBlockingQueue Benchmark size Mode Samples Mean Mean error Units r i u PerfRingBuffer onNextConsume 100 thrpt 5 159236 300 7108 964 ops s r i u PerfRingBuffer onNextConsume 1023 thrpt 5 15615 351 953 520 ops s r i u PerfRingBuffer onNextPollLoop 100 thrpt 5 158659 665 7847 576 ops s r i u PerfRingBuffer onNextPollLoop 1000000 thrpt 5 17 495 0 246 ops s Using SpscArrayQueue Benchmark size Mode Samples Mean Mean error Units r i u PerfRingBuffer onNextConsume 100 thrpt 5 321948 603 9071 204 ops s r i u PerfRingBuffer onNextConsume 1023 thrpt 5 35104 267 1586 282 ops s r i u PerfRingBuffer onNextPollLoop 100 thrpt 5 324645 717 11050 170 ops s r i u PerfRingBuffer onNextPollLoop 1000000 thrpt 5 41 269 0 630 ops s RxJava pull requests #1265 https netflixoss ci cloudbees com job RxJava pull requests 1265 SUCCESS This pull request looks good RxJava pull requests #1266 https netflixoss ci cloudbees com job RxJava pull requests 1266 SUCCESS This pull request looks good @benjchristensen I m interested but currently my time is fully consumed by my professional work plus I haven t been able to wrap my head around the composition of the backpressure I understand from and range but not how it can be requested 1 2 steps down the line RxJava pull requests #1267 https netflixoss ci cloudbees com job RxJava pull requests 1267 SUCCESS This pull request looks good @akarnokd Not a problem if you get the time at some point let me know I ll keep pushing forward on improvements RxJava pull requests #1268 https netflixoss ci cloudbees com job RxJava pull requests 1268 ABORTED RxJava pull requests #1269 https netflixoss ci cloudbees com job RxJava pull requests 1269 SUCCESS This pull request looks good Replaced by https github com Netflix RxJava pull 1358',RxJava,true,false,false
35463977,'NullPointerException in','I ve been experimenting with the ReplaySubject see this gist for sample code https gist github com linead bceeeea54463a6faeeda In short I have 100 writer threads add Strings to the ReplaySubject and 100 reader threads blocking to filter out a random entry and return I m getting the following exception java lang NullPointerException at rx subjects ReplaySubject BoundedState acceptTest ReplaySubject java 491 at rx subjects ReplaySubject BoundedState replayObserverFromIndexTest ReplaySubject java 522 at rx subjects ReplaySubject TimedOnAdd call ReplaySubject java 740 at rx subjects ReplaySubject TimedOnAdd call ReplaySubject java 726 at rx subjects SubjectSubscriptionManager call SubjectSubscriptionManager java 59 at rx subjects SubjectSubscriptionManager call SubjectSubscriptionManager java 35 at rx Observable 2 call Observable java 159 at rx Observable 2 call Observable java 155 at rx Observable 2 call Observable java 159 at rx Observable 2 call Observable java 155 at rx Observable 2 call Observable java 159 at rx Observable 2 call Observable java 155 at rx Observable 2 call Observable java 159 at rx Observable 2 call Observable java 155 at rx Observable 2 call Observable java 159 at rx Observable 2 call Observable java 155 at rx Observable subscribe Observable java 6842 at rx internal operators BlockingOperatorToIterator toIterator BlockingOperatorToIterator java 49 at rx observables BlockingObservable getIterator BlockingObservable java 151 at rx observables BlockingObservable 2 iterator BlockingObservable java 433 at rx observables BlockingObservable single BlockingObservable java 348 at rx observables BlockingObservable first BlockingObservable java 165 at GuiceTest Reader run GuiceTest java 103 at java lang Thread run Thread java 724 If there s a better way to populate the Subject to avoid this behaviour please let me know this exception seems to be mitigated if there s less contention on the Subject','You need to serialize access to Subjects i e you are not allowed to call onNext on any Observer or Subject concurrently Wrap your message with SerializedObserver java final ReplaySubject String messages ReplaySubject createWithTime 20 TimeUnit SECONDS Schedulers io final SerializedObserver String messagesSerial new SerializedObserver String messages for int i 0 i 100 i new Thread new Writer messagesSerial i start for int i 0 i 100 i new Thread new Reader messages i start private class Writer implements Runnable private final Observer String messages private final int count public Writer Observer String messages int i this messages messages this count i @Override public void run int val count int iter 0 while true iter messages onNext Message # val val count if iter 10 break System out println Done Great thought it would be something simple like that Thanks for the quick response The reason we don t make everything thread safe by default is that everything would then pay the cost The assumption is that the origin complies with the Rx contract and if it doesn t or can t the SerializedObserver and serialize operators are there to enforce it',RxJava,false,false,false
35519918,'Make operator parameter names consistent across operators','I recommend that some of the parameter names used in Observable operators be changed so that similar parameters have similar names from operator to operator Specifically #### Collections of Observables An iterable list or array of Observables is called sources in amb and combineLatest sequences in merge and ws in zip I recommend standardizing on observables as the parameter name for these #### Observables that emit Observables An Observable that emits Observables is called observables in concat source in merge mergeDelayError and parallelMerge sequenceOfSequences in switchOnNext and ws in zip I recommend standardizing on observables as the parameter name for these #### Ordinary Observable Some operators take an ordinary Observable as a parameter The zip operator calls the Observable that you pass as a parameter to zip with the source Observable other the groupJoin and join operators use the parameter name right to describe a similar thing I recommend standardizing on other for this #### Multiple Observables Some operators take two or more Observables as parameters amb combineLatest and zip call these o1 o2 o3 etc concat merge and mergeDelayError call these t1 t2 t3 etc sequenceEqual calls these first and second My recommendation for at least the operators in the first two bullet points choose a single naming scheme and standardize over it for all of those operators #### Special Function Observables Some operators are passed Observables that emit indicators that instruct the operators to do certain things at certain times The naming schemes for these could be improved Currently buffer opening indicator bufferOpenings closing indicator bufferClosingSelector boundary indicator boundary window opening indicator windowOpenings closing indicator closingSelector boundary indicator boundary My recommendation for both opening indicator openingIndicator closing indicator closingIndicator boundary indicator boundaryIndicator I also recommend changing the names of the following parameters so that they conform to a similar naming scheme durationSelector leftDuration rightDuration groupByUntil leftDurationSelector rightDurationSelector join other skipUntil and takeUntil firstTimeoutSelector and timeoutSelector timeout debounceSelector debounce sampler sample There are also the two functions that _generate_ Observables that emit indicators subscriptionDelay and itemDelay from delay and the function that generates an Observable that emits closing indicators closingSelector from window #### Observables that act as back up sequences Observables that are meant to supply items in case of failure in a primary Observable are called resumeSequence in onError ExceptionrResumeNext and other in timeout I recommend standardizing on a single parameter name for these #### Number of repetitions repeat uses count to indicate how many times the items should be repeated retry uses retryCount to indicate how many times to attempt to retry Recommendation either use count for both or change the first one to repeatCount #### Numbers of items to skip emit or observe You can instruct some operators to ignore a certain number of items emitted by an observable You indicate this number with skip buffer and window num skip or count skipLast I recommend standardizing on skip for all three You can also instruct some operators to attend to or to emit a particular number of items emitted by an observable You indicate this number with num limit and take or count buffer range takeLast takeLastBuffer and window I recommend standardizing on one or the other for all of these operators #### Durations Several operators have parameters that indicate durations of time There are currently at least eight parameter names for parameters indicating duration I recommend this be reduced not necessarily to one but to fewer Here are the current ones timespan buffer window timeout debounce from throttleWithTimeout timeout interval interval time replay skip skipLast take takeLast takeLastBuffer period sample timer windowDuration and skipDuration throttleFirst intervalDuration throttleLast There are also several operators that have parameters related to shifting things forward in time or delaying things in time There are three names for these parameters now one or maybe two are probably sufficient timeshift buffer window delay delay delaySubscription initialDelay timer There is a single inconsistency in the parameter for indicating the time unit This is called unit everywhere except in timeout where it is called timeUnit I recommend changing it to unit there as well #### Schedulers The parameter indicating which Scheduler to use is called scheduler everywhere except for the parallel operator where it is called s I recommend changing it to scheduler there as well #### Items emitted by Observables There are many names used for the parameters that describe an item emitted or to be emitted by an Observable for instance element contains and value just also t1 startWith and initialValue publish reduce BlockingObservable mostRecent for an item to emit as the first emission and defaultValue many operators for an item to emit if there were no emitted items from the source or none that met a predicate I ve been using item in the wiki javadocs to describe things emitted from Observables rather than value element or object This is because Observables can emit lots of sorts of things e g objects elementals additional Observables and usually in the documentation the important thing about these emissions is _that_ they re emissions rather than that they re a particular sort of thing Item is a less misleading vague specifier for such emissions For this reason I recommend that the parameter names also standardize on the item terminology so element and value become item t1 and initialValue become initialItem defaultValue becomes defaultItem There are also a few different names for parameters describing _arrays_ of items t1 from items from values startWith I recommend consolidating these into items #### Collectors and accumulators Are collectors and accumulators two different sorts of things or pretty much the same sort of thing collect calls its function a collector while reduce and scan call theirs an accumulator I m not certain whether these are distinct enough things to necessitate distinct terminology #### Functions that transform items emitted by Observables The following are used as parameter names for passing functions that are meant to transform items emitted by Observables valueSelector groupByUntil toMap toMultiMap func map selector multicast publish publishLast replay I recommend standardizing on a single name and considering something other than selector since these functions aren t really selecting items so much as _changing_ them #### Functions that combine multiple items emitted by Observables to create single items The following parameter names describe functions that take items emitted by multiple Observables and operate on them to generate a single new item to be emitted combineFunction combineLatest resultSelector groupByUntil join mergeMap mergeMapIterable zipFunction zip I recommend standardizing on a single name for all of these and again I m not sold on the selector terminology #### Functions that generate Observables There are a number of parameters that describe functions that generate Observables func concatMap flatMap mergeMap switchMap collectionSelector mergeMap observableFactory defer using resumeFunction onErrorFlatMap onErrorResumeNext My recommendation change func to something more descriptive and see if you can consolidate some of these others as well #### On State actions functions doOnCompleted and mergeMap have onCompleted parameters forEach and subscribe call their parameters onComplete Recommendation change forEach and subscribe to use onCompleted so as to better match the name of the Observer method finallyDo takes a parameter called action most other operators of this sort take parameters of the form onSomething e g onTerminate onNotification onNext Recommendation change the name of this parameter to use an onSomething form #### Iterables from calls its Iterable parameter iterable zip calls it other Recommendation change zip to match from in this respect #### Number of Observables to deal with at once merge uses maxConcurrent and parallelMerge uses parallelObservables as their parameter names for the parameter describing how many Observables to deal with at once a single name might work for both or if not two names with similar structures','Great notes @DavidMGross One remark from my side I would like to stay as close as possible to the original Rx NET names as we can http msdn microsoft com en us library system reactive linq observable v vs 103 aspx even if it is a bit suboptimal for instance for buffer http msdn microsoft com en us library hh229621 v vs 103 aspx Then we can maintain some uniformity in Rx across the different languages without creating a tower of Babel Of course one can also argue to use the same parameter names as Java streams if there is a match Besides that I am all for improving parameter names and making them more uniform Note that in Scala everything is called f and g etc to match the local style Nothing to gain there LIKE @DavidMGross Seems like a good idea @headinthebox If we see inconsistencies in the Rx NET parameter names what s the plan @benjchristensen Then let s make a list of those so we can see whats going on and relay back to the NET folks and Js C Beaut On 22 Jun 2014 19 04 headinthebox notifications@github com wrote Then let s make a list of those so we can see whats going on and relay back to the NET folks and Js C Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1353#issuecomment 46775923 Anyone want to tackle this I would ignore the Rx NET parameter names since parameter names themselves do not affect the public API so it doesn t affect functionality or uniformity @headinthebox parameter name is more important in RxScala since changing parameter names will break the source compatibility Therefore do you think if it s worth to review the names in RxScala and make them consistent Yes but let s make them consistent with the Scala libraries instead i e def map R func T R Observable R should be def map B f A B Observable B and filter predicate T Boolean Observable T should be filter p T Boolean Observable T to be consistent with the native Scala style as in say http www scala lang org api current index html#scala collection Iterable So I guess that means lots of alpha renaming of S T A B and using f g and h and op Makes sense',RxJava,false,false,false
35529113,'NPE in pollQueue','Since using 0 19 I see some sporadic NPEs where the complete stack trace contains only rx methods Therefore I cannot really say what conditions in our code trigger that NPE 06 11 23 18 24 060 E AndroidRuntime 15279 java lang NullPointerException 06 11 23 18 24 060 E AndroidRuntime 15279 at rx internal operators OperatorObserveOn ObserveOnSubscriber pollQueue OperatorObserveOn java 135 06 11 23 18 24 060 E AndroidRuntime 15279 at rx internal operators OperatorObserveOn ObserveOnSubscriber access 000 OperatorObserveOn java 61 06 11 23 18 24 060 E AndroidRuntime 15279 at rx internal operators OperatorObserveOn ObserveOnSubscriber 1 call OperatorObserveOn java 121 06 11 23 18 24 060 E AndroidRuntime 15279 at rx android schedulers HandlerThreadScheduler InnerHandlerThreadScheduler 1 run HandlerThreadScheduler java 77 06 11 23 18 24 060 E AndroidRuntime 15279 at android os Handler handleCallback Handler java 733 06 11 23 18 24 060 E AndroidRuntime 15279 at android os Handler dispatchMessage Handler java 95 06 11 23 18 24 060 E AndroidRuntime 15279 at android os Looper loop Looper java 136 06 11 23 18 24 060 E AndroidRuntime 15279 at android app ActivityThread main ActivityThread java 5144 06 11 23 18 24 060 E AndroidRuntime 15279 at java lang reflect Method invokeNative Native Method 06 11 23 18 24 060 E AndroidRuntime 15279 at java lang reflect Method invoke Method java 515 06 11 23 18 24 060 E AndroidRuntime 15279 at com android internal os ZygoteInit MethodAndArgsCaller run ZygoteInit java 795 06 11 23 18 24 060 E AndroidRuntime 15279 at com android internal os ZygoteInit main ZygoteInit java 611 06 11 23 18 24 060 E AndroidRuntime 15279 at dalvik system NativeStart main Native Method','Hi I can t see anything obviously wrong with the ObserveOn it appears either vs is null or the vs array is null which both should be impossible since vs is never set to null and vs array should contain an object array with at least a single value because the pollQueue is executed only after it has gained its first item So either the AtomicLongFieldUpdater on Android doesn t behave correctly or JIT compilation generates incorrect code or memory fences @akaranokd what if onNext is called twice at the same time Wouldn t that cause a race condition where both could execute their queue add successively since this part of code is synchronized one of them would execute its schedule which calls pollQueue which empties the list then the other does the same while the list is now empty If Murphy s law kicks in and one of the onNext is stopped for some time right before schedule I don t immediately see anything to prevent this I m not sure this can happen though as COUNTER_UPDATER would have gone to 1 at this time and a new pollQueue should not be scheduled as the initial state of the counter is not 0 You re right The queue is of length 2 and the counter is decremented to 1 by pollQueue and then incremented to 0 by onNext without scheduling another pollQueue Due to 1 and the after addAndGet it doesn t quit and now reads a FastList with null array Changing the 0 to 0 should fix the problem I can t do a PR until Monday I can do one in order to get some reviews and I think you mean 0 or you want to put the test in the while part which also makes sense and seems even more readable to me #1360',RxJava,false,false,false
35569743,'Don t add the subscriber to the manager if it unsubscribed during the on','Start call This may happen for example when subscribing to a ReplaySubject containing some elements and taking fewer elements than available In the original the logic opened a small window where the SubjectSubscriber could get an onNext event even if the actual Subscriber was already unsubscribed at that point','RxJava pull requests #1274 https netflixoss ci cloudbees com job RxJava pull requests 1274 SUCCESS This pull request looks good',RxJava,true,false,false
35578074,'wiki broken link','The main wiki page https github com Netflix RxJava wiki has a broken link to https github com Netflix RxJava wiki How To Use#composition composing flows and sequences of asynchronous data','cc @DavidMGross Good catch Thanks for the note I ll make the correction On Thu Jun 12 2014 at 10 01 AM Ben Christensen notifications@github com wrote cc @DavidMGross https github com DavidMGross Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1356#issuecomment 45919028 David M Gross PLP Consulting',RxJava,false,false,false
35605560,'MergeWith ConcatWith AmbWith','Single arity instance versions of merge concat and amb Since we can t use the merge concat amb names on both static and instance methods these have the With suffix which actually reads quite well java o mergeWith o2 subscribe ts o concatWith o2 subscribe ts o ambWith o2 subscribe ts If we feel the need for more arities fine but I wanted to start simple This originated from discussions with @headinthebox and over a year of wanting instance methods for merge','RxJava pull requests #1276 https netflixoss ci cloudbees com job RxJava pull requests 1276 SUCCESS This pull request looks good Like',RxJava,true,false,false
35647156,'Backpressure 4 Merge ObserveOn Not Production Ready','Further progress on top of https github com Netflix RxJava pull 1351 that adds object pooling of ring buffers and various improvements while looking at performance Next is to redo the merge implementation that I m not happy with Pivot and parallel operators seem broken concurrency bugs with merge I think Still have performance problems gradlew benchmarks Pjmh f 1 tu s bm thrpt wi 5 i 5 r 2 prof GC rx usecases PerfBaseline Benchmark size Mode Samples Mean Mean error Units r u PerfBaseline observableConsumption 1 thrpt 5 29341887 334 1377398 290 ops s r u PerfBaseline observableConsumption 1024 thrpt 5 235288 206 36803 980 ops s r u PerfBaseline observableViaRange 1 thrpt 5 10995116 886 851761 135 ops s r u PerfBaseline observableViaRange 1024 thrpt 5 83175 180 2983 626 ops s vs 0 19 Benchmark size Mode Samples Mean Mean error Units r u PerfBaseline observableConsumption 1 thrpt 5 31394747 471 781746 789 ops s r u PerfBaseline observableConsumption 1024 thrpt 5 245864 811 6657 154 ops s','RxJava pull requests #1277 https netflixoss ci cloudbees com job RxJava pull requests 1277 SUCCESS This pull request looks good The observableConsumption case which tests a firehose without backpressure appears to be inline Benchmark size Mode Samples Mean Mean error Units r u PerfBaseline observableConsumption 1 thrpt 5 30114136 836 434909 305 ops s r u PerfBaseline observableConsumption 1024 thrpt 5 244266 777 7570 678 ops s vs master Benchmark size Mode Samples Mean Mean error Units r u PerfBaseline observableConsumption 1 thrpt 5 30779288 887 1910282 467 ops s r u PerfBaseline observableConsumption 1024 thrpt 5 240332 800 8839 365 ops s This is good as it means the basics of Subscriber and Observable are not affected Run test with gradlew benchmarks Pjmh f 1 tu s bm thrpt wi 5 i 5 r 2 prof GC rx usecases PerfBaseline observableConsumption RxJava pull requests #1278 https netflixoss ci cloudbees com job RxJava pull requests 1278 SUCCESS This pull request looks good RxJava pull requests #1280 https netflixoss ci cloudbees com job RxJava pull requests 1280 SUCCESS This pull request looks good Nice Pay when use RxJava pull requests #1286 https netflixoss ci cloudbees com job RxJava pull requests 1286 SUCCESS This pull request looks good RxJava pull requests #1287 https netflixoss ci cloudbees com job RxJava pull requests 1287 SUCCESS This pull request looks good RxJava pull requests #1288 https netflixoss ci cloudbees com job RxJava pull requests 1288 SUCCESS This pull request looks good RxJava pull requests #1289 https netflixoss ci cloudbees com job RxJava pull requests 1289 ABORTED Replaced by https github com Netflix RxJava pull 1366',RxJava,true,false,false
35649788,'Fixed padding of the integer and node classes','Added proper padding of MpscLinkedQueue and PaddedAtomicInteger based on Netty s implementation Note that each padded class now occupies 256 bytes which translates to either 2 or 4 cache lines to avoid false sharing in both before and after the actual value and to avoid adjacent cache line fetch effects For issue #1310','RxJava pull requests #1279 https netflixoss ci cloudbees com job RxJava pull requests 1279 SUCCESS This pull request looks good',RxJava,true,false,false
35732121,'NPE in OperatorObserveOn RxJava 0 19','One of my production user got the following NullPointerException Environment rxjava android 0 19 0 Android 4 4 2 Device GT I9505 java lang NullPointerException at rx internal operators OperatorObserveOn ObserveOnSubscriber pollQueue OperatorObserveOn java 135 at rx internal operators OperatorObserveOn ObserveOnSubscriber access 000 OperatorObserveOn java 61 at rx internal operators OperatorObserveOn ObserveOnSubscriber 1 call OperatorObserveOn java 121 at rx android schedulers HandlerThreadScheduler InnerHandlerThreadScheduler 1 run HandlerThreadScheduler java 77 at android os Handler handleCallback Handler java 733 at android os Handler dispatchMessage Handler java 95 at android os Looper loop Looper java 157 at android app ActivityThread main ActivityThread java 5356 at java lang reflect Method invokeNative Method java at java lang reflect Method invoke Method java 515 at com android internal os ZygoteInit MethodAndArgsCaller run ZygoteInit java 1265 at com android internal os ZygoteInit main ZygoteInit java 1081 at dalvik system NativeStart main NativeStart java','I forgot the nice share Crashlytics feature http crashes to s a5ab97ddcfc for complete details See #1354 You may want to comment on #1361 which should fix that issue @niqo01 this should be fixed since 0 19 2 Do you still have the issue @benjchristensen keep an eye on this issue since we might want to close once we confirm the issue is fixed The observeOn operator is changed significantly in 0 20 so can anyone review and confirm whether this is still fixed in 0 20 0 RC3 or later @dpsm I don t know how to reproduce myself the only way I see is to deliver an update in production and wait and see our crash report tools I ll update to 0 20 release and let you know if I see it again',RxJava,false,false,false
35738850,'Fix a race condition if queued actions have been handled already','This should fix #1354 Cc @Bananeweizen @akarnokd','RxJava pull requests #1281 https netflixoss ci cloudbees com job RxJava pull requests 1281 SUCCESS This pull request looks good Looking good to me Okay with me as well Note that in v0 20 if we accept the backpressure changes being worked on this class will get modified again and need a thorough review Thanks for this fix',RxJava,true,false,false
35744614,'RxScala Fix #1340 and #1343','Implement create for #1340 Remove XXX for #1343 cc @headinthebox @samuelgruetter','RxJava pull requests #1282 https netflixoss ci cloudbees com job RxJava pull requests 1282 SUCCESS This pull request looks good',RxJava,true,false,false
35746397,'Fix the bug that single may unsubscribe the whole Subscription chain incorrectly','Decoupled the parent and child Subscribers to fix this bug','RxJava pull requests #1283 https netflixoss ci cloudbees com job RxJava pull requests 1283 SUCCESS This pull request looks good Many operators are implemented this way i e sharing the same underlying composite and calling unsubscribe on error merge concat zip etc I warned about the sharing before but I was told one should not spawn an async task after onCompleted or onError in this case The single operator should not have to do anything here It is subscribeOn that should handle scheduling and decoupling if needed Closed it because it s not a correct fix You can apply the same logic in subscribeOn as here java final Worker inner scheduler createWorker subscriber add inner Subscriber Observable T s new Subscriber Observable T @Override public void onCompleted ignore because this is a nested Observable and we expect only 1 Observable T emitted to onNext @Override public void onError Throwable e subscriber onError e @Override public void onNext final Observable T o inner schedule new Action0 @Override public void call o unsafeSubscribe subscriber subsciber add s return s',RxJava,true,false,false
35762786,'Why BehaviorSubject requires default value','I often need BehaviorSubject that don t have default value and should not spawn values until first value is supplied Currently as a workaround I initialize it with null and provide access to it after filter that ignores null value Which looks ugly java private BehaviorSubject Location locationUpdateSubject BehaviorSubject create Location null public Observable Location getLocationUpdates return locationUpdateSubject filter new Func1 Location Boolean @Override public Boolean call Location location return location null','Hi A parameterless create has been already added to BehaviorSubject with v0 19',RxJava,false,false,false
35832555,'Exception in the inner observable of flatMap not rethrown','Hi all I m trying to figure out how errors are handled in RxJava 0 19 1 Basically I d expect the fundamental rule to be something like Any exception thrown within an operator is either handed to the onError handler of subscribe if one is provided or rethrown if none is provided This works for the map operator scala def throwOnB2 prefix String Observable from List 1 2 3 map x prefix x toString map s if s b2 throw new Exception Bang else s throwOnB2 b subscribe next println next throws a rx exceptions OnErrorNotImplementedException Bang as expected scala throwOnB2 b subscribe next println next err println s error err println completed prints error java lang Exception Bang as expected For nested observables joined using flatMap scala def nested Observable from List a b c flatMap prefix throwOnB2 prefix nested subscribe next println next err println s error err println completed prints error java lang Exception Bang as expected But scala nested subscribe next println next prints a1 a2 a3 b1 and finishes without throwing any exception Is this the intended behavior For me it is quite unfortunate since bugs in my code can easily slip away unnoticed but perhaps there is something I don t see Thank you best regards','@dvtomas Good catch',RxJava,false,false,false
35846796,'Backpressure 5 Merge ObserveOn SubscribeOn etc','Mostly functional backpressure with merge and observeOn Pivot and Parallel operators have issues and unit tests and ignored This is NOT production ready Need to work on algorithms in merge data structures and concurrency implementations Performance of flatMap compared with 0 19 gradlew benchmarks Pjmh f 1 tu s bm thrpt wi 5 i 5 r 2 prof GC rx usecases PerfObserveOn observeOnComputation Current Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapInt 1 thrpt 5 1513055 461 35120 889 ops s r u PerfTransforms flatMapInt 1024 thrpt 5 2229 818 50 863 ops s r u PerfTransforms flatMapNestedMapFilterTake 1 thrpt 5 1114912 405 137096 910 ops s r u PerfTransforms flatMapNestedMapFilterTake 1024 thrpt 5 82 799 1 695 ops s 0 19 master Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapInt 1 thrpt 5 3372557 564 131729 592 ops s r u PerfTransforms flatMapInt 1024 thrpt 5 6713 975 159 005 ops s r u PerfTransforms flatMapNestedMapFilterTake 1 thrpt 5 2231392 499 50190 297 ops s r u PerfTransforms flatMapNestedMapFilterTake 1024 thrpt 5 16 437 0 413 ops s java input observable flatMap i return Observable from i subscribe input observer Current Run 10 1 697 014 ops sec Run 11 1 675 210 ops sec Run 12 1 781 483 ops sec Run 13 1 674 677 ops sec Run 14 1 714 354 ops sec vs 0 19 Run 10 2 809 225 ops sec Run 11 3 051 850 ops sec Run 12 3 100 006 ops sec Run 13 3 007 699 ops sec Run 14 3 114 585 ops sec','If anyone is interested in figuring out how to make the merge operator perform better I d appreciate your help RxJava pull requests #1290 https netflixoss ci cloudbees com job RxJava pull requests 1290 SUCCESS This pull request looks good RxJava pull requests #1291 https netflixoss ci cloudbees com job RxJava pull requests 1291 SUCCESS This pull request looks good RxJava pull requests #1294 https netflixoss ci cloudbees com job RxJava pull requests 1294 SUCCESS This pull request looks good The last commit improves performance quite a big on merge and flatMap almost getting it back to 0 19 Before Run 10 1 697 014 ops sec Run 11 1 675 210 ops sec Run 12 1 781 483 ops sec Run 13 1 674 677 ops sec Run 14 1 714 354 ops sec After Run 10 2 474 757 ops sec Run 11 2 491 652 ops sec Run 12 2 481 759 ops sec Run 13 2 491 963 ops sec Run 14 2 706 213 ops sec Before Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapInt 1 thrpt 5 1513055 461 35120 889 ops s r u PerfTransforms flatMapInt 1024 thrpt 5 2229 818 50 863 ops s r u PerfTransforms flatMapNestedMapFilterTake 1 thrpt 5 1114912 405 137096 910 ops s r u PerfTransforms flatMapNestedMapFilterTake 1024 thrpt 5 82 799 1 695 ops s After Benchmark size Mode Samples Mean Mean error Units r u PerfTransforms flatMapInt 1 thrpt 5 2435788 713 81926 617 ops s r u PerfTransforms flatMapInt 1024 thrpt 5 3116 816 326 367 ops s r u PerfTransforms flatMapNestedMapFilterTake 1 thrpt 5 1833742 000 174429 120 ops s r u PerfTransforms flatMapNestedMapFilterTake 1024 thrpt 5 83 968 3 688 ops s Interesting hot method that can be explored screen shot 2014 06 17 at 11 54 01 am https cloud githubusercontent com assets 813492 3305315 83e255a0 f654 11e3 8a40 8300882152f9 png For the flatMap use case critical path for most systems hence the focus here are object allocations hot spots LinkedList from SubscriptionList screen shot 2014 06 17 at 12 16 51 pm https cloud githubusercontent com assets 813492 3305324 ab418b02 f654 11e3 99a7 928fdfc3e0c7 png SubscriptionList from Merge InnerSubscriber screen shot 2014 06 17 at 12 17 56 pm https cloud githubusercontent com assets 813492 3305376 f2baea00 f654 11e3 8250 88e8a4fd5ad6 png Merge InnerSubscriber screen shot 2014 06 17 at 12 17 03 pm https cloud githubusercontent com assets 813492 3305332 b73a7662 f654 11e3 877e 6f4877522d04 png Node via ObjectPool screen shot 2014 06 17 at 12 17 25 pm https cloud githubusercontent com assets 813492 3305334 c2ff3384 f654 11e3 8b15 fbae66a24ec9 png Node via ConcurrentLinkedNode screen shot 2014 06 17 at 12 17 39 pm https cloud githubusercontent com assets 813492 3305342 cb7be02a f654 11e3 8592 abfab9d1c131 png RxJava pull requests #1296 https netflixoss ci cloudbees com job RxJava pull requests 1296 SUCCESS This pull request looks good RxJava pull requests #1297 https netflixoss ci cloudbees com job RxJava pull requests 1297 SUCCESS This pull request looks good RxJava pull requests #1298 https netflixoss ci cloudbees com job RxJava pull requests 1298 SUCCESS This pull request looks good RxJava pull requests #1299 https netflixoss ci cloudbees com job RxJava pull requests 1299 SUCCESS This pull request looks good Replaced by https github com Netflix RxJava pull 1371',RxJava,true,false,false
35859978,'Fix the bug that flatMap swallows OnErrorNotImplementedException','Fixed #1365 Not sure if any other place will swallow OnErrorNotImplementedException or the fatal errors','RxJava pull requests #1292 https netflixoss ci cloudbees com job RxJava pull requests 1292 SUCCESS This pull request looks good RxJava pull requests #1293 https netflixoss ci cloudbees com job RxJava pull requests 1293 SUCCESS This pull request looks good',RxJava,true,false,false
35894910,'From RxJava Observable to RxScala Observable','Hey scala folks I m relatively new to scala so bear with me I need to convert from an RxJava observable over to scala since I want to expose it nicely The shortest way that I found is like scala override def openBucket name String password String Observable Bucket new Observable OpenBucketResponse core send OpenBucketResponse new OpenBucketRequest name password map _ new CouchbaseBucket core name password so with the new Observable T style Is there a quicker or nice way with imports or so I need to do this quite often','Maybe with the implicit import scala override def openBucket name String password String Observable Bucket toScalaObservable core send OpenBucketResponse new OpenBucketRequest name password map _ new CouchbaseBucket core name password Yup that s the right approach Note that implicit def toScalaObservable T observable rx Observable _ T Observable T so depending on how lucky you are you may be able to trigger the implicit conversion to kick in and don t need to write toScalaObservable but I prefer the little extra explicitness thanks',RxJava,false,false,false
35919589,'DebugHook got miswired before','This was throwing ClassCastExceptions when used Now it works','RxJava pull requests #1295 https netflixoss ci cloudbees com job RxJava pull requests 1295 SUCCESS This pull request looks good',RxJava,true,false,false
35924212,'rx lang scala Observable Misleading deprecation notice','Reading the deprecation notice a developer may assume that Observable apply and Observable create may be equivalent However when changing the following example to Observable Unit the unsubscription code does not get called anymore scala def collision Observable create Unit obs val sub Subscription accelerometerObservable filter _ x 2 subscribe _ obs onNext Subscription sub unsubscribe Instead the developer would have to write scala def collision Observable Unit obs val sub Subscription accelerometerObservable filter _ x 2 subscribe _ obs onNext obs add Subscription sub unsubscribe Unfortunately we figured out this solution only after reading the sources The documentation should mention this way of running arbitrary code upon unsubscription','We will bring back Observable create just as it was before But yes apply and create are not the same @headinthebox Anything to do here',RxJava,false,false,false
35944231,'Backpressure 6 Merge ObserveOn SubscribeOn etc','Mostly functional backpressure with merge and observeOn This is NOT production ready Need to work on algorithms in merge data structures and concurrency implementations This does not yet have zip implemented and despite effort on performance there are still degradations as shown below gradlew benchmarks Pjmh f 1 tu s bm thrpt wi 5 i 5 r 2 prof GC rx usecases Performance for 0 19 x vs 0 20 this branch Benchmark size 0 19 0 20 diff r u PerfBaseline forLoopConsumption 1 344850705 588 356169426 506 within mean error r u PerfBaseline forLoopConsumption 1024 304909 309 311743 590 within mean error r u PerfBaseline iterableViaForLoopConsumption 1 239518717 088 241586374 313 within mean error r u PerfBaseline iterableViaForLoopConsumption 1024 177090 461 180974 316 within mean error r u PerfBaseline iterableViaHasNextConsumption 1 302479118 588 307508627 346 within mean error r u PerfBaseline iterableViaHasNextConsumption 1024 282783 917 287813 401 within mean error r u PerfBaseline observableConsumption 1 29295739 451 28748055 426 within mean error 29 2m vs 28 7m mean error 0 45m r u PerfBaseline observableConsumption 1024 233194 851 234253 687 within mean error r u PerfBaseline observableViaRange 21535829 318 r u PerfBaseline observableViaRange 51645 436 r u PerfObserveOn observeOnComputation 1 378476 870 310228 157 378k vs 310k mean error 50k r u PerfObserveOn observeOnComputation 1024 13122 964 4423 132 WORSE 13k vs 4k r u PerfObserveOn observeOnImmediate 1 20465307 041 17203295 323 WORSE 20 4m vs 17 2m mean error 800k r u PerfObserveOn observeOnImmediate 1024 232424 832 51503 696 WORSE 232k vs 51k r u PerfObserveOn observeOnNewThread 1 20209 183 20055 322 within mean error r u PerfObserveOn observeOnNewThread 1024 10170 748 4224 503 WORSE 10k vs 4k r u PerfTransforms flatMapInt 1 3308740 889 2404699 223 WORSE 3 3m vs 2 4m r u PerfTransforms flatMapInt 1024 6522 641 3053 996 WORSE 6 5k vs 3 0k r u PerfTransforms flatMapNestedMapFilterTake 1 2150209 920 1777010 078 WORSE 2 1m vs 1 8m mean error 60k r u PerfTransforms flatMapNestedMapFilterTake 1024 15 943 80 803 BETTER 15 vs 80 mean error 3 r u PerfTransforms mapIntStringInt 1 9107565 666 9004589 569 within mean error r u PerfTransforms mapIntStringInt 1024 18774 750 15238 517 WORSE 18 7k vs 15 2k mean error 500 r u PerfTransforms mapPassThru 1 19336755 193 15719416 479 WORSE 19 3m vs 15 7m mean error 500k r u PerfTransforms mapPassThru 1024 199751 628 49089 139 WORSE 200k vs 49k','RxJava pull requests #1300 https netflixoss ci cloudbees com job RxJava pull requests 1300 SUCCESS This pull request looks good RxJava pull requests #1302 https netflixoss ci cloudbees com job RxJava pull requests 1302 SUCCESS This pull request looks good RxJava pull requests #1303 https netflixoss ci cloudbees com job RxJava pull requests 1303 SUCCESS This pull request looks good RxJava pull requests #1304 https netflixoss ci cloudbees com job RxJava pull requests 1304 SUCCESS This pull request looks good RxJava pull requests #1305 https netflixoss ci cloudbees com job RxJava pull requests 1305 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1306 https netflixoss ci cloudbees com job RxJava pull requests 1306 SUCCESS This pull request looks good RxJava pull requests #1308 https netflixoss ci cloudbees com job RxJava pull requests 1308 ABORTED RxJava pull requests #1309 https netflixoss ci cloudbees com job RxJava pull requests 1309 ABORTED RxJava pull requests #1310 https netflixoss ci cloudbees com job RxJava pull requests 1310 ABORTED RxJava pull requests #1311 https netflixoss ci cloudbees com job RxJava pull requests 1311 SUCCESS This pull request looks good RxJava pull requests #1312 https netflixoss ci cloudbees com job RxJava pull requests 1312 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
36126560,'FieldUpdater Perf Issue','While profiling I ve seen issue with the field updaters They reduce memory but I m seeing CPU lost Further information can be seen here http jsr166 concurrency 10961 n7 nabble com The Atomic FieldUpdater situation td8579 html Here is a screenshot showing the issue screen shot 2014 06 19 at 4 01 36 pm https cloud githubusercontent com assets 813492 3334791 b273d3b4 f805 11e3 86a5 1b873219a07c png','I think the reason is that the field updater is created inside an abstract class and is called from a subclass thus the access check finds a different class than the one it was instantiated with and calls fullCheck all the time You could try to move the field updater to the outermost class and see if that helps Yes that is why In most cases though this means abstract parent classes and inheritance can t be used as the child class can t have the FieldUpdater when all the references to it are in the parent class I didn t know field updater can t use a superclass field and apparently it can t What remains is Unsafe Yes I ve been using Unsafe and it works but it isn t pretty @benjchristensen time for a PlatformDependent class maybe Possibly depends on what Android supports I ve read that it supports sun misc Unsafe for the common functionality but I have no actual evidence of this Please take a look at https github com Netflix RxJava pull 1377 and provide guidance Anything from the sun package wouldn t exist on Android the Android JRE was originally forked from Apache Harmony which I assume also wouldn t have the vendor specific classes I think it would be best to introduce this as a platform specific change On Android where the sequences you process are relatively small compared to a server side high throughput setting the performance drawbacks you mention should be negligible or non existent anyway and probably don t warrant the added complexity here I think it would be best to introduce this as a platform specific change How do you suggest doing that I m exploring options Here is the impl of PlatformDependent from Netty https github com netty netty blob master common src main java io netty util internal PlatformDependent java @benjchristensen Instead of trying to identify a specific platform would it be sufficient to merely test for existence of the sun misc package I wonder though if the goal is to optimize to a degree where even dynamic dispatches are to be avoided I m not sure how we would write an adapter that uses different means of atomic field access since any such adapter would introduce another level of indirection by nature I also found this http stackoverflow com questions 4519556 how to determine if my app is running on android So you could check the environment for e g java vm vendor Looking at the Netty sample they simply try to load a class from the android app package and see whether it fails Hacky but effective I guess I d prefer testing the vendor string but should make no difference In the few places where sun misc Unsafe is being used it is gated behind https github com Netflix RxJava blob master rxjava core src main java rx internal util unsafe UnsafeAccess java so that Android doesn t get affected by it',RxJava,false,false,false
36153923,'AndroidObservable bindFragment FRAGMENT_VALIDATOR not called','It seems like calling observeOn AndroidSchedulers mainThread on an observable that is passed to bindFragment causes call in FRAGMENT_VALIDATOR not to be called sometimes and the observer s onNext is not executed anymore When I use this line of code the subscription is not working reliably AndroidObservable bindFragment fragmentToBind observable observeOn AndroidSchedulers mainThread subscribe onComplete onError When I use this instead it works reliably omitting the observeOn part AndroidObservable bindFragment fragmentToBind observable subscribe onComplete onError','@joluet AndroidObservable bindFragment internally calls observeOn AndroidSchedulers mainThread on the passed in Observable This seems an interesting behaviour when observeOn AndroidSchedulers mainThread is applied 2x You mentioned not working reliably how reliably is is not working if working at all Yes I just tested it once more With observeOn AndroidSchedulers mainThread being applied 2x It seems to work 10 of the times on average @joluet would you by any chance be able to share some code that reproduces this behaviour @joluet try version 0 19 4 I believe it has been fixed there @dpsm Thank you I m gonna test it @dpsm Yeah it seems to be fixed The code that reproduced the behavior looks like this I cannot share the real code java AndroidObservable bindFragment fragmentToBind observable observeOn AndroidSchedulers mainThread subscribe onComplete onError Now I don t see any issues there Thanks',RxJava,false,false,false
36180326,'Fix head tail false sharing issues','See discussion in issue #1310','RxJava pull requests #1307 https netflixoss ci cloudbees com job RxJava pull requests 1307 SUCCESS This pull request looks good Thank you @nitsanw',RxJava,true,false,false
36268309,'RxScala Add idiomatic toXXX methods','Suggested by @headinthebox in https github com Netflix RxJava pull 1336#issuecomment 46118339 cc @headinthebox @samuelgruetter','RxJava pull requests #1313 https netflixoss ci cloudbees com job RxJava pull requests 1313 SUCCESS This pull request looks good RxJava pull requests #1314 https netflixoss ci cloudbees com job RxJava pull requests 1314 SUCCESS This pull request looks good',RxJava,true,false,false
36334119,'Revision of JMH Tests','This updates all perf testing to use only JMH I tried to get all of them to follow a common pattern and to comply with examples at https github com nitsanw jmh samples blob master src main java org openjdk jmh samples by @nitsanw @nitsanw if you re willing to take a look at this and confirm or correct them I d appreciate that I am doing this in 0 19 so that work on 0 20 has a common set of perf tests to use for comparison','RxJava pull requests #1315 https netflixoss ci cloudbees com job RxJava pull requests 1315 SUCCESS This pull request looks good Sorry not sure when I ll be able to review these changes In the next few days weeks perhaps @nitsanw No problem I know you re very busy If you ever have the chance and interest it would be good to know we re following your examples right In the meantime though I m pushing forward based on my current understandings of how to use JMH I appreciate your responses and involvement in our project My examples are very dated by now you should look at the latest samples on the JMH project On 25 Jun 2014 at 18 34 Ben Christensen notifications@github com wrote @nitsanw No problem I know you re very busy If you ever have the chance and interest it would be good to know we re following your examples right In the meantime though I m pushing forward based on my current understandings of how to use JMH I appreciate your responses and involvement in our project Reply to this email directly or view it on GitHub I ended up finding those after looking at yours and went through them as well I assume you re referring to these http hg openjdk java net code tools jmh file tip jmh samples src main java org openjdk jmh samples Yes On 25 Jun 2014 at 21 22 Ben Christensen notifications@github com wrote I ended up finding those after looking at yours and went through them as well I assume you re referring to these http hg openjdk java net code tools jmh file tip jmh samples src main java org openjdk jmh samples Reply to this email directly or view it on GitHub Hi there Not sure if that s intentional or not but poking around a few benchmarks there it seems you can make them even cleaner instead of using the explicit Input nested class you might as well use the enclosing class holding the @Benchmark methods as @State class You seem to be having @State Thread already on the enclosing classes only to delegate everything to nested class afterwards That is this sample works http hg openjdk java net code tools jmh file 0 9 jmh samples src main java org openjdk jmh samples JMHSample_04_DefaultState java',RxJava,true,false,false
36334441,'Utility Class for Accessing Unsafe','While working on code for v0 20 I have come across reasons for using sun misc Unsafe such as #1372 This provides a common way for getting access to sun misc Unsafe as well as utility methods for commonly needed APIs that exist in Java 8 but not Java 6 I need someone to help me confirm whether this works on Android and if not how we can make this be aware of what platform it is running on as per https github com Netflix RxJava issues 1372#issuecomment 46717293','cc @daschl @akarnokd @mttkay will this work on Android If not can you provide some guidance please RxJava pull requests #1316 https netflixoss ci cloudbees com job RxJava pull requests 1316 SUCCESS This pull request looks good How do you get the object field offset or array offsets I have mixed feelings about the implementation since intrinsics applied to incrementAndGet and co provide better performance automagically on later Javas but we lock us out of it @akarnokd You get the offset via Unsafe though I ve considered adding utility methods on UnsafeAccess itself java private volatile IndexSection next private static final long _nextOffset static try _nextOffset UnsafeAccess UNSAFE objectFieldOffset IndexSection class getDeclaredField next catch Exception ex throw new Error ex @nitsanw What is the right way to use Unsafe when Java 6 must be supported while not breaking performance optimizations done in Java 7 8 Particularly the question by @akarnokd above I have mixed feelings about the implementation since intrinsics applied to incrementAndGet and co provide better performance automagically on later Javas but we lock us out of it @benjchristensen For most methods I use on Unsafe this is not an issue For incrementAndGet and getAndSet there were new intrinsics added in JDK8 You could support those via an Unsafe wrapper with an implementation decided at runtime or by resorting to the field updater in these specific cases Using Unsafe is wrong so there s no official right way to do this',RxJava,true,false,false
36349162,'BugFix Pivot Concurrency','It wasn t serializing the onNext','',RxJava,true,false,false
36349170,'Parallel Operator Rewrite','A rewrite of the parallel operator that is more efficient by not using groupBy and ready to support backpressure','RxJava pull requests #1317 https netflixoss ci cloudbees com job RxJava pull requests 1317 SUCCESS This pull request looks good',RxJava,true,false,false
36349758,'Variety of Fixes','found while working on backpressure','RxJava pull requests #1318 https netflixoss ci cloudbees com job RxJava pull requests 1318 SUCCESS This pull request looks good Nice catches',RxJava,true,false,false
36351048,'Replace Arrays copyOf with System arraycopy','Arrays copyOf is not supported on android api8 Maybe it make sense to create helper class like ArraysCompat to have all copyOf in one place','RxJava pull requests #1319 https netflixoss ci cloudbees com job RxJava pull requests 1319 SUCCESS This pull request looks good This was discussed at https github com Netflix RxJava issues 1004 and it was decided that Android 9 is supported cc @mttkay Aren t there more places than this one that would need to be changed If we change these I agree with having a utility class in rx internal utils Android 2 2 has been largely replaced by Gingerbread API 9 and is on the verge of non existence 8 according to the official numbers https developer android com about dashboards index html We dropped Froyo support at SoundCloud a while ago To use Reto Meier s words play where the puck is going I can t speak for everyone of course but considering the marginal percentage of apps that use RxJava times the marginal percentage of devices that still run Froyo I m just not convinced it s worth the effort Hey guys I don t remember any other breaking changes except Arrays class in android If you know any other please let me know will be good to know But in mean while it is just 2 places and it is an easy fix Yes I agree that overall number of api8 is 1 but it also various from app to app so yes if you dropped your users you will have 0 if you do support your users you can still can have 15 20k of users I just don t see the point to drop yet especially android is so great with support tools so it is pretty easy to support older versions But this is a different story right now as I can see Arrays is the only class that is used and missed on api8 Thanks I d rather use System arraycopy everywhere because Arrays copyOf uses reflection to figure out the array type which adds unnecessary overhead Closing out Java 6 is what we code to as per https github com Netflix RxJava issues 1004 The Array class is not the only issue it is also Deque as discussed here https github com Netflix RxJava issues 1004#issuecomment 39112694',RxJava,true,false,false
36351531,'Backpressure 7 Merge ObserveOn','This is a functioning but non performant implementation of backpressure Of the major unbounded queue operators in 0 19 this implements observeOn and merge but not yet zip Several attempts at performance improvements last week failed so I have rolled them back and left this with naive data structures while restarting the performance work I want to kick off the design and functionality review while continuing to work on performance ### New Signatures java public interface Producer public void request int n java public abstract class Subscriber T implements Observer T Subscription Optionally called from Observable OnSubscribe public final void setProducer Producer producer Allow implementing classes to capture decorate or override the Producer without affecting the Subscriber logic protected Producer onSetProducer Producer producer public final void request int n ### Subscriber request vs Producer request This is possibly confusing and I think we may want to eliminate Subscriber request It would make some operators like take more complicated but for the rare time it is needed I think it s more clear that you must capture the Producer and call Producer request ### Operator Changes OnSubscribeFromIterable and OnSubscribeRange are both updated to support Producer and will only emit as many onNext as requested The implementations are a little more complex than needed as they optimize for cases where backpressure is not requested and fallback to the firehose model of 0 19 and earlier This allows for higher throughput in case where backpressure is not needed parallel had to be rewritten with a different approach to support backpressure The filter take and skip operators were modified to support backpressure and propagate request modifications based on each of their logic takeUntil needed to be rewritten because NotificationLite can t be allowed to leak across operators The subscribeOn operator was modified to correctly reschedule work on the given Scheduler when a request n occurs after the Producer has let itself shut down ### Design Questions ##### 1 Producer Is the name and signature of Producer request n correct ##### 2 Subscriber setProducer Is this the correct signature for an Observable OnSubscribe to register the Producer ##### 3 Subscriber request This seems confusing and should probably be removed despite it making some use cases such as take and filter more complicated ##### 4 Requesting 0 for Infinite no backpressure To be backwards compatible and support performance optimizations when backpressure is not needed Producer request n can be invoked with a negative number This means no backpressure and the Producer can then emit data in a tight loop without further limitations Is this acceptable and the best solution ##### 5 Producer BUFFER_SIZE Currently there is a public constant Producer BUFFER_SIZE that represents the system wide size of buffers used for backpressure This is exposed so that an operator implementation can optimize to skip the setProducer path when it knows it will emit less data that the BUFFER_SIZE This does have a performance benefit but it comes at the cost of exposing implementation details It also means all buffers MUST use the same buffer size or at least not be any smaller Is this something we want Is the performance benefit worth the trade offs and complexity ##### 6 Other operators like filter Are there other operators that filter out onNext like filter does that we must modify to call request 1 each time it filters something out Is there a better way of handling this so operators do not need to manually handle this ##### 7 onBackpressure Are the onBackpressureBuffer and onBackpressureDrop operators well named clear in their usage and implemented correctly Should we implemented others such as onBackpressureUnsubscribe and onBackpressureBuffer int limitUntilDropping ##### 8 Unit Tests and Use Cases Are there major use cases that are missing from BackpressureTests What problems are there that are not yet resolved or handled by the design ##### 9 observeOn Is the design of observeOn as efficient and correct as it can be ##### 10 merge The merge operator currently has a naive algorithm for handling the queue of buffers We need to design a better one There are some unit tests marked as ignored for merge in the BackpressureTests class Should those work What should be the behavior of merge when merging all synchronous all asynchronous or mixed sync async Observables ### Performance Performance is not good right now The biggest problem is merge and that s critical since it s key to flatMap which is a core operator Performance can be tested via the JMH performance tests This is where I m currently focusing','RxJava pull requests #1320 https netflixoss ci cloudbees com job RxJava pull requests 1320 SUCCESS This pull request looks good RxJava pull requests #1327 https netflixoss ci cloudbees com job RxJava pull requests 1327 SUCCESS This pull request looks good Is the name and signature of Producer request n correct What I find confusing is what the protocol is precisely i e when you use Observable create subscriber subscriber onNext clear push next value to subscriber subscriber isUnsubscribed clear check if subscriber wants more values subscriber add clear piggyback on subscription subscriber setProducer n what do I do here Similarly when subscribing using a subscriber what are you supposed to do with the producer I e how do I invoke back pressure here xs subscribe new Subscriber @override protected Producer onSetProducer Producer producer Requesting 0 for Infinite no backpressure This is a MUST Other operators that seem hard are the temporal ones like Observable timer 0 5 seconds or xs window 10 seconds what does it mean to request n items for those And ones that are the opposite of merge especially ones that create overlapping nested streams such as window count skip or groupBy You don t know how much items from the source stream it takes to produce n groups in the result stream a bit like filter but here those n groups themselves can be unbounded and contain any number of values Other operators that seem hard are the temporal ones like Observable timer 0 5 seconds or xs window 10 seconds what does it mean to request n items for those Those wouldn t request backpressure Time based operators would always request 1 the default so they get the firehose and apply their time based logic And ones that are the opposite of merge especially ones that create overlapping nested streams As each group consumes it requests more from upstream so that part is easy The hard part would be if a single group is slow and can no longer consume it would require the origin no longer sending and thus all groups would slow down to the request rate of the slowest group This feels like the right thing though if I have 10 groups and 1 of them is receiving far more data than the rest and is filling its buffer the other 9 will have to go at the same rate as that 1 Otherwise that 1 must choose to drop data or buffer bloat Similarly when subscribing using a subscriber what are you supposed to do with the producer I e how do I invoke back pressure here This is the most awkward part of the API right now I m trying to find a performant way of doing it I had Subscriber request which was easy but it has its own problems What I find confusing is what the protocol is precisely i e when you create an observable what do you with setProducer It s an either or scenario You either ignore backpressure and do this java Observable create subscriber subscriber onNext subscriber onCompleted or you give a Producer that will emit data when requested java Observable create subscriber subscriber setProducer new Producer public void request int n subscriber onNext subscriber onCompleted See https github com benjchristensen RxJava blob backpressure 7 rxjava core src main java rx internal operators OnSubscribeFromIterable java#L65 for when setProducer is done This class shows how it conditionally does either or based on the number of elements to emit A simpler solution would skip lines 45 64 and only call setProducer Similarly when subscribing using a subscriber what are you supposed to do with the producer I e how do I invoke back pressure here Here is how I currently have it working sync https github com Netflix RxJava pull 1382 files#diff e6729e027cb3cbf9f1251f7ea8bc5907R301 async https github com Netflix RxJava pull 1382 files#diff e6729e027cb3cbf9f1251f7ea8bc5907R341 The general idea is java note how it requests 100 in the constructor observable subscribe new Subscriber T 100 public void onCompleted public void onError Throwable e public void onNext T t as it receives elements it can request more request 1 better to batch but can do one at a time like this Thanks @benjchristensen RxJava pull requests #1331 https netflixoss ci cloudbees com job RxJava pull requests 1331 SUCCESS This pull request looks good RxJava pull requests #1332 https netflixoss ci cloudbees com job RxJava pull requests 1332 SUCCESS This pull request looks good Baseline performance of subscribe map observeOn are back inline 2 big changes done to achieve this are 1 Assume single threaded wherever possible 2 Use object pooling and JCTools array backed ring buffers with fallback when Unsafe isn t available for observeOn queues gradlew benchmarks Pjmh f 1 wi 5 i 5 r 2 PerfBaseline observable 0 19 Benchmark size Mode Samples Mean Mean error Units r PerfBaseline observableConsumption 1 thrpt 5 31881123 086 1556397 821 ops s r PerfBaseline observableConsumption 1000 thrpt 5 235797 222 13915 448 ops s r PerfBaseline observableConsumption 1000000 thrpt 5 245 064 12 162 ops s r PerfBaseline observableViaRange 1 thrpt 5 25019595 907 797863 816 ops s r PerfBaseline observableViaRange 1000 thrpt 5 186548 299 10512 421 ops s r PerfBaseline observableViaRange 1000000 thrpt 5 183 245 13 291 ops s 0 19 with volatile synchronization changes Benchmark size Mode Samples Mean Mean error Units r PerfBaseline observableConsumption 1 thrpt 5 58303018 095 935455 977 ops s r PerfBaseline observableConsumption 1000 thrpt 5 227118 383 19715 515 ops s r PerfBaseline observableConsumption 1000000 thrpt 5 227 567 43 552 ops s r PerfBaseline observableViaRange 1 thrpt 5 29536860 600 475787 569 ops s r PerfBaseline observableViaRange 1000 thrpt 5 184212 623 4187 098 ops s r PerfBaseline observableViaRange 1000000 thrpt 5 178 653 12 047 ops s backpressure 7 before volatile synchronization changes Benchmark size Mode Samples Mean Mean error Units r PerfBaseline observableConsumption 1 thrpt 5 18016008 716 271261 264 ops s r PerfBaseline observableConsumption 1000 thrpt 5 243090 495 4693 818 ops s r PerfBaseline observableConsumption 1000000 thrpt 5 254 516 3 178 ops s r PerfBaseline observableViaRange 1 thrpt 5 17179874 861 319574 244 ops s r PerfBaseline observableViaRange 1000 thrpt 5 182684 247 4077 967 ops s r PerfBaseline observableViaRange 1000000 thrpt 5 53 867 0 440 ops s backpressure 7 Benchmark size Mode Samples Score Score error Units r PerfBaseline observableConsumption 1 thrpt 5 51472952 744 5987759 439 ops s r PerfBaseline observableConsumption 1000 thrpt 5 239038 814 6860 951 ops s r PerfBaseline observableConsumption 1000000 thrpt 5 244 674 6 567 ops s r PerfBaseline observableViaRange 1 thrpt 5 30302378 407 772629 965 ops s r PerfBaseline observableViaRange 1000 thrpt 5 171595 529 12502 807 ops s r PerfBaseline observableViaRange 1000000 thrpt 5 161 238 9 059 ops s gradlew benchmarks Pjmh f 1 wi 5 i 5 r 2 rx operators OperatorMapPerf 0 19 Benchmark size Mode Samples Mean Mean error Units r o OperatorMapPerf mapPassThru 1 thrpt 5 17834349 447 417931 393 ops s r o OperatorMapPerf mapPassThru 1000 thrpt 5 153400 393 17397 004 ops s r o OperatorMapPerf mapPassThru 1000000 thrpt 5 160 887 4 557 ops s r o OperatorMapPerf mapPassThruViaLift 1 thrpt 5 19127321 386 503906 389 ops s r o OperatorMapPerf mapPassThruViaLift 1000 thrpt 5 158085 344 3763 660 ops s r o OperatorMapPerf mapPassThruViaLift 1000000 thrpt 5 160 650 2 875 ops s backpressure 7 Benchmark size Mode Samples Score Score error Units r o OperatorMapPerf mapPassThru 1 thrpt 5 20809605 075 217396 485 ops s r o OperatorMapPerf mapPassThru 1000 thrpt 5 157102 490 3143 752 ops s r o OperatorMapPerf mapPassThru 1000000 thrpt 5 147 605 5 704 ops s r o OperatorMapPerf mapPassThruViaLift 1 thrpt 5 19478234 492 587866 316 ops s r o OperatorMapPerf mapPassThruViaLift 1000 thrpt 5 151529 625 15069 277 ops s r o OperatorMapPerf mapPassThruViaLift 1000000 thrpt 5 146 516 11 072 ops s gradlew benchmarks Pjmh f 1 wi 5 i 5 r 2 rx operators OperatorObserveOnPerf 0 19 Benchmark size Mode Samples Mean Mean error Units r o OperatorObserveOnPerf observeOnComputation 1 thrpt 5 86331 092 5181 739 ops s r o OperatorObserveOnPerf observeOnComputation 1000 thrpt 5 8787 634 316 166 ops s r o OperatorObserveOnPerf observeOnComputation 1000000 thrpt 5 8 590 4 527 ops s r o OperatorObserveOnPerf observeOnImmediate 1 thrpt 5 13074710 596 217808 611 ops s r o OperatorObserveOnPerf observeOnImmediate 1000 thrpt 5 188868 055 5448 065 ops s r o OperatorObserveOnPerf observeOnImmediate 1000000 thrpt 5 185 372 4 190 ops s r o OperatorObserveOnPerf observeOnNewThread 1 thrpt 5 13848 943 2601 271 ops s r o OperatorObserveOnPerf observeOnNewThread 1000 thrpt 5 6867 300 172 123 ops s r o OperatorObserveOnPerf observeOnNewThread 1000000 thrpt 5 10 100 1 925 ops s backpressure 7 Benchmark size Mode Samples Score Score error Units r o OperatorObserveOnPerf observeOnComputation 1 thrpt 5 86711 196 3714 229 ops s r o OperatorObserveOnPerf observeOnComputation 1000 thrpt 5 8150 631 202 839 ops s r o OperatorObserveOnPerf observeOnComputation 1000000 thrpt 5 9 391 5 451 ops s r o OperatorObserveOnPerf observeOnImmediate 1 thrpt 5 14749198 208 53924 729 ops s r o OperatorObserveOnPerf observeOnImmediate 1000 thrpt 5 173567 350 6099 180 ops s r o OperatorObserveOnPerf observeOnImmediate 1000000 thrpt 5 161 833 3 909 ops s r o OperatorObserveOnPerf observeOnNewThread 1 thrpt 5 13568 487 573 296 ops s r o OperatorObserveOnPerf observeOnNewThread 1000 thrpt 5 6689 964 292 888 ops s r o OperatorObserveOnPerf observeOnNewThread 1000000 thrpt 5 12 129 3 199 ops s RxJava pull requests #1333 https netflixoss ci cloudbees com job RxJava pull requests 1333 SUCCESS This pull request looks good Here is the current perf status of merge which is the big problem right now 0 19 Benchmark size Mode Samples Mean Mean error Units r o OperatorMergePerf mergeAsynchronous 1 thrpt 5 89142 570 65414 938 ops s r o OperatorMergePerf mergeAsynchronous 1000 thrpt 5 8 250 0 412 ops s r o OperatorMergePerf mergeNStreams 1 thrpt 5 3095264 007 64920 841 ops s r o OperatorMergePerf mergeNStreams 100 thrpt 5 64981 233 6422 160 ops s r o OperatorMergePerf mergeNStreams 1000 thrpt 5 6331 538 191 554 ops s r o OperatorMergePerf mergeSynchronous 1 thrpt 5 3043336 841 82126 247 ops s r o OperatorMergePerf mergeSynchronous 1000 thrpt 5 70 891 2 517 ops s r o OperatorMergePerf mergeTwoAsyncStreams 1 thrpt 5 66412 194 7226 698 ops s r o OperatorMergePerf mergeTwoAsyncStreams 1000 thrpt 5 4055 900 233 247 ops s backpressure 7 Benchmark size Mode Samples Score Score error Units r o OperatorMergePerf mergeAsynchronous 1 thrpt 5 92179 009 4694 946 ops s r o OperatorMergePerf mergeAsynchronous 1000 thrpt 5 0 061 0 000 ops s r o OperatorMergePerf mergeNStreams 1 thrpt 5 945850 251 76633 902 ops s r o OperatorMergePerf mergeNStreams 100 thrpt 5 11871 962 375 179 ops s r o OperatorMergePerf mergeNStreams 1000 thrpt 5 1191 540 43 378 ops s r o OperatorMergePerf mergeSynchronous 1 thrpt 5 949127 819 56293 866 ops s r o OperatorMergePerf mergeSynchronous 1000 thrpt 5 20 006 0 930 ops s r o OperatorMergePerf mergeTwoAsyncStreams 1 thrpt 5 58893 109 1592 355 ops s r o OperatorMergePerf mergeTwoAsyncStreams 1000 thrpt 5 1958 489 63 114 ops s RxJava pull requests #1334 https netflixoss ci cloudbees com job RxJava pull requests 1334 SUCCESS This pull request looks good RxJava pull requests #1337 https netflixoss ci cloudbees com job RxJava pull requests 1337 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1338 https netflixoss ci cloudbees com job RxJava pull requests 1338 FAILURE Looks like there s a problem with this pull request Decent progress with merge over the past couple days Doing very methodical JMH driven development so each change I do is validate by JMH The merge code is definitely not simple and the implementation now is less elegant than the one last week but it performs far far better Here is the comparison between 0 19 and this branch In most cases it is now better Many of the optimizations made particularly related to ScalarSynchronousObservable could also be applied to 0 19 without backpressure I m doing it all together since they are very tied to each other in the implementation 0 19 Benchmark size Mode Samples Score Score error Units r o OperatorMergePerf merge1SyncStreamOfN 1 thrpt 5 2946833 283 34656 012 ops s r o OperatorMergePerf merge1SyncStreamOfN 1000 thrpt 5 68757 821 2885 689 ops s r o OperatorMergePerf mergeNAsyncStreamsOfN 1 thrpt 5 101272 545 6422 220 ops s r o OperatorMergePerf mergeNAsyncStreamsOfN 1000 thrpt 5 8 457 0 299 ops s r o OperatorMergePerf mergeNSyncStreamsOf1 1 thrpt 5 2961735 889 129304 035 ops s r o OperatorMergePerf mergeNSyncStreamsOf1 100 thrpt 5 65060 345 1794 712 ops s r o OperatorMergePerf mergeNSyncStreamsOf1 1000 thrpt 5 6487 781 228 564 ops s r o OperatorMergePerf mergeNSyncStreamsOfN 1 thrpt 5 2950430 071 61758 514 ops s r o OperatorMergePerf mergeNSyncStreamsOfN 1000 thrpt 5 70 900 1 508 ops s r o OperatorMergePerf mergeTwoAsyncStreamsOfN 1 thrpt 5 65560 958 3881 703 ops s r o OperatorMergePerf mergeTwoAsyncStreamsOfN 1000 thrpt 5 4080 117 249 937 ops s backpressure 7 Benchmark size Mode Samples Score Score error Units r o OperatorMergePerf merge1SyncStreamOfN 1 thrpt 5 8056282 024 1244398 099 ops s r o OperatorMergePerf merge1SyncStreamOfN 1000 thrpt 5 95552 979 4783 600 ops s r o OperatorMergePerf merge1SyncStreamOfN 1000000 thrpt 5 61 996 2 765 ops s r o OperatorMergePerf mergeNAsyncStreamsOfN 1 thrpt 5 99261 303 7468 987 ops s r o OperatorMergePerf mergeNAsyncStreamsOfN 1000 thrpt 5 6 154 0 475 ops s r o OperatorMergePerf mergeNSyncStreamsOf1 1 thrpt 5 9605862 246 258832 255 ops s r o OperatorMergePerf mergeNSyncStreamsOf1 100 thrpt 5 921790 636 28790 629 ops s r o OperatorMergePerf mergeNSyncStreamsOf1 1000 thrpt 5 73696 935 17967 741 ops s r o OperatorMergePerf mergeNSyncStreamsOfN 1 thrpt 5 8669361 559 849097 317 ops s r o OperatorMergePerf mergeNSyncStreamsOfN 1000 thrpt 5 73 843 1 305 ops s r o OperatorMergePerf mergeTwoAsyncStreamsOfN 1 thrpt 5 73709 795 11261 906 ops s r o OperatorMergePerf mergeTwoAsyncStreamsOfN 1000 thrpt 5 3768 807 195 025 ops s r o OperatorMergePerf oneStreamOfNthatMergesIn1 1 thrpt 5 8329906 527 222020 342 ops s r o OperatorMergePerf oneStreamOfNthatMergesIn1 1000 thrpt 5 69658 588 3154 351 ops s r o OperatorMergePerf oneStreamOfNthatMergesIn1 1000000 thrpt 5 72 440 2 486 ops s There is one major round of work to be done on merge related to downstream backpressure requests such as merge o1 o2 observeOn It will end up with its own set of performance tests as that will likely end up with different code paths for that use case so it doesn t destroy the perf on use cases where it can firehose the data By the way the unit tests that are failing are known to be failing and are doing so on purpose as they represent work still to be done Nice RxJava pull requests #1341 https netflixoss ci cloudbees com job RxJava pull requests 1341 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1342 https netflixoss ci cloudbees com job RxJava pull requests 1342 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1343 https netflixoss ci cloudbees com job RxJava pull requests 1343 FAILURE Looks like there s a problem with this pull request Replaced by https github com Netflix RxJava pull 1403',RxJava,true,false,false
36402738,'Subscription and Synchronization','I want to explore whether it is possible to eliminate synchronization inside a Subscription particularly the SubscriptionList used inside Subscriber We have discussed this before and determined that it is difficult to guarantee it doesn t get called from other threads when subscribeOn and observeOn are used since a user can get a reference to the Subscription and call unsubscribe from anywhere The cost however of protecting against this slim chance is pretty high The rx PerfBaseline observableConsumption perf test shows that by removing synchronization including use of volatile and or cas we can increase from 32m to 46m ops second Since this is a non trivial increase I d like to determine if we can adopt a single threaded assumption for Subscription that same as we do for Observer The observeOn operator does schedule the unsubscribe for the worker https github com Netflix RxJava blob master rxjava core src main java rx internal operators OperatorObserveOn java#L190 But it passes the same Subscriber through to the parent https github com Netflix RxJava blob master rxjava core src main java rx internal operators OperatorObserveOn java#L75 which means it is crossing over thread boundaries This is an example of an area where Subscription requires synchronization as currently used Similarly the subscribeOn use case can mean a user gets the returned Subscription on one thread while the work happens on a second The user can therefore call unsubscribe from the first thread and it needs to synchronize to the second Most of the time though we have synchronous execution where synchronization is not needed but we always pay the cost Anyone else have insights on this or how we can improve so that we only pay the cost of synchronization when needed For example I wonder if we can fix the observeOn implementation and decorate the Subscription resulting from subscribeOn to include synchronization and leave it unsynchronized the rest of the time Is that sufficient to be safe','cc @akarnokd @headinthebox Please take a look at an exploration of this in https github com Netflix RxJava pull 1384 It makes a lot of sense to make the same assumptions for subscribers and observers and only synchronize in operators like observeOn and subscribeOn In fact I kind of hit myself in the head for not observing this pun intended One question is there something like serialize that users can apply to synchronize access Would you be able to release this as a canary in production I have created a SynchronizedSubscription for internal use right now We also have the unsubscribeOn operator but I have not proven to myself yet that it is all 100 correct Yes I could canary this but the types of issues that this could cause probably would not be easily seen in our environment since it is still mostly request response and an unsubscribe being missed wouldn t severely affect anything it would just get filtered out by take for example Where we do use streams they are infinite and thus never exercise the unsubscribe Makes sense Schedulers are another place where both subscriptions and concurrency exist Yes I ll need to review those I ve been spending more time on this and it definitely appears to consistently help performance The one area where I think this change makes us vulnerable is in this signature java public Subscription subscribe Subscriber s public Subscription subscribe Observer s I propose changing these to java public void subscribe Subscriber s public void subscribe Observer s Returning the Subscription is useless on synchronous streams and on asynchronous streams it requires synchronization on unsubscribe for the rare occasion someone uses it I can t figure out a way to do that protection only when it s used without wrapping the Subscription with a SynchronizedSubscription This adds another object allocation per subscribe that significantly impacts some benchmarks tight loop of observable create subscribe Is there any reason other than being a bad breaking change for keeping the Subscription return We almost removed them when we did 0 17 but kept them just to not do the breaking change Can we keep them without impeding performance Mmmm need to think about this I do unsubscribe when I subscribe quite often and it will be a massive breaking change Since most operators are defined using lift and thus unsafeSubscribe it is not an issue there Can t we introduce an unsafeCreate operator that does not protect and use that internally user code will use the safe variant I tend to save all current subscriptions in my Android apps on the Activity then when the Activity is destroyed it unsubscribes from them all in order to free up resources It gets used extensively there I think it is required because if the Subscription holds a reference to the Activity via onNext etc then the Activity may never be deallocated I have an app that has a long lasting TCP connection pumping events into a hot Observable that survives multiple Activities and if I could not unsubscribe from it then those Activities would be leaked It would require using WeakReferences to the activity inside of subscriptions to overcome I think which was used in the Android library previously but was removed because it caused other problems I cannot recall what they were @DylanSale Thanks for helping on this I m pretty certain we can t do this change as it is a very significant breaking change for this late in the game Putting that aside on your use case would it work if you use takeWhile or takeUntil instead of capturing all of the subscriptions In short something like this java someObservable takeUntil activityDestroyed subscribe s or someObservable takeWhile activityIsActive subscribe s Yes it looks like that would work Cheers for that I did some further testing on different approaches and here are the results manually formatted to make it more readable while comparing non volatile volatile synchronized synchronized AtomicIntegerFieldUpdater SubscriptionList SubscriptionList SubscriptionList SafeSubscriber Subscriptionlist Baseline without RxJava r PerfBaseline iterableViaForLoopConsumption 1 248 286 785 loops over iterable of 1 item consumed into Observer onNext r PerfBaseline iterableViaForLoopConsumption 1000 182 798 loops over iterable of 1000 items consumed into Observer onNext r PerfBaseline iterableViaForLoopConsumption 1000000 172 loops over iterable of 1 000 000 items consumed into Observer onNext r PerfBaseline iterableViaHasNextConsumption 1 325 036 745 r PerfBaseline iterableViaHasNextConsumption 1000 298 493 r PerfBaseline iterableViaHasNextConsumption 1000000 268 non volatile volatile synchronized synchronized AtomicIntegerFieldUpdater SubscriptionList SubscriptionList SubscriptionList SafeSubscriber Subscriptionlist Fastest we should expect from RxJava Single Observable subscribed to repeatedly via unsafeSubscribe without any wrapping new Subscriber each time r PerfBaseline observableConsumptionUnsafe 1 121 447 376 66 666 838 121 434 744 122 254 109 68 761 481 r PerfBaseline observableConsumptionUnsafe 1000 318 131 319 493 318 508 320 140 318 099 r PerfBaseline observableConsumptionUnsafe 1000000 315 308 314 315 315 r PerfBaseline observableViaRangeUnsafe 1 230 223 319 96 690 586 223 722 344 230 588 005 99 951 920 r PerfBaseline observableViaRangeUnsafe 1000 310 078 297 840 231 158 311 091 309 594 r PerfBaseline observableViaRangeUnsafe 1000000 280 268 200 267 246 non volatile volatile synchronized synchronized AtomicIntegerFieldUpdater SubscriptionList SubscriptionList SubscriptionList SafeSubscriber Subscriptionlist r PerfBaseline observableConsumption 1 54 346 582 29 219 633 37 542 983 32 687 078 26 254 636 r PerfBaseline observableConsumption 1000 246 747 231 651 266 484 245 754 246 173 r PerfBaseline observableConsumption 1000000 252 237 259 249 251 r PerfBaseline observableViaRange 1 55 475 749 29 832 040 34 142 305 32 975 147 29 737 054 r PerfBaseline observableViaRange 1000 255 971 234 519 168 015 214 055 255 824 r PerfBaseline observableViaRange 1000000 222 214 170 174 226 non volatile volatile synchronized synchronized AtomicIntegerFieldUpdater SubscriptionList SubscriptionList SubscriptionList SafeSubscriber Subscriptionlist r o OperatorMergePerf merge1SyncStreamOfN 1 8 598 036 8 221 514 8 324 789 8 587 566 7 908 497 r o OperatorMergePerf merge1SyncStreamOfN 1000 81 244 11 1945 98 456 81 036 81 396 r o OperatorMergePerf merge1SyncStreamOfN 1000000 72 78 64 75 73 r o OperatorMergePerf mergeNAsyncStreamsOfN 1 102 689 105 055 103 722 103 979 101 734 r o OperatorMergePerf mergeNAsyncStreamsOfN 1000 8 8 5 8 8 r o OperatorMergePerf mergeNSyncStreamsOf1 1 10 586 891 9 149 101 9 365 997 9 961 394 9 045 580 r o OperatorMergePerf mergeNSyncStreamsOf1 100 1 139 139 1 060 454 962 148 1 134 602 1 051 191 r o OperatorMergePerf mergeNSyncStreamsOf1 1000 95 961 99 052 79 349 101 080 98 040 r o OperatorMergePerf mergeNSyncStreamsOfN 1 9 794 588 8 852 408 9 040 839 8 803 122 9 054 888 r o OperatorMergePerf mergeNSyncStreamsOfN 1000 83 82 74 72 83 r o OperatorMergePerf mergeTwoAsyncStreamsOfN 1 81 126 81 421 81 029 81 481 80 370 r o OperatorMergePerf mergeTwoAsyncStreamsOfN 1000 5 837 5 670 3 808 5 721 4 873 r o OperatorMergePerf oneStreamOfNthatMergesIn1 1 9 195 390 7 852 711 8 360 268 8 650 547 8 238 710 r o OperatorMergePerf oneStreamOfNthatMergesIn1 1000 77 743 75 857 70 337 79 576 76 601 r o OperatorMergePerf oneStreamOfNthatMergesIn1 1000000 79 79 73 71 79 Considering it as unlikely that we can make the necessary changes to allow a Subscription to not be thread safe it seems that using synchronized instead of volatile is better in most situations though all of the alternatives I pursued obviously have a performance penalty Unless we make a design change that removes direct use of Subscription unsubscribed and pushes those use cases to takeWhile takeUntil and other such operators I think Subscription needs to ensure thread safety It can not be hidden inside something like a createUnsafe because the create has nothing to do with the Subscription which is passed into it at subscription time The issue is that the Subscription is given back to the user where by definition if they call unsubscribe it is happening from a different thread and since isUnsubscribed is checked inside tight loops it must be at least volatile to ensure visibility of changes across threads and comes with the cost Does anyone disagree with my assessment and testing above Is there a better alternative I m not considering I can give the raw JMH results if interested And sorry about the wrong post that I posted then deleted and the closing reopening of this issue fat fingered it By the way the tests I included above show two different perspectives of RxJava The PerfBaseline ones are showing the fastest possible use cases of RxJava with just the overhead of Observable and Subscriber I then include merge since it commonly is used via flatMap The results show merge is impacted far less by this decision primarily because there is already quite a bit of overhead in doing merge and all the bookkeeping and concurrency it naturally has Due to this the impact of volatile is hardly noticeable The point of this issue is to present and discuss the impact of requiring a thread safe Subscription for pipelines that are trying to be as fast as possible pure pub sub or simple map transformations without going through anything heavy like merge flatMap or observeOn Ideally if I could go back in time I think I would change the signature of Subscription subscribe Subscriber s to void subscribe Subscriber s and say that takeWhile and takeUntil are the general approach to handling unsubscribe or calling unsubscribe directly from within Subscriber onNext but rarely or never from the outside like we allow by returning a Subscription',RxJava,false,false,false
36404798,'Explore SubscriptionList Subscriber Synchronization','This is an exploratory pull request related to https github com Netflix RxJava issues 1383 that removes SubscriptionList synchronization and synchronizes ObserveOn unsubscribe The performance impact on rapid subscribe unsubscribe such as an Observable with 1 item is significant 31m 47m ops second What I don t know however is if this is completely safe Some unit tests did indeed fail when I removed the synchronization from SubscriptionList until I modified observeOn so that s good Then the unit tests all passed again when I made observeOn handle the synchronization I have to think however that there are use cases I m not covering with unit tests I d appreciate other peoples thoughts on this BEFORE Benchmark size Mode Samples Mean Mean error Units r PerfBaseline observableConsumption 1 thrpt 5 31167007 424 2027918 084 ops s r PerfBaseline observableConsumption 1000 thrpt 5 227387 447 32738 021 ops s r PerfBaseline observableConsumption 1000000 thrpt 5 245 632 13 743 ops s AFTER Benchmark size Mode Samples Mean Mean error Units r PerfBaseline observableConsumption 1 thrpt 5 47142418 802 5341223 740 ops s r PerfBaseline observableConsumption 1000 thrpt 5 220175 324 35936 506 ops s r PerfBaseline observableConsumption 1000000 thrpt 5 221 077 44 437 ops s BEFORE Benchmark size Mode Samples Mean Mean error Units r o OperatorObserveOnPerf observeOnComputation 1 thrpt 5 86331 092 5181 739 ops s r o OperatorObserveOnPerf observeOnComputation 1000 thrpt 5 8787 634 316 166 ops s r o OperatorObserveOnPerf observeOnComputation 1000000 thrpt 5 8 590 4 527 ops s r o OperatorObserveOnPerf observeOnImmediate 1 thrpt 5 13074710 596 217808 611 ops s r o OperatorObserveOnPerf observeOnImmediate 1000 thrpt 5 188868 055 5448 065 ops s r o OperatorObserveOnPerf observeOnImmediate 1000000 thrpt 5 185 372 4 190 ops s r o OperatorObserveOnPerf observeOnNewThread 1 thrpt 5 13848 943 2601 271 ops s r o OperatorObserveOnPerf observeOnNewThread 1000 thrpt 5 6867 300 172 123 ops s r o OperatorObserveOnPerf observeOnNewThread 1000000 thrpt 5 10 100 1 925 ops s AFTER Benchmark size Mode Samples Mean Mean error Units r o OperatorObserveOnPerf observeOnComputation 1 thrpt 5 69120 389 16422 228 ops s r o OperatorObserveOnPerf observeOnComputation 1000 thrpt 5 12261 472 267 137 ops s r o OperatorObserveOnPerf observeOnComputation 1000000 thrpt 5 15 466 0 269 ops s r o OperatorObserveOnPerf observeOnImmediate 1 thrpt 5 13200910 511 418278 691 ops s r o OperatorObserveOnPerf observeOnImmediate 1000 thrpt 5 179868 400 6465 965 ops s r o OperatorObserveOnPerf observeOnImmediate 1000000 thrpt 5 184 210 2 299 ops s r o OperatorObserveOnPerf observeOnNewThread 1 thrpt 5 12880 951 2183 905 ops s r o OperatorObserveOnPerf observeOnNewThread 1000 thrpt 5 9164 764 385 580 ops s r o OperatorObserveOnPerf observeOnNewThread 1000000 thrpt 5 17 249 1 173 ops s','RxJava pull requests #1321 https netflixoss ci cloudbees com job RxJava pull requests 1321 SUCCESS This pull request looks good RxJava pull requests #1326 https netflixoss ci cloudbees com job RxJava pull requests 1326 SUCCESS This pull request looks good I think this is okay with the two common ways of making an Observable async java Assert that a non thread safe SubscriptionList works okay being unsubscribed when everything is moved to a separate thread p This should be okay as long as all notifications occurs on the new thread @Test public void testOnSubscribeConcurrencyWithCustomThread for int i 0 i 100 i TestSubscriber Integer ts new TestSubscriber Integer Observable create new OnSubscribe Integer @Override public void call final Subscriber super Integer s new Thread new Runnable int i 0 @Override public void run while s isUnsubscribed s onNext i if i 1000 s onError new RuntimeException expected to be unsubscribed at 1000 i start take 1000 subscribe ts ts awaitTerminalEvent ts assertNoErrors this should NOT be running on the main thread assertTrue ts getLastSeenThread getName contains main @Test public void testOnSubscribeConcurrencyWithSubscribeOn for int i 0 i 100 i TestSubscriber Integer ts new TestSubscriber Integer Observable create new OnSubscribe Integer int i 0 @Override public void call final Subscriber super Integer s while s isUnsubscribed s onNext i if i 1000 s onError new RuntimeException expected to be unsubscribed at 1000 i subscribeOn Schedulers computation take 1000 subscribe ts ts awaitTerminalEvent ts assertNoErrors this should NOT be running on the main thread assertTrue ts getLastSeenThread getName contains main In both cases the onNext and unsubscribe are happening on the same thread This however is an awkward case java TestSubscriber Integer ts new TestSubscriber Integer Subscription s Observable create new OnSubscribe Integer int i 0 @Override public void call final Subscriber super Integer s while s isUnsubscribed s onNext i if i 1000000 s onError new RuntimeException should have been unsubscribed externally but appears not to have i s onCompleted subscribeOn Schedulers computation subscribe ts Thread sleep 10 s unsubscribe The Subscription is received outside on the main thread but the work is happening on Schedulers computation The unsubscribe therefore is happening across thread boundaries As of 0 17 I question this being allowed and would rather stop returning Subscription from the subscribe method To make this safe would require wrapping the non thread safe Subscription before returning it just in case someone does this very very rare Impact of wrapping it 41m ops second 34m ops second By the way for comparison removing SafeSubscriber takes us from 45m 85m ops second That s how impactful object allocation is when creating and subscribing to Observables that have a single item in them all the time is spent on object creation and capture If I remove the volatile from SafeSubscriber and continue the assumption that onNext onCompleted onError are sequential I can get up to 51m ops second We still have the cost of object allocation but eliminate the volatile cost Here are performance numbers showing the impact of these changes 0 19 Benchmark size Mode Samples Mean Mean error Units r PerfBaseline observableConsumption 1 thrpt 5 31881123 086 1556397 821 ops s r PerfBaseline observableConsumption 1000 thrpt 5 235797 222 13915 448 ops s r PerfBaseline observableConsumption 1000000 thrpt 5 245 064 12 162 ops s r PerfBaseline observableViaRange 1 thrpt 5 25019595 907 797863 816 ops s r PerfBaseline observableViaRange 1000 thrpt 5 186548 299 10512 421 ops s r PerfBaseline observableViaRange 1000000 thrpt 5 183 245 13 291 ops s 0 19 with volatile synchronization changes Benchmark size Mode Samples Mean Mean error Units r PerfBaseline observableConsumption 1 thrpt 5 58303018 095 935455 977 ops s r PerfBaseline observableConsumption 1000 thrpt 5 227118 383 19715 515 ops s r PerfBaseline observableConsumption 1000000 thrpt 5 227 567 43 552 ops s r PerfBaseline observableViaRange 1 thrpt 5 29536860 600 475787 569 ops s r PerfBaseline observableViaRange 1000 thrpt 5 184212 623 4187 098 ops s r PerfBaseline observableViaRange 1000000 thrpt 5 178 653 12 047 ops s backpressure 7 Benchmark size Mode Samples Score Score error Units r PerfBaseline observableConsumption 1 thrpt 5 50367010 733 2884558 129 ops s r PerfBaseline observableConsumption 1000 thrpt 5 231407 494 9519 348 ops s r PerfBaseline observableConsumption 1000000 thrpt 5 232 499 21 800 ops s r PerfBaseline observableViaRange 1 thrpt 5 26502187 876 524628 593 ops s r PerfBaseline observableViaRange 1000 thrpt 5 167343 786 4203 656 ops s r PerfBaseline observableViaRange 1000000 thrpt 5 53 195 2 001 ops s In short 0 19 before changes 31 8m ops second 0 19 after changes 58 3m ops second 0 20 before changes 18 0m ops second 0 20 after changes 50 3m ops second These changes reduce the performance impact of backpressure machinery on throughput when backpressure is not being applied Not doing this It breaks too many things Not doing this It breaks too many things',RxJava,true,false,false
36447920,'OperatorTake remove unsubscribe call to parent on take 0','This is a very minor cleanup of OperatorTake By changing the order of the existing code I removed a call to parent unsubscribe','RxJava pull requests #1324 https netflixoss ci cloudbees com job RxJava pull requests 1324 SUCCESS This pull request looks good What problem are you trying to solve If it doesn t unsubscribe the upstream will continue to produce and it will just get filtered out and cause unnecessary work until the final SafeSubscriber calls unsubscribe up the chain This could be a non deterministic amount of time later if the onComplete is scheduled on other threads delayed or other such things That is why it immediately unsubscribes so the parent will stop without waiting I think the eager unsubscription works and might offer some performance benefit but other operators don t do eager unsubscriptions just after calling onComplete They rather leave it for the unsubscription from downstream Does it set a strange example Motivation for even noticing this was I have been looking at Operators in the code base trying to glean facts and principles and conventions about writing Operators Purpose is to update the wiki article on How to implement your own operator https github com Netflix RxJava wiki Implementing Your Own Operators My statement other operators don t do eager unsubscriptions just after calling onComplete looks to be completely without evidence On that basis let s give this request the boot The merge operator is the stereotypical example of where eager unsubscription is required rather than waiting for SafeSubscriber to do it An infinite Observable that is being flat mapped merging an infinite number of Observable s would never clean up unsubscribe the Observable s being merged into it if it didn t do eager unsubscription The general rule is for operators to not need to concern themselves with cleanup unless they are involved in the termination of individual Observable s without the entire downstream also being terminated yes indeed that s clear thanks',RxJava,true,false,false
36455018,'add Observable sort instance methods','Added two Observable sort instance methods that are equivalent to java Observable toSortedList flatMap x Observable from x I guess you might ask well why don t people just code that I think it adds the following a more natural reading api method doesn t interrupt the observable flow with buffered type Observable List T less mess for those people coding without lambdas','RxJava pull requests #1325 https netflixoss ci cloudbees com job RxJava pull requests 1325 SUCCESS This pull request looks good I am not a big fan of having any sort of sort on observables Sorting in general makes little sense for observable streams rule of thumb it you cannot write using scan it should probably not be there If you do want to sort that is available on regular finite lists Sorting doesn t make sense for infinite streams of course On one project I use rxjava in a high performance computing role to process chunks of data on disk Many thousands of chunks of data need to be sorted within each chunk then aggregated chunk by chunk in parallel later merged and aggregated with another function Works well and quickly very happy with it Observables come in all flavours small large infinite etc and a sort method makes sense for the small collection wholly fits in memory to me But you are not sorting an observable you are sorting a list created from an observable Saying xs sort seems like it is harmless but it isn t Truth in advertising And for your scenario of course I lack the details but I really wonder why you turn sorted lists back to observables and don t work at the level of Observable List T as opposed to flattening Observable T Note it sucks that Java does not have extension methods In NET or Scala you can easily add this as a convenience method for your specific use case my scenario nope not that simple The top level code is here https gist github com davidmoten e6d630ae2b2c8cf91a34 if you are interested but it might be a bit too much detail In short I have 115m timestamped position reports for ships over a year and for each ship I load the reports and sort by time they arrive out of order due to different delivery latencies At that point I can join the dots and start calculating metrics about grids on the earth like distance travelled per cell you then end up with nifty vessel traffic density plots I take your point about extension methods The language you use changes the things you care about eh I m a long term scala person but haven t used rxjava with it yet I m not really fussed about this pull request just thought I d put it out there as a practical thing and expected pushback as the sort method is an obvious omission from the api had to be deliberate had to be deliberate Very deliberate It is not a streaming operation I d like to explore this a bit further to see if I can glean a rule to apply in other similar situations The sort method as proposed has some characteristics that are apparently inherently undesirable buffers entire incoming stream till completion then starts emitting changes the order of the incoming items I m assuming that the 2nd point is not a problem asynchronous processing can change order anyway and we often don t mind Re the first point let s look at the the last method which waits till completion before emitting It seems to be a bona fide member of the ok Observable methods so I assume there is nothing inherently undesirable about it We are left with the fact that the entire stream is buffered In general this sounds risky if your buffer has practical limits like available memory So lets reword the objection as that a potentially large stream is buffered I went looking for card carrying Observable methods that have this characteristic and there are a few among them zip merge and window with a time interval Those methods are part of the backpressure work going on at the moment and may not threaten a buffer filling if backpressure can be applied So perhaps that is the nub of it The sort method is an undesirable method in a streaming world because it buffers potentially large streams and the only way backpressure can assist is in preventing completion No doubt I ve missed something important Enlighten me @headinthebox Well behaved operators should produce output in constant time after receiving input This has nothing to do with back pressure please don t confuse orthogonal concerns Changing the order is ok as soon as you do flatMap or merge that will happen So last is dangerous as well like any other operator that buffers values until the end take linear time to produce output Alas it is too late to kick it out zip is dangerous because producing output depends on two streams so the fact that output is produced in constant time or not looking for one of the inputs is determined by the other merge is OK since it produced output as soon as input arrives as is window which immediately starts producing output when a new window is produced buffer is still OK since its intent is to produce input as soon as it can but generally it is better to use window if you want to be streaming The toList operator is the worst of the bunch By the way we already have toSortedList which is already bad and does virtually the same thing as sort just it emits List T rather than flattening back into T If I could go back to the beginning of RxJava I d probably argue for these types of operators to be on a different Observable similar to how BlockingObservable was separated out If I could go back to the beginning of RxJava Yes me too I m still searching for a bit of precision about these undesirable operators The idea of producing output within constant time is interesting but I can manufacture a variant of sort that emits a STILL_GOING token every N input items and I suspect that that operator is still an undesirable I m suspecting that it hinges on emission after completion of source Note that buffer can emit after completion of source but does not always do so Note also that materialize always emits after completion but emits a constant So how s this an operator is undesirable if the operator always emits non constant information after source completion On this basis the following operators would be considered undesirable or bad sort doesn t exist except in this pull request last toSortedList toList toMap toMultimap all collect I think though haven t looked closely at this one count max min sum takeLast The above criterion does not categorize zip as undesirable but as it operates on multiple streams I think it s a special case that could be explored on its own Your list is correct and include reduce This was discussed somewhat in https github com Netflix RxJava issues 671 Adding a sort function to the current state of Observable is no different than having toSortedList which we already have As I mentioned above if I could go back in time I would argue for moving all of these aggregate terminal operators to a different Observable The way I d prefer to handle these flattening requirements is with a flatten operator but Java doesn t make that easy to do There is a discussion about that in https github com Netflix RxJava issues 295 I think the main drawback of an operator called sort as opposed to toSortedList is whether it is clear to people that sort will wait until the entire origin is finished before starting to emit anything The toSortedList operator is at least explicit about this toSortedList flatten is more explicit than sort if we had flatten The same reason reduce collect are dangerous None of those however are necessarily reasons for not adding sort since we obviously already have this problem IMHO you are overanalyzing this a bit Of course creating a stuttering term they use for this in process algebra stream when you sort is not very useful I am not I understand what the problem is with materialize emitting after completion it just turns an Observable T into an Observable Notification T and does not wait for the input stream to terminate to produce notifications Same with buffer it outputs the buffered values as soon as the buffer is filled as you asked for but as I said you should normally prefer window That aside your list is spot on You miss reduce and probably some other operators as well like concatMap Note however that sometimes doing a toList on a nested observable is exactly what you need but typically not a good idea I m more interested in the criterion I put forward than the list and I wasn t suggesting there is a problem with emitting after completion like buffer can do and materialize does Here s the criterion an operator is bad if it always emits non constant information after source completion None of this is an argument for adding sort I don t really care about that What I m interested in is characterizing the API I routinely use the so called bad operators and am glad they are there but I think what s going on is that the rxjava API serves both a general purpose functional programming role as well as the stream processing role Splitting stuff off into separate stream and non stream modules is a pain for people because as @headinthebox mentions we don t have extension methods in java Oh well I m still pretty happy with the API as is but wouldn t mind if more non stream bits got chucked in for general convenience Not sure that works for example under this definition scan would be bad I think it is easier better to think what a good operator is namely one that produces its results incrementally For example if you look at groupBy in Rx we made sure sends out new groups and values on existing groups as soon as a new element arrives on the input whereas in SQL or most implementation on in memory collections groupBy in not incremental like that But even then groupBy is kind of dangerous because it can have an unbounded number of keys that why we have groupByUntil Not you could try to define a sort function that would send out the input so far as incremental sorted lists but obviously that would not work for infinite streams You may want to take a look at http en wikipedia org wiki Streaming_algorithm as well for interesting algorithms over infinite streams That s a good characterization of it the stream vs non stream operators I think the question comes down to what s more important having easy familiar in your face dangling right off Observable access to non stream operators or the fact that people then really need to understand which ones work on infinite streams and which ones require a terminal state We already crossed that line Rx Net led the way So do we try and pull back or do we just accept it and let them all be in here If we do let them all in do we distinguish between them in any way Note that there is no problem combining Rx with say Java8 streams when you do toList and then call the existing operators on those If you would look at my code you see this split a lot I e don t try to use Rx for collections that are really lists for that use http docs oracle com javase 8 docs api java util stream Stream html To be fair @benjchristensen in NET we pulled back as well No API is perfect but that should not be a reason to make it more imperfect @headinthebox I totally agree I was just commenting on how we re in a weird middle ground where we have a mixture so it s hard to say no to adding new non stream operators when precedent already exists Using the bad definition scan is not bad it doesn t emit after completion but rather emits after each item reduce on the other hand would be bad I m going to try to redefine bad Define a well behaved stream operator as one that does not always emits non constant information after source completion I ve had a great time using the functional and streaming aspects of the api together It s an absolute winner in the java space especially pre java 8 but also post We could add javadoc to the poorly behaved stream operators so that people know and allow useful functional constructs to enter the api I m not a fan of making things verbose in the API because it s educational in some sense toSortedList flatten Documentation can help there Perhaps this Stream Operator Criterion An Operator is considered a Stream Operator if and only if it does not always emit non constant information after source completion I m going to pass on this for now sorting of streams is generally a bad idea and we already have toSortedList and window buffer that can then each be sorted',RxJava,true,false,false
36504294,'Upgrade to JMH 0 9','','',RxJava,true,false,false
36530348,'CompositeException stops mutating nested Exceptions','Instead it aggregates them at print time Since nothing is being mutated there s no chance of accidentally creating a cycle in the Exception chain We ran into this in production very intermittently and had to add handling any time we were touching the Exception chain','RxJava pull requests #1329 https netflixoss ci cloudbees com job RxJava pull requests 1329 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1330 https netflixoss ci cloudbees com job RxJava pull requests 1330 SUCCESS This pull request looks good',RxJava,true,false,false
36535494,'SerializedObserverTest testNoficationDelay not deterministic','This test https github com Netflix RxJava blob 0 19 1 rxjava core src test java rx observers SerializedObserverTest java#L274 284 is failing 50 of the time on my old laptop and if I bump up n to 10000 on a modern desktop it fails all the time My laptop runs ubuntu 12 04 i5 4 virtual processors java 8 runtime and failed 5 out of 10 tests with n 10 My desktop runs ubuntu 12 04 xeon 12 virtual processors java 8 runtime and fails every time after i gets between 1000 and 3000 The line failing is line 330 assertSame t1 t2','The test is commented out right now https github com Netflix RxJava blob master rxjava core src test java rx observers SerializedObserverTest java#L273 If anyone can spend time figuring this out I d appreciate it so we can re enable the test',RxJava,false,false,false
36537509,'initial gradle build fails with Artifact com google guava guava 11 0 2@jar not found','After cloning from Github running gradle fails with java version java version 1 7 0_51 Java TM SE Runtime Environment build 1 7 0_51 b13 Java HotSpot TM 64 Bit Server VM build 24 51 b03 mixed mode gradlew eclipse Downloading http services gradle org distributions gradle 1 8 all zip Unzipping home gliptak gradle wrapper dists gradle 1 8 all 2kopnp0i5dq014k75fp36m3vd5 gradle 1 8 all zip to home gliptak gradle wrapper dists gradle 1 8 all 2kopnp0i5dq014k75fp36m3vd5 Set executable permissions for home gliptak gradle wrapper dists gradle 1 8 all 2kopnp0i5dq014k75fp36m3vd5 gradle 1 8 bin gradle Download http dl bintray com content netflixoss external gradle plugins nl javadude gradle plugins license gradle plugin 0 6 1 license gradle plugin 0 6 1 pom Download http repo1 maven org maven2 com mapvine gradle cobertura plugin 0 1 gradle cobertura plugin 0 1 pom Download http dl bintray com content netflixoss external gradle plugins gradle release gradle release 1 1 5 gradle release 1 1 5 pom Download http repo1 maven org maven2 org ajoberstar gradle git 0 5 0 gradle git 0 5 0 pom Download http dl bintray com content gvsmirnov gradle plugins com github jengelman gradle plugins shadow 0 8 1 shadow 0 8 1 pom Download http repo1 maven org maven2 com mycila maven license plugin maven license plugin 1 10 b1 maven license plugin 1 10 b1 pom Download http repo1 maven org maven2 com mycila parent pom 5 parent pom 5 pom Download http repo1 maven org maven2 org eclipse jgit org eclipse jgit ui 2 2 0 201212191850 r org eclipse jgit ui 2 2 0 201212191850 r pom Download http repo1 maven org maven2 org eclipse jgit org eclipse jgit parent 2 2 0 201212191850 r org eclipse jgit parent 2 2 0 201212191850 r pom Download http repo1 maven org maven2 org eclipse jgit org eclipse jgit 2 2 0 201212191850 r org eclipse jgit 2 2 0 201212191850 r pom Download http repo1 maven org maven2 jdom jdom 1 1 jdom 1 1 pom Download http repo1 maven org maven2 asm asm 3 3 1 asm 3 3 1 pom Download http repo1 maven org maven2 asm asm parent 3 3 1 asm parent 3 3 1 pom Download http repo1 maven org maven2 asm asm commons 3 3 1 asm commons 3 3 1 pom Download http repo1 maven org maven2 com mycila xmltool xmltool 3 3 xmltool 3 3 pom Download http repo1 maven org maven2 org codehaus plexus plexus utils 2 0 5 plexus utils 2 0 5 pom Download http repo1 maven org maven2 org codehaus plexus plexus 2 0 6 plexus 2 0 6 pom Download http repo1 maven org maven2 com jcraft jsch 0 1 44 1 jsch 0 1 44 1 pom Download http repo1 maven org maven2 org sonatype oss oss parent 6 oss parent 6 pom Download http repo1 maven org maven2 org jdom jdom 1 1 jdom 1 1 pom Download http repo1 maven org maven2 asm asm tree 3 3 1 asm tree 3 3 1 pom Download http dl bintray com content netflixoss external gradle plugins nl javadude gradle plugins license gradle plugin 0 6 1 license gradle plugin 0 6 1 jar Download http repo1 maven org maven2 com mapvine gradle cobertura plugin 0 1 gradle cobertura plugin 0 1 jar Download http dl bintray com content netflixoss external gradle plugins gradle release gradle release 1 1 5 gradle release 1 1 5 jar Download http repo1 maven org maven2 org ajoberstar gradle git 0 5 0 gradle git 0 5 0 jar Download http dl bintray com content gvsmirnov gradle plugins com github jengelman gradle plugins shadow 0 8 1 shadow 0 8 1 jar FAILURE Build failed with an exception What went wrong A problem occurred configuring root project rxjava Could not resolve all dependencies for configuration classpath Could not download artifact com google guava guava 11 0 2@jar Artifact com google guava guava 11 0 2@jar not found Try Run with stacktrace option to get the stack trace Run with info or debug option to get more log output BUILD FAILED Total time 5 mins 50 933 secs The guava jar does seem to be available at http repo1 maven org maven2 com google guava guava 11 0 2 Did I miss some required settings Thanks','Looks like your maven repo cache is corrupted Try deleting m2 and building again Yes deleting m2 cleared the error Thank you for the pointer Is there any other option besides deleting m2 just cleaning the folder guava works for me',RxJava,false,false,false
36565766,'RxScala Improve type inference','What do you think if we change the signatures below def combineLatest U R that Observable U f T U R Observable R def zipWith U R that Observable U selector T U R Observable R def combineLatestWith U R that Observable U selector T U R Observable R def zipWith U R that Observable U selector T U R Observable R to improve type inference so we don t need to provide explicit parameter types for the lambdas and for more uniform naming It is kind of weird that we have zipWith but not combineLatestWith cc @samuelgruetter @zsxwing','1 @zsxwing You wanna help go through the API and curry and possibly rename a few operators such that we can maximize type inference see http pchiusano blogspot in 2011 05 making most of scalas extremely limited html Sure I can take it this weekend Cool thanks let s make sure that no type is left uninferred Anything more to do on this issue or can it be closed We can close this @zsxwing did a great job',RxJava,false,false,false
36566522,'RxScala more opportunities for better type inference','Some other function that we might look at amongst others def window Opening openings Observable Opening closings Opening Observable Any def buffer Opening openings Observable Opening closings Opening Observable Any Observable Seq T def flatMap U R collectionSelector T Observable U resultSelector T U R Observable R def flatMapIterable U R collectionSelector T Iterable U resultSelector T U R Observable R def groupByUntil K f T K closings K Observable T Observable Any Observable K Observable T def groupByUntil K V keySelector T K valueSelector T V closings K Observable V Observable Any Observable K Observable V def groupJoin S R other Observable S leftDuration T Observable Any rightDuration S Observable Any resultSelector T Observable S R Observable R def sequenceEqual U T that Observable U equality U U Boolean Observable Boolean to def window Opening openings Observable Opening closings Opening Observable Any def buffer Opening openings Observable Opening closings Opening Observable Any Observable Seq T def flatMap U R collectionSelector T Observable U resultSelector T U R Observable R def flatMapIterable U R collectionSelector T Iterable U resultSelector T U R Observable R def groupByUntil K f T K closings K Observable T Observable Any Observable K Observable T def groupByUntil K V keySelector T K valueSelector T V closings K Observable V Observable Any Observable K Observable V def groupJoin S R other Observable S leftDuration T Observable Any rightDuration S Observable Any resultSelector T Observable S R Observable R def sequenceEqual U T that Observable U equality U U Boolean Observable Boolean This is more in line with scan and fold as well','See this post for more info http pchiusano blogspot in 2011 05 making most of scalas extremely limited html I have to confess that coming from C# where the uncurried signatures just work having to write types in Scala all the time and worse fighting the compiler to fix type errors was always annoying but I did not know that currying would fix a lot of the pain until Martin Odersky told me when I complained about it to him I will go through all RxScala signatures and curry them as much as possible for the 0 20 release This will be a lot of breaking changes but it will make using Rx in Scala orders of magnitude more pleasant and this is our last opportunity to do that So speak now or forever hold your peace Nice post 1 for using currying There are conflicts in the following methods if using currying scala def flatMap R f T Observable R Observable R def flatMap U R collectionSelector T Observable U resultSelector T U R Observable R def flatMapIterable R collectionSelector T Iterable R Observable R def flatMapIterable U R collectionSelector T Iterable U resultSelector T U R Observable R def buffer boundary Observable Any Observable Seq T def buffer Opening openings Observable Opening closings Opening Observable Any Observable Seq T def window boundary Observable Any Observable Observable T def window Opening openings Observable Opening closings Opening Observable Any def sequenceEqual U T that Observable U Observable Boolean def sequenceEqual U T that Observable U equality U U Boolean Observable Boolean E g The compiler will report error missing parameter type for the following code scala val o Observable items 10 100 o flatMap n Observable interval 200 millis map _ n take 20 toBlocking foreach println I need to add Int to resolve it scala val o Observable items 10 100 o flatMap Int n Observable interval 200 millis map _ n take 20 toBlocking foreach println This is quite inconvenient since flatMap is a very common operator Renaming the currying methods to xxxWith can solve the conflicts @headinthebox thoughts Renaming the currying methods to xxxWith can solve the conflicts Yes that was I was thinking as well for flatMap We do that for zipWith already and in case of flatMap it is the same pattern as zip where we pass in an additional result selector That will work for sequenceEqual as well So those are OK For window and buffer I need to sleep over it there the second function is not a result selector like the previous ones For window and buffer we may use tumblingWindow and tumblingBuffer for the overloads that only take boundaries and the ones that take opening and closing slidingWindow and slidingBuffer that s what the CEP people call them I actually like that because it makes the difference clear in the name How does that sound @zsxwing Also Scala has sliding http www scala lang org api current index html#scala collection Seq but they use sliding for both tumbling non overlapping as well as for properly sliding windows Maybe we should sliding and tumbling as shorthands for tumblingWindow and slidingWindow and then use the appropriate long names for buffer since that more dangerous because it buffers And another option is something like this scala def flatMap S R f T Observable S Observable S with Object def finish R g T S R Observable R new Observable S override private scala val asJavaObservable rx Observable _ S src flatMap f asJavaObservable def finish R g T S R src flatMap f g which allows you to write xs flatMap f finish g map h as well as xs flatMap f map h Would like to use with but that is a Scala keyword This is a trick of returning a subtype with a few additional methods is something we do in NET a lot for example for writing xs orderby f thenBy g map h xs flatMap f finish g map h This does not work because the return type is not a part of method signature E g val ys xs flatMap f what s the type of ys flatMap should be def flatMap R f T Observable R Observable R or def flatMap S R f T Observable S Observable S with Object The latter you return a subtype that has additional methods which is the static type of ys Oh I see Sorry that I misunderstood your idea So you mean combining the two methods scala def flatMap R f T Observable R Observable R def flatMap U R collectionSelector T Observable U resultSelector T U R Observable R to only one method However I prefer the renaming idea I like less Observables and less concepts In addition for sequenceEqual Scala Seq has sameElements Do you think which one is better renaming sequenceEqual to sameElements or add sameElements as an alias to sequenceEqual Maybe we should sliding and tumbling as shorthands for tumblingWindow and slidingWindow and then use the appropriate long names for buffer since that more dangerous because it buffers Sound great for me Is this issue done now',RxJava,false,false,false
36625513,'Add cache int capacity to Observable','Proposed patch for #1303','RxJava pull requests #1335 https netflixoss ci cloudbees com job RxJava pull requests 1335 SUCCESS This pull request looks good',RxJava,true,false,false
36628604,'Set scalatest as testCompile dependency','Gradle now generates correct eclipse dependencies','RxJava pull requests #1336 https netflixoss ci cloudbees com job RxJava pull requests 1336 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1361 https netflixoss ci cloudbees com job RxJava pull requests 1361 SUCCESS This pull request looks good Cleaned up more provided references LGTM With current master running gradlew eclipse generates a project file which does not contain the scalatest JAR so Eclipse cannot build the project I ve been annoyed by this for a long time already and just fixed it by manually adding the scalatest JAR because I did not know how to fix the gradle configuration This PR fixes the problem so that gradlew eclipse generates a correct project file Thank you @gliptak Could you also fix other build gradle s RxJava pull requests #1363 https netflixoss ci cloudbees com job RxJava pull requests 1363 SUCCESS This pull request looks good RxJava pull requests #1370 https netflixoss ci cloudbees com job RxJava pull requests 1370 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1371 https netflixoss ci cloudbees com job RxJava pull requests 1371 SUCCESS This pull request looks good @zsxwing with this last commit I removed support for provided in the general build process so I would like to suggest staying with compile for now I looked into switching to http tools android com tech docs new build system user guide The changes will be fairly invasive as the plugin android conflicts with plugin java so I would like to work that as a separate pull request @gliptak sorry that I may explain unclearly I mean let s keep the following lines provided com google android android 4 0 1 2 provided com google android support v4 r7 For the android gradle plugin I mean when some projects depends on rxjava android they can use android gradle plugin I don t mean that rxjava android needs to use it So for rxjava android I suggest we only need to do the following changes provided junit junit dep 4 10 provided org mockito mockito core 1 8 5 provided org robolectric robolectric 2 2 testCompile junit junit dep 4 10 testCompile org mockito mockito core 1 8 5 testCompile org robolectric robolectric 2 2 RxJava pull requests #1376 https netflixoss ci cloudbees com job RxJava pull requests 1376 FAILURE Looks like there s a problem with this pull request Hmm The build failed with a possibly unrelated test failure I started seeing failures locally after rebasing on the backpressure changes Ignore rx internal operators OperatorPivotTest testPivotEvenAndOdd It has some non determinism that I haven t been able to figure out RxJava pull requests #1378 https netflixoss ci cloudbees com job RxJava pull requests 1378 SUCCESS This pull request looks good LGTM Tested most projects in eclipse and IntelliJ IDEA Didn t test rxjava clojure rxjava groovy rxjava jruby and rxjava kotlin because I didn t install these language plugins in my IDES Thanks @gliptak 1',RxJava,true,false,false
36745971,'kotlin recently went from ABI 15 to ABI 16','Would it be possible to update the artifact on mavenCentral','Can you provide a pull request that changes the build dependencies and make sure everything works correctly once it is updated https github com Netflix RxJava blob master language adaptors rxjava kotlin build gradle Once merged it will be included in the next release to Maven Central I hadn t realised that the adapter to kotlin was a single file namespace kt file I just copied it in my project and build it and the problem with the Abi went away with snapshot This works with 0 1 SNAPSHOT but doesn t with 0 7 1217 and 0 7 270 The abi change happened between 0 7 1217 and 0 7 1300 and as I am unable with with config to use a different plugin from these 3 I m also unable to provide a fixed version number that will durably make it work for everybody so I can t provide a pull request at the moment RxJava kotlin was updated to work with Kotlin M8',RxJava,false,false,false
36749977,'RxScala Fix the compiler warnings','This PR fixed the annoying warnings in RxScala including replacing toBlockingObservable with toBlocking and adding language imports cc @headinthebox @samuelgruetter','RxJava pull requests #1339 https netflixoss ci cloudbees com job RxJava pull requests 1339 SUCCESS This pull request looks good LGTM Good to go',RxJava,true,false,false
36844687,'Adding the hooks unsafeSubscribe','by making the execution and error handling exactly same as safe version without the safety checks','RxJava pull requests #1340 https netflixoss ci cloudbees com job RxJava pull requests 1340 SUCCESS This pull request looks good',RxJava,true,false,false
36965096,'RxScala Use currying to improve type inference','As per discussion in #1392 cc @headinthebox @samuelgruetter','RxJava pull requests #1344 https netflixoss ci cloudbees com job RxJava pull requests 1344 SUCCESS This pull request looks good RxJava pull requests #1345 https netflixoss ci cloudbees com job RxJava pull requests 1345 SUCCESS This pull request looks good I like the tumbling sliding naming idea 10 overloads with the same name makes it hard to think reason and talk about code and defining good terminology that developers can use to think reason and talk about their code makes the library better However I think that this PR s naming scheme is not yet very consistent It names the different window operators as follows scala tumbling Observable Any window Int window Int Int window Duration Duration window Duration Duration Scheduler window Duration window Duration Int window Duration Int Scheduler window Duration Scheduler sliding Observable Opening Opening Observable Any I would prefer tumblingWindow and slidingWindow instead of just tumbling sliding It s not nice to have naked window operators without any indication whether they re sliding tumbling but adding sliding tumbling to all operator names might be too bulky I m not sure if it s correct to call the last method a sliding window because usually sliding windows are all of the same size in time or in number of elements See this paper http dl acm org citation cfm id 1920841 1920874 Definition 6 for instance I personally prefer sliding and tumbling seems also more consistent with Scala http daily scala blogspot nl 2009 11 iteratorsliding html Don t mind too much about same size for sliding windows the main difference is tumbling no overlap think of a brick tumbling and sliding overlap The CEP folks typically do not abstract over time like Rx does with openings and closings so it makes it hard to compare My vote is to eliminate all window s and only use sliding and tumbling I d be happy with renaming all window methods into sliding or tumbling and all buffer methods into slidingBuffer or tumblingBuffer Cool agree with that Buffer is expensive so should feel heavyweight Already renamed all buffer and window methods RxJava pull requests #1346 https netflixoss ci cloudbees com job RxJava pull requests 1346 SUCCESS This pull request looks good Holding off until 0 20 as this contains breaking changes I believe based on discussion with @headinthebox Yes lot s of breaking changes and I am sure we will iterate a bit before we reach a fixed point I m currently converting my Rx sample repo over to the new API BTW thanks again @zsxwing RxJava pull requests #1350 https netflixoss ci cloudbees com job RxJava pull requests 1350 SUCCESS This pull request looks good Rebased LGTM Is this ready for me to merge into master as part of 0 20 Can we potentially have breaking changes after 0 20 Once we hit 0 20 we can split the projects and let rxjava core go to 1 0 and RxScala can keep doing 0 x releases if it needs to Ack',RxJava,true,false,false
37001114,'Update Perf Tests','matching with work being done for 0 20 to allow comparisons','RxJava pull requests #1347 https netflixoss ci cloudbees com job RxJava pull requests 1347 SUCCESS This pull request looks good',RxJava,true,false,false
37006018,'Internal Data Structures','Various data structures to allow performance improvements I am committing these separately from the code that uses it to keep the pull requests simpler Nothing in RxJava depends on these classes in this commit','RxJava pull requests #1348 https netflixoss ci cloudbees com job RxJava pull requests 1348 SUCCESS This pull request looks good',RxJava,true,false,false
37014471,'OnError while emitting onNext value object toString','public OnNextValue Object value super OnError while emitting onNext value value this value value I know this is probably a helpful error message in some cases but this can be a really costly operation when an objects toString is an expensive call or contains alot of output I don t think we should be printing this in any case but if so it should be on demand overload of getMessage rather than eagerly In my case it is causing a toString of a large context object that is normally only used for debugging purposes which makes the exception logs hard to use and they are rolling over the log files very quickly There is an added danger that if there is a bug in the toString method it will cause inconsistent exception creation If the object throws an exception while rendering a string it will actually end up not seeing the real exception','Forgot to include the results of the test Here is the expected error On Error java lang IllegalArgumentException Failure while handling at rx exceptions OnNextValueTest 1 call OnNextValueTest java 87 at rx exceptions OnNextValueTest 1 call OnNextValueTest java 84 at rx internal operators OperatorMap 1 onNext OperatorMap java 54 at rx Observable 3 call Observable java 1551 at rx Observable 3 call Observable java 1546 at rx Observable 2 call Observable java 159 at rx Observable 2 call Observable java 155 at rx Observable subscribe Observable java 6921 at rx Observable subscribe Observable java 6800 at rx exceptions OnNextValueTest addOnNextValueExceptionAdded OnNextValueTest java 83 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 57 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at java lang reflect Method invoke Method java 606 at org junit runners model FrameworkMethod 1 runReflectiveCall FrameworkMethod java 45 at org junit internal runners model ReflectiveCallable run ReflectiveCallable java 15 at org junit runners model FrameworkMethod invokeExplosively FrameworkMethod java 42 at org junit internal runners statements InvokeMethod evaluate InvokeMethod java 20 at org junit runners ParentRunner runLeaf ParentRunner java 263 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 68 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 47 at org junit runners ParentRunner 3 run ParentRunner java 231 at org junit runners ParentRunner 1 schedule ParentRunner java 60 at org junit runners ParentRunner runChildren ParentRunner java 229 at org junit runners ParentRunner access 000 ParentRunner java 50 at org junit runners ParentRunner 2 evaluate ParentRunner java 222 at org junit runners ParentRunner run ParentRunner java 300 at org junit runner JUnitCore run JUnitCore java 157 at com intellij junit4 JUnit4IdeaTestRunner startRunnerWithArgs JUnit4IdeaTestRunner java 74 at com intellij rt execution junit JUnitStarter prepareStreamsAndStart JUnitStarter java 211 at com intellij rt execution junit JUnitStarter main JUnitStarter java 67 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 57 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at java lang reflect Method invoke Method java 606 at com intellij rt execution application AppMain main AppMain java 134 Caused by rx exceptions OnErrorThrowable OnNextValue OnError while emitting onNext value BadToString at rx exceptions OnErrorThrowable addValueAsLastCause OnErrorThrowable java 98 at rx internal operators OperatorMap 1 onNext OperatorMap java 56 33 more Heres what we get with an exception in toString On Error java lang IllegalArgumentException Error Making toString at rx exceptions OnNextValueTest BadToString toString OnNextValueTest java 39 at java lang String valueOf String java 2854 at java lang StringBuilder append StringBuilder java 128 at rx exceptions OnErrorThrowable OnNextValue init OnErrorThrowable java 119 at rx exceptions OnErrorThrowable addValueAsLastCause OnErrorThrowable java 98 at rx internal operators OperatorMap 1 onNext OperatorMap java 56 at rx Observable 3 call Observable java 1551 at rx Observable 3 call Observable java 1546 at rx Observable 2 call Observable java 159 at rx Observable 2 call Observable java 155 at rx Observable subscribe Observable java 6921 at rx Observable subscribe Observable java 6800 at rx exceptions OnNextValueTest addOnNextValueExceptionNotAddedWithBadString OnNextValueTest java 97 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 57 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at java lang reflect Method invoke Method java 606 at org junit runners model FrameworkMethod 1 runReflectiveCall FrameworkMethod java 45 at org junit internal runners model ReflectiveCallable run ReflectiveCallable java 15 at org junit runners model FrameworkMethod invokeExplosively FrameworkMethod java 42 at org junit internal runners statements InvokeMethod evaluate InvokeMethod java 20 at org junit runners ParentRunner runLeaf ParentRunner java 263 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 68 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 47 at org junit runners ParentRunner 3 run ParentRunner java 231 at org junit runners ParentRunner 1 schedule ParentRunner java 60 at org junit runners ParentRunner runChildren ParentRunner java 229 at org junit runners ParentRunner access 000 ParentRunner java 50 at org junit runners ParentRunner 2 evaluate ParentRunner java 222 at org junit runners ParentRunner run ParentRunner java 300 at org junit runner JUnitCore run JUnitCore java 157 at com intellij junit4 JUnit4IdeaTestRunner startRunnerWithArgs JUnit4IdeaTestRunner java 74 at com intellij rt execution junit JUnitStarter prepareStreamsAndStart JUnitStarter java 211 at com intellij rt execution junit JUnitStarter main JUnitStarter java 67 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 57 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at java lang reflect Method invoke Method java 606 at com intellij rt execution application AppMain main AppMain java 134 And a system err output of rx exceptions CompositeException 2 exceptions occurred See them in causal chain below at rx observers SafeSubscriber _onError SafeSubscriber java 182 at rx observers SafeSubscriber onError SafeSubscriber java 103 at rx Observable 2 call Observable java 167 at rx Observable 2 call Observable java 155 at rx Observable subscribe Observable java 6921 at rx Observable subscribe Observable java 6800 at rx exceptions OnNextValueTest addOnNextValueExceptionNotAddedWithBadString OnNextValueTest java 97 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 57 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at org junit runners model FrameworkMethod 1 runReflectiveCall FrameworkMethod java 45 at org junit internal runners model ReflectiveCallable run ReflectiveCallable java 15 at org junit runners model FrameworkMethod invokeExplosively FrameworkMethod java 42 at org junit internal runners statements InvokeMethod evaluate InvokeMethod java 20 at org junit runners ParentRunner runLeaf ParentRunner java 263 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 68 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 47 at org junit runners ParentRunner 3 run ParentRunner java 231 at org junit runners ParentRunner 1 schedule ParentRunner java 60 at org junit runners ParentRunner runChildren ParentRunner java 229 at org junit runners ParentRunner access 000 ParentRunner java 50 at org junit runners ParentRunner 2 evaluate ParentRunner java 222 at org junit runners ParentRunner run ParentRunner java 300 at org junit runner JUnitCore run JUnitCore java 157 at com intellij junit4 JUnit4IdeaTestRunner startRunnerWithArgs JUnit4IdeaTestRunner java 74 at com intellij rt execution junit JUnitStarter prepareStreamsAndStart JUnitStarter java 211 at com intellij rt execution junit JUnitStarter main JUnitStarter java 67 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 57 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at com intellij rt execution application AppMain main AppMain java 134 ComposedException 1 java lang IllegalArgumentException Error Making toString at rx exceptions OnNextValueTest BadToString toString OnNextValueTest java 39 at java lang String valueOf String java 2854 at java lang StringBuilder append StringBuilder java 128 at rx exceptions OnErrorThrowable OnNextValue init OnErrorThrowable java 119 at rx exceptions OnErrorThrowable addValueAsLastCause OnErrorThrowable java 98 at rx internal operators OperatorMap 1 onNext OperatorMap java 56 at rx Observable 3 call Observable java 1551 at rx Observable 3 call Observable java 1546 at rx Observable 2 call Observable java 159 at rx Observable 2 call Observable java 155 at rx Observable subscribe Observable java 6921 at rx Observable subscribe Observable java 6800 at rx exceptions OnNextValueTest addOnNextValueExceptionNotAddedWithBadString OnNextValueTest java 97 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 57 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at org junit runners model FrameworkMethod 1 runReflectiveCall FrameworkMethod java 45 at org junit internal runners model ReflectiveCallable run ReflectiveCallable java 15 at org junit runners model FrameworkMethod invokeExplosively FrameworkMethod java 42 at org junit internal runners statements InvokeMethod evaluate InvokeMethod java 20 at org junit runners ParentRunner runLeaf ParentRunner java 263 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 68 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 47 at org junit runners ParentRunner 3 run ParentRunner java 231 at org junit runners ParentRunner 1 schedule ParentRunner java 60 at org junit runners ParentRunner runChildren ParentRunner java 229 at org junit runners ParentRunner access 000 ParentRunner java 50 at org junit runners ParentRunner 2 evaluate ParentRunner java 222 at org junit runners ParentRunner run ParentRunner java 300 at org junit runner JUnitCore run JUnitCore java 157 at com intellij junit4 JUnit4IdeaTestRunner startRunnerWithArgs JUnit4IdeaTestRunner java 74 at com intellij rt execution junit JUnitStarter prepareStreamsAndStart JUnitStarter java 211 at com intellij rt execution junit JUnitStarter main JUnitStarter java 67 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 57 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at com intellij rt execution application AppMain main AppMain java 134 ComposedException 2 java lang AssertionError No Cause on throwablejava lang IllegalArgumentException Error Making toString at org junit Assert fail Assert java 93 at org junit Assert assertTrue Assert java 43 at rx exceptions OnNextValueTest BadToStringObserver onError OnNextValueTest java 60 at rx Observable 29 onError Observable java 6809 at rx observers SafeSubscriber _onError SafeSubscriber java 135 at rx observers SafeSubscriber onError SafeSubscriber java 103 at rx Observable 2 call Observable java 167 at rx Observable 2 call Observable java 155 at rx Observable subscribe Observable java 6921 at rx Observable subscribe Observable java 6800 at rx exceptions OnNextValueTest addOnNextValueExceptionNotAddedWithBadString OnNextValueTest java 97 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 57 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at org junit runners model FrameworkMethod 1 runReflectiveCall FrameworkMethod java 45 at org junit internal runners model ReflectiveCallable run ReflectiveCallable java 15 at org junit runners model FrameworkMethod invokeExplosively FrameworkMethod java 42 at org junit internal runners statements InvokeMethod evaluate InvokeMethod java 20 at org junit runners ParentRunner runLeaf ParentRunner java 263 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 68 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 47 at org junit runners ParentRunner 3 run ParentRunner java 231 at org junit runners ParentRunner 1 schedule ParentRunner java 60 at org junit runners ParentRunner runChildren ParentRunner java 229 at org junit runners ParentRunner access 000 ParentRunner java 50 at org junit runners ParentRunner 2 evaluate ParentRunner java 222 at org junit runners ParentRunner run ParentRunner java 300 at org junit runner JUnitCore run JUnitCore java 157 at com intellij junit4 JUnit4IdeaTestRunner startRunnerWithArgs JUnit4IdeaTestRunner java 74 at com intellij rt execution junit JUnitStarter prepareStreamsAndStart JUnitStarter java 211 at com intellij rt execution junit JUnitStarter main JUnitStarter java 67 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 57 at com intellij rt execution application AppMain main AppMain java 134 RxJava pull requests #1349 https netflixoss ci cloudbees com job RxJava pull requests 1349 SUCCESS This pull request looks good This rather defeats the point of OnErrorThrowable which exists to help debugging What change do you recommend that doesn t defeat the current purpose of OnErrorThrowable that allows someone to know what value caused the error The exception can still contain the value it just shouldn t be eagerly toStringed into the base exception message If the user code wants to handle those exceptions and print out the related object they are free to do so In any case It is only sometimes helpful to know what value is being processed when a request failed What if the cause of the failure is a downed connection to an external service or a cache being disconnected something unrelated to the data being processed It doesn t matter what value caused the error any value would have failed and seeing this in the log may cause people to assume it was related to this specific value java try processing catch Exception e logger log Exception in processing e if e getCause instanceOf OnNextValue logger log Value that was being processed when it failed OnNextValue e getCause getValue In any case It is only sometimes helpful to know what value is being processed when a request failed Obviously but it s very valuable when it is indeed related to the value How about we include the toString value if it is a primitive type Number String Boolean otherwise just retain the object reference inside the OnErrorThrowable I think that is a good idea we can also print out the classname of unknown objects How about this java Render the object if it is a basic type This avoids the library making potentially expensive or calls to toString which may throw exceptions See PR #1401 for details @param value the item that the Observable was trying to emit at the time of the exception @return a string version of the object if primitive otherwise the classname of the object private static String renderValue Object value if value null return null if value getClass isPrimitive return value toString if value instanceof String return String value return value getClass getSimpleName class I played with the wording a bit to try to make it obvious this is a class name of the instance not the Class itself but everything I thought of might be misinterpreted Caused by rx exceptions OnErrorThrowable OnNextValue OnError while emitting onNext value BadToString class at rx exceptions OnErrorThrowable addValueAsLastCause OnErrorThrowable java 98 RxJava pull requests #1352 https netflixoss ci cloudbees com job RxJava pull requests 1352 SUCCESS This pull request looks good I like it Merging Thanks @samhendley',RxJava,true,false,false
37018003,'Remove Pivot Operator in 0 20','The pivot operator continues to have concurrency issues I m considering removing it in 0 20 it probably should never have been added Does anyone use it Does anyone have issues with me removing it i think it is better suited to being a custom operator rather than part of rxjava core','I d be totally fine with that it is a monster that is hard to tame Great I ll remove it in 0 20 I d rather wait until it matures and possibly bring it back in the 1 x series than leave it in its current state 1 It has been removed',RxJava,false,false,false
37052931,'Backpressure 8 Merge ObserveOn','This is a functioning implementation of backpressure Of the major unbounded queue operators in 0 19 this implements observeOn and merge but not yet zip Compared with the previous PRs backpressure 7 and earlier this brings performance to levels that are possible to be merged into master ### New Signatures java public interface Producer public void request int n java public abstract class Subscriber T implements Observer T Subscription Optionally called from Observable OnSubscribe public final void setProducer Producer producer Allow implementing classes to capture decorate or override the Producer without affecting the Subscriber logic protected Producer onSetProducer Producer producer public final void request int n ### Operator Changes OnSubscribeFromIterable and OnSubscribeRange are both updated to support Producer and will only emit as many onNext as requested The implementations are a little more complex than needed as they optimize for cases where backpressure is not requested and fallback to the firehose model of 0 19 and earlier This allows for higher throughput in case where backpressure is not needed parallel had to be rewritten with a different approach to support backpressure The filter take and skip operators were modified to support backpressure and propagate request modifications based on each of their logic takeUntil needed to be rewritten because NotificationLite can t be allowed to leak across operators The subscribeOn operator was modified to correctly reschedule work on the given Scheduler when a request n occurs after the Producer has let itself shut down ### Design Questions ##### 1 Producer Is the name and signature of Producer request n correct ##### 2 Subscriber setProducer Is this the correct signature for an Observable OnSubscribe to register the Producer ##### 3 Requesting 0 for Infinite no backpressure To be backwards compatible and support performance optimizations when backpressure is not needed Producer request n can be invoked with a negative number This means no backpressure and the Producer can then emit data in a tight loop without further limitations Is this acceptable and the best solution ##### 4 onBackpressure Are the onBackpressureBuffer and onBackpressureDrop operators well named clear in their usage and implemented correctly Should we implemented others such as onBackpressureUnsubscribe and onBackpressureBuffer int limitUntilDropping ##### 5 Unit Tests and Use Cases Are there major use cases that are missing from BackpressureTests What problems are there that are not yet resolved or handled by the design ### Performance gradlew benchmarks Pjmh f 1 wi 5 i 5 r 2 PerfBaseline observable 0 19 Benchmark size Mode Samples Score Score error Units r PerfBaseline iterableViaForLoopConsumption 1 thrpt 5 250139466 600 6920354 087 ops s r PerfBaseline iterableViaForLoopConsumption 1000 thrpt 5 182500 174 5244 888 ops s r PerfBaseline iterableViaForLoopConsumption 1000000 thrpt 5 170 911 3 823 ops s r PerfBaseline iterableViaHasNextConsumption 1 thrpt 5 320148600 957 11599243 208 ops s r PerfBaseline iterableViaHasNextConsumption 1000 thrpt 5 297314 203 9485 727 ops s r PerfBaseline iterableViaHasNextConsumption 1000000 thrpt 5 269 004 4 151 ops s r PerfBaseline observableConsumption 1 thrpt 5 29298639 717 277675 587 ops s r PerfBaseline observableConsumption 1000 thrpt 5 243968 954 10311 720 ops s r PerfBaseline observableConsumption 1000000 thrpt 5 252 916 3 420 ops s r PerfBaseline observableConsumptionUnsafe 1 thrpt 5 199935597 149 31884367 299 ops s r PerfBaseline observableConsumptionUnsafe 1000 thrpt 5 311704 723 39346 976 ops s r PerfBaseline observableConsumptionUnsafe 1000000 thrpt 5 307 188 58 163 ops s r PerfBaseline observableViaRange 1 thrpt 5 23843851 260 324794 935 ops s r PerfBaseline observableViaRange 1000 thrpt 5 193208 479 3741 146 ops s r PerfBaseline observableViaRange 1000000 thrpt 5 188 261 12 172 ops s r PerfBaseline observableViaRangeUnsafe 1 thrpt 5 45762792 585 1379450 701 ops s r PerfBaseline observableViaRangeUnsafe 1000 thrpt 5 240280 347 3312 756 ops s r PerfBaseline observableViaRangeUnsafe 1000000 thrpt 5 234 143 1 163 ops s backpressure 8 Benchmark size Mode Samples Score Score error Units r PerfBaseline iterableViaForLoopConsumption 1 thrpt 5 250601807 892 12009864 080 ops s r PerfBaseline iterableViaForLoopConsumption 1000 thrpt 5 184859 869 2400 585 ops s r PerfBaseline iterableViaForLoopConsumption 1000000 thrpt 5 172 127 4 979 ops s r PerfBaseline iterableViaHasNextConsumption 1 thrpt 5 322464817 267 8117858 197 ops s r PerfBaseline iterableViaHasNextConsumption 1000 thrpt 5 294868 674 7349 485 ops s r PerfBaseline iterableViaHasNextConsumption 1000000 thrpt 5 266 602 5 682 ops s r PerfBaseline observableConsumption 1 thrpt 5 33622221 238 963042 530 ops s r PerfBaseline observableConsumption 1000 thrpt 5 244097 704 4564 965 ops s r PerfBaseline observableConsumption 1000000 thrpt 5 256 587 5 404 ops s r PerfBaseline observableConsumptionUnsafe 1 thrpt 5 206453075 285 4940138 228 ops s r PerfBaseline observableConsumptionUnsafe 1000 thrpt 5 320284 165 6034 968 ops s r PerfBaseline observableConsumptionUnsafe 1000000 thrpt 5 314 259 7 683 ops s r PerfBaseline observableViaRange 1 thrpt 5 37486671 210 887127 291 ops s r PerfBaseline observableViaRange 1000 thrpt 5 172643 588 7439 349 ops s r PerfBaseline observableViaRange 1000000 thrpt 5 173 171 2 794 ops s r PerfBaseline observableViaRangeUnsafe 1 thrpt 5 236013059 425 7822030 114 ops s r PerfBaseline observableViaRangeUnsafe 1000 thrpt 5 211461 722 13717 277 ops s r PerfBaseline observableViaRangeUnsafe 1000000 thrpt 5 202 761 12 915 ops s gradlew benchmarks Pjmh f 1 wi 5 i 5 r 2 rx operators OperatorMapPerf 0 19 Benchmark size Mode Samples Score Score error Units r o OperatorMapPerf mapPassThru 1 thrpt 5 17853002 462 556655 574 ops s r o OperatorMapPerf mapPassThru 1000 thrpt 5 150669 958 16170 385 ops s r o OperatorMapPerf mapPassThru 1000000 thrpt 5 162 473 3 961 ops s r o OperatorMapPerf mapPassThruViaLift 1 thrpt 5 18947641 742 644348 550 ops s r o OperatorMapPerf mapPassThruViaLift 1000 thrpt 5 160047 002 20086 976 ops s r o OperatorMapPerf mapPassThruViaLift 1000000 thrpt 5 162 310 6 204 ops s backpressure 8 Benchmark size Mode Samples Score Score error Units r o OperatorMapPerf mapPassThru 1 thrpt 5 24092718 114 586172 216 ops s r o OperatorMapPerf mapPassThru 1000 thrpt 5 149191 341 3154 653 ops s r o OperatorMapPerf mapPassThru 1000000 thrpt 5 150 013 3 124 ops s r o OperatorMapPerf mapPassThruViaLift 1 thrpt 5 26144219 306 368383 801 ops s r o OperatorMapPerf mapPassThruViaLift 1000 thrpt 5 150500 298 2074 296 ops s r o OperatorMapPerf mapPassThruViaLift 1000000 thrpt 5 150 896 1 945 ops s gradlew benchmarks Pjmh f 1 wi 5 i 5 r 2 rx operators OperatorObserveOnPerf 0 19 Benchmark size Mode Samples Score Score error Units r o OperatorObserveOnPerf observeOnComputation 1 thrpt 5 110481 792 991 073 ops s r o OperatorObserveOnPerf observeOnComputation 1000 thrpt 5 8386 714 103 294 ops s r o OperatorObserveOnPerf observeOnComputation 1000000 thrpt 5 8 568 4 330 ops s r o OperatorObserveOnPerf observeOnImmediate 1 thrpt 5 13144808 808 852878 900 ops s r o OperatorObserveOnPerf observeOnImmediate 1000 thrpt 5 191230 661 4066 226 ops s r o OperatorObserveOnPerf observeOnImmediate 1000000 thrpt 5 186 919 6 075 ops s r o OperatorObserveOnPerf observeOnNewThread 1 thrpt 5 15972 029 1955 679 ops s r o OperatorObserveOnPerf observeOnNewThread 1000 thrpt 5 6606 316 104 860 ops s r o OperatorObserveOnPerf observeOnNewThread 1000000 thrpt 5 10 683 2 060 ops s backpressure 8 Benchmark size Mode Samples Score Score error Units r o OperatorObserveOnPerf observeOnComputation 1 thrpt 5 93371 544 12564 954 ops s r o OperatorObserveOnPerf observeOnComputation 1000 thrpt 5 5209 287 161 070 ops s r o OperatorObserveOnPerf observeOnComputation 1000000 thrpt 5 10 070 5 387 ops s r o OperatorObserveOnPerf observeOnImmediate 1 thrpt 5 15855354 194 74122 090 ops s r o OperatorObserveOnPerf observeOnImmediate 1000 thrpt 5 173351 676 5924 790 ops s r o OperatorObserveOnPerf observeOnImmediate 1000000 thrpt 5 170 760 4 379 ops s r o OperatorObserveOnPerf observeOnNewThread 1 thrpt 5 15524 785 1373 757 ops s r o OperatorObserveOnPerf observeOnNewThread 1000 thrpt 5 4878 633 54 696 ops s r o OperatorObserveOnPerf observeOnNewThread 1000000 thrpt 5 15 285 0 564 ops s gradlew benchmarks Pjmh f 1 wi 5 i 5 r 2 rx operators OperatorMergePerf 0 19 Benchmark size Mode Samples Score Score error Units r o OperatorMergePerf merge1SyncStreamOfN 1 thrpt 5 3047431 417 33607 539 ops s r o OperatorMergePerf merge1SyncStreamOfN 1000 thrpt 5 70708 027 2468 027 ops s r o OperatorMergePerf merge1SyncStreamOfN 1000000 thrpt 5 70 950 3 242 ops s r o OperatorMergePerf mergeNAsyncStreamsOfN 1 thrpt 5 106426 955 3921 743 ops s r o OperatorMergePerf mergeNAsyncStreamsOfN 1000 thrpt 5 7 645 0 409 ops s r o OperatorMergePerf mergeNSyncStreamsOf1 1 thrpt 5 2924643 167 90602 452 ops s r o OperatorMergePerf mergeNSyncStreamsOf1 100 thrpt 5 65041 997 4387 032 ops s r o OperatorMergePerf mergeNSyncStreamsOf1 1000 thrpt 5 6727 579 140 162 ops s r o OperatorMergePerf mergeNSyncStreamsOfN 1 thrpt 5 2923542 700 55565 638 ops s r o OperatorMergePerf mergeNSyncStreamsOfN 1000 thrpt 5 71 998 1 992 ops s r o OperatorMergePerf mergeTwoAsyncStreamsOfN 1 thrpt 5 80321 863 19568 569 ops s r o OperatorMergePerf mergeTwoAsyncStreamsOfN 1000 thrpt 5 3832 958 236 712 ops s r o OperatorMergePerf oneStreamOfNthatMergesIn1 1 thrpt 5 2927868 656 517769 910 ops s r o OperatorMergePerf oneStreamOfNthatMergesIn1 1000 thrpt 5 6799 933 180 123 ops s r o OperatorMergePerf oneStreamOfNthatMergesIn1 1000000 thrpt 5 6 408 0 206 ops s backpressure 8 Benchmark size Mode Samples Score Score error Units r o OperatorMergePerf merge1SyncStreamOfN 1 thrpt 5 5475300 198 156741 334 ops s r o OperatorMergePerf merge1SyncStreamOfN 1000 thrpt 5 68932 278 1311 023 ops s r o OperatorMergePerf merge1SyncStreamOfN 1000000 thrpt 5 64 405 0 611 ops s r o OperatorMergePerf mergeNAsyncStreamsOfN 1 thrpt 5 102736 219 2948 102 ops s r o OperatorMergePerf mergeNAsyncStreamsOfN 1000 thrpt 5 5 893 0 278 ops s xxxxx r o OperatorMergePerf mergeNSyncStreamsOf1 1 thrpt 5 4941243 788 109965 809 ops s r o OperatorMergePerf mergeNSyncStreamsOf1 100 thrpt 5 368061 743 11456 008 ops s r o OperatorMergePerf mergeNSyncStreamsOf1 1000 thrpt 5 38941 345 1974 002 ops s r o OperatorMergePerf mergeNSyncStreamsOfN 1 thrpt 5 6070127 935 58505 579 ops s r o OperatorMergePerf mergeNSyncStreamsOfN 1000 thrpt 5 57 002 1 708 ops s r o OperatorMergePerf mergeTwoAsyncStreamsOfN 1 thrpt 5 77911 340 2413 596 ops s r o OperatorMergePerf mergeTwoAsyncStreamsOfN 1000 thrpt 5 4258 650 116 595 ops s r o OperatorMergePerf oneStreamOfNthatMergesIn1 1 thrpt 5 5429881 489 26728 872 ops s r o OperatorMergePerf oneStreamOfNthatMergesIn1 1000 thrpt 5 28932 279 572 963 ops s r o OperatorMergePerf oneStreamOfNthatMergesIn1 1000000 thrpt 5 30 147 1 253 ops s gradlew benchmarks Pjmh f 1 wi 5 i 5 r 2 rx operators OperatorFlatMapPerf 0 19 Benchmark size Mode Samples Score Score error Units r o OperatorFlatMapPerf flatMapIntPassthruAsync 1 thrpt 5 352212 163 24668 380 ops s r o OperatorFlatMapPerf flatMapIntPassthruAsync 1000 thrpt 5 350 930 8 635 ops s r o OperatorFlatMapPerf flatMapIntPassthruAsync 1000000 thrpt 5 0 352 0 010 ops s r o OperatorFlatMapPerf flatMapIntPassthruSync 1 thrpt 5 3323839 174 38716 562 ops s r o OperatorFlatMapPerf flatMapIntPassthruSync 1000 thrpt 5 6456 484 1262 577 ops s r o OperatorFlatMapPerf flatMapIntPassthruSync 1000000 thrpt 5 6 337 0 149 ops s r o OperatorFlatMapPerf flatMapTwoNestedSync 1 thrpt 5 2117425 124 45292 911 ops s r o OperatorFlatMapPerf flatMapTwoNestedSync 1000 thrpt 5 35047 747 637 443 ops s r o OperatorFlatMapPerf flatMapTwoNestedSync 1000000 thrpt 5 35 408 1 304 ops s backpressure 8 Benchmark size Mode Samples Score Score error Units r o OperatorFlatMapPerf flatMapIntPassthruAsync 1 thrpt 5 307489 156 24595 370 ops s r o OperatorFlatMapPerf flatMapIntPassthruAsync 1000 thrpt 5 315 122 79 497 ops s r o OperatorFlatMapPerf flatMapIntPassthruAsync 1000000 thrpt 5 305 585 33 345 ops s why is this better r o OperatorFlatMapPerf flatMapIntPassthruSync 1 thrpt 5 5932020 586 123609 972 ops s r o OperatorFlatMapPerf flatMapIntPassthruSync 1000 thrpt 5 26402 347 4096 510 ops s r o OperatorFlatMapPerf flatMapIntPassthruSync 1000000 thrpt 5 29 338 5 235 ops s r o OperatorFlatMapPerf flatMapTwoNestedSync 1 thrpt 5 3843959 776 204899 691 ops s r o OperatorFlatMapPerf flatMapTwoNestedSync 1000 thrpt 5 29316 657 446 403 ops s r o OperatorFlatMapPerf flatMapTwoNestedSync 1000000 thrpt 5 32 767 0 754 ops s','This code is ready for review and I d appreciate feedback and help validating it so we can move forward RxJava pull requests #1351 https netflixoss ci cloudbees com job RxJava pull requests 1351 ABORTED @benjchristensen I d like to try this out with the couchbase sdk What scenarios are you interest in particularly @daschl My first priority is to achieve stability of existing functionality to make sure that this code works is stable and performant both CPU and memory The only things that should break with this release are use cases where back pressure is required and now a MissingBackpressureException gets thrown In those cases we should now be able to handle them by modifying the origin OnSubscribe or by using onBackpressureBuffer onBackpressureDrop Second priority is to test various use cases that require non blocking back pressure We need to validate that the new signatures Producer setProducer request etc satisfy the use cases and make sense Along the way I expect to find operators in Rx that we need to improve and areas where we ll need to add back pressure support We will also find places where it just doesn t make sense and need to document in the Javadocs when an operator won t work with it multicast subjects and temporal operators for example By the way I really don t like the merge code but at this point don t have a better way of doing it that performs An earlier implementation was far more elegant as far as how the code read and looked but it was horrible performance This current implementation was done with JMH perf tests driving almost every decision I have tried to document it in the code to explain why it is the way it is I would have preferred to have an elegant fill the queue drain the queue design but I couldn t get one to perform better than the current code I fully expect that this code will be refactored improved or completely replaced as more minds think about it I also am open to the idea of plugging in replacement implementations that use techniques we don t want in the core library such as using the Disruptor library an extra thread for draining etc if they prove to be far better for use cases such as large server deployments RxJava pull requests #1353 https netflixoss ci cloudbees com job RxJava pull requests 1353 ABORTED rx internal operators OperatorMergeTest testBackpressureBothUpstreamAndDownstreamWithRegularObservables That test is hanging on Cloudbees so there is some kind of non deterministic bug RxJava pull requests #1354 https netflixoss ci cloudbees com job RxJava pull requests 1354 ABORTED RxJava pull requests #1355 https netflixoss ci cloudbees com job RxJava pull requests 1355 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1356 https netflixoss ci cloudbees com job RxJava pull requests 1356 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1357 https netflixoss ci cloudbees com job RxJava pull requests 1357 SUCCESS This pull request looks good RxJava pull requests #1358 https netflixoss ci cloudbees com job RxJava pull requests 1358 SUCCESS This pull request looks good RxJava pull requests #1364 https netflixoss ci cloudbees com job RxJava pull requests 1364 SUCCESS This pull request looks good RxJava pull requests #1365 https netflixoss ci cloudbees com job RxJava pull requests 1365 ABORTED So when I try and run this in our prod environment I m getting a JVM error # # A fatal error has been detected by the Java Runtime Environment # # SIGSEGV 0xb at pc 0x00007fa5edf12c61 pid 10149 tid 140350607697664 # # JRE version Java TM SE Runtime Environment 7 0_40 b43 build 1 7 0_40 b43 # Java VM Java HotSpot TM 64 Bit Server VM 24 0 b56 mixed mode linux amd64 # Problematic frame # V libjvm so 0x5bbc61 oopDesc size_given_klass Klass 0x31 # # Failed to write core dump Core dumps have been disabled To enable core dumping try ulimit c unlimited before starting Java again # # If you would like to submit a bug report please visit # http bugreport sun com bugreport crash jsp # T H R E A D Current thread 0x00007fa5e801c800 GCTaskThread stack 0x00007fa5ec0da000 0x00007fa5ec1db000 id 10186 siginfo si_signo SIGSEGV si_errno 0 si_code 1 SEGV_MAPERR si_addr 0x00000000000000a8 Registers RAX 0x0000000000000000 RBX 0x00007f99c45e0c00 RCX 0x0000000000000000 RDX 0x00007fa5000002d9 RSP 0x00007fa5ec1d9120 RBP 0x00007fa5ec1d9120 RSI 0x00007f99c45e0c00 RDI 0x00007fa5000002d9 R8 0x0000000000000005 R9 0x0000000000000004 R10 0x0000000000000005 R11 0x00007fa5e802b590 R12 0x00000000000002c8 R13 0x00007f97c90cbb30 R14 0x00007f9a8793dcf8 R15 0x0000000000000000 RIP 0x00007fa5edf12c61 EFLAGS 0x0000000000010246 CSGSFS 0x000000000000e033 ERR 0x0000000000000004 TRAPNO 0x000000000000000e Top of Stack sp 0x00007fa5ec1d9120 0x00007fa5ec1d9120 00007fa5ec1d9160 00007fa5edf13970 0x00007fa5ec1d9130 0000000600000000 00007f9a8793dd00 0x00007fa5ec1d9140 00007f9a8793dd08 00007f97c90cbb30 0x00007fa5ec1d9150 00007fa587e6b6b8 00007fa587e6b6c0 0x00007fa5ec1d9160 00007fa5ec1d91b0 00007fa5edf081c3 0x00007fa5ec1d9170 00007fa5ec1d9000 00007f9a8793dcd8 0x00007fa5ec1d9180 00007fa587e6b418 00007fa5e802d920 0x00007fa5ec1d9190 00007f97c90cba90 0000000000000050 0x00007fa5ec1d91a0 00007fa5ee756f68 00007fa5e802d928 0x00007fa5ec1d91b0 00007fa5ec1d9240 00007fa5ee185bbd 0x00007fa5ec1d91c0 00007fa5ec1d91e0 00007fa5ec1d91f0 0x00007fa5ec1d91d0 00007f97c90cbb30 00007f97c90cbb80 0x00007fa5ec1d91e0 00007fa5ec1d9b60 00007f99c45df330 0x00007fa5ec1d91f0 00007f97c90cbbd0 0000000000000001 0x00007fa5ec1d9200 00007f96e326c2e0 00007fa5ec1d92d0 0x00007fa5ec1d9210 00007fa5ec1d9240 0000000000000001 0x00007fa5ec1d9220 0000000000000002 0000000000000001 0x00007fa5ec1d9230 0000000000000009 00007fa5ec1d92d0 0x00007fa5ec1d9240 00007fa5ec1d9290 00007fa5ee15f137 0x00007fa5ec1d9250 00007fa5ec1d9330 00000005d42848c8 0x00007fa5ec1d9260 00007fa5ec1d92e8 00007fa5ec1d92d0 0x00007fa5ec1d9270 00007f97c90cbbd0 00007fa5ec1d93f0 0x00007fa5ec1d9280 00007f97c83299c8 0000000000000021 0x00007fa5ec1d9290 00007fa5ec1d93a0 00007fa5ede71800 0x00007fa5ec1d92a0 000000045410fc00 01007fa5e802d920 0x00007fa5ec1d92b0 00007fa5ec1d9420 00007fa5e801c800 0x00007fa5ec1d92c0 00000005ee756f68 00007f97d40226a0 0x00007fa5ec1d92d0 00007fa5879a2e28 00000005ee180021 0x00007fa5ec1d92e0 00007fa500000000 0000000000000009 0x00007fa5ec1d92f0 0000000000000000 00007f97c90cbb80 0x00007fa5ec1d9300 00007fa5d910da16 00007f99b3dd6ee8 0x00007fa5ec1d9310 00007f97c90cbbd0 0000000000000001 Instructions pc 0x00007fa5edf12c61 0x00007fa5edf12c41 01 75 14 89 c8 c9 c1 f8 03 c3 0f 1f 44 00 00 75 0x00007fa5edf12c51 1e 66 0f 1f 44 00 00 48 8b 02 48 89 fe 48 89 d7 0x00007fa5edf12c61 4c 8b 98 a8 00 00 00 c9 41 ff e3 0f 1f 40 00 48 0x00007fa5edf12c71 8b 05 e9 ca 83 00 80 38 01 48 8b 05 8f fd 83 00 Register to memory mapping RAX 0x0000000000000000 is an unknown value RBX error occurred during error reporting printing register info id 0xb Stack 0x00007fa5ec0da000 0x00007fa5ec1db000 sp 0x00007fa5ec1d9120 free space 1020k Native frames J compiled Java code j interpreted Vv VM code C native code V libjvm so 0x5bbc61 oopDesc size_given_klass Klass 0x31 V libjvm so 0x5bc970 void ParScanClosure do_oop_work oopDesc oopDesc bool bool 0x80 V libjvm so 0x5b11c3 instanceKlass oop_oop_iterate_nv oopDesc ParScanWithoutBarrierClosure 0xf3 V libjvm so 0x82ebbd ParScanThreadState trim_queues int 0x14d V libjvm so 0x808137 InterpreterOopMap iterate_oop OffsetClosure 0x97 V libjvm so 0x51a800 frame oops_interpreted_do OopClosure RegisterMap const bool 0x270 V libjvm so 0x94748a JavaThread oops_do OopClosure CodeBlobClosure 0x15a V libjvm so 0x948652 Threads possibly_parallel_oops_do OopClosure CodeBlobClosure 0x112 V libjvm so 0x8a4ed2 SharedHeap process_strong_roots bool bool SharedHeap ScanningOption OopClosure CodeBlobClosure OopsInGenClosure 0xa2 V libjvm so 0x561c34 GenCollectedHeap gen_process_strong_roots int bool bool bool SharedHeap ScanningOption OopsInGenClosure bool OopsInGenClosure 0x74 V libjvm so 0x82df9f ParNewGenTask work unsigned int 0xef V libjvm so 0x9a7f0f GangWorker loop 0xcf V libjvm so 0x814a58 java_start Thread 0x108 JavaThread 0x00007fa5e81ff000 nid 10707 was being processed Java frames J compiled Java code j interpreted Vv VM code j java util concurrent atomic AtomicReferenceArray init I V 6 j rx internal util IndexedRingBuffer ElementSection init V 12 j rx internal util IndexedRingBuffer ElementSection getNext Lrx internal util IndexedRingBuffer ElementSection 16 j rx internal util IndexedRingBuffer getElementSection I Lrx internal util IndexedRingBuffer ElementSection 33 J rx internal operators OperatorMerge MergeSubscriber onNext Ljava lang Object V J rx internal operators OnSubscribeFromIterable IterableProducer request I V J rx Subscriber setProducer Lrx Producer V j rx internal operators OnSubscribeFromIterable call Lrx Subscriber V 32 j rx internal operators OnSubscribeFromIterable call Ljava lang Object V 5 J rx Observable 2 call Ljava lang Object V J rx Observable 2 call Ljava lang Object V J rx Observable 2 call Ljava lang Object V J rx Observable 2 call Ljava lang Object V J rx Observable subscribe Lrx Subscriber Lrx Subscription j rx internal operators BlockingOperatorToIterator toIterator Lrx Observable Ljava util Iterator 20 j rx observables BlockingObservable getIterator Ljava util Iterator 4 j rx observables BlockingObservable 2 iterator Ljava util Iterator 4 J com netflix api service list APIMAPList 1 run Lrx Subscriber V j com netflix api service list APIMAPList prefetch Ljava util List V 16 j com netflix api service list APIListImpl internalSubscribe Lrx Subscriber Ljava util List V 16 j com netflix api service list APIListImpl access 000 Lcom netflix api service list APIListImpl Lrx Subscriber Ljava util List V 3 j com netflix api service list APIListImpl 1 call Lrx Subscriber V 16 j com netflix api service list APIListImpl 1 call Ljava lang Object V 5 J rx Observable 2 call Ljava lang Object V J rx Observable 2 call Ljava lang Object V J rx Observable 2 call Ljava lang Object V J rx internal operators OperatorMerge MergeSubscriber onNext Ljava lang Object V J rx internal operators OperatorMap 1 onNext Ljava lang Object V j com netflix api service list APIMAPLolomoServiceImpl 1 call Lrx Subscriber V 342 j com netflix api service list APIMAPLolomoServiceImpl 1 call Ljava lang Object V 5 J rx Observable 2 call Ljava lang Object V J rx Observable 2 call Ljava lang Object V J rx Observable 2 call Ljava lang Object V J rx Observable unsafeSubscribe Lrx Subscriber Lrx Subscription j rx internal operators OperatorZip Zip zip V 26 j rx internal operators OperatorZip 1 onNext Lrx Observable V 43 j rx internal operators OperatorZip 1 onNext Ljava lang Object V 5 j rx internal util ScalarSynchronousObservable 1 call Lrx Subscriber V 5 j rx internal util ScalarSynchronousObservable 1 call Ljava lang Object V 5 RxJava pull requests #1367 https netflixoss ci cloudbees com job RxJava pull requests 1367 FAILURE Looks like there s a problem with this pull request Replacing with https github com Netflix RxJava pull 1412 Replacing with https github com Netflix RxJava pull 1412',RxJava,true,false,false
37099347,'Unclear semanticson publish and ConnectableObservable connect','Hi I have the following use case and I m not sure whether there is an issue in publish in the documentation or my brain assume the latter I have a PublishSubject where we onNext asynchronously when we receive some notifications from a remote service I m exposing the subject s observable to subscribers I have a fixed set of subscribers that initialise and subscribe to that data stream but these take a bit to initialise and I can t afford losing any element from the stream so what I want is to buffer the elements into the source until all subscribers are subscribed Only then start emitting elements So for example imagine the following sequence of events 1 connect to the queue and plug into the Source observable 2 source onNext A 3 subscriber 1 subscribes to the source 4 source onNext B 5 subscriber 2 subscribes to the source 6 initialisation complete tell source to stop buffering 7 source onNext C 8 a new subscriber 3 subscribes I want both subscribers 1 and 2 to see A B C because both subscribed before we told the source to stop buffering Subscriber 3 would get only C it subscribed late for A and B Note that this is why I don t want a ReplaySubject I don t want 3 to receive A or B Reading through the documentation I understand that I want a ConnectableObservable and do connect at point 6 ConnectableObservable c source publish c subscribe A c subscribe B c connect Note that this is the same as is described in this diagram https netflix github io RxJava javadoc rx observables ConnectableObservable html and here http www introtorx com Content v1 0 10621 0 14_HotAndColdObservables html#PublishAndConnect I think the crux of the problem might be in the fact that my source observable is async But I m not sure about this and the documentation doesn t make this evident at all So is this a bug in publish Is it the expected behaviour but then should the documentation make this more explicit Or am I doing something wrong Thanks','Since xs publish makes the underlying observable xs hot publishing a hot observable is a noop scala object MainScala def main args Array String Unit val xs Observable Long val xs Observable timer 0 seconds 1 second take 5 publish xs subscribe x println s hot observable produces x e println hot observable done xs connect xs Thread sleep 1000 println publish hot observable val ys xs publish Thread sleep 1000 println subscribe first subscriber to published hot observable ys subscribe x println s first subscriber x Thread sleep 1000 println subscribe second subscriber to published hot observable ys subscribe x println s second subscriber x Thread sleep 1000 println connect published hot observable ys connect readLine If you really have a hot observable to start with you probably want to use replay subjects But if possible I would see if you can make things cold so that only when you connect you actually connect to zookeeper to start receiving notification The problem is that you don t know how long you need to buffer values when you wait for the subscribers to all come in If we have a hot observable my case we will lose events emitted by the source between the subscribe and the connect That s correct and how it s expected to behave connect is subscribing the source If your source is hot and firing events before you connect subscribe then you will never receive them That is the nature of hot sources you receive their events only after you subscribe to them Thus the only value of publish and connect on an already hot stream is to ensure that a set of subscribers all start receiving data at the same time otherwise they can each just subscribe to the hot stream directly Reopen if you have further followup to this',RxJava,false,false,false
37113567,'CompositeException issue','I m using RxJava on Android and I ve encountered issues with CompositeException Because it collects throwables as Collection Throwable errors the exceptions are not logged to the logcat output if there is an unhandled Exception in onError callback Here is a sample output 2739 E AndroidRuntime 14639 FATAL EXCEPTION main 2740 E AndroidRuntime 14639 rx exceptions OnErrorFailedException Error occurred when trying to propagate error to Observer onError 2741 E AndroidRuntime 14639 at rx observers SafeSubscriber _onError SafeSubscriber java 182 2742 E AndroidRuntime 14639 at rx observers SafeSubscriber onError SafeSubscriber java 103 2743 E AndroidRuntime 14639 at rx internal operators NotificationLite accept NotificationLite java 144 2744 E AndroidRuntime 14639 at rx internal operators OperatorObserveOn ObserveOnSubscriber pollQueue OperatorObserveOn java 139 2745 E AndroidRuntime 14639 at rx internal operators OperatorObserveOn ObserveOnSubscriber access 000 OperatorObserveOn java 61 2746 E AndroidRuntime 14639 at rx internal operators OperatorObserveOn ObserveOnSubscriber 1 call OperatorObserveOn java 121 2747 E AndroidRuntime 14639 at rx internal schedulers ScheduledAction run ScheduledAction java 43 2748 E AndroidRuntime 14639 at android os Handler handleCallback Handler java 730 2749 E AndroidRuntime 14639 at android os Handler dispatchMessage Handler java 92 2750 E AndroidRuntime 14639 at android os Looper loop Looper java 137 2751 E AndroidRuntime 14639 at android app ActivityThread main ActivityThread java 5103 2752 E AndroidRuntime 14639 at java lang reflect Method invokeNative Native Method 2753 E AndroidRuntime 14639 at java lang reflect Method invoke Method java 525 2754 E AndroidRuntime 14639 at com android internal os ZygoteInit MethodAndArgsCaller run ZygoteInit java 737 2755 E AndroidRuntime 14639 at com android internal os ZygoteInit main ZygoteInit java 553 2756 E AndroidRuntime 14639 at dalvik system NativeStart main Native Method 2757 E AndroidRuntime 14639 Caused by rx exceptions CompositeException 2 exceptions occurred See them in causal chain below 2758 E AndroidRuntime 14639 16 more That s it No logs about real cause I can wrap my onError code in try catch block and log the real cause but I think this can be handled better by RxJava What do you guys think','How do you recommend doing it differently What about using initCause API 1 or I m sure addSuppressed is dedicated for this case but as far as I remember it was introduced in java 7 so it s available in KitKat API 19 We print them out when printStackTrace is called but we no longer add them as part of the actual causal chain as it could end up causing circular loops under odd edge cases This was just barely changed in the last release https github com Netflix RxJava pull 1388 Here is the code https github com Netflix RxJava blob master rxjava core src main java rx exceptions CompositeException java Note how it will print all causes https github com Netflix RxJava blob master rxjava core src main java rx exceptions CompositeException java#L111 What version of RxJava are you running to get that stack trace In the example you give it looks like the chain is being cropped when it had more to display 2 causes I m wondering if Android does something different than normal Java and doesn t actually invoke the printStackTrace method and thus won t see the causal chain I m using 0 19 2 I ve also encountered problems with the previous version when unhandled exception in onError ended up in circular loop and crash of a StringBuilder but current implementation doesn t provide any useful information for debugging If you are using error logging service like Bugsense or Crashlytics the only information you see is the stacktrace I ve pasted above it s useless Solution with initCause works perfect for me What do you think about it As I said above we used to use initCause but because this is a composite of many exceptions we are creating an artificial causal chain and it could result in infinite loops hence it being removed in 0 19 2 I can t speak to Bugsense or Crashlytics but if something printing a stack trace calls printStackTrace then it would work and print out the full list of causes For historical information here is the version that used initCause https github com Netflix RxJava blob ea2249afecbf4d1380f2d7b0775fec60e37e3369 rxjava core src main java rx exceptions CompositeException java#L108 and the current one without it https github com Netflix RxJava blob master rxjava core src main java rx exceptions CompositeException java#L111 We need a solution that either does not use initCause due to the circular reference problem or solves the circular reference problem The change done in https github com Netflix RxJava pull 1388 was based on the assumption that anything printing a stack trace would do it correctly via the printStackTrace method and thus we can override the printing of the causes so the causal chain is shown but not actually mutate the chain by using initCause which is what causes the issues Ok I ve dive deeper into the implementation and it turns out that none of the printStackTrace methods are called when an OnErrorFailedException is thrown Only getMessage and getCause methods are called so the real cause is not printed to the output Here is my simple test with logged methods of the CompositeException class AndroidRuntime D Shutting down VM dalvikvm W threadid 1 thread exiting with uncaught exception group 0x4195e700 gt_CompositeException I CompositeException getMessage I CompositeException getCause dalvikvm D GC_FOR_ALLOC freed 453K 5 free 11287K 11776K paused 29ms total 30ms gt_CompositeException I CompositeException getCause I CompositeException getMessage I CompositeException getCause AndroidRuntime E FATAL EXCEPTION main E rx exceptions OnErrorFailedException a E at test MainActivity refreshTasksLists MainActivity java 267 E at test MainActivity onCreateOptionsMenu MainActivity java 156 E at android app Activity onCreatePanelMenu Activity java 2504 E at com android internal policy impl PhoneWindow preparePanel PhoneWindow java 413 E at com android internal policy impl PhoneWindow doInvalidatePanelMenu PhoneWindow java 775 E at com android internal policy impl PhoneWindow 1 run PhoneWindow java 198 E at android view Choreographer CallbackRecord run Choreographer java 749 E at android view Choreographer doCallbacks Choreographer java 562 E at android view Choreographer doFrame Choreographer java 531 E at android view Choreographer FrameDisplayEventReceiver run Choreographer java 735 E at android os Handler handleCallback Handler java 730 E at android os Handler dispatchMessage Handler java 92 E at android os Looper loop Looper java 137 E at android app ActivityThread main ActivityThread java 5103 E at java lang reflect Method invokeNative Native Method E at java lang reflect Method invoke Method java 525 E at com android internal os ZygoteInit MethodAndArgsCaller run ZygoteInit java 737 E at com android internal os ZygoteInit main ZygoteInit java 553 E at dalvik system NativeStart main Native Method E Caused by test CompositeException 2 exceptions occurred See them in causal chain below E 19 more gt_CompositeException I CompositeException getMessage I CompositeException getCause I CompositeException getMessage I CompositeException getCause Process 28215 ended It turns out Android has its own implementation of a Throwable with uses private void private void printStackTrace Appendable err String indent StackTraceElement parentStack to print the stacktrace If the cause is null nothing is printed to the output I don t see any solution for this issue For KitKat and above the addSuppressed is an easy fix but what about older versions What about appending the stack trace to the message of a CompositeException This is some kind of a dirty hack but it will work on any platform regardless of printStackTrace implementation Appending the stacktrace to the message is bad practice and would be despised in non Android environments It s very annoying that Android does the wrong thing for this If we do anything it would need to special case behavior just for Android such as appending the whole stack trace as a message I think any working solution would be appreciated by the Android developers society I ended up wrapping the whole implementation of onError in try catch block so I m able to log the cause So far this is a simple workaround but better error logging by the RxJava should be really addressed in the future release @mttkay What do you suggest be done for Android and CompositeException since it doesn t behave correctly with Throwable printStackTrace @tomrozb According to the code I see for Android this should work if the logger is calling printStackTrace as it looks exactly like the Java one https android googlesource com platform libcore git android 4 2 2_r1 luni src main java java lang Throwable java How are the logs being generated Is this default Android logging that bypasses printStackTrace or a 3rd party logging library Thanks for flagging this We re still on 0 19 1 so haven t had this problem yet I ll have a look as well @benjchristensen I m not using any 3rd party logging library The logs I ve attached are from the standard logging tool called logcat Logs are generated by Android system The second posted log is slightly different because I m using tool to present it in a user friendly way but the log is still being generated by Android OS Crash reporting tools like Crashlytics or Bugsense utilize the Thread UncaughtExceptionHandler to obtain the stack trace and send it to the server As I wrote above stack traces obtained this way are exactly the same as printed by the system The Throwable implementation is different for Android and plain Java If they are using the private printStackTrace method with 3 arguments to print the stack trace other public printStackTrace methods which are overridden by RxJava will not be called when a crash occurred I can confirm this bug on Galaxy Nexus 4 3 stock Android G900F 4 4 2 GT I9506 4 4 2 GT I9195 4 4 2 GT N7100 4 4 2 SM T335 4 4 2 SM T320 4 4 2 I ve not tested this on non samsung devices but I m sure this apply to all Android devices It is very easy to understand what is going under the hood even without writing a line of code The simplest test case throw new RuntimeException new CompositeException Arrays asList new RuntimeException the real cause No matter which one of the printStackTrace methods is called in the first place it end up calling the printStackTrace err null on a first RuntimeException Now take a look at the Throwable implementation Android 4 2 2 private void printStackTrace Appendable err String indent StackTraceElement parentStack throws IOException err append toString err append n StackTraceElement stack getInternalStackTrace if stack null int duplicates parentStack null countDuplicates stack parentStack 0 for int i 0 i stack length duplicates i err append indent err append tat err append stack i toString err append n if duplicates 0 err append indent err append t err append Integer toString duplicates err append more n Print suppressed exceptions indented one level deeper if suppressedExceptions null for Throwable throwable suppressedExceptions err append indent err append tSuppressed throwable printStackTrace err indent t stack Throwable cause getCause if cause null err append indent err append Caused by cause printStackTrace err indent stack What is important the only method used on a cause is printStackTrace with 3 arguments Our cause is the CompositeException which doesn t have a cause That s why it doesn t work Just wondering if the problem is that Android s Throwable refuses to print the stack trace when the cause is null why not simply return this from CompositeException getCause That way we still don t have to initCause on the wrapped exceptions and make Android forward to CompositeException s custom printStackTrace impl This is just by reading the discussion mind you so sorry if I m not making any sense I still haven t had time into bumping RxJava in our app to a newer version yet',RxJava,false,false,false
37134381,'Kotlin M8','Update to Kotlin milestone 8 Some reformat on test Replacing deprecated method calls','RxJava pull requests #1359 https netflixoss ci cloudbees com job RxJava pull requests 1359 SUCCESS This pull request looks good',RxJava,true,false,false
37157075,'Android Problems with HandlerThreadScheduler since 0 19 1','We ve put our app in beta recently running RxJava 0 19 1 We re suddenly seeing problems with scheduling on the main thread where notifications arrive even after unsubscribing from the observable I suspect RxJava itself might be the cause here since the scheduler implementation changed in 0 19 I wanted to double check if anyone else is seeing this happen More specifically what happens is that in a subscriber from which we unsubscribe in Fragment#onDestroyView getView returns null crashing the app This should never happen when unsubscribing before the views get destroyed unless messages for some reason keep propagating to the subscriber There had even been a fix committed recently that eagerly removes all pending Runnables from the handler s message looper upon unsubscription so I wonder how this can even happen Unfortunately these things are incredibly difficult to debug as they are usually timing issues Some code extracts public class PlaylistTagsFragment extends Fragment @Override public void onViewCreated View view Bundle savedInstanceState super onViewCreated view savedInstanceState viewSubscriptions new CompositeSubscription viewSubscriptions add allTagsObservable subscribe new TagsSubscriber viewSubscriptions add recentTagsObservable subscribe new RecentsSubscriber @Override public void onDestroyView viewSubscriptions unsubscribe super onDestroyView private final class RecentsSubscriber extends DefaultSubscriber PlaylistTagsCollection @Override public void onNext PlaylistTagsCollection tags if tags getCollection isEmpty crashes here getView findViewById R id recent_tags_container setVisibility VISIBLE displayRecentTags tags','So one thing I discovered is that in this particular case the action we execute is actually quite fast for small amounts of data and we forgot to actually schedule it on a background thread so we didn t notice it was running on the main UI thread i e we didn t subscribeOn anything when firing the observable but we did observeOn the main thread I wonder if there s a timing issue or other glitch when observing something on the same thread you re already on I can t reproduce it locally unfortunately @mttkay I saw your description above which made me curious After looking into OperatorObserveOn and It s interaction with HandlerThreadScheduler here is what I found 1 Both ObserveOnSubscriber onNext and ScheduledUnsubscribe unsubscribe end up posting a Runnable in the HandlerThreadScheduler s Handler So with the code below final Subscription subscription Observable from new Object subscribeOn Schedulers newThread observeOn AndroidSchedulers mainThread subscribe new Action1 Object @Override public void call final Object o Log d HERE subscription unsubscribe If ObserveOnSubscriber onNext is called and an InnerHandlerThreadScheduler schedule call puts a ScheduledAction in the Loopers queue when you call subscription unsubscribe it will also queue another Runnable behind the one which will call onNext on your subscriber So you end up with something like this in the Looper s MessageQueue HEAD ObserveOnSubscriber pollQueue InnerHandlerThreadScheduler unsubscribe TAIL Note that that happens since even though you are calling unsubscribe from the main thread ScheduledUnsubscribe unsubscribe queues the subscribe for the worker see below @Override public void unsubscribe if ONCE_UPDATER getAndSet this 1 0 worker schedule new Action0 @Override public void call worker unsubscribe So when your call to unsubscribe returns within onDestroyView all pending Runnable instances in the queue will still be executed It seems to me that within OperatorObserveOn pollQueue there should be a check for scheduledUnsubscribe isUnsubscribed I am going to send a pull request with the fix for it today Let me know your thoughts @mttkay there is a fix at https github com Netflix RxJava pull 1409 The problem is that an unsubscribe call from downstream is not distinguished from upstream The former should unsubscribe the worker and drop every queued event whereas an upstream unsubscribe usually called due to an onError case should let queued events including the final onError to be delivered before the worker is shut down The problem is in L75 don t share the child subscriber s internal composite but rather use child add new ObserveOnSubscriber near L56 @dpsm good find I wasn t aware of OperatorObserveOn scheduling unsubscribe This is highly problematic actually since code like this will not work as expected void onDestroyView subscription unsubscribe is supposed to detach listeners from views super onDestroyView since the call to super detaching all the views will now overtake the scheduled unsubscription This is counter intuitive as you would think that unsubscribing is synchronous and immediately makes an attempt at stopping the observable and detaching subscribers This also means that removing posted runnables in the subscription block is less effective than it could be @akarnokd what do you mean with up and downstream @mttkay we have a fix to be merged soon that should implement the correct behaviour See my comment above referring to the fix @benjchristensen the fix for it is merged @mttkay please verify with version 0 19 4 Thanks so much guys I will see to release a new beta running on 0 19 4 ASAP It usually takes a few days for crash reports to come in but I ll report back in case the problem should persist Closing out Please reopen or start a new issue if the fix did not work',RxJava,false,false,false
37160037,'Make it easy to flatten Observable Iterable T to Observable T','In my code I often make API calls that return Observable Iterable T and then I want to process each element of the returned collection To do this I keep having to write something like java moviesService listMovies flatMap movies Observable from movies map movie doSomethingWith movie In Java 8 scala this isn t too bad but with Java 7 Android syntax the flatMap call is not pretty Since we can t add a flatten instance method that only applies to Observable Iterable T in java I see two solutions 1 Add Observable T flatten Observable Iterable T obs to rx Observable java Observable flatten moviesService listMovies map movie doSomethingWith movie 2 Add Func1 Iterable T Observable T flatten to rx functions Functions java moviesService listMovies flatMap Functions flatten map movie doSomethingWith movie I ve added a similar static method in a utils package to my code but I imagine this to be a pretty frequent use case','You can use mergeMapIterable but there should be a flatMap version as well I guess This is related to https github com Netflix RxJava issues 295 about a flatten operator As you suggest since Java doesn t allow targeting instance methods based on generics the only choice is static methods and or functions Adding Observable flatten is straight forward but we haven t yet started using Functions for utilities of this type I m not sure if we want to open that up and if we do if Functions is the right place to put them all I m going to close this as a duplicate and move the conversation over to https github com Netflix RxJava issues 295#issuecomment 48395054',RxJava,false,false,false
37180857,'Avoiding OperatorObserveOn from calling subscriber onNext after unsu','bscribe The OperatorObserveOn operator uses a scheduler to cancel subscriptions as well as to deliver the objects passing through it s onNext in the right context Calling unsubscribe will schedule the actual unsubscription while not making sure that the child subscriber will no longer receive calls to onNext after unsubscribe returns This fix makes sure that after unsubscribe returns no more onNext calls will be made on the child subscribers Signed off by David Marques dpsmarques@gmail com','RxJava pull requests #1360 https netflixoss ci cloudbees com job RxJava pull requests 1360 SUCCESS This pull request looks good What to change L56 Subscriber T s new ObserveOnSubscriber T scheduler child child add s return s L75 delete line L79 subscriber add recursiveScheduler This way if an unsubscribe call comes from the child it will stop the worker immediately but upstream calls are scheduled Beause the worker is stopped before the ObserveOnSubscriber unsubscribe is called the scheduling of the worker unsubscription will not succeed RxJava pull requests #1362 https netflixoss ci cloudbees com job RxJava pull requests 1362 SUCCESS This pull request looks good This looks okay @akarnokd thanks for the help with this fix Adding @benjchristensen Looks good to me Merging and releasing soon Actually is it possible for you to re submit this without the round about merges along the way @benjchristensen you mean squash the commits into one Yes please And if possible revert the lines that touched whitespace and aren t involved in the fix @benjchristensen done RxJava pull requests #1366 https netflixoss ci cloudbees com job RxJava pull requests 1366 SUCCESS This pull request looks good Thanks',RxJava,true,false,false
37181582,'0 20 Release Candidates','Since the backpressure #1000 changes are non trivial I suggest we do 0 20 0 RC releases until it stabilizes similar to how we did 0 17 I propose branching master into 0 19 x for ongoing maintenance releases and allowing master to be used for active development of 0 20 and the backpressure changes Any issues with me proceeding with this approach I d like to do this no later than Monday if there are no issues with this approach','Makes sense This will give us a change to shake out bug and perf issues and for people to code their favorite examples that require back pressure to kick the tires of the API Very much appreciated I ll ship the couchbase sdk developer preview 2 with 0 19 and hopefully move the upcoming beta to 0 20 Looking forward to test it I have merged the code into master I intend on releasing within the next 12 36 hours after some further validations and tweaks I have not released anything because there is a critical bug blocking me https github com Netflix RxJava issues 1420 It looks like I may have solved #1420 so can do a preview release The only thing that isn t done that I want done is the zip operator I have it almost done Should I release the preview before I finish zip or wait until I finish that I d go ahead so we can all play with it and hopefully find no other bugs I have released 0 20 0 RC1 https github com Netflix RxJava releases tag 0 20 0 RC1 awesome congrats 1',RxJava,false,false,false
37205968,'RxScala Subscribe with anonymous case matching','This is somewhat related to #1398 with all the changes to the Observable method signatures to improve type inference I was hoping something could be done to how subscribe onNext T Unit Subscription is defined so the common Scala simplification of case class matching from example 1 to example 2 would still compile Example 1 scala import rx lang scala Observable object Subscribe extends App Observable items Foo Answer 42 subscribe foo foo match case Foo bar boo println Got Foo case _ println Got Other case class Foo bar String boo Long Example 2 scala import rx lang scala Observable object Subscribe extends App Observable items Foo Answer 42 subscribe case Foo bar boo println Got Foo case _ println Got Other case class Foo bar String boo Long From my limited understanding of Scala type inference the problem is that the compiler can t differentiate between subscribe onNext T Unit Subscription subscribe subscriber Subscriber T Subscription or subscribe observer Observer T Subscription Which leads to the dreaded missing parameter type for expanded function The argument types of an anonymous function must be fully known SLS 8 5 error If someone can point me in the right direction I could create a pull request implementing the change and update examples test cases etc as required If this is simply not possible with Scala current type inference support just close this issue and I ll have to live with the more verbose case class matching syntax cc @headinthebox @zsxwing @samuelgruetter for feedback','The simplest solution to make your Example 2 work is to replace subscribe by foreach which is just an alias for subscribe but has no overloads of the same arity so the problem that the compiler can t differentiate between the different overloads is gone Thanks didn t think of using foreach but that looks like a simple enough workaround Haven t used foreach much since I don t really like that it hides the subscribe making the code harder to read and understand IMHO but I guess I ll have to make a choice Originally I didn t like foreach either but I was convinced to like it at least a bit See https github com Netflix RxJava pull 1316#commitcomment 6554430',RxJava,false,false,false
37317780,'Backpressure 0 20 0 RC1','This is a functioning implementation of backpressure Of the major unbounded queue operators in 0 19 this implements observeOn and merge but not yet zip ### New Signatures java public interface Producer public void request int n java public abstract class Subscriber T implements Observer T Subscription Optionally called from Observable OnSubscribe public final void setProducer Producer producer Allow implementing classes to capture decorate or override the Producer without affecting the Subscriber logic protected Producer onSetProducer Producer producer public final void request int n','RxJava pull requests #1368 https netflixoss ci cloudbees com job RxJava pull requests 1368 SUCCESS This pull request looks good As per discussion in https github com Netflix RxJava issues 1410 I am merging this and master is now going to be used for 0 20 release candidates RxJava pull requests #1369 https netflixoss ci cloudbees com job RxJava pull requests 1369 SUCCESS This pull request looks good Until I m back with more time could you compose a document about developing with the new backpressure what to look out etc The thing I don t see is what calls request n first and over again and when in a chain of operators',RxJava,true,false,false
37324026,'Switch build to Gradle 1 9','','Gradle 1 9 is a prereq for using plugin android RxJava pull requests #1372 https netflixoss ci cloudbees com job RxJava pull requests 1372 SUCCESS This pull request looks good Holding off a bit need to make sure this works with the release process to Maven Central There were issues in the past that caused us to downgrade from Gradle 1 10 We are working on an upgrade to 1 12 or 2 0 @benjchristensen Is there a way to validate without actually releasing or maybe release a SNAPSHOT version Is there a way to validate without actually releasing or maybe release a SNAPSHOT version I ll have to look into that I m working with @quidryan on all of our Gradle stuff and significant changes are coming @benjchristensen please let me know how I can contribute Work is going into https github com nebula plugins gradle rxjava project plugin I m actively working on adding the last pieces for publishing and releasesing Code reviews and soon manual testing will be helpful @gliptak Could t be the case that now when any sub project fails no jars are created for the sub projects that did compile For some reason on my machine several of the Rx contrib modules fail because of doc comment problems In the past I just let them blow up but jars would be created @headinthebox It has always been like that Now I am getting crazy I was never able to build beyond the first contrib module but I did manage to create jars for rx core and rx scala Anyway I ll just comment and uncomment the gradle file then @quidryan Are you planning to publish an RxJava subset to help learn how your plugin gets applied The rxjava project plugin will come with documentation once development is done and it s available for rxjava projects Ben will be the major consumer of it while he breaks apart the rxjava projects It won t be for general consumption outside of rxjava projects there s a lot of hard coded opinions in there that would make it un usable outside that specific project On Mon Jul 14 2014 at 12 38 PM gliptak notifications@github com wrote @quidryan https github com quidryan Are you planning to publish an RxJava subset to help learn how your plugin gets applied Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 1413#issuecomment 48949099 Closing this as it will be achieved through the redo of Gradle plugins with @quidryan',RxJava,true,false,false
37335535,'Merge Fixes','A handful of fixes particularly one that could cause non deterministic missing data','',RxJava,true,false,false
37371493,'can t find referenced class sun misc Unsafe','Since gradle downloaded release 0 19 4 I get lots of warnings in proGuard about UnSafe like Warning rx internal util unsafe UnsafeAccess can t find referenced class sun misc Unsafe And it breaks the building process too many warnings in proGuard As this is a warning It is fixed in proGuard by ignoring warnings from Rx but I m not sure this should be done with dontwarn rx internal util','I don t know anything about proGuard so can t comment about it but the classes that use sun misc Unsafe are all restricted to being in rx internal util unsafe and are only used in environments where it exists so not on Android In 0 19 4 they aren t used anywhere at all They are in the codebase preparatory for 0 20 where there are used to speed things up in environments where OpenJDK OracleJDK are used The gate for checking whether Unsafe can be used is here https github com Netflix RxJava blob master rxjava core src main java rx internal util unsafe UnsafeAccess java#L47 If anything that relies on sun misc Unsafe is used without checking this UnsafeAccess class it is a bug as it will fail to work on Android or other JVM implementations without sun misc Unsafe We are allowing it to be used though as it permits performance improvements in some use cases cc @mttkay Using dontwarn is perfectly fine here The reason ProGuard is failing is that it found this class to be reachable from the byte code it processed but did not find it included in any of the class files that make up the dependency graph This typically indicates a class path issue which would result in a runtime crash but here we know that it would never actually reach the missing class thanks to the safe guard Like Ben already said as long as we make sure we don t access it directly we should be good I m running into this issue with compiling RxJava as part of an android project using buck My current work around is adding a dummy Unsafe java class https gist github com chucknthem c3803a299d1d7c384348 And then modifying UnsafeAccess isUnsafeAvailable to always return false I don t understand what buck is I assume it is this http facebook github io buck Have you found a code path that actually tries to use sun misc Unsafe a problem that needs to be fixed if so or this is another tool that does reflection and incorrectly assumes sun misc Unsafe is being used even when it is not being used at runtime Thanks for the quick reply Yes that s the correct buck False alarm I got it to compile If anyone else is interested it will compile using java_library buck rule for rxjava core instead of an android_library which won t include libraries not available in android Thanks for sharing the solution about marking it as a java_library Answers for both proGuard and buck are in the discussion above',RxJava,false,false,false
37408121,'Chain method','Should we add a chain method similar to lift but that takes a function from Observable T to Observable R This carries on the conversation from https github com Netflix RxJava pull 983 A summary can be found at https github com Netflix RxJava pull 983#issuecomment 40541483 Signature java public R Observable R chain Func1 super Observable T extends Observable R function Usage java puts 0 before and 100 after an observable Func1 Observable Integer Observable Integer surround Observable Integer source return Observable concat Observable just 0 source Observable just 100 List Integer list Observable range 1 3 surround the source with 0 and 100 chain surround get as a list toList toBlockingObservable single This would emit 0 1 2 3 100 Similar to lift do we need a cover type on this as well to handle generics Right now the T and R are not marked super and I think they need to be','How is that different from publish that s already there This would not use multicast under the covers and would therefore be more efficient and retain subscription chains as it would not create a hot observable as publish does Yes that s what I imagined Could we call it lift as well or does that lead to erasure troubles I d have to play with Groovy and Clojure to see We d likely want another type like Operator that is a cover for generics insanity Not sure what to call this one',RxJava,false,false,false
37411225,'Proposal Subscriber onStart','This is a proposal derived from conversations with @headinthebox to use Subscriber onStart rather than constructor overloads as the mechanism for allowing request n to be called to operationally start backpressure or do anything else at the start of a stream The idea is that it is at the start the same as onError or onCompleted are terminal events It will always be called Usage for subscribing is like this java Observable from 1 2 3 4 take 2 subscribe new Subscriber Integer @Override public void onStart request 1 @Override public void onCompleted @Override public void onError Throwable e @Override public void onNext Integer t System out println t request 1 or when writing an Operator via lift java Observable from 1 2 3 4 lift new Operator Integer Integer @Override public Subscriber super Integer call final Subscriber super Integer child return new Subscriber Integer @Override public void onStart request 1 @Override public void onCompleted child onCompleted @Override public void onError Throwable e child onError e @Override public void onNext Integer t System out println t child onNext t request 1 subscribe Both of these examples are requesting 1 item at a time','Have you considered the single onSubscribe from the reactive manifesto I e a single callback with an injected object to request and cancel the producer instead of buffing up the Subscriber Yes I have I ve been involved in that design The problem is that RxJava already has a contract about how the Subscription is handled and we must support Observable Subscriber without backpressure Also the RxJava rx Subscription can not be the same as rx Producer due to how rx Subscription is used The Subscriber setProducer Producer p is the equivalent of the Reactive Streams onSubscribe Subscription s In Reactive Streams it must ALWAYS emit this and nothing will flow unless request n is invoked That is not the case in Rx Like RxJava pull requests #1375 https netflixoss ci cloudbees com job RxJava pull requests 1375 ABORTED',RxJava,true,false,false
37439146,'Zip with backpressure support','If I understand the backpressure correctly zip with backpressure is relatively simple if the client requests N items it is forwarded to all sources because they would need to produce N events each in order to get N events zipped Since N may vary bounded buffering may not be feasible In addition I m not sure what type of typical backpressure tests should be written so I only included a simple one I ve also fixed the unsynchronized read of requested in Subscriber setProducer','RxJava pull requests #1377 https netflixoss ci cloudbees com job RxJava pull requests 1377 FAILURE Looks like there s a problem with this pull request Zip is an async operator since it buffers so it needs to decouple the backpressure Producer and request rather than just passing it through It also needs to change to bounded buffers RxRingBuffer for example rather than remaining unbounded The reason it can t just pass through the requests is two fold 1 if the downstream doesn t require backpressure and requests 1 then passing that upstream will mean no backpressure into zip which will have unbounded buffer growth or overflow the bounded buffers 2 the downstream can process the output from onNext at a different rate than the buffers are filled thus zip can no longer just emit whenever it receives a complete set it must only emit if it has been requested This means the latest set can be emitted either by a producing thread or when the request is received which drains the queues Not sure if this breaks things but I d be happy if xs zip ys just forced xs and ys to produce at the same speed even just requesting 1 from each I see that the ringbuffer reduces garbage and there could be logic added to zip s request implementation to consider current buffer sizes when more values are requested from the sources but I don t see how the processing speed of downstream matters here Downstream should be responsible where and when it asks for the next batch of values for example in the test I could count the times the client onNext was called and call request 10 on modulo 10 of this count the next batch should come in right after it It is true that for example range s continuation mechanism will run on the same thread which invoked request n twice in the test code but there is no good way to put that continuation back to the original thread we are not Akka Actors I m closing this as I don t have time to improve it further before 0 20 goes out and apparently I don t get all the aspects of backpressure',RxJava,true,false,false
37441491,'BlockingObservable#next returns empty iterable','This code is fine java BlockingObservable Integer o Observable from 1 2 3 4 flatMap new Func1 Integer Observable Integer public Observable Integer call Integer n return Observable from n 2 subscribeOn Schedulers immediate toBlocking Log d RXT all new Gson toJson Lists newArrayList o getIterator Assert assertEquals 2 o first intValue Assert assertEquals 2 o first intValue Assert assertEquals 2 o first intValue Assert assertEquals 8 o last intValue Assert assertTrue Iterators elementsEqual Lists newArrayList 2 4 6 8 iterator o getIterator But if you replace getIterator with next the test is fails because next returns an empty list','Hi Next only emits values if there is someone waiting for a value which can never happen with a synchronous source what will happen is that next rushes through the source before the first next call can happen',RxJava,false,false,false
37485130,'BlockingOperatorToIterator Hanging','Doing a canary test of the current 0 20 code in master branch with real workloads it runs fine for several hours and then non deterministically fails over a couple hours Threads end up in this state 204 WAITING at sun misc Unsafe park Native Method at java util concurrent locks LockSupport park LockSupport java 186 at java util concurrent locks AbstractQueuedSynchronizer ConditionObject await AbstractQueuedSynchronizer java 2043 at java util concurrent LinkedBlockingQueue take LinkedBlockingQueue java 442 at rx internal operators BlockingOperatorToIterator 2 take BlockingOperatorToIterator java 92 Here is a screenshot showing 3 instances over 9 hours how they perform well until something triggers the bug at different times on each box screen shot 2014 07 09 at 9 42 09 am https cloud githubusercontent com assets 813492 3527738 0968e970 0788 11e4 9de8 2d43aff51c8e png','@benjchristensen Would you be able to provide some information regarding what does the source observable and the chain of operators look like I guess can can say the after materialize the complete notification never made it though the internal subscriber in BlockingOperatorToIterator Does it use backpressure what does the source observable and the chain of operators look like It is a list of Observables that each return a single item being merged together java lang Thread State WAITING parking at sun misc Unsafe park Native Method parking to wait for 0x00007f69fe0c6798 a java util concurrent locks AbstractQueuedSynchronizer ConditionObject at java util concurrent locks LockSupport park LockSupport java 186 at java util concurrent locks AbstractQueuedSynchronizer ConditionObject await AbstractQueuedSynchronizer java 2043 at java util concurrent LinkedBlockingQueue take LinkedBlockingQueue java 442 at rx internal operators BlockingOperatorToIterator 2 take BlockingOperatorToIterator java 92 at rx internal operators BlockingOperatorToIterator 2 hasNext BlockingOperatorToIterator java 72 at rx internal operators BlockingOperatorToIterator 2 next BlockingOperatorToIterator java 82 at rx observables BlockingObservable single BlockingObservable java 348 at com netflix api service at rx Observable 2 call Observable java 163 at rx Observable 2 call Observable java 156 at rx Observable unsafeSubscribe Observable java 6846 at rx internal operators OperatorMerge MergeSubscriber handleNewSource OperatorMerge java 127 at rx internal operators OperatorMerge MergeSubscriber onNext OperatorMerge java 110 at rx internal operators OperatorMerge MergeSubscriber onNext OperatorMerge java 49 at rx internal operators OperatorMap 1 onNext OperatorMap java 54 Does it use backpressure Nothing is explicitly using backpressure except for changes in RxJava itself The codebase is currently running RxJvaa 0 19 2 and I m dropping in 0 20 0 SNAPSHOT Debugging as I have time Pretty certain this is yet another concurrency bug in merge See my zip pr for a candidate If I have time I ll look at merge I had some time but the current merge is so complicated I can t make anything out of it I really don t like the merge code but everything I try to simplify it such as simple add to queue then drain kills the performance significantly The changes in #1422 did not solve this I ran a new canary and have the same issue Digging That is a scary stack trace Does the simplification kill perf for the non backpressure case as well No the simplification in #1422 didn t kill perf The stack trace itself is pretty normal merge does unsafeSubscribe except for the ugliness of how toBlocking is being used by the Observables being merged Thus far I still have no idea what causes this to fail I can t replicate it anywhere except for production and that s making it very hard to track down I confirmed over the weekend with a production canary that the issue is related to merge I took the code in master branch and reverted OperatorMerge to 0 19 x code but left everything else as is The issue did not occur Continuing to dig I have an idea as to where the issue might be Code changes I ve committed seem to have fixed this issue I ve had the code running in production for 12 hours and the score is good and thread dumps look clean @benjchristensen great news Looks like this isn t completely solved as I m seeing it still just far less often I m going to commit a change that I know solves it but it uses synchronization in a bad way I don t yet understand the actual issue just the symptoms and the hammer that removes the symptoms Could you help me understand how merge Observable Observable T works If the downstream requests 10 elements how is that translated to requests to the outer and inner observables Even if any requests are transformed into one by one requests that can t be held in a fixed buffer because either one requests 1 from N observables which might not deliver or requests 1 from all observables where there could be a buffer overrun if all produce The outer is unbounded except in the optimized case with ScalarSynchronousObservable The merge Observable Observable T case is an odd one and basically the user is asking for unbounded horizontal buffering We can achieve backpressure vertically how many items queued per Observable but not horizontally number of Observables being merged The reasoning is A user can t control how many onNext per Observable flow but they can generally control the number of Observables they are merging We can t restrict how many Observables are merged unless the user asks for it such as merge Observable o int maxConcurrent because it may only be the very last Observable that emits so if we sit waiting on the first ones we may never receive any values and never move on to the final Observable that has the data This is different in the ScalarSynchronousObservable case as we treat those as onNext and don t even subscribe to them This is why the request 1 behavior occurs in the current merge implementation at these two locations every Observable we receive we automatically request more https github com Netflix RxJava blob master rxjava core src main java rx internal operators OperatorMerge java#L191 on ScalarSynchronousObservable s we only request more once we have been able to emit their values https github com Netflix RxJava blob master rxjava core src main java rx internal operators OperatorMerge java#L230 I ve solved this for now with synchronization so am closing I ll work more on this over time for performance and efficiency reasons but as of 0 20 0 RC3 the issue is not showing itself and I have successfully passed a 20 hour production canary test in Netflix API production',RxJava,false,false,false
37540189,'Range backpressure concurrency off by one bugfix','Bugs deficiencies fixed reading of the volatile requested multiple times numLeft calculated incorrectly if start was not 0 since end is an absolute index and index goes up to it there is no need for start index gets only updated by a single thread thanks to the barriers provided by the atomic REQUESTED updater there is no need for volatile numLeft calculated incorrectly since end is an inclusive end index thus the remaining count is 1 completeOnFinish was false if the exact remaining amount is requested','RxJava pull requests #1379 https netflixoss ci cloudbees com job RxJava pull requests 1379 FAILURE Looks like there s a problem with this pull request @akarnokd aside from the build failure above looks good aside from the build failure above looks good I really do need to just get rid of the pivot operator until it is fixed Thank you @akarnokd for fixing my mess',RxJava,true,false,false
37609787,'Concurrency Fixes for RxRingBuffer Merge','Possible fix for #1420 I was unable to exactly reproduce the issue but was able to create a possibly related one This fixes it It also simplifies the logic and code somewhat at a possible small performance cost for these r o OperatorMergePerf merge1SyncStreamOfN 1000 thrpt 5 59407 716 2073 945 ops s r o OperatorMergePerf merge1SyncStreamOfN 1000000 thrpt 5 66 557 2 693 ops s r o OperatorMergePerf mergeNSyncStreamsOfN 1000 thrpt 5 59 293 5 046 ops s','',RxJava,true,false,false
37614546,'Changed producer interface to work with long instead of int','Changing int to long in Producer implementations','RxJava pull requests #1380 https netflixoss ci cloudbees com job RxJava pull requests 1380 SUCCESS This pull request looks good',RxJava,true,false,false
37622943,'Custom subject that stores last value but emits it only once','I will try to describe this by example There is a rest operation that provides observable result CustomSubject TResult result restClient doSmth subject could be hidden for consumer and represented as observable View needs to react on result of this rest call once View subscribes on this subject when it resumes and unsubscribe when it pauses View could be paused while rest call is in progress and resumed after rest call was performed I need to reflect result in the view when it resumed But I only need to react on it once So if user will pause and resume app again I won t react on rest call result again Any suggestions how to build such subject','Hi I d use some message identity let s say an always incrementing long as part of the result of restClient Then the client would keep a lastSeen value and drop anything that s lower or equal This way you can use a possibly bounded ReplaySubject',RxJava,false,false,false
37641944,'Kotlin warnings','Seems like a good idea to try to have everything compile without warnings language adaptors rxjava kotlin compileTestKotlin warning Annotations path entry points to a non existent location Trash RxJava 10 40 28 AM language adaptors rxjava kotlin src test kotlin rx lang kotlin KotlinTests kt 33 warning T has a nullable upper bound This means that a value of this type may be null Using T is likely to mislead the reader Trash RxJava 10 40 28 AM language adaptors rxjava kotlin src test kotlin rx lang kotlin KotlinTests kt 34 warning T has a nullable upper bound This means that a value of this type may be null Using T is likely to mislead the reader','@MarioAriasC Can you take care of this',RxJava,false,false,false
37642133,'Ruby bindings','These warnings have been there for a long time language adaptors rxjava jruby javadoc Trash RxJava 10 40 28 AM language adaptors rxjava jruby src main java rx lang jruby JRubyActionWrapper java 33 warning no description for @param @param T1 Trash RxJava 10 40 28 AM language adaptors rxjava jruby src main java rx lang jruby JRubyActionWrapper java 34 warning no description for @param @param T2 Trash RxJava 10 40 28 AM language adaptors rxjava jruby src main java rx lang jruby JRubyActionWrapper java 35 warning no description for @param @param T3 Trash RxJava 10 40 28 AM language adaptors rxjava jruby src main java rx lang jruby JRubyActionWrapper java 36 warning no description for @param @param T4 Trash RxJava 10 40 28 AM language adaptors rxjava jruby src main java rx lang jruby JRubyFunctionWrapper java 40 warning no description for @param @param T1 Trash RxJava 10 40 28 AM language adaptors rxjava jruby src main java rx lang jruby JRubyFunctionWrapper java 41 warning no description for @param @param T2 Trash RxJava 10 40 28 AM language adaptors rxjava jruby src main java rx lang jruby JRubyFunctionWrapper java 42 warning no description for @param @param T3 Trash RxJava 10 40 28 AM language adaptors rxjava jruby src main java rx lang jruby JRubyFunctionWrapper java 43 warning no description for @param @param T4 Trash RxJava 10 40 28 AM language adaptors rxjava jruby src main java rx lang jruby JRubyFunctionWrapper java 44 warning no description for @param @param T5 Trash RxJava 10 40 28 AM language adaptors rxjava jruby src main java rx lang jruby JRubyFunctionWrapper java 45 warning no description for @param @param T6 Trash RxJava 10 40 28 AM language adaptors rxjava jruby src main java rx lang jruby JRubyFunctionWrapper java 46 warning no description for @param @param T7 Trash RxJava 10 40 28 AM language adaptors rxjava jruby src main java rx lang jruby JRubyFunctionWrapper java 47 warning no description for @param @param T8 Trash RxJava 10 40 28 AM language adaptors rxjava jruby src main java rx lang jruby JRubyFunctionWrapper java 48 warning no description for @param @param T9 Trash RxJava 10 40 28 AM language adaptors rxjava jruby src main java rx lang jruby JRubyFunctionWrapper java 49 warning no description for @param @param R 14 warnings','',RxJava,false,false,false
37644069,'rxjava contrib rxjava async util javadoc','@akarnokd My build still breaks on rxjava contrib rxjava async util javadoc 66 errors 12 warnings rxjava contrib rxjava async util javadoc FAILED FAILURE Build failed with an exception','Could you run it with info i e gradle rxjava contrib rxjava async util javadoc info to see what it complains about Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async operators Functionals java 69 warning no @param for inner public static Action0 fromRunnable Runnable run Worker inner Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async operators OperatorFromFunctionals java 36 warning no @param for R public static R OnSubscribe R fromAction Action0 action R result Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async operators OperatorFromFunctionals java 36 warning no @param for action public static R OnSubscribe R fromAction Action0 action R result Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async operators OperatorFromFunctionals java 36 warning no @param for result public static R OnSubscribe R fromAction Action0 action R result Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async operators OperatorFromFunctionals java 36 warning no @return public static R OnSubscribe R fromAction Action0 action R result Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async operators OperatorFromFunctionals java 44 warning no @param for R public static R OnSubscribe R fromCallable Callable extends R callable Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async operators OperatorFromFunctionals java 44 warning no @param for callable public static R OnSubscribe R fromCallable Callable extends R callable Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async operators OperatorFromFunctionals java 44 warning no @return public static R OnSubscribe R fromCallable Callable extends R callable Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async operators OperatorFromFunctionals java 48 warning no @param for R public static R OnSubscribe R fromRunnable final Runnable run final R result Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async operators OperatorFromFunctionals java 48 warning no @param for run public static R OnSubscribe R fromRunnable final Runnable run final R result Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async operators OperatorFromFunctionals java 48 warning no @param for result public static R OnSubscribe R fromRunnable final Runnable run final R result Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async operators OperatorFromFunctionals java 48 warning no @return public static R OnSubscribe R fromRunnable final Runnable run final R result Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 48 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators start png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 67 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators start s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 83 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync an png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 97 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 112 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync an png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 127 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 143 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync an png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 159 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 176 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync an png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 193 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 211 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync an png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 229 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 248 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync an png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 267 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 287 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync an png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 307 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 328 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync an png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 349 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 371 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync an png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 393 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 416 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync an png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 439 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 463 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync an png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 476 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 490 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync ans png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 505 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 544 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync ans png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 560 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 600 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync ans png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 617 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 658 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync ans png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 676 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 718 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync ans png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 737 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 780 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync ans png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 800 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 844 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync ans png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 865 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 910 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync ans png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 932 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 978 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync ans png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1001 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1048 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync ans png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1072 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1120 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync ans png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1134 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators toAsync s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1172 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators asyncAction n png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1187 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators asyncAction ns png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1203 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators asyncFunc png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1219 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators asyncFunc s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1238 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators startFuture png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1254 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators startFuture s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1273 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators deferFuture png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1289 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators deferFuture s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1310 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators forEachFuture png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1333 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators forEachFuture png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1358 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators forEachFuture png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1382 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators forEachFuture s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1406 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators forEachFuture s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1432 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators forEachFuture s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1458 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators fromAction png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1476 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators fromCallable png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1495 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators fromRunnable png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1513 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators fromAction s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1530 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators fromCallable s png Users XXX IdeaProjects RxJava rxjava contrib rxjava async util src main java rx util async Async java 1548 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators fromRunnable s png 66 errors 12 warnings rxjava contrib rxjava async util javadoc FAILED FAILURE Build failed with an exception Also in joins rxjava contrib rxjava joins javadoc Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins operators OperatorJoinPatterns java 45 warning no @param for T1 public static T1 T2 Pattern2 T1 T2 and this Observable T1 left Observable T2 right Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins operators OperatorJoinPatterns java 45 warning no @param for T2 public static T1 T2 Pattern2 T1 T2 and this Observable T1 left Observable T2 right Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins operators OperatorJoinPatterns java 45 warning no @param for left public static T1 T2 Pattern2 T1 T2 and this Observable T1 left Observable T2 right Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins operators OperatorJoinPatterns java 45 warning no @param for right public static T1 T2 Pattern2 T1 T2 and this Observable T1 left Observable T2 right Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins operators OperatorJoinPatterns java 45 warning no @return public static T1 T2 Pattern2 T1 T2 and this Observable T1 left Observable T2 right Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins operators OperatorJoinPatterns java 58 warning no @param for T1 public static T1 R Plan0 R then this Observable T1 source Func1 T1 R selector Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins operators OperatorJoinPatterns java 58 warning no @param for R public static T1 R Plan0 R then this Observable T1 source Func1 T1 R selector Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins operators OperatorJoinPatterns java 58 warning no @param for source public static T1 R Plan0 R then this Observable T1 source Func1 T1 R selector Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins operators OperatorJoinPatterns java 58 warning no @param for selector public static T1 R Plan0 R then this Observable T1 source Func1 T1 R selector Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins operators OperatorJoinPatterns java 58 warning no @return public static T1 R Plan0 R then this Observable T1 source Func1 T1 R selector Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins operators OperatorJoinPatterns java 71 warning no @param for R public static R OnSubscribe R when Plan0 R plans Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins operators OperatorJoinPatterns java 71 warning no @param for plans public static R OnSubscribe R when Plan0 R plans Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins operators OperatorJoinPatterns java 71 warning no @return public static R OnSubscribe R when Plan0 R plans Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins operators OperatorJoinPatterns java 81 warning no @param for R public static R OnSubscribe R when final Iterable extends Plan0 R plans Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins operators OperatorJoinPatterns java 81 warning no @param for plans public static R OnSubscribe R when final Iterable extends Plan0 R plans Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins operators OperatorJoinPatterns java 81 warning no @return public static R OnSubscribe R when final Iterable extends Plan0 R plans Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 27 warning no @param for T public static T JoinObservable T from Observable T o Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 34 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators and_then_when png Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 44 warning no @param for T2 public final T2 Pattern2 T T2 and Observable T2 right Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 51 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators and_then_when png Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 61 warning no @param for R public final static R JoinObservable R when Iterable extends Plan0 R plans Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 71 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators and_then_when png Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 81 warning no @param for R public final static R JoinObservable R when Plan0 R plans Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 88 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators and_then_when png Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 97 warning no @param for R public final static R JoinObservable R when Plan0 R p1 Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 104 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators and_then_when png Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 115 warning no @param for R public final static R JoinObservable R when Plan0 R p1 Plan0 R p2 Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 122 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators and_then_when png Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 135 warning no @param for R public final static R JoinObservable R when Plan0 R p1 Plan0 R p2 Plan0 R p3 Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 142 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators and_then_when png Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 157 warning no @param for R public final static R JoinObservable R when Plan0 R p1 Plan0 R p2 Plan0 R p3 Plan0 R p4 Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 164 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators and_then_when png Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 181 warning no @param for R public final static R JoinObservable R when Plan0 R p1 Plan0 R p2 Plan0 R p3 Plan0 R p4 Plan0 R p5 Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 188 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators and_then_when png Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 207 warning no @param for R public final static R JoinObservable R when Plan0 R p1 Plan0 R p2 Plan0 R p3 Plan0 R p4 Plan0 R p5 Plan0 R p6 Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 214 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators and_then_when png Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 235 warning no @param for R public final static R JoinObservable R when Plan0 R p1 Plan0 R p2 Plan0 R p3 Plan0 R p4 Plan0 R p5 Plan0 R p6 Plan0 R p7 Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 242 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators and_then_when png Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 265 warning no @param for R public final static R JoinObservable R when Plan0 R p1 Plan0 R p2 Plan0 R p3 Plan0 R p4 Plan0 R p5 Plan0 R p6 Plan0 R p7 Plan0 R p8 Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 272 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators and_then_when png Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 297 warning no @param for R public final static R JoinObservable R when Plan0 R p1 Plan0 R p2 Plan0 R p3 Plan0 R p4 Plan0 R p5 Plan0 R p6 Plan0 R p7 Plan0 R p8 Plan0 R p9 Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 305 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators and_then_when png Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx observables JoinObservable java 315 warning no @param for R public final R Plan0 R then Func1 T R selector Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins Pattern1 java 45 warning no @param for R public R Plan0 R then Func1 T1 R selector Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins Pattern2 java 48 warning no @param for T3 public T3 Pattern3 T1 T2 T3 and Observable T3 other Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins Pattern2 java 65 warning no @param for R public R Plan0 R then Func2 T1 T2 R selector Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins Pattern3 java 55 warning no @param for T4 public T4 Pattern4 T1 T2 T3 T4 and Observable T4 other Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins Pattern3 java 72 warning no @param for R public R Plan0 R then Func3 T1 T2 T3 R selector Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins Pattern4 java 65 warning no @param for T5 public T5 Pattern5 T1 T2 T3 T4 T5 and Observable T5 other Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins Pattern4 java 81 warning no @param for R public R Plan0 R then Func4 T1 T2 T3 T4 R selector Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins Pattern5 java 72 warning no @param for T6 public T6 Pattern6 T1 T2 T3 T4 T5 T6 and Observable T6 other Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins Pattern5 java 88 warning no @param for R public R Plan0 R then Func5 T1 T2 T3 T4 T5 R selector Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins Pattern6 java 79 warning no @param for T7 public T7 Pattern7 T1 T2 T3 T4 T5 T6 T7 and Observable T7 other Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins Pattern6 java 95 warning no @param for R public R Plan0 R then Func6 T1 T2 T3 T4 T5 T6 R selector Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins Pattern7 java 86 warning no @param for T8 public T8 Pattern8 T1 T2 T3 T4 T5 T6 T7 T8 and Observable T8 other Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins Pattern7 java 102 warning no @param for R public R Plan0 R then Func7 T1 T2 T3 T4 T5 T6 T7 R selector Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins Pattern8 java 93 warning no @param for T9 public T9 Pattern9 T1 T2 T3 T4 T5 T6 T7 T8 T9 and Observable T9 other Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins Pattern8 java 109 warning no @param for R public R Plan0 R then Func8 T1 T2 T3 T4 T5 T6 T7 T8 R selector Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins Pattern9 java 130 warning no @param for R public R Plan0 R then Func9 T1 T2 T3 T4 T5 T6 T7 T8 T9 R selector Users XXX IdeaProjects RxJava rxjava contrib rxjava joins src main java rx joins PatternN java 78 warning no @param for R public R Plan0 R then FuncN R selector 13 errors 47 warnings rxjava contrib rxjava joins javadoc FAILED FAILURE Build failed with an exception What went wrong Execution failed for task rxjava contrib rxjava joins javadoc Javadoc generation failed And computatiuon expressions rxjava contrib rxjava computation expressions javadoc Users XXX IdeaProjects RxJava rxjava contrib rxjava computation expressions src main java rx Statement java 34 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators switchCase png Users XXX IdeaProjects RxJava rxjava contrib rxjava computation expressions src main java rx Statement java 58 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators switchCase s png Users XXX IdeaProjects RxJava rxjava contrib rxjava computation expressions src main java rx Statement java 85 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators switchCase png Users XXX IdeaProjects RxJava rxjava contrib rxjava computation expressions src main java rx Statement java 112 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators doWhile png Users XXX IdeaProjects RxJava rxjava contrib rxjava computation expressions src main java rx Statement java 121 warning no @param for T public static T Observable T doWhile Observable extends T source Func0 Boolean postCondition Users XXX IdeaProjects RxJava rxjava contrib rxjava computation expressions src main java rx Statement java 121 warning no @param for source public static T Observable T doWhile Observable extends T source Func0 Boolean postCondition Users XXX IdeaProjects RxJava rxjava contrib rxjava computation expressions src main java rx Statement java 129 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators whileDo png Users XXX IdeaProjects RxJava rxjava contrib rxjava computation expressions src main java rx Statement java 137 warning no @param for T public static T Observable T whileDo Observable extends T source Func0 Boolean preCondition Users XXX IdeaProjects RxJava rxjava contrib rxjava computation expressions src main java rx Statement java 137 warning no @param for source public static T Observable T whileDo Observable extends T source Func0 Boolean preCondition Users XXX IdeaProjects RxJava rxjava contrib rxjava computation expressions src main java rx Statement java 145 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators ifThen png Users XXX IdeaProjects RxJava rxjava contrib rxjava computation expressions src main java rx Statement java 166 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators ifThen s png Users XXX IdeaProjects RxJava rxjava contrib rxjava computation expressions src main java rx Statement java 190 error no alt attribute for image img width 640 src https raw github com wiki Netflix RxJava images rx operators ifThen e png 8 errors 4 warnings rxjava contrib rxjava computation expressions javadoc FAILED FAILURE Build failed with an exception What went wrong Execution failed for task rxjava contrib rxjava computation expressions javadoc Javadoc generation failed Javadoc 8 requires alt attribute to be present but they are omitted like everywhere even in core Yes I compared the doc comments in both but for some reason all the contrib modules fail for me Maybe there is something different in the build files for them Issue #773 I don t have any issues with Eclipse 4 4 and NetBeans 8 0 when building the project It might be possible that IntelliJ does not properly use the settings in the subprojects but defaults to the global settings I m not building with IntelliJ just gradlew build cc @gliptak I never bothered that the build broke there because the jars for core and the language bindings were created but now if anything breaks no jars are created Handle in https github com Netflix RxJava issues 1502',RxJava,false,false,false
37649105,'Simplify creation of single thread used by event loop based Schedulers','Removes overhead of using a ScheduledThreadPool for the single thread used by the event loop based Schedulers Explicitly creates a single thread and uses a minimal queue implementation so that execution of scheduled actions are serialized I ve seen some spurious unit tests failures that I m unable to reproduce so a code review to point any concurrency issues would be much appreciated Also if someone could point me to which JMH benchmarks that would be relevant for this change and how to run them I can post some numbers to see if this change is worthwhile','RxJava pull requests #1382 https netflixoss ci cloudbees com job RxJava pull requests 1382 FAILURE Looks like there s a problem with this pull request But this way you lose the ability to interrupt an executing ScheduledAction I had a version that made a ScheduledAction into a FutureTask Void but it looked like it didn t buy much so I removed it I could bring that back to make each action interruptible as well RxJava pull requests #1383 https netflixoss ci cloudbees com job RxJava pull requests 1383 SUCCESS This pull request looks good You are only a few steps away from a regular ThreadPoolExecutor so this might not be worth it One place where I see some improvement possibility is to use MPSC queue with some park unpark logic instead of the heavyweight BlockingQueue to reduce latency and increase throughput Yeah this is definitely getting closer to the regular ThreadPoolExecutor but it would be interesting to do some actual benchmarking to see how big of a difference it makes Wouldn t a MPSC queue implementing park unpark logic simply be a BlockingQueue as well or do you mean for it to just implement put take The guaranteed single consumer makes the queue implementation simpler and more performant As you say any performance gain from this seems to be tied to queue implementation used I did some benchmarking and most of it shows worse numbers than Master It seems like a better blocking MPSC queue is needed to perform better than the ScheduledThreadPoolExecutor s DelayedWorkQueue ### Master Benchmark size Mode Samples Score Score error Units r s ComputationSchedulerPerf observeOn 1 thrpt 5 140372 217 7604 718 ops s r s ComputationSchedulerPerf observeOn 1000 thrpt 5 6602 389 89 210 ops s r s ComputationSchedulerPerf observeOn 1000000 thrpt 5 12 624 2 932 ops s r s ComputationSchedulerPerf subscribeOn 1 thrpt 5 167700 033 1098 972 ops s r s ComputationSchedulerPerf subscribeOn 1000 thrpt 5 31300 122 800 504 ops s r s ComputationSchedulerPerf subscribeOn 1000000 thrpt 5 39 737 0 885 ops s ### LinkedBlockingQueue Benchmark size Mode Samples Score Score error Units r s ComputationSchedulerPerf observeOn 1 thrpt 5 121386 119 141345 030 ops s r s ComputationSchedulerPerf observeOn 1000 thrpt 5 5083 430 891 982 ops s r s ComputationSchedulerPerf observeOn 1000000 thrpt 5 11 778 7 257 ops s r s ComputationSchedulerPerf subscribeOn 1 thrpt 5 164133 469 6639 425 ops s r s ComputationSchedulerPerf subscribeOn 1000 thrpt 5 29505 655 12970 264 ops s r s ComputationSchedulerPerf subscribeOn 1000000 thrpt 5 39 286 3 089 ops s ### LinkedTransferQueue Benchmark size Mode Samples Score Score error Units r s ComputationSchedulerPerf observeOn 1 thrpt 5 144432 159 2752 933 ops s r s ComputationSchedulerPerf observeOn 1000 thrpt 5 2201 598 614 237 ops s r s ComputationSchedulerPerf observeOn 1000000 thrpt 5 10 687 4 447 ops s r s ComputationSchedulerPerf subscribeOn 1 thrpt 5 165733 652 12205 731 ops s r s ComputationSchedulerPerf subscribeOn 1000 thrpt 5 30813 692 162 427 ops s r s ComputationSchedulerPerf subscribeOn 1000000 thrpt 5 39 683 1 279 ops s ### MPSC https gist github com jbripley 24ee20c893966c87c5c8 based of MpscLinkedQueue https github com aweisberg MpscLinkedBlockingQueue tree master src Benchmark size Mode Samples Score Score error Units r s ComputationSchedulerPerf observeOn 1 thrpt 5 103297 671 65273 029 ops s r s ComputationSchedulerPerf observeOn 1000 thrpt 5 2143 169 767 458 ops s r s ComputationSchedulerPerf observeOn 1000000 thrpt 5 13 877 2 030 ops s r s ComputationSchedulerPerf subscribeOn 1 thrpt 5 224816 844 18572 658 ops s r s ComputationSchedulerPerf subscribeOn 1000 thrpt 5 22132 332 12309 970 ops s r s ComputationSchedulerPerf subscribeOn 1000000 thrpt 5 34 461 5 266 ops s ### Master Benchmark size Mode Samples Score Score error Units r s IOSchedulerPerf observeOn 1 thrpt 5 143321 787 6837 897 ops s r s IOSchedulerPerf observeOn 1000 thrpt 5 6380 070 43 481 ops s r s IOSchedulerPerf observeOn 1000000 thrpt 5 12 217 4 397 ops s r s IOSchedulerPerf subscribeOn 1 thrpt 5 162479 302 1394 904 ops s r s IOSchedulerPerf subscribeOn 1000 thrpt 5 31334 989 2276 957 ops s r s IOSchedulerPerf subscribeOn 1000000 thrpt 5 39 742 1 410 ops s ### LinkedBlockingQueue Benchmark size Mode Samples Score Score error Units r s IOSchedulerPerf observeOn 1 thrpt 5 136678 425 8607 107 ops s r s IOSchedulerPerf observeOn 1000 thrpt 5 4883 127 436 343 ops s r s IOSchedulerPerf observeOn 1000000 thrpt 5 10 793 10 151 ops s r s IOSchedulerPerf subscribeOn 1 thrpt 5 148977 633 9378 303 ops s r s IOSchedulerPerf subscribeOn 1000 thrpt 5 29709 568 2458 071 ops s r s IOSchedulerPerf subscribeOn 1000000 thrpt 5 39 648 2 434 ops s ### LinkedTransferQueue Benchmark size Mode Samples Score Score error Units r s IOSchedulerPerf observeOn 1 thrpt 5 136473 718 20596 581 ops s r s IOSchedulerPerf observeOn 1000 thrpt 5 2437 555 157 557 ops s r s IOSchedulerPerf observeOn 1000000 thrpt 5 10 633 7 839 ops s r s IOSchedulerPerf subscribeOn 1 thrpt 5 164893 460 400 947 ops s r s IOSchedulerPerf subscribeOn 1000 thrpt 5 30876 749 1124 711 ops s r s IOSchedulerPerf subscribeOn 1000000 thrpt 5 39 871 0 773 ops s ### MPSC https gist github com jbripley 24ee20c893966c87c5c8 based of MpscLinkedQueue https github com aweisberg MpscLinkedBlockingQueue tree master src Benchmark size Mode Samples Score Score error Units r s IOSchedulerPerf observeOn 1 thrpt 5 67 912 58 321 ops s r s IOSchedulerPerf observeOn 1000 thrpt 5 1428 191 1210 344 ops s r s IOSchedulerPerf observeOn 1000000 thrpt 5 13 690 1 823 ops s r s IOSchedulerPerf subscribeOn 1 thrpt 5 30 144 15 015 ops s r s IOSchedulerPerf subscribeOn 1000 thrpt 5 32165 599 6923 167 ops s r s IOSchedulerPerf subscribeOn 1000000 thrpt 5 39 101 2 060 ops s The ObserveOn throughput for 1M items seems to be slightly better but the latency overhead for smaller values seem to kill the throughput How did you implement the sleeping waking logic When I worked on a new computation scheduler I did need to park unpark the worker see #1200 this https github com Netflix RxJava pull 1200 files#diff bfc58d00fd0fd05d459ce62ce2ebc62fR314 and this https github com Netflix RxJava pull 1200 files#diff bfc58d00fd0fd05d459ce62ce2ebc62fR320 Unfortunately LockSupport park is system dependent and I get 3ms latency when unparking a thread in Win7 The MPSC queue https gist github com jbripley 24ee20c893966c87c5c8 I used is heavily based on the code created for this blog post http www afewmoreamps com 2014 04 improving on abstractnodequeuempsclinke html It does unparking on offer https gist github com jbripley 24ee20c893966c87c5c8#file mpsclinkedqueue java L82 and a combination of spin yield and parking on take https gist github com jbripley 24ee20c893966c87c5c8#file mpsclinkedqueue java L269 These benchmarks were run on Windows 7 so it might have something to do with the high latency overhead of the MPSC queue Also it fails some concurrent unit tests OperatorParallelTest RxRingBufferSpmcTest that indicates it still has some thread safety bugs to fix RxJava pull requests #1392 https netflixoss ci cloudbees com job RxJava pull requests 1392 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1393 https netflixoss ci cloudbees com job RxJava pull requests 1393 FAILURE Looks like there s a problem with this pull request Finally constructed a MPSC queue that consistently passes all unit tests It s currently a combination of @JCTools MpscLinkedQueue7 and @aweisberg s park unpark spin code for blocking in take poll timeout Some current benchmarks numbers below Master vs current MPSC queue based solution This branch should allocate less objects than Master s ScheduledThreadPool based implementation but I m not sure how measure that in a good way and it doesn t seem to make much difference in these benchmarks at least Suggestions for other benchmarks to run and how to best measure object allocations gladly accepted ### Master Benchmark size Mode Samples Score Score error Units r s ComputationSchedulerPerf observeOn 1 thrpt 5 140372 217 7604 718 ops s r s ComputationSchedulerPerf observeOn 1000 thrpt 5 6602 389 89 210 ops s r s ComputationSchedulerPerf observeOn 1000000 thrpt 5 12 624 2 932 ops s r s ComputationSchedulerPerf subscribeOn 1 thrpt 5 167700 033 1098 972 ops s r s ComputationSchedulerPerf subscribeOn 1000 thrpt 5 31300 122 800 504 ops s r s ComputationSchedulerPerf subscribeOn 1000000 thrpt 5 39 737 0 885 ops s Benchmark size Mode Samples Score Score error Units r s IOSchedulerPerf observeOn 1 thrpt 5 143321 787 6837 897 ops s r s IOSchedulerPerf observeOn 1000 thrpt 5 6380 070 43 481 ops s r s IOSchedulerPerf observeOn 1000000 thrpt 5 12 217 4 397 ops s r s IOSchedulerPerf subscribeOn 1 thrpt 5 162479 302 1394 904 ops s r s IOSchedulerPerf subscribeOn 1000 thrpt 5 31334 989 2276 957 ops s r s IOSchedulerPerf subscribeOn 1000000 thrpt 5 39 742 1 410 ops s ### MPSC Benchmark size Mode Samples Score Score error Units r s ComputationSchedulerPerf observeOn 1 thrpt 5 159001 339 2977 556 ops s r s ComputationSchedulerPerf observeOn 1000 thrpt 5 3050 850 350 512 ops s r s ComputationSchedulerPerf observeOn 1000000 thrpt 5 10 094 2 223 ops s r s ComputationSchedulerPerf subscribeOn 1 thrpt 5 186420 975 2577 608 ops s r s ComputationSchedulerPerf subscribeOn 1000 thrpt 5 31862 328 2128 144 ops s r s ComputationSchedulerPerf subscribeOn 1000000 thrpt 5 40 052 1 939 ops s Benchmark size Mode Samples Score Score error Units r s IOSchedulerPerf observeOn 1 thrpt 5 149359 054 7119 008 ops s r s IOSchedulerPerf observeOn 1000 thrpt 5 3041 888 602 697 ops s r s IOSchedulerPerf observeOn 1000000 thrpt 5 12 671 3 516 ops s r s IOSchedulerPerf subscribeOn 1 thrpt 5 164704 772 7044 405 ops s r s IOSchedulerPerf subscribeOn 1000 thrpt 5 31622 103 1619 894 ops s r s IOSchedulerPerf subscribeOn 1000000 thrpt 5 39 967 0 641 ops s RxJava pull requests #1394 https netflixoss ci cloudbees com job RxJava pull requests 1394 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1396 https netflixoss ci cloudbees com job RxJava pull requests 1396 FAILURE Looks like there s a problem with this pull request Did some more benchmarking after merging in the latest Master changes and these were the more significant differences complete results https gist github com jbripley 2b2e798388a9e7287c3f between Master and this branch I don t which of these benchmarks are more indicative of improved performance for a regular RxJava project though ### Master #### Scheduler Perf r s ComputationSchedulerPerf observeOn 1 thrpt 10 144830 081 1560 140 ops s r s ComputationSchedulerPerf observeOn 1000 thrpt 10 6512 983 259 519 ops s r s ComputationSchedulerPerf observeOn 1000000 thrpt 10 11 204 1 591 ops s r s IOSchedulerPerf observeOn 1 thrpt 10 140350 109 3255 753 ops s r s IOSchedulerPerf observeOn 1000 thrpt 10 6488 518 411 015 ops s r s IOSchedulerPerf observeOn 1000000 thrpt 10 10 394 2 041 ops s #### Operators Perf r o OperatorFlatMapPerf flatMapIntPassthruAsync 1 thrpt 10 778686 269 44655 053 ops s r o OperatorFlatMapPerf flatMapIntPassthruAsync 1000 thrpt 10 676 562 86 066 ops s r o OperatorFlatMapPerf flatMapIntPassthruAsync 1000000 thrpt 10 0 636 0 140 ops s r o OperatorMergePerf mergeTwoAsyncStreamsOfN 1 thrpt 10 93557 200 1153 979 ops s r o OperatorMergePerf mergeTwoAsyncStreamsOfN 1000 thrpt 10 4027 269 100 208 ops s r o OperatorObserveOnPerf observeOnComputation 1 thrpt 10 144870 832 1512 479 ops s r o OperatorObserveOnPerf observeOnComputation 1000 thrpt 10 6564 630 62 596 ops s r o OperatorObserveOnPerf observeOnComputation 1000000 thrpt 10 7 387 0 909 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1 thrpt 10 150387 669 2602 008 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1000 thrpt 10 19790 099 2802 973 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1 thrpt 10 64561 534 312 131 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1000 thrpt 10 63898 823 852 689 ops s ### This Branch #### Scheduler Perf r s ComputationSchedulerPerf observeOn 1 thrpt 10 154202 940 3255 814 ops s r s ComputationSchedulerPerf observeOn 1000 thrpt 10 3208 208 381 419 ops s r s ComputationSchedulerPerf observeOn 1000000 thrpt 10 10 369 2 518 ops s r s IOSchedulerPerf observeOn 1 thrpt 10 156368 921 1268 033 ops s r s IOSchedulerPerf observeOn 1000 thrpt 10 3025 508 337 313 ops s r s IOSchedulerPerf observeOn 1000000 thrpt 10 8 136 1 963 ops s #### Operators Perf r o OperatorFlatMapPerf flatMapIntPassthruAsync 1 thrpt 10 767125 486 48270 943 ops s r o OperatorFlatMapPerf flatMapIntPassthruAsync 1000 thrpt 10 640 688 86 499 ops s r o OperatorFlatMapPerf flatMapIntPassthruAsync 1000000 thrpt 10 0 604 0 037 ops s r o OperatorMergePerf mergeTwoAsyncStreamsOfN 1 thrpt 10 114217 076 1661 953 ops s r o OperatorMergePerf mergeTwoAsyncStreamsOfN 1000 thrpt 10 2871 055 1082 536 ops s r o OperatorObserveOnPerf observeOnComputation 1 thrpt 10 158239 534 805 563 ops s r o OperatorObserveOnPerf observeOnComputation 1000 thrpt 10 3264 463 58 058 ops s r o OperatorObserveOnPerf observeOnComputation 1000000 thrpt 10 3 367 1 517 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1 thrpt 10 168699 190 2011 217 ops s r o OperatorSerializePerf serializedTwoStreamsOneFastOneSlow 1000 thrpt 10 43453 264 224 597 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1 thrpt 10 78015 228 780 627 ops s r o OperatorSerializePerf serializedTwoStreamsSlightlyContended 1000 thrpt 10 79084 087 673 788 ops s This is a very lengthy discussion with several commits and modifications and a lot of code If you still want to proceed with this after the discussion can you please close this and submit a new one that rebases the code to a single commit and clearly states what is being proposed and why Keep in mind data structures that have been added here https github com Netflix RxJava tree master rxjava core src main java rx internal util and https github com Netflix RxJava tree master rxjava core src main java rx internal util unsafe Also keep in mind that any use of sun misc Unsafe must be used conditionally so that environments such as Android have other data structures to use https github com Netflix RxJava blob master rxjava core src main java rx internal util unsafe UnsafeAccess java#L47 Performance tests that seem applicable to this are https github com Netflix RxJava tree master rxjava core src perf java rx schedulers https github com Netflix RxJava blob master rxjava core src perf java rx operators OperatorObserveOnPerf java We have a small number of perf tests so likely more are needed Your testing above seems to already be using the relevant ones As the benchmarks seem to indicate that this is a marginal except serializedTwoStreams improvement or worse performing observeOn I ll need to rethink the design of this before it ll be worth merging The current solution will allocate less objects for each scheduling on a worker but that doesn t seem to make much of a impact in the benchmarks',RxJava,true,false,false
37655126,'RxRingBuffer test fails','Just reporting Class rx internal util RxRingBufferWithoutUnsafeTest java lang AssertionError expected 94390 but was 94389 at org junit Assert fail Assert java 93 at org junit Assert failNotEquals Assert java 647 at org junit Assert assertEquals Assert java 128 at org junit Assert assertEquals Assert java 472 at org junit Assert assertEquals Assert java 456 at rx internal util RxRingBufferWithoutUnsafeTest testConcurrency RxRingBufferWithoutUnsafeTest java 166 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 62 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at java lang reflect Method invoke Method java 483 at org junit runners model FrameworkMethod 1 runReflectiveCall FrameworkMethod java 45 at org junit internal runners model ReflectiveCallable run ReflectiveCallable java 15 at org junit runners model FrameworkMethod invokeExplosively FrameworkMethod java 42 at org junit internal runners statements InvokeMethod evaluate InvokeMethod java 20 at org junit internal runners statements FailOnTimeout StatementThread run FailOnTimeout java 62','Thanks for the report Fixed and merged',RxJava,false,false,false
37657378,'Unneeded Variance Cleanup','Removed unneeded variance and replaced a few type variables in result types that don t matter with Any Used @uncheckedVariance in one place that I think is safe and correspond better with Java signature which also just takes a T def publish R selector Observable T Observable R initialValue T @uncheckedVariance Observable R ublic final R Observable R publish Func1 super Observable T extends Observable R selector final T initialValue Aside Is the class CompletenessTest extends JUnitSuite useful not for me at least it requires too much manual messing around and I am never sure what to change and why','RxJava pull requests #1384 https netflixoss ci cloudbees com job RxJava pull requests 1384 SUCCESS This pull request looks good You commented out almost all of the projects in settings gradle can you remove that from this commit I thought I did not commit that file my build suddenly breaks when I try to compile any of the contrib modules',RxJava,true,false,false
37658539,'CompositeException fix for Android','Fixes #1405 revert changes from f4ae92aa remove duplicated causes in stack trace chain','RxJava pull requests #1385 https netflixoss ci cloudbees com job RxJava pull requests 1385 FAILURE Looks like there s a problem with this pull request This will take a while to review as those changes were done for good reason Maybe I should provide some explanation about what was wrong with the previous implementation Here s how most of Java programmers will rethrow an exception if not handled Observable create Subscriber super Object subscriber subscriber onError new RuntimeException ex1 observeOn AndroidSchedulers mainThread subscribeOn Schedulers io subscribe object error handle some exception rethrow unhandled throw new RuntimeException ex2 error Now we have CompositeException with two nested exceptions ex1 ex2 which cause is ex1 The previous implementation will create a loop in this situation OnErrorFailedException CompositeException ex1 ex2 ex1 ex2 I ve provided test for this scenario and additional method to remove throwables which are causes of another throwable It means ex1 will not be attached as a cause of the CompositeException because it is a cause of ex2 so it currently attached and will be printed in the stack trace OnErrorFailedException CompositeException ex2 ex1 cc @mattrjacobs Matt can you get involved here now that you re back since you have the most recent history and context in this code Discussion at https github com Netflix RxJava issues 1405 Given the new constraint that Android does something unexpected to me anyway with the set of printStackTrace methods it s probably preferable to modify the structure of CompositeException so that any arbitrary output of a CompositeException is correct Relying on the implementation details of precisely how Android does the printStackTrace doesn t protect us from any other edge cases So I generally think the sort of change proposed by @tomrozb is good I m validating what the output looks like in our prod env now Thanks @tomrozb for the PR I m merging this now thanks for the clear explanation and fix with a test @tomrozb Thanks @mattrjacobs and @tomrozb',RxJava,true,false,false
37675896,'Remove variance try 2','Removed unneeded variance and replaced a few type variables in result types that don t matter with Any Used @uncheckedVariance in one place that I think is safe and correspond better with Java signature which also just takes a T def publish R selector Observable T Observable R initialValue T @uncheckedVariance Observable R ublic final R Observable R publish Func1 super Observable T extends Observable R selector final T initialValue','RxJava pull requests #1386 https netflixoss ci cloudbees com job RxJava pull requests 1386 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
37676330,'Take 3','Removed unneeded variance and replaced a few type variables in result types that don t matter with Any Used @uncheckedVariance in one place that I think is safe and correspond better with Java signature which also just takes a T def publish R selector Observable T Observable R initialValue T @uncheckedVariance Observable R ublic final R Observable R publish Func1 super Observable T extends Observable R selector final T initialValue','RxJava pull requests #1387 https netflixoss ci cloudbees com job RxJava pull requests 1387 SUCCESS This pull request looks good',RxJava,true,false,false
37694395,'onErrorFlatMap not called when error happened in subscriber s onNext','I want to make some of my observable uninterruptible I currently trying to use onErrorFlatMap to spawn another observable sequence but if error happens in subscriber onNext it stops receiving updates and onErrorFlatMap is never called Im sure Im just using this method incorrectly How can I fix it java Observable Long observable Observable interval 1 TimeUnit SECONDS onErrorFlatMap new Func1 OnErrorThrowable Observable extends Long @Override public Observable extends Long call OnErrorThrowable onErrorThrowable return Observable interval 1 TimeUnit SECONDS observable subscribe new Subscriber Long @Override public void onCompleted @Override public void onError Throwable e @Override public void onNext Long aLong Log d TAG val test aLong throw new RuntimeException oops','Why not catch the exception in onNext @zsxwing Yeah I that is my current option I thought there is better way to do it Take a look at this https github com Netflix RxJava pull 1441 We are killing onErrorFlatMap as it breaks the Rx contract See #1465 for the reasons Here is a simple event bus example that allows error handling retry when errors happen java import rx Observable import rx subjects PublishSubject public class EventBus public static void main String args MyEventBus bus new MyEventBus bus toObservable filter EventBus IS_NUMBER forEach n System out println Got number n bus toObservable filter EventBus IS_STRING forEach System out println something that can fail it assumes Integer bus toObservable map o if Integer o 10 return Greater than 10 else return Less than or equal to 10 doOnError e System err println e getMessage retry forEach System out println bus send 1 System out println bus send 11 System out println bus send 28 System out println bus send hello System out println bus send 5 System out println bus send world System out println public static boolean IS_NUMBER Object o if o instanceof Number return true else return false public static boolean IS_STRING Object o if o instanceof String return true else return false public static class MyEventBus private final PublishSubject Object bus PublishSubject create public void send Object o bus onNext o public Observable Object toObservable return bus What use cases does this example not cover I d like to put together an event bus example in the docs',RxJava,false,false,false
37707330,'Don t use postdelayed if already on right looper','There is no need to do postDelayed if we are on the right looper already and no delay needed Fix is required because for some UI scenarios postDelayed latency is not acceptable I don t know how to write test for this case Let me know if have an idea and I will add it @loganj @akarnokd @benjchristensen','RxJava pull requests #1389 https netflixoss ci cloudbees com job RxJava pull requests 1389 FAILURE Looks like there s a problem with this pull request This will preempt other tasks waiting in the queue and cause potential stack overflow with a recursive schedule Actually it was discussed previously #1102 It seems this approach was decided against here https github com Netflix RxJava pull 1102#issuecomment 43407329 @lexer Please review that discussion If you still feel this PR should be open there are several people who will need to be involved in the decision Closing out based on #1102 Please reopen or start another thread if you want to pursue this further',RxJava,true,false,false
37709671,'Correct warnings','','RxJava pull requests #1390 https netflixoss ci cloudbees com job RxJava pull requests 1390 SUCCESS This pull request looks good',RxJava,true,false,false
37718877,'Allow us to make custom Scheduler','If someone wants to extend Scheduler he needs to override asJavaScheduler but it s very tedious due to the private scala val declaration In RxJava it s pretty easy to make custom Scheduler In my opinion RxScala shouldn t prevent people doing so','RxJava pull requests #1391 https netflixoss ci cloudbees com job RxJava pull requests 1391 FAILURE Looks like there s a problem with this pull request Question answered and PR doesn t build so closing out',RxJava,true,false,false
37724719,'RxScala publish','cc @zsxwing When I run anything using share like this small repro scala object MainScala def main args Array String Unit val xs Observable items 1 2 share xs subscribe x println x readLine I get the following exception Exception in thread main java lang NoSuchMethodError rx Observable share Lrx Observable at rx lang scala Observable class share Observable scala 1589 at rx lang scala JavaConversions anon 2 share JavaConversions scala 53 at MainScala main MainScala scala 14 at MainScala main MainScala scala at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 57 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at java lang reflect Method invoke Method java 491 at com intellij rt execution application AppMain main AppMain java 134 Probably some Scala compiler bytecode voodoo','I encounter NoSuchMethodError sometimes Rebuild project can solve it for me Could you try it I assume rebuild the project that uses share No amount of rebuilding helps with that I tested rxjava scala 0 19 6 with both scala 2 10 4 and 2 11 1 and could not reproduce your problem Could you elaborate your environment IntelliJ Java 8 and Scala 2 11 0 Maybe the latter is the issue My environment is jdk 8u5 scala 2 11 0 rxjava scala 0 19 6 intellij ce 13 0 1 Your code works fine in my machine Can you run this class in the console If it works I guess it may be an IntelliJ issue',RxJava,false,false,false
37758757,'0 19 javadocs aren t published','http netflix github io RxJava javadoc 0 19 404',Posted,RxJava,false,false,false
37825922,'Micro optimization by nulling out list','A micro optimization done as per discussion in https github com Netflix RxJava issues 1292 It is questionable whether this will help but if it can help Android memory pressure then it s worth it as it is a trivial change','',RxJava,true,false,false
37828555,'OnErrorFlatMap FlatMap','Allow onError to be treated as a non terminal event when flowing through flatMap merge SerializedObserver so onErrorFlatMap can be used','@spodila Does this fix the issue you reported to me RxJava pull requests #1395 https netflixoss ci cloudbees com job RxJava pull requests 1395 SUCCESS This pull request looks good @benjchristensen That should work thanks @headinthebox I d like you to weigh in on this as I m concerned with this It started out innocently but I find this onErrorFlatMap operator veers outside the lines as its purpose is basically to break the Rx contract be swallowing errors Really what s trying to be done here is map onErrorResumeNext merge but flatMap is map merge so errors get merged through and then are trying to be handled in a way that doesn t shut down a stream The general use case for onErrorFlatMap is to swallow errors so pipelines can be used as an event bus and errors don t act as terminal events I d like to discuss this further before we ship 1 0 We may want a different solution than this one Merged along with mergeDelayError changes in https github com Netflix RxJava pull 1457',RxJava,true,false,false
37851558,'Merge Bug','Working on https github com Netflix RxJava issues 1420 In testing on prod this looks like it may solve it running longer term tests to confirm','',RxJava,true,false,false
37852553,'Infinite request with Long MAX_VALUE instead of 1','Migrating to this after discussions at https github com reactive streams reactive streams issues 62','',RxJava,true,false,false
37861415,'Backpressure specific operators','I ve been thinking about backpressure with respect of the zip operator My suggested decorating approach doesn t work as expected because the request n calls end up executing in the same thread as the caller effectively serializing out all sources I see two possibilities to fix this by adding a new operator or changing an existing one 1 Adding backpressureOn Scheduler which will schedule the Producer request long and thus allows the from and range operators to resume emitting values from there 2 Changing subscribeOn to schedule the Producer request long call on the same worker as was used for subscribing and thus the value emission will resume on the very same thread In addition there might be a need to batch out events for observers that don t support backpressure by themselves Therefore I suggest adding a batch long operator which counts how many onNext calls have been made and issues a request n periodically One issue with this approach is that how to handle the situation if the downstream actually calls request n which n is in conflict with the batch s value either ignore the downstream value or use a min logic Thoughts','I see option 2 is already implemented never mind Yes you are correct that this type of stuff is needed to handle the scheduling on different threads the subscribeOn approach has worked out quite well and composes elegantly You can also see take and skip getting involved in modifying the requests',RxJava,false,false,false
37900533,'Flow control for specific exception','Hi folks I raised an issue here because I m not sure what the proper way to do is What is the best practice way to deal with code paths of different exceptions For example if exception XYZ is returned I want to bail out and do something else but if a TimeoutException is returned I want to retry I was looking for an onError where I can pass in the specific exception type I m looking for but apparently that s not available I m sure error handling is a solved topic but there are some unknowns to me Also on a related note Let s say in my code there is a insert call which should fail if the document is already in there Would it make sense to throw an exception here or wrap it in some kind of status and pass it through onNext As you can see I m a little uncertain what the most natural flow would be','May be you can try this onError Exception e if e instanceof TimeOutException retry else if e instanceof xyz handle You can use onErrorResumeNext that receives the Throwable to resume with different code paths based on the exception type http netflix github io RxJava javadoc rx Observable html#onErrorResumeNext rx functions Func1 Also it s generally preferable and more idiomatic to return Observable error yourException than throwing If however you re trying to treat errors as events rather than errors then you can materialize your streams so everything becomes Notification T including error and onComplete thanks I ll try to go on with this',RxJava,false,false,false
37951243,'Zip with Backpressure Support','This supports both upstream and downstream backpressure','RxJava pull requests #1397 https netflixoss ci cloudbees com job RxJava pull requests 1397 ABORTED I get random hangs and test failures in OperatorGroupByTest testFirstGroupsCompleteAndParentSlowToThenEmitFinalGroupsAndThenComplete hangs OperatorPivotTest testPivotEvenAndOdd Exception OnSubscribeCacheTest testWithPublishSubjectAndRepeat java lang AssertionError at OnSubscribeCacheTest java 146 OnSubscribeCacheTest testWithBehaviorSubjectAndRepeat java lang AssertionError at OnSubscribeCacheTest java 146 RxRingBufferWithoutUnsafeTest testConcurrency java lang AssertionError at RxRingBufferWithoutUnsafeTest java 166 I get random hangs and test failures in I think we should probably remove the pivot operator https github com Netflix RxJava issues 1402 The others all need to be researched RxJava pull requests #1397 ABORTED Oddly this hung in the rxjava scalaz project rxjava contrib rxjava scalaz test From my command line it also hangs ant scalac Element Users benjchristensen development github RxJavaFork rxjava contrib rxjava scalaz build resources main does not exist rxjava contrib rxjava scalaz processTestResources UP TO DATE rxjava contrib rxjava scalaz testClasses Building rxjava contrib rxjava scalaz test 6 tests completed It fails here 08 12 07 758 DEBUG TestEventLogger rx lang scala scalaz ObservableZipSpec STARTED 08 12 07 779 DEBUG TestEventLogger 08 12 07 779 DEBUG TestEventLogger rx lang scala scalaz ObservableZipSpec Zip Operators should be able to appy to Observable STARTED Here is the code and I don t understand this syntax at all https github com Netflix RxJava blob master rxjava contrib rxjava scalaz src test scala rx lang scala scalaz ObservableZipSpec scala#L26 Scalaz turns you code into messy tokensoup I can t read it either RxJava pull requests #1406 https netflixoss ci cloudbees com job RxJava pull requests 1406 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1407 https netflixoss ci cloudbees com job RxJava pull requests 1407 SUCCESS This pull request looks good Non deterministic tests can be tracked here https github com Netflix RxJava issues 1455',RxJava,true,false,false
37952563,'zipAll Operator','I find the following zipAll is very useful java Returns an Observable that emits items that are the result of applying a specified function to pairs of values one each from the source Observable and another specified Observable @param T2 the type of items emitted by the @code other Observable @param R the type of items emitted by the resulting Observable @param other the other Observable @param thisElem the element to be used to fill up the result if this Observable is shorter than other Observable @param otherElem the element to be used to fill up the result if other Observable is shorter than this Observable @param zipFunction a function that combines the pairs of items from the two Observables to generate the items to be emitted by the resulting Observable @return an Observable that pairs up values from the source Observable and the @code other Observable and emits the results of @code zipFunction applied to these pairs public final T2 R Observable R zipAll Observable extends T2 other T thisElem T2 otherElem Func2 super T super T2 extends R zipFunction E g java public static void example1 Observable Integer o1 Observable from 1 1 Observable Integer o2 Observable from 2 2 2 2 Observable Integer o3 o1 zipAll o2 1 2 new Func2 Integer Integer Integer @Override public Integer call Integer i1 Integer i2 return i1 i2 System out println o3 toList toBlocking single 3 3 1 1 public static void example2 Observable Integer o1 Observable from 1 1 1 1 Observable Integer o2 Observable from 2 2 Observable Integer o3 o1 zipAll o2 1 2 new Func2 Integer Integer Integer @Override public Integer call Integer i1 Integer i2 return i1 i2 System out println o3 toList toBlocking single 3 3 1 1 Thoughts','I can see how that would be useful but it seems overly specific to include in the library since there are so many different arities that can come into play here Also if the arities are know ahead of time like would be needed for this I can use concatWith like this java Observable Integer o1 Observable from 1 1 concatWith Observable from 1 2 Observable Integer o2 Observable from 2 2 2 2 Observable zip o1 o2 a b a b forEach System out println or to support a larger unknown arity java Observable Integer o1 Observable from 1 1 concatWith Observable just 1 repeat 10 Observable Integer o2 Observable from 2 2 2 2 Observable zip o1 o2 a b a b forEach System out println If o2 is infinite it s really hard to implement it Neither zip o2 o1 concatWith Observable just 1 repeat nor zip o1 concatWith Observable just 1 repeat o2 can work because the first Observable of zip must not be infinite Although we can use Scheduler like zip o1 concatWith Observable just 1 repeat subscribeOn Schedulers compute o2 zipAll will be much more efficient than the Scheduler solution',RxJava,false,false,false
37975887,'RxScala Add Scala idiomatic methods','For #523 cc @headinthebox @samuelgruetter','RxJava pull requests #1398 https netflixoss ci cloudbees com job RxJava pull requests 1398 SUCCESS This pull request looks good',RxJava,true,false,false
37980578,'Add operators to create Observables from BroadcastReceiver','wraps BroadcastReceiver with Observable Can be used with gloabl broadcasts and with local using LocalBroadcastManager','RxJava pull requests #1399 https netflixoss ci cloudbees com job RxJava pull requests 1399 FAILURE Looks like there s a problem with this pull request cast @mttkay There are no tests for OperatorBroadcastRegister yet because Roboelectric seems to ignores calls context registerReceiver broadcastReceiver intentFilter broadcastPermission schedulerHandler and I don t know how to write correct tests for it This looks pretty good to me overall would love to test it out One suggestion I have have you thought about using Subject s instead I think they would model more closely what a broadcast is since they can fire without a subscriber I thought about it but it creates much more questions and become not so clear 1 It s more closer to Producer I know that there is no such entity than to Receiver 2 We can not determine before registering receiver which type of Intent will we receive sticky or not so we can not pick up right implementation of subject behavior or publish 3 And at least if user want to multicast observable he she can use operations like publish replay etc He can even subscribe to observable several times as it will create several independent Receivers RxJava pull requests #1400 https netflixoss ci cloudbees com job RxJava pull requests 1400 SUCCESS This pull request looks good The intent matching within robolectric was fixed not too long ago here https github com robolectric robolectric pull 1162 @dpsm I was having another problem As BroadcastOperator use call context registerReceiver broadcastReceiver intentFilter broadcastPermission schedulerHandler event for method fromLocalBroadcast Context context IntentFilter filter it seems like roboelectric ignore this call at all However if i use context registerReceiver broadcastReceiver intentFilter everything works well in roboelectric but I don t want to change semantics of code just to pass the tests Looks like there is still ongoing discussion here let me know when there is agreement on this being ready to merge @Yarikx I looked into the robolectric implementation of the Application shadow https github com xtremelabs robolectric blob master src main java com xtremelabs robolectric shadows ShadowApplication java and indeed it does not implement the call you use to register the receiver With that said the test you have in the pull request fails Would you be interested in contributing to robolectric with a fix for it so the test can pass Yes I would like Just let me day or two to setup environment and start digging it On Jul 22 2014 4 56 PM David Sobreira Marques notifications@github com wrote @Yarikx https github com Yarikx I looked into the robolectric implementation of the Application shadow https github com xtremelabs robolectric blob master src main java com xtremelabs robolectric shadows ShadowApplication java and indeed it does not implement the call you use to register the receiver With that said the test you have in the pull request fails Would you be interested in contributing to robolectric with a fix for it so the test can pass Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 1449#issuecomment 49741796 Actually I think it s already fixed in current version of robolectric 2 3 https github com robolectric robolectric blob afeb7321f3 src 2Fmain 2Fjava 2Forg 2Frobolectric 2Fshadows 2FShadowApplication java this project use 2 2 I tried to increase version of it but stuck with robolectric dependency to android support lib which gradle can not resolve And actually I don t know how to resolve it without android gradle plugin Can anyone help with this test @mttkay If I will add tests for OperatorBroadcast will it be candidate to be merged Sure By the way anyone having problems building under IntelliJ lately Something must have changed w r t Gradle dependency configs since anything in provided scope isn t recognized by IntelliJ as a compile time dependency anymore I saw #1394 but it looks harmless to me as it merely touches test dependencies Rebased it to https github com Netflix RxJava pull 1528 Rebased it to https github com Netflix RxJava pull 1528 RxJava pull requests #1399 https netflixoss ci cloudbees com job RxJava pull requests 1399 FAILURE Looks like there s a problem with this pull request cast @mttkay There are no tests for OperatorBroadcastRegister yet because Roboelectric seems to ignores calls context registerReceiver broadcastReceiver intentFilter broadcastPermission schedulerHandler and I don t know how to write correct tests for it This looks pretty good to me overall would love to test it out One suggestion I have have you thought about using Subject s instead I think they would model more closely what a broadcast is since they can fire without a subscriber I thought about it but it creates much more questions and become not so clear 1 It s more closer to Producer I know that there is no such entity than to Receiver 2 We can not determine before registering receiver which type of Intent will we receive sticky or not so we can not pick up right implementation of subject behavior or publish 3 And at least if user want to multicast observable he she can use operations like publish replay etc He can even subscribe to observable several times as it will create several independent Receivers RxJava pull requests #1400 https netflixoss ci cloudbees com job RxJava pull requests 1400 SUCCESS This pull request looks good The intent matching within robolectric was fixed not too long ago here https github com robolectric robolectric pull 1162 @dpsm I was having another problem As BroadcastOperator use call context registerReceiver broadcastReceiver intentFilter broadcastPermission schedulerHandler event for method fromLocalBroadcast Context context IntentFilter filter it seems like roboelectric ignore this call at all However if i use context registerReceiver broadcastReceiver intentFilter everything works well in roboelectric but I don t want to change semantics of code just to pass the tests Looks like there is still ongoing discussion here let me know when there is agreement on this being ready to merge @Yarikx I looked into the robolectric implementation of the Application shadow https github com xtremelabs robolectric blob master src main java com xtremelabs robolectric shadows ShadowApplication java and indeed it does not implement the call you use to register the receiver With that said the test you have in the pull request fails Would you be interested in contributing to robolectric with a fix for it so the test can pass Yes I would like Just let me day or two to setup environment and start digging it On Jul 22 2014 4 56 PM David Sobreira Marques notifications@github com wrote @Yarikx https github com Yarikx I looked into the robolectric implementation of the Application shadow https github com xtremelabs robolectric blob master src main java com xtremelabs robolectric shadows ShadowApplication java and indeed it does not implement the call you use to register the receiver With that said the test you have in the pull request fails Would you be interested in contributing to robolectric with a fix for it so the test can pass Reply to this email directly or view it on GitHub https github com Netflix RxJava pull 1449#issuecomment 49741796 Actually I think it s already fixed in current version of robolectric 2 3 https github com robolectric robolectric blob afeb7321f3 src 2Fmain 2Fjava 2Forg 2Frobolectric 2Fshadows 2FShadowApplication java this project use 2 2 I tried to increase version of it but stuck with robolectric dependency to android support lib which gradle can not resolve And actually I don t know how to resolve it without android gradle plugin Can anyone help with this test @mttkay If I will add tests for OperatorBroadcast will it be candidate to be merged Sure By the way anyone having problems building under IntelliJ lately Something must have changed w r t Gradle dependency configs since anything in provided scope isn t recognized by IntelliJ as a compile time dependency anymore I saw #1394 but it looks harmless to me as it merely touches test dependencies Rebased it to https github com Netflix RxJava pull 1528',RxJava,true,false,false
37996326,'BlockingOperatorToIterator hanging when exception is thrown from OnSubscribe call','See code snippet bellow Basically in BlockingOperatorToIterator toIterator method lifted subscriber ignores exception in onError method what makes iterator s hasNext method to wait forever for a notification that never arrives java Iterable String strings Observable create new Observable OnSubscribe String @Override public void call Subscriber super String subscriber throw new RuntimeException intentional toBlocking toIterable for String string strings never reaches here','Thanks for this report Fix coming',RxJava,false,false,false
38017936,'Using Observable toList after takeWhile fails in some cases','With the latest 0 20 0 RC1 a combination of takeWhile and toList on an Observable fails sometimes Here s a unit test that fails java @Test public void testTakeWhile int nums 1 2 3 final AtomicInteger count new AtomicInteger for final int n nums Observable from Boolean TRUE Boolean FALSE takeWhile new Func1 Boolean Boolean @Override public Boolean call Boolean value return value toList doOnNext new Action1 List Boolean @Override public void call List Boolean booleans count incrementAndGet subscribe assertEquals nums length count get Here s the same unit test that passes with slight modification java @Test public void testTakeWhile int nums 1 2 3 final AtomicInteger count new AtomicInteger for final int n nums Observable from Boolean TRUE Boolean FALSE Boolean FALSE takeWhile new Func1 Boolean Boolean @Override public Boolean call Boolean value return value toList doOnNext new Action1 List Boolean @Override public void call List Boolean booleans count incrementAndGet subscribe assertEquals nums length count get','This should be fixed in 0 20 0 RC3',RxJava,false,false,false
38018077,'Removing onStart and onSetProducer from rx Subscriber','because they are unnecessary and it can t be undone once it is released The rx Subscriber is part of the public API and these methods aren t really needed for the Rx to work','RxJava pull requests #1401 https netflixoss ci cloudbees com job RxJava pull requests 1401 SUCCESS This pull request looks good We have reviewed this in person and will modify this somewhat keep onStart make Subscriber request protected remove onSetProducer Thanks @abersnaze for this',RxJava,true,false,false
38037968,'New test case for takeWhile that currently fails','Created a test case to verify the failing case of takeWhile followed by toList as mentioned in a href https github com Netflix RxJava issues 1451 Issue 1451 a','RxJava pull requests #1402 https netflixoss ci cloudbees com job RxJava pull requests 1402 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
38042199,'Fix issue #1451','Add done to make sure calling doOnEachObserver obey the Rx contract','RxJava pull requests #1403 https netflixoss ci cloudbees com job RxJava pull requests 1403 SUCCESS This pull request looks good RxJava pull requests #1404 https netflixoss ci cloudbees com job RxJava pull requests 1404 SUCCESS This pull request looks good RxJava pull requests #1405 https netflixoss ci cloudbees com job RxJava pull requests 1405 SUCCESS This pull request looks good I don t think we should need to be checking isUnsubscribed before onComplete There is no guarantee an Observable won t emit after unsubscribe and if an operator like doOnEach cares it should itself check but not require all other sources to be strict',RxJava,true,false,false
38118289,'Non deterministic Test backpressure related','Some tests we need to research OperatorGroupByTest testFirstGroupsCompleteAndParentSlowToThenEmitFinalGroupsAndThenComplete hangs OnSubscribeCacheTest testWithPublishSubjectAndRepeat java lang AssertionError at OnSubscribeCacheTest java 146 OnSubscribeCacheTest testWithBehaviorSubjectAndRepeat java lang AssertionError at OnSubscribeCacheTest java 146 RxRingBufferWithoutUnsafeTest testConcurrency java lang AssertionError at RxRingBufferWithoutUnsafeTest java 166','RxRingBufferWithoutUnsafeTest testConcurrency Fixed in https github com Netflix RxJava commit 45bda44bba1a52e2c334fc995b9f75d8a54e92c9 testFirstGroupsCompleteAndParentSlowToThenEmitFinalGroupsAndThenComplete I can t replicate this one OnSubscribeCacheTest I believe these got fixed in recent changes as I can not reproduce them',RxJava,false,false,false
38121880,'Removing onSetProducer from the API','','RxJava pull requests #1408 https netflixoss ci cloudbees com job RxJava pull requests 1408 FAILURE Looks like there s a problem with this pull request This simplification looks good I d be interested to see the discussion behind this I take it occurred offline but can you give a summary or copy it through It started because I lobbed this #1452 at @benjchristensen yesterday I m not 100 sold on keeping onStart because anything in there could be done on the Subscriber before it is returned by the Operator call Ben convinced me that it is more in line with reactive stream onSubscribe Subscription He did like the removal onSetProducer While we were at it we made request long n protected The onSetProducer method always felt ugly and wrong but was added to solve a problem and I left it there but never liked it The onStart was added to be more explicit rather than requiring either 1 an overloaded constructor which is what I first did or 2 requiring users to define the Subscriber and then call request on it which prevent inline declarations @abersnaze pushed me to clean these up and we spent time discussing them and came to the following conclusions The onSetProducer can be removed but at the risk of a very nuanced behavior the problem I mentioned above if someone then calls Subscriber request since it will no longer do anything if setProducer is over written To prevent this non obvious behavior Subscriber request was made protected so it can only be called by the class implementing the setProducer so they can make the right decision and because request doesn t really make sense any longer on a Subscriber that is decoupling the setProducer chain We kept onStart because making request protected effectively forces us to have a hook inside the class for invoking request it can no longer be done externally even if we wanted to go that route and we still don t like the constructor If I wasn t trying to make these changes additive and was willing to do massive breaking changes I would likely do some things differently but the constraint we have is to not fundamentally break RxJava 0 x while getting to 1 0',RxJava,true,false,false
38125751,'MergeDelayError OnErrorFlatMap w Merge','','RxJava pull requests #1409 https netflixoss ci cloudbees com job RxJava pull requests 1409 FAILURE Looks like there s a problem with this pull request',RxJava,true,false,false
38126805,'Remove Pivot Operator','as per https github com Netflix RxJava issues 1402','RxJava pull requests #1410 https netflixoss ci cloudbees com job RxJava pull requests 1410 FAILURE Looks like there s a problem with this pull request Too Many Modules But pivot must die Its death is imminent RxJava pull requests #1411 https netflixoss ci cloudbees com job RxJava pull requests 1411 SUCCESS This pull request looks good',RxJava,true,false,false
38128908,'Remove Subscriber onSetProducer','This is a manual merge of https github com Netflix RxJava pull 1456 Removes the awkward Subscriber onSetProducer API and makes Subscriber request protected so it can t easily be misused','',RxJava,true,false,false
38134014,'Change Java future observable implementation from blocking to non blocking','','RxJava pull requests #1412 https netflixoss ci cloudbees com job RxJava pull requests 1412 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1413 https netflixoss ci cloudbees com job RxJava pull requests 1413 SUCCESS This pull request looks good Generally we don t do polling but rather use Schedulers io for blocking threads I m not certain if we want to change into this direction This is being pursued due to the high cost of having a 1 1 relationship of thread to Future RxJava pull requests #1424 https netflixoss ci cloudbees com job RxJava pull requests 1424 SUCCESS This pull request looks good RxJava pull requests #1412 https netflixoss ci cloudbees com job RxJava pull requests 1412 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1413 https netflixoss ci cloudbees com job RxJava pull requests 1413 SUCCESS This pull request looks good Generally we don t do polling but rather use Schedulers io for blocking threads I m not certain if we want to change into this direction This is being pursued due to the high cost of having a 1 1 relationship of thread to Future RxJava pull requests #1424 https netflixoss ci cloudbees com job RxJava pull requests 1424 SUCCESS This pull request looks good',RxJava,true,false,false
38136442,'int to long performance hit','PR https github com Netflix RxJava pull 1443 changing request int n to request long n appears to have caused a non trivial performance hit in the JMH tests Before Benchmark size Mode Samples Score Score error Units r o OperatorMergePerf merge1SyncStreamOfN 1 thrpt 5 5246591 736 240800 312 ops s r o OperatorMergePerf merge1SyncStreamOfN 1000 thrpt 5 57309 810 3333 567 ops s r o OperatorMergePerf merge1SyncStreamOfN 1000000 thrpt 5 60 163 1 654 ops s After Benchmark size Mode Samples Score Score error Units r o OperatorMergePerf merge1SyncStreamOfN 1 thrpt 5 4940791 384 317585 017 ops s r o OperatorMergePerf merge1SyncStreamOfN 1000 thrpt 5 27655 680 2216 176 ops s r o OperatorMergePerf merge1SyncStreamOfN 1000000 thrpt 5 30 091 1 015 ops s','Found it it was changing from 1 to Long MAX_VALUE and one of the fast path conditionals was missed it was checking for 0 rather than 1 so was missed',RxJava,false,false,false
38139654,'Merge Perf Fix Re enable fast path','Fixes https github com Netflix RxJava issues 1461','',RxJava,true,false,false
38193376,'Merge Bug Missing Emissions','Notes and temporary fix using synchronized to achieve correctness until a proper solution can be found This code does not exhibit the issue when I do production testing Without the two synchronized methods I get errors in prod that I ve temporarily added to BlockingOperatorToIterator until this is fixed so it s visible apps tomcat logs tail f catalina out grep Timed out waiting for value Timed out waiting for value File a bug at github com Netflix RxJava Timed out waiting for value File a bug at github com Netflix RxJava Timed out waiting for value File a bug at github com Netflix RxJava Timed out waiting for value File a bug at github com Netflix RxJava Timed out waiting for value File a bug at github com Netflix RxJava Timed out waiting for value File a bug at github com Netflix RxJava Timed out waiting for value File a bug at github com Netflix RxJava Timed out waiting for value File a bug at github com Netflix RxJava Timed out waiting for value File a bug at github com Netflix RxJava Timed out waiting for value File a bug at github com Netflix RxJava Timed out waiting for value File a bug at github com Netflix RxJava Timed out waiting for value File a bug at github com Netflix RxJava Timed out waiting for value File a bug at github com Netflix RxJava Timed out waiting for value File a bug at github com Netflix RxJava Timed out waiting for value File a bug at github com Netflix RxJava Timed out waiting for value File a bug at github com Netflix RxJava Timed out waiting for value File a bug at github com Netflix RxJava','RxJava pull requests #1414 https netflixoss ci cloudbees com job RxJava pull requests 1414 SUCCESS This pull request looks good',RxJava,true,false,false
38201325,'Is there operator to cache latest value of observable','java Obsevable Long observable1 Is there any operator that will allow to cache latest value of observable1 and fire it immediately when somebody subscribe on its value It could be done with BehaviorSubject java BehaviorSubject T cachedObservable1 BehaviorSubject create observable subscribe cachedObservable1 But since cachedObservable1 is not a transformation of observable1 unsubscribe from cachedObservable1 won t unsubscribe from observable1','Probable solution is observable1 multicast BehaviorSubject Long create refCount Yes that sounds like it should work',RxJava,false,false,false
38319142,'onErrorFlatMap and Event Bus Use Cases','The onErrorFlatMap operator was added a few releases ago to allow swallowing errors and letting a stream continue It works in certain scenarios such as this java observable map t function that fails onErrorFlatMap e swallow error subscribe In this case the error is coming from the user provided map function so the source observable is not breaking it s contract by continuing Not all scenarios are this clear however java observable flatMap t user function error gets emitted onErrorFlatMap e swallow error subscribe If flatMap emits an error was it the function that failed or a source Observable that it is merging Should the merge function unsubscribe the source Observable that failed to clean up resources or should it not Issues have arisen from these nuances and recent fixes attempted in https github com Netflix RxJava issues 1434 https github com Netflix RxJava pull 1441 and https github com Netflix RxJava pull 1457 More to the point though is that onErrorFlatMap is working against or outright breaking the Rx contract by not treating an onError as a terminal state This means any operator that cleans up after receiving an onError will stop onErrorFlatMap from working It is completely okay for operators to move into a terminal state after receiving an onError since that is what onError signals yet onErrorFlatMap is trying to override this It results in non deterministic behavior depending on the implementations of each operator in the sequence For this reason I suggest we remove onErrorFlatMap It is confusing and breaks the Rx contract This leads us to what the replacement of onErrorFlatMap should be It was added to handle use cases where a user wants to ignore errors so the source Observable can continue in other words there are use cases where users wants an Observable to not follow the Rx contract These are primarily event bus cases where all the message passing semantics of Rx are wanted but not the lifecycle it should never terminate I suggest we need to treat this use case differently so we are not trying to break the Rx contract with operators like onErrorFlatMap The current Rx way of doing this is to materialize all events into Notification T so onError and onCompleted become notifications The drawback to this is each event now has an extra object allocation In most cases that object allocation is doing to fine as few applications are attempting millions of events per second the rate where this extra object allocation starts to matter Even with materialize though a map function that throws an Exception can result in the upstream being unsubscribed depending on the operators it is composed within I d like to discuss what the solution should be for this that is idiomatic contractually correct and deterministic I also propose we deprecate onErrorFlatMap in 0 20 and remove it in 1 0','cc @headinthebox I d like to get you involved in this one please I m happy to junk it The one I am using is public final R rx Observable R mergeMap Func1 T Observable R onNext Func1 Throwable Observable R onError Func0 Observable R onCompleted which has been in NET for a long time http msdn microsoft com en us library hh244247 v vs 103 aspx but I guess you think that one is problematic as well We may also look at the flatMap vs mergeMap aliasing I would prefer to eliminate mergeMap it just describes the implementation in Rx of flatMap but that does not need to surface flatMap vs mergeMap That aliasing was added on your request Opened issue here https github com Netflix RxJava issues 1500 I guess you think that one is problematic as well It still doesn t solve the general problem where an error in any user provided function fails and causes the source Observable to be terminated and shuts down the event bus Did I really ask for mergeMap Must have had a blue screen moment I am happy to have a few operators where you can shoot yourself in the foot but are awesome when you know what you are doing This one is in that category We should ask @DavidMGross to document that this is for expert use only Can you help me get more insight into what people need to be warned against Is the problem scenario simply that if the function passed to flat mergeMap fails flat mergeMap will send an onError notification and that it may be ambiguous to those downstream whether that error was emitted by one of the merged Observables or whether it was caused by the failure to correctly generate one of those Observables in the first place Or is there more to it than that On Thu Jul 24 2014 at 2 01 AM headinthebox notifications@github com wrote Did I really ask for mergeMap Must have had a blue screen moment I am happy to have a few operators where you can shoot yourself in the foot but are awesome when you know what you are doing This one is in that category We should ask @DavidMGross https github com DavidMGross to document that this is for expert use only Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1465#issuecomment 49983703 David M Gross PLP Consulting',RxJava,false,false,false
38362123,'Observable using method can be improved','This is the signature of Observable using currently java static T Resource extends Subscription Observable T using Func0 Resource resourceFactory Func1 Resource extends Observable extends T observableFactory What use case is there for the observableFactory to have access to the Subscription methods of Resource which are there for resource disposal If the source observable needs access to the resource disposal method then why would the using method be used at all I noticed that this method exists with this signature in the Rx Net API so @headinthebox may be able to enlighten me I d prefer the existence of a less coupled method either as an addition or a replacement like java static S T Observable T using final Func0 S resourceFactory final Func1 super S extends Observable T observableFactory final Action1 super S dispose The existing method is also non intuitive to use I think and ideally involves the trick of using Subscriptions create Action0 as demonstrated to me once by @zsxwing Here s an example with a resource that is an InputStream from a file that we want using to close once we are finished Using the current api java package com github davidmoten rx import java io File import java io FileInputStream import java io FileNotFoundException import java io IOException import java io InputStream import org junit Test import rx Observable import rx Subscription import rx functions Func0 import rx functions Func1 import rx subscriptions Subscriptions public class UsingTest @Test public void testUsingCurrentStyle throws IOException final File file new File target temp file createNewFile do stuff with file inputstream then close inputstream Func0 Resource resourceFactory return new Resource file dummy observable that doesn t actually use the input stream Func1 Resource Observable String observableFactory resource Observable just boo Observable String ob Observable using resourceFactory observableFactory private static class Resource implements Subscription private final InputStream is private final Subscription sub Resource File file try this is new FileInputStream file catch FileNotFoundException e throw new RuntimeException e this sub Subscriptions create try is close catch IOException e throw new RuntimeException e InputStream getInputStream return is @Override public void unsubscribe sub unsubscribe @Override public boolean isUnsubscribed return sub isUnsubscribed With the proposed change addition java package com github davidmoten rx import java io File import java io FileInputStream import java io FileNotFoundException import java io IOException import java io InputStream import org junit Test import rx Observable import rx functions Action1 import rx functions Func0 import rx functions Func1 public class UsingNewTest @Test public void testUsingNewStyle throws IOException File file new File target temp file createNewFile do stuff with file inputstream then close inputstream Func0 InputStream resourceFactory try return new FileInputStream target catch FileNotFoundException e throw new RuntimeException e Func1 InputStream Observable String observableFactory is Observable just boo Action1 InputStream dispose is try is close catch IOException e throw new RuntimeException e this method does not exist yet Observable String ob Observable using resourceFactory observableFactory dispose What do people think of such an addition replacement @benjchristensen @abersnaze @akarnokd','',RxJava,false,false,false
38370096,'Javadocs for cache operator','','RxJava pull requests #1415 https netflixoss ci cloudbees com job RxJava pull requests 1415 SUCCESS This pull request looks good',RxJava,true,false,false
38387679,'RxScala Update CompletenessTest scala','Cleaned up CompletenessTest scala onBackpressureBuffer and onBackpressureDrop are missing in RxScala now Wait until they are finalized in RxJava cc @headinthebox @samuelgruetter','RxJava pull requests #1416 https netflixoss ci cloudbees com job RxJava pull requests 1416 SUCCESS This pull request looks good Thanks @zsxwing Would there be a way to make this code less stringlytyped and use reflection or something instead of manually maintaining a list of signatures Is this ready to merge or is there more to do based on the last comment by @headinthebox I think you can merge we can discuss alternatives in an issue Would there be a way to make this code less stringlytyped and use reflection or something instead of manually maintaining a list of signatures We already use reflection to generate the defaultMethodCorrespondence which contains all obvious Java Scala mappings which can be obtained through mechanical changes such as replacing Func1 T U by T U or Long TimeUnit by Duration The mappings in correspondenceChanges only contain deviations from the obvious default correspondence and override the auto generated default correspondence I see no other solution than maintaining the correspondenceChanges list manually We also use reflection to check that the methods mentioned in correspondenceChanges actually exist checkJavaMethodPresence and checkScalaMethodPresence report all mentioned methods which do not exist So it s still stringlytyped but we have a typechecker for it I agree that this code still looks too stringlytyped and that one would also want to use reflection to write down the correspondenceChanges list I ve tried this but I abandoned it because it became very verbose and unreadable LGTM',RxJava,true,false,false
38431193,'ToList operator needs to ignore backpressure','','RxJava pull requests #1417 https netflixoss ci cloudbees com job RxJava pull requests 1417 SUCCESS This pull request looks good reviewed',RxJava,true,false,false
38432045,'Added overload for retry to accept a Func1 Obs Obs','Rebase and clean up of #1326 while Aaron is at LambdaJam','RxJava pull requests #1418 https netflixoss ci cloudbees com job RxJava pull requests 1418 SUCCESS This pull request looks good @DavidMGross thanks for the pointing out those copy paste errors I ve pushed an update RxJava pull requests #1423 https netflixoss ci cloudbees com job RxJava pull requests 1423 SUCCESS This pull request looks good Merged in https github com Netflix RxJava pull 1493',RxJava,true,false,false
38440734,'OperatorAny needs to ignore backpressure','','RxJava pull requests #1419 https netflixoss ci cloudbees com job RxJava pull requests 1419 SUCCESS This pull request looks good Found a better solution analogous to OperatorAll in PR https github com Netflix RxJava pull 1473',RxJava,true,false,false
38441923,'Add test of backpressure to OperatorAll','','RxJava pull requests #1420 https netflixoss ci cloudbees com job RxJava pull requests 1420 SUCCESS This pull request looks good',RxJava,true,false,false
38442663,'OperatorAny needs to handle backpressure','','RxJava pull requests #1421 https netflixoss ci cloudbees com job RxJava pull requests 1421 SUCCESS This pull request looks good',RxJava,true,false,false
38448645,'Ignore backpressure for OperatorToObservableSortedList','','RxJava pull requests #1422 https netflixoss ci cloudbees com job RxJava pull requests 1422 SUCCESS This pull request looks good',RxJava,true,false,false
38451076,'Backpressure amb','The amb operator needs to be updated with backpressure support','',RxJava,false,false,false
38451136,'Backpressure CombineLatest','The combineLatest operator needs to be updated with backpressure support','',RxJava,false,false,false
38451489,'Backpressure Iterable Range','request n must handle a scenario where request Long MAX_VALUE is received the fast path starts and then it receives request 1 or something else They should be ignored right now they are not and could result in bad behavior','Fixed in https github com Netflix RxJava blob cc8bf6d21acead9176b8e4e603a5dd97f5921add rxjava core src main java rx internal operators OnSubscribeRange java',RxJava,false,false,false
38451617,'Backpressure Join GroupJoin','The join and groupJoin operators need a backpressure story','',RxJava,false,false,false
38453104,'Backpressure BufferWithSize','The buffer int count operator should be updated to support backpressure','',RxJava,false,false,false
38453300,'Backpressure concat','The concat operator should be updated to support backpressure on each Observable it subscribes to Right now the inner Subscriber does not obey downstream backpressure requests It should pass through the child request','I have fixed the outer backpressure but the inner still needs to be done',RxJava,false,false,false
38471866,'OperatorConcat Take BlockingOperatorToIterator failure','The following test fails with 0 20 0 RC2 throwing a RuntimeException timed out waiting for a value I ve done some simple isolation tests and it seems to be the full combination of operators below that is not working Have not debugged it to determine cause as don t have time at the moment but I m sure the answer will jump out to someone java @Test public void testTakeShouldNotHang assertEquals 1 int Observable Integer empty concatWith Observable just 1 take 1 toBlocking single stacktrace java lang RuntimeException Timed out waiting for value File a bug at github com Netflix RxJava at rx internal operators BlockingOperatorToIterator 2 take BlockingOperatorToIterator java 96 at rx internal operators BlockingOperatorToIterator 2 hasNext BlockingOperatorToIterator java 73 at rx internal operators BlockingOperatorToIterator 2 next BlockingOperatorToIterator java 83 at rx observables BlockingObservable single BlockingObservable java 348 at com github davidmoten rx jdbc DatabaseTestBase testTakeShouldNotHang DatabaseTestBase java 807','Also occurs in master at time of this comment This is actually an issue with concat Looking at it now',RxJava,false,false,false
38491694,'Backpressure switchOnNext','The switchOnNext operator needs to handle backpressure on the inner subscribe The outer should request infinite while the inner passes through the requests from the child','',RxJava,false,false,false
38492374,'Backpressure cache','The cache operator should support downstream backpressure It should request Long MAX_VALUE up but be capable of correctly responding to downstream similar to from Iterable This will mean we either have to stop using ReplaySubject or be able to handle it with ReplaySubject in the mix The idea here is that once data is cached it should behave as an Iterable Therefore the cache really should behave like onBackpressureBuffer','',RxJava,false,false,false
38493324,'Backpressure mergeMapIterable','Need to add support for backpressure','',RxJava,false,false,false
38493808,'Backpressure parallel','The parallel operator needs to be updated to properly support backpressure','',RxJava,false,false,false
38494475,'Backpressure repeat retry','Need to confirm that repeat retry work correctly with request long n as they recursively subscribe to the source It needs to make sure it correctly maintains the right request count of the subscriber through the repetitions','',RxJava,false,false,false
38494761,'Backpressure replay','The replay operators and ReplaySubject should respect backpressure for the downstream while replaying back Depending on the variant of replay such as unbounded buffering it could support it even in multicast mode For the variants that don t do unbounded buffering then once it finishes replying the cached values then it can no longer support backpressure due to multicasting but it s still good to support it during replay as that can be a very rapid firehose whereas it could be quite slow once caught up','',RxJava,false,false,false
38495531,'Backpressure takeLastTimed','The emission of values after the time has passed can be made to support backpressure','',RxJava,false,false,false
38499088,'Backpressure Fixes and Docs','Docs for operators that don t support backpressure particularly all the temporal operators Fixes for several that needed to request 1 or request Long MAX_VALUE','',RxJava,true,false,false
38500332,'non deterministic timeouts on slow machines','','',RxJava,true,false,false
38501836,'Concat Outer Backpressure','Fixed https github com Netflix RxJava issues 1481','',RxJava,true,false,false
38503168,'retry tests timing out on CloudBees','Some recent change has caused these tests to start hanging and timing out on CloudBees but I can t yet replicate it locally rx internal operators OperatorRetryTest testTimeoutWithRetry FAILED java lang Exception rx internal operators OperatorRetryWithPredicateTest testTimeoutWithRetry FAILED java lang Exception','I think that these are now fixed with the new OnSubscribeRedo implementation',RxJava,false,false,false
38551608,'Manual merge of retryWhen repeatWhen','Manual merge and rebase of https github com Netflix RxJava pull 1470','RxJava pull requests #1425 https netflixoss ci cloudbees com job RxJava pull requests 1425 SUCCESS This pull request looks good',RxJava,true,false,false
38553126,zipWith,'Match the naming convention of mergeWith concatWith ambWith etc','RxJava pull requests #1426 https netflixoss ci cloudbees com job RxJava pull requests 1426 SUCCESS This pull request looks good',RxJava,true,false,false
38562547,'Upgrade to Quasar 0 6 0','','RxJava pull requests #1427 https netflixoss ci cloudbees com job RxJava pull requests 1427 SUCCESS This pull request looks good',RxJava,true,false,false
38574137,'Change RxRingBuffer Queue Usage','There are non determinisitic failures in the offer behavior of the JCTools code that I don t understand yet so reverting to SynchronizedQueue which does not show the problem The performance hit is not huge it s even better in some cases This should result in more object allocation though so that needs to be tested I ll do so along with Netflix production testing','RxJava pull requests #1428 https netflixoss ci cloudbees com job RxJava pull requests 1428 SUCCESS This pull request looks good',RxJava,true,false,false
38580979,'spsc ring buffer concurrency test','','RxJava pull requests #1429 https netflixoss ci cloudbees com job RxJava pull requests 1429 ABORTED RxJava pull requests #1430 https netflixoss ci cloudbees com job RxJava pull requests 1430 SUCCESS This pull request looks good',RxJava,true,false,false
38581863,'non deterministic testUserSubscriberUsingRequestAsync','fix non deterministic failures of BackpressureTests testUserSubscriberUsingRequestAsync I was able to replicate the occasional failure by putting it in a tight loop With these changes it no longer fails','',RxJava,true,false,false
38583180,'retrytest iterativeBackoff','Unable to replicate failure of this test but adding assertNoErrors so we can see an exception if it happens again','',RxJava,true,false,false
38597431,'Remove mergeMap Alias','',1,RxJava,false,false,false
38600385,'blocking synchronous next','Fixes https github com Netflix RxJava issues 624','RxJava pull requests #1431 https netflixoss ci cloudbees com job RxJava pull requests 1431 SUCCESS This pull request looks good',RxJava,true,false,false
38601774,'Javadocs Disable or Make Work','The generation of Javadocs from the Gradle config is mostly broken and unusable formatting is default bad it doesn t exclude internal packages it breaks on different versions of the JVM Right now I generate the hosted docs http netflix github io RxJava javadoc rx Observable html using a bash script on my local machine I want this automated but correctly to at least match what is hosted at http netflix github io RxJava javadoc and so it works regardless of Java 7 or 8 being used','1 I ll buy a beer for the person who fixes this',RxJava,false,false,false
38602165,'Reimplement OperatorMergeMapTransform','OperatorMergeMapTransform needs to be reimplemented as it does not support backpressure via the heavily changed merge operator This needs to use merge directly rather than reinventing merge behavior The Observable mergeMap flatMap overloads should just use merge map f directly','This is related to https github com Netflix RxJava issues 1154 Understand that merge is hell but my gut feel is that having a super operator xs flatMapXXX next error done post might be more performant Maybe a good entry exam for new contributors',RxJava,false,false,false
38603151,'Eliminate duplication of List in toList','Fixes https github com Netflix RxJava issues 1218','RxJava pull requests #1432 https netflixoss ci cloudbees com job RxJava pull requests 1432 ABORTED The hung build is concerning but I can t figure out how to replicate it The logs success it was in ExceptionTests which doesn t make sense https netflixoss ci cloudbees com job RxJava pull requests 1432 console',RxJava,true,false,false
38605423,'ParallelTest testBackpressureViaSynchronousTake','I m seeing non deterministic timeouts on this test','',RxJava,false,false,false
38625009,'Unable to substitute a default scheduler with a wrapped Executor','Hello I m trying to substitute the default IO scheduler following these guidelines https github com Netflix RxJava wiki Plugins#rxjavadefaultschedulers The substitute is a cached thread pool wrapped using Schedulers from Executor executor However the attempt to set the default scheduler fails because it is already set when the call to Schedulers from causes the single Schedulers instance to be initialized This is the related part of the stack trace java lang IllegalStateException Another strategy was already registered rx plugins RxJavaDefaultSchedulersDefault@ebb013f at rx plugins RxJavaPlugins registerDefaultSchedulers RxJavaPlugins java 207 Do you have any ideas on how to approach this PS The reason to do this is a separate problem I need to limit the number of threads spawned by the IO scheduler I saw this mentioned in several closed issues but it doesn t seem to be on the track for implementation','',RxJava,false,false,false
38633220,'BufferWithSize with Backpressure Support','For #1479','RxJava pull requests #1433 https netflixoss ci cloudbees com job RxJava pull requests 1433 SUCCESS This pull request looks good RxJava pull requests #1463 https netflixoss ci cloudbees com job RxJava pull requests 1463 SUCCESS This pull request looks good RxJava pull requests #1433 https netflixoss ci cloudbees com job RxJava pull requests 1433 SUCCESS This pull request looks good RxJava pull requests #1463 https netflixoss ci cloudbees com job RxJava pull requests 1463 SUCCESS This pull request looks good',RxJava,true,false,false
38653180,'Missing javadoc comments in exceptions Exceptions java','The Exceptions class itself needs a javadoc description as does its propagate method that method s t parameter and its return value I ve flagged areas that need help in the javadocs with @warn tags That tag is not part of the javadoc standard so it triggers a javadoc compilation warning Please remove those tags from any areas that you fix','',RxJava,false,true,true
38653403,'Missing javadoc comments in Notification java','The type parameter to Notification createOnCompleted is not documented in the javadocs and needs some sort of explanation particularly as it doesn t seem to have any purpose I ve flagged areas that need help in the javadocs with @warn tags That tag is not part of the javadoc standard so it triggers a javadoc compilation warning Please remove those tags from any areas that you fix','',RxJava,false,true,true
38653834,'Javadoc for Observable multicast subjectFactory selector needs improvement','The description of Observable multicast subjectFactory selector in the javadocs is difficult to parse for someone who is not already familiar with its operation The subjectFactory parameter is poorly described the Subject factory clearly not being a useful description The selector parameter is described in a way that seems overly obscure I d take care of this myself but I m not sure I really understand what s going on here or what gap this multicast variant is meant to fill I ve flagged areas that need help in the javadocs with @warn tags That tag is not part of the javadoc standard so it triggers a javadoc compilation warning Please remove those tags from any areas that you fix','',RxJava,false,true,true
38653980,'Missing javadoc comments for Producer java','The Producer class needs a class description in the javadocs I ve flagged areas that need help in the javadocs with @warn tags That tag is not part of the javadoc standard so it triggers a javadoc compilation warning Please remove those tags from any areas that you fix','',RxJava,false,true,true
38654172,'Missing javadoc comments for Subscriber setProducer','The Subscriber setProducer method needs a javadoc description and its producer parameter needs a description as well I ve flagged areas that need help in the javadocs with @warn tags That tag is not part of the javadoc standard so it triggers a javadoc compilation warning Please remove those tags from any areas that you fix','',RxJava,false,true,true
38669104,'Revert to copying list in toList','It is a breaking change to existing code to make it immutable so reverting back to copying','RxJava pull requests #1434 https netflixoss ci cloudbees com job RxJava pull requests 1434 SUCCESS This pull request looks good',RxJava,true,false,false
38683646,'Provide a facility for decorating a Runnable before submission to ExecutorService via Scheduler','For Issue #1279 This provides another method of hooking into the Scheduler process Rather than forcing the plugin writer to write all 3 Schedulers computation io newThread from scratch it allows the plugin writer to have access to the Runnable before it gets submitted to the ExecutorService In my implementation which needs to decorate Runnables this reduced the effort from a copy n paste of the entire Scheduler codebase to a 1 liner Happy to debate names or any other aspect of this proposal','RxJava pull requests #1435 https netflixoss ci cloudbees com job RxJava pull requests 1435 SUCCESS This pull request looks good',RxJava,true,false,false
38686772,'Support Subject Factory with Multicast','This is a proposed change to allow using a Subject factory with multicast and for methods such as publish and replay to use the factory so that each time ConnectableObservable connect is invoked a new Subject is created and used Otherwise an Observable sequence can not be reused #### Use Case java final AtomicInteger count new AtomicInteger Observable Integer subject1 Observable just 10 Observable Integer subject2 Observable just 20 Observable Integer combined Observable combineLatest subject1 subject2 fst snd int i count incrementAndGet System out println fst i snd i return fst snd publish refCount combined subscribe System out println t t printStackTrace System out println Completed combined subscribe System out println t t printStackTrace System out println Completed Output without these changes 11 21 30 Completed Completed Output with changes 11 21 30 Completed 12 22 30 Completed #### Test Case java @Test public void testConnectDisconnectConnectAndSubjectState Observable Integer o1 Observable just 10 Observable Integer o2 Observable just 20 Observable Integer combined Observable combineLatest o1 o2 new Func2 Integer Integer Integer @Override public Integer call Integer t1 Integer t2 return t1 t2 publish refCount TestSubscriber Integer ts1 new TestSubscriber Integer TestSubscriber Integer ts2 new TestSubscriber Integer combined subscribe ts1 combined subscribe ts2 ts1 assertTerminalEvent ts1 assertNoErrors ts1 assertReceivedOnNext Arrays asList 30 ts2 assertTerminalEvent ts2 assertNoErrors ts2 assertReceivedOnNext Arrays asList 30','cc @headinthebox and @mattpodwysocki This is based on our email conversation and is a proposed change to make publish refCount and other similar multicast use cases behave as a user would expect RxJava pull requests #1436 https netflixoss ci cloudbees com job RxJava pull requests 1436 SUCCESS This pull request looks good Here is another example to demonstrate why this change is probably a good thing Output without this pull request 0 1 2 3 4 0 1 2 3 4 0 1 2 3 0 1 2 3 4 0 Start again With this pull request what a user would expect 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 8 0 0 1 Start again 0 1 2 3 4 5 6 7 0 1 2 3 4 5 0 1 2 0 1 2 Example code java import java util List import java util concurrent TimeUnit import rx Observable import rx Subscriber import rx schedulers Schedulers public class DebounceBuffer public static void main String args The following will emit a buffered list as it is debounced first we multicast the stream using refCount so it handles the subscribe unsubscribe Observable Integer burstStream intermittentBursts take 20 publish refCount then we get the debounced version Observable Integer debounced burstStream debounce 10 TimeUnit MILLISECONDS then the buffered one that uses the debounced stream to demark window start stop Observable List Integer buffered burstStream buffer debounced then we subscribe to the buffered stream so it does what we want buffered toBlocking forEach System out println System out println Start again buffered toBlocking forEach System out println public static Observable Integer intermittentBursts return Observable create Subscriber super Integer s while s isUnsubscribed burst some number of items for int i 0 i Math random 20 i s onNext i try sleep for a random amount of time Thread sleep long Math random 1000 catch Exception e do nothing subscribeOn Schedulers newThread use newThread since we are using sleep to block 1 here for the change It proves subjects are nasty things And that anything that has side effects should be I will loose some quizzes in my Rx course because it is fun to show what happens when you reconnect to an infinite vs a finite sequence I will loose some quizzes in my Rx course because it is fun to show what happens when you reconnect to an infinite vs a finite sequence Thanks for the review Merging this',RxJava,true,false,false
38725417,'Amb with backpressure support','For #1475','RxJava pull requests #1437 https netflixoss ci cloudbees com job RxJava pull requests 1437 SUCCESS This pull request looks good Please take a look at https github com Netflix RxJava pull 1533 which builds on top of your change Close as done in #1533 RxJava pull requests #1437 https netflixoss ci cloudbees com job RxJava pull requests 1437 SUCCESS This pull request looks good Please take a look at https github com Netflix RxJava pull 1533 which builds on top of your change Close as done in #1533',RxJava,true,false,false
38762961,'0 20 0 Release','Version 0 20 0 RC3 has passed the Netflix API production canary tests for 20 hours with good performance numbers and no functional issues we re aware of Despite much that can continue to be worked on there doesn t appear to be anything that must be done before 0 20 0 is released I would however like to know from other users particularly those on Android if 0 20 0 RC3 is working correctly Please test and report back Also this is the last chance to dispute any of the design or API decisions in 0 20 before they are finalized and we start our work on 1 0 release candidates Thank you all','@benjchristensen I try to understand the assumptions for Producer request Here is my thought happen before relation subscriber onStart 1st request emit 1st event 1st onNext 2nd request means happen before relation The data source such as OnSubscribeRange and OnSubscribeFromIterable does not need to handle the currency of Producer request because observeOn will dispatch request s to the same scheduler Please correct me if I made a mistake happen before relation Mostly correct except that in RxJava since request pull behavior is optional there is nothing preventing an Observable OnSubscribe emitting events before a request occurs The onStart will always happen before but then it branches into two paths Observable OnSubscribe that calls setProducer where a request happens before emissions Observable OnSubscribe that does not call setProducer where emission can happen before or after a request the request is ignored because observeOn will dispatch requests to the same scheduler This is not correct for observeOn but is correct for subscribeOn The observeOn case can result in work being stolen and run by the observeOn Scheduler rather than wherever the Observable OnSubscribe originally started it You can see how subscribeOn does this here https github com Netflix RxJava blob 82c634fdf93cc6608c3bb94645ae14b2232abd74 rxjava core src main java rx internal operators OperatorSubscribeOn java#L90 observeOn on the other hand could steal the work and execute it directly see here https github com Netflix RxJava blob master rxjava core src main java rx internal operators OperatorObserveOn java#L184 if the upstream Observable is synchronous @benjchristensen have been using on a development branch and everything remains working fine within the scope of what I use from rxjava an the android extensions I replaced RxJava 0 19 6 with 0 20 0 RC3 in cgeo for Android http github com cgeo cgeo I got hit by E cgeo 394 java lang RuntimeException Timed out waiting for value File a bug at github com Netflix RxJava E cgeo 394 at rx internal operators BlockingOperatorToIterator 2 take BlockingOperatorToIterator java 97 E cgeo 394 at rx internal operators BlockingOperatorToIterator 2 hasNext BlockingOperatorToIterator java 73 E cgeo 394 at rx internal operators BlockingOperatorToIterator 2 next BlockingOperatorToIterator java 83 E cgeo 394 at rx observables BlockingObservable single BlockingObservable java 348 E cgeo 394 at rx observables BlockingObservable first BlockingObservable java 165 E cgeo 394 at cgeo geocaching SearchResult parallelCombineActive SearchResult java 317 However it looks like this timeout is arbitrary and is going to be removed before 0 20 https github com Netflix RxJava blob master rxjava core src main java rx internal operators BlockingOperatorToIterator java#L93 java TODO remove this timeout and logging before final release of 0 20 Notification extends T n notifications poll 10000 TimeUnit MILLISECONDS if n null System err println Timed out waiting for value File a bug at github com Netflix RxJava throw new RuntimeException Timed out waiting for value File a bug at github com Netflix RxJava else return n So I won t file a bug about it Apart from that everything went fine Played some time with latest version of RxJava on current application but without using any new introduced in 20 api Everything seems to works fine except strange issue I had before that I m sure is pretty much the same as https github com Netflix RxJava issues 1234 Everything else works fine for me @samueltardieu Thanks for the feedback As long as the reason for the RuntimeException was that your code had a legit reason to take longer than 10 seconds then that s fine That code has been left in to help us find hangs due to bugs @Yarikx Thanks I m most concerned right now about existing functionality working as expected so that s exactly the feedback I need If you can provide more information on #1234 we can reopen it @dpsm Thanks for the confirmation Ok I will try to write reproducible code little bit later In my case this problem occurs in some special combination of observables that run through different schedulers On Jul 29 2014 9 08 PM Ben Christensen notifications@github com wrote @samueltardieu https github com samueltardieu Thanks for the feedback As long as the reason for the RuntimeException was that your code had a legit reason to take longer than 10 seconds then that s fine That code has been left in to help us find hangs due to bugs @Yarikx https github com Yarikx Thanks I m most concerned right now about existing functionality working as expected so that s exactly the feedback I need If you can provide more information on #1234 https github com Netflix RxJava issues 1234 we can reopen it Reply to this email directly or view it on GitHub https github com Netflix RxJava issues 1517#issuecomment 50515074 @benjchristensen I updated to 0 20 and my harness doesn t report any errors so thumbs up Thanks @daschl for the test and confirmation Version 0 20 0 RC4 is released with further fixes and enhancements https github com Netflix RxJava releases tag 0 20 0 RC4 This code ran successfully for 18 hours in a Netflix production canary before release There are however still some issues that concern me that are causing non deterministic hangs and failures of unit tests In particular #1536 Outstanding items https github com Netflix RxJava issues q is 3Aopen is 3Aissue milestone 3A0 20',RxJava,false,false,false
38767053,'Fix typos in javadoc comments','Recieve Receive','RxJava pull requests #1438 https netflixoss ci cloudbees com job RxJava pull requests 1438 SUCCESS This pull request looks good Thanks',RxJava,true,false,false
38767460,'Remove unused param comments','Fixed https github com Netflix RxJava issues 1426','',RxJava,true,false,false
38768060,'Fix non deterministic test','Fixes https github com Netflix RxJava issues 1429','RxJava pull requests #1439 https netflixoss ci cloudbees com job RxJava pull requests 1439 SUCCESS This pull request looks good',RxJava,true,false,false
38770696,'Fix toIterator Exception Handling','Fixes https github com Netflix RxJava issues 1450','RxJava pull requests #1440 https netflixoss ci cloudbees com job RxJava pull requests 1440 SUCCESS This pull request looks good',RxJava,true,false,false
38812983,'OperatorFilter failure','This test hangs with 0 20 0 RC3 I m supposing because of OperatorFilter java import org junit Assert import org junit Test import rx Observable import rx functions Functions public class BackpressureTest @Test public void testDoesNotHang Assert assertEquals 0 Observable empty count filter Functions alwaysFalse toList toBlocking single size','Thanks for the report I ll take a look soon @benjchristensen I m working on it Looks a bug in takeLast',RxJava,false,false,false
38820671,'Fix issue #1522','TakeLast should ignore other request s if it s requested with Long MAX_VALUE #1522','RxJava pull requests #1441 https netflixoss ci cloudbees com job RxJava pull requests 1441 SUCCESS This pull request looks good RxJava pull requests #1442 https netflixoss ci cloudbees com job RxJava pull requests 1442 SUCCESS This pull request looks good RxJava pull requests #1443 https netflixoss ci cloudbees com job RxJava pull requests 1443 SUCCESS This pull request looks good RxJava pull requests #1445 https netflixoss ci cloudbees com job RxJava pull requests 1445 SUCCESS This pull request looks good RxJava pull requests #1450 https netflixoss ci cloudbees com job RxJava pull requests 1450 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1453 https netflixoss ci cloudbees com job RxJava pull requests 1453 SUCCESS This pull request looks good I think this looks good though I m still curious if the complexity here is worth us having a fast path Would be interesting to do JMH testing In OnSubscribeFromRange it does make a difference but here I question it because every onNext is passing through a Queue',RxJava,true,false,false
38848498,'Bump to Robolectric 2 3 make samples build under Studio 0 8','This should help get https github com Netflix RxJava pull 1449 off the ground','RxJava pull requests #1444 https netflixoss ci cloudbees com job RxJava pull requests 1444 SUCCESS This pull request looks good',RxJava,true,false,false
38885083,'Bug in Mpsc queue should compare head to tail not itself in peekNode','https github com Netflix RxJava blob master rxjava core src main java rx internal util MpscPaddedQueue java#L124','',RxJava,false,false,false
38937631,'Restore use of SpmcArrayQueue in RxRingBuffer','Modification of SpmcArrayQueue with fix from https github com JCTools JCTools issues 21 I expect updates to this code over time but wanted to move forward with a working solution for now Restore RxRingBuffer to use SpmcArrayQueue this reduces object allocation significantly and increases performance in some use cases ### Performance Diff #### 0 20 0 RC3 gradlew benchmarks Pjmh f 1 wi 5 i 5 r 2 rx internal RxRingBufferPerf Benchmark Mode Samples Score Score error Units r i RxRingBufferPerf spmcCreateUseAndDestroy1 thrpt 5 33224158 580 399867 898 ops s r i RxRingBufferPerf spmcCreateUseAndDestroy1000 thrpt 5 73346 934 853 989 ops s r i RxRingBufferPerf spmcRingBufferAddRemove1 thrpt 5 22034846 226 579563 777 ops s r i RxRingBufferPerf spmcRingBufferAddRemove1000 thrpt 5 21612 517 567 086 ops s r i RxRingBufferPerf spscCreateUseAndDestroy1 thrpt 5 32277699 473 2481022 929 ops s r i RxRingBufferPerf spscCreateUseAndDestroy1000 thrpt 5 72782 657 3836 229 ops s r i RxRingBufferPerf spscRingBufferAddRemove1 thrpt 5 21625427 399 555584 413 ops s r i RxRingBufferPerf spscRingBufferAddRemove1000 thrpt 5 21588 532 875 871 ops s gradlew benchmarks Pjmh f 1 wi 5 i 5 r 2 rx operators OperatorMergePerf Benchmark size Mode Samples Score Score error Units r o OperatorMergePerf merge1SyncStreamOfN 1 thrpt 5 5066495 356 73296 083 ops s r o OperatorMergePerf merge1SyncStreamOfN 1000 thrpt 5 55094 237 1067 519 ops s r o OperatorMergePerf merge1SyncStreamOfN 1000000 thrpt 5 57 981 1 324 ops s r o OperatorMergePerf mergeNAsyncStreamsOfN 1 thrpt 5 97273 839 9582 028 ops s r o OperatorMergePerf mergeNAsyncStreamsOfN 1000 thrpt 5 4 754 0 115 ops s r o OperatorMergePerf mergeNSyncStreamsOf1 1 thrpt 5 4384357 616 302930 385 ops s r o OperatorMergePerf mergeNSyncStreamsOf1 100 thrpt 5 278124 421 36626 222 ops s r o OperatorMergePerf mergeNSyncStreamsOf1 1000 thrpt 5 35179 120 1059 293 ops s r o OperatorMergePerf mergeNSyncStreamsOfN 1 thrpt 5 5383548 483 125915 654 ops s r o OperatorMergePerf mergeNSyncStreamsOfN 1000 thrpt 5 54 551 3 245 ops s r o OperatorMergePerf mergeTwoAsyncStreamsOfN 1 thrpt 5 66546 808 30474 772 ops s r o OperatorMergePerf mergeTwoAsyncStreamsOfN 1000 thrpt 5 2828 244 103 470 ops s r o OperatorMergePerf oneStreamOfNthatMergesIn1 1 thrpt 5 5030721 519 181734 814 ops s r o OperatorMergePerf oneStreamOfNthatMergesIn1 1000 thrpt 5 24489 183 759 520 ops s r o OperatorMergePerf oneStreamOfNthatMergesIn1 1000000 thrpt 5 30 101 0 802 ops s Memory allocation capture with Java Flight Recorder while executing gradlew benchmarks Pjmh f 1 wi 5 i 5 r 20 rx operators OperatorMergePerf mergeNAsyncStreamsOfN object allocation with linkedlist https cloud githubusercontent com assets 813492 3727745 35c44dca 16a1 11e4 89c1 7a1c2475bcbb png #### with JCTools impl gradlew benchmarks Pjmh f 1 wi 5 i 5 r 2 rx internal RxRingBufferPerf Benchmark Mode Samples Score Score error Units r i RxRingBufferPerf spmcCreateUseAndDestroy1 thrpt 5 27028267 871 2547216 752 ops s r i RxRingBufferPerf spmcCreateUseAndDestroy1000 thrpt 5 78238 446 2539 165 ops s r i RxRingBufferPerf spmcRingBufferAddRemove1 thrpt 5 43396574 546 918454 062 ops s r i RxRingBufferPerf spmcRingBufferAddRemove1000 thrpt 5 64074 506 531 873 ops s r i RxRingBufferPerf spscCreateUseAndDestroy1 thrpt 5 27163028 506 506868 149 ops s r i RxRingBufferPerf spscCreateUseAndDestroy1000 thrpt 5 77472 474 2875 597 ops s r i RxRingBufferPerf spscRingBufferAddRemove1 thrpt 5 43309504 983 337590 502 ops s r i RxRingBufferPerf spscRingBufferAddRemove1000 thrpt 5 64140 916 1292 265 ops s gradlew benchmarks Pjmh f 1 wi 5 i 5 r 2 rx operators OperatorMergePerf Benchmark size Mode Samples Score Score error Units r o OperatorMergePerf merge1SyncStreamOfN 1 thrpt 5 5146417 279 168011 480 ops s r o OperatorMergePerf merge1SyncStreamOfN 1000 thrpt 5 56640 224 789 709 ops s r o OperatorMergePerf merge1SyncStreamOfN 1000000 thrpt 5 60 610 1 022 ops s r o OperatorMergePerf mergeNAsyncStreamsOfN 1 thrpt 5 97759 963 1897 592 ops s r o OperatorMergePerf mergeNAsyncStreamsOfN 1000 thrpt 5 5 937 0 404 ops s r o OperatorMergePerf mergeNSyncStreamsOf1 1 thrpt 5 4511685 053 136414 240 ops s r o OperatorMergePerf mergeNSyncStreamsOf1 100 thrpt 5 285644 030 9325 626 ops s r o OperatorMergePerf mergeNSyncStreamsOf1 1000 thrpt 5 32789 901 1143 208 ops s r o OperatorMergePerf mergeNSyncStreamsOfN 1 thrpt 5 5415231 898 107538 428 ops s r o OperatorMergePerf mergeNSyncStreamsOfN 1000 thrpt 5 55 918 0 660 ops s r o OperatorMergePerf mergeTwoAsyncStreamsOfN 1 thrpt 5 74341 892 3274 847 ops s r o OperatorMergePerf mergeTwoAsyncStreamsOfN 1000 thrpt 5 4138 087 329 935 ops s r o OperatorMergePerf oneStreamOfNthatMergesIn1 1 thrpt 5 5026384 994 242183 595 ops s r o OperatorMergePerf oneStreamOfNthatMergesIn1 1000 thrpt 5 24700 473 334 516 ops s r o OperatorMergePerf oneStreamOfNthatMergesIn1 1000000 thrpt 5 30 458 0 603 ops s Memory allocation capture with Java Flight Recorder while executing gradlew benchmarks Pjmh f 1 wi 5 i 5 r 20 rx operators OperatorMergePerf mergeNAsyncStreamsOfN object allocation with arrayqueue https cloud githubusercontent com assets 813492 3727746 38de2d8c 16a1 11e4 93cd 32dba4497a5f png','Note that in this comparison 1 minute test of mergeNAsyncStreamsOfN over 6GB of object allocation is eliminated by changing the data structure RxJava pull requests #1446 https netflixoss ci cloudbees com job RxJava pull requests 1446 SUCCESS This pull request looks good',RxJava,true,false,false
38957822,'Failing unit test for reduce showing it does not implement backpressure correctly','','reduce scan takeLast and takeLast backpressure bug #1522 is being worked on in PR #1523 at the moment so they will probably appreciate this extra unit test RxJava pull requests #1447 https netflixoss ci cloudbees com job RxJava pull requests 1447 FAILURE Looks like there s a problem with this pull request Just added another unit test Interestingly source reduce sum fails and source reduce 0 sum succeeds RxJava pull requests #1448 https netflixoss ci cloudbees com job RxJava pull requests 1448 FAILURE Looks like there s a problem with this pull request Thanks for finding and fixing this I complete missed single in my pass through operators @mattrjacobs Can you touch this PR again to kick off builds and validate whether it is now fixed with #1529 merged After takeLast implementaion was fixed this unit test passes',RxJava,true,false,false
38977043,'Add operators to create Observables from BroadcastReceiver rebased','Rebase https github com Netflix RxJava pull 1449 on the top of https github com Netflix RxJava pull 1524 Add test for OperatorBroadcastRegister','RxJava pull requests #1449 https netflixoss ci cloudbees com job RxJava pull requests 1449 FAILURE Looks like there s a problem with this pull request LGTM @mttkay Are you also ready for this to merge 1 Thanks Are you okay with this only being released in 0 20 or do you need it back ported to 0 19 Have any of you tried 0 20 0 RC3 on Android and confirmed whether it is okay https github com Netflix RxJava issues 1517 I bumped out beta channel version to 0 20 0 RC 3 today it will go out tomorrow to our beta users I passed all our testing so far so definitely nothing major to report The issues we had were mostly due to race conditions which got fixed now which is quite difficult to reproduce in automated or even manual testing so I ll have to wait for logging to trickle in from the beta release Good to know it s passing initial tests That means the major code paths like merge and observeOn are okay on Android and I didn t make any fundamental mistakes in the sun misc Unsafe gates There are definitely still some bugs that have been found and fixed but not yet released Hopefully tomorrow I ll release RC4',RxJava,true,false,false
38987324,'Make single support backpressure Fix #1527','Fix #1527','RxJava pull requests #1451 https netflixoss ci cloudbees com job RxJava pull requests 1451 ABORTED Unit tests hang Need to fix single and takeLast together Merged it to #1523',RxJava,true,false,false
38989666,'Fix the unbounded check for merge','','RxJava pull requests #1452 https netflixoss ci cloudbees com job RxJava pull requests 1452 ABORTED Good catch thanks I don t understand what caused the build to hang https netflixoss ci cloudbees com job RxJava pull requests 1452 console Tests pass when I re run them locally and the logs don t point to anything obvious Merging this as the fixes are valid but we ll have to hunt down the hanging test',RxJava,true,false,false
39007108,'Perf Test takeLast Fast path','Validate whether the complexity of takeLast having a fast path is worth it See https github com Netflix RxJava pull 1523#issuecomment 50501023','',RxJava,false,true,false
39008216,'Added unit tests of backpressure to OperatorReduce','Replaced PR #1527','RxJava pull requests #1454 https netflixoss ci cloudbees com job RxJava pull requests 1454 FAILURE Looks like there s a problem with this pull request RxJava pull requests #1455 https netflixoss ci cloudbees com job RxJava pull requests 1455 FAILURE Looks like there s a problem with this pull request Already merged in #1527',RxJava,true,false,false
39059773,'Amb Backpressure','Building on top of https github com Netflix RxJava pull 1516','RxJava pull requests #1456 https netflixoss ci cloudbees com job RxJava pull requests 1456 ABORTED I can not yet replicate the hang that s happening on the builds It has happened around this area twice https netflixoss ci cloudbees com job RxJava pull requests 1456 console https netflixoss ci cloudbees com job RxJava pull requests 1432 console RxJava pull requests #1457 https netflixoss ci cloudbees com job RxJava pull requests 1457 SUCCESS This pull request looks good Forcing the build again shows that this change is successful and that unfortunately it is indeed a non deterministic hang somewhere Amb http www formal stanford edu jmc basis1 node7 html#SECTION00025000000000000000 with back pressure is intrinsically hard If you would do it on iterable you d need to add a thread Glancing at the code I would request just a single item from each source initially @headinthebox I don t understand the complexity of backpressure on this It is pretty straight forward to implement here Whatever the child requests we propagate to each of the parent Observable s and whichever one emits first wins and continues in the reactive pull relationship with the child All the others are unsubscribed and emissions ignored This means the request n count has a 1 1 relationship with whichever the winner is What am I missing @zsxwing can you please review the various changes I ve made to prevent race conditions and memory leaks RxJava pull requests #1459 https netflixoss ci cloudbees com job RxJava pull requests 1459 FAILURE Looks like there s a problem with this pull request Ha I accidentally didn t commit the chunk of the file including the imports re committing RxJava pull requests #1460 https netflixoss ci cloudbees com job RxJava pull requests 1460 SUCCESS This pull request looks good Rebased to collapse my 3 commits Forced commit Merging Thanks @zsxwing for the reviews and your initial work on this RxJava pull requests #1461 https netflixoss ci cloudbees com job RxJava pull requests 1461 ABORTED RxJava pull requests #1456 https netflixoss ci cloudbees com job RxJava pull requests 1456 ABORTED I can not yet replicate the hang that s happening on the builds It has happened around this area twice https netflixoss ci cloudbees com job RxJava pull requests 1456 console https netflixoss ci cloudbees com job RxJava pull requests 1432 console RxJava pull requests #1457 https netflixoss ci cloudbees com job RxJava pull requests 1457 SUCCESS This pull request looks good Forcing the build again shows that this change is successful and that unfortunately it is indeed a non deterministic hang somewhere Amb http www formal stanford edu jmc basis1 node7 html#SECTION00025000000000000000 with back pressure is intrinsically hard If you would do it on iterable you d need to add a thread Glancing at the code I would request just a single item from each source initially @headinthebox I don t understand the complexity of backpressure on this It is pretty straight forward to implement here Whatever the child requests we propagate to each of the parent Observable s and whichever one emits first wins and continues in the reactive pull relationship with the child All the others are unsubscribed and emissions ignored This means the request n count has a 1 1 relationship with whichever the winner is What am I missing @zsxwing can you please review the various changes I ve made to prevent race conditions and memory leaks RxJava pull requests #1459 https netflixoss ci cloudbees com job RxJava pull requests 1459 FAILURE Looks like there s a problem with this pull request Ha I accidentally didn t commit the chunk of the file including the imports re committing RxJava pull requests #1460 https netflixoss ci cloudbees com job RxJava pull requests 1460 SUCCESS This pull request looks good Rebased to collapse my 3 commits Forced commit Merging Thanks @zsxwing for the reviews and your initial work on this RxJava pull requests #1461 https netflixoss ci cloudbees com job RxJava pull requests 1461 ABORTED',RxJava,true,true,true
39064999,'Concat Backpressure','Route backpressure through the inner subscribers Fixes https github com Netflix RxJava issues 1480','RxJava pull requests #1458 https netflixoss ci cloudbees com job RxJava pull requests 1458 SUCCESS This pull request looks good',RxJava,true,false,false
39114834,'If Subscriber was unsubscribed once it won t receive onNext next time somebody will subscribe using it','java private Subscriber Location onLocationUpdated new Subscriber Location @Override public void onNext Location location never called when was resumed after pause Subscription subscription Subscriptions empty void onResume subscription locationService observe subscribe onLocationUpdated void onPause subscription unsubscribe I have a class field with subscriber implementation When my UI resumed I subscribe using that subscriber on location updates When UI is paused I unsubscribe Subscriber is field is not destroyed when UI is paused and should be reused for subscribe on UI resume Unfortunately onNext will be never called Guess this related to this fix #1409','A Subscriber should not be reused It will not work because it is a Subscription and once unsubscribed is done Use an Observer instead if you want to reuse it Got it',RxJava,false,false,false
39116619,'Non deterministic Hang ExceptionsTest','Three builds have hung around the same place near here rx exceptions ExceptionsTest testStackOverflowIsThrown STANDARD_OUT rx exceptions ExceptionsTest STANDARD_OUT The logs can be seen at https netflixoss ci cloudbees com job RxJava pull requests 1456 console https netflixoss ci cloudbees com job RxJava pull requests 1432 console https netflixoss ci cloudbees com job RxJava pull requests 1461 console I have tried to replicate in the ExceptionsTest code but have not succeeded','',RxJava,false,true,true
39187632,'recursive scheduling in RxScala','This PR adds a scheduleRec method to the Scheduler Worker trait to make recursive scheduling more convenient in Scala This issue is raised in #1348','RxJava pull requests #1462 https netflixoss ci cloudbees com job RxJava pull requests 1462 FAILURE Looks like there s a problem with this pull request Not sure why the cloudbees build fails The assertion error in rx BackpressureTests testMergeAsyncThenObserveOn has nothing to do with these changes Also the build succeeds locally with the changes merged into the latest master',RxJava,true,false,false
39204781,'Non deterministic test failure testMergeAsyncThenObserveOn','This test failed non deterministically in https github com Netflix RxJava pull 1537 https netflixoss ci cloudbees com job RxJava pull requests 1462 testReport junit rx BackpressureTests testMergeAsyncThenObserveOn java lang AssertionError at org junit Assert fail Assert java 92 at org junit Assert assertTrue Assert java 43 at org junit Assert assertTrue Assert java 54 at rx BackpressureTests testMergeAsyncThenObserveOn BackpressureTests java 139 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 57 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at java lang reflect Method invoke Method java 606 at org junit runners model FrameworkMethod 1 runReflectiveCall FrameworkMethod java 45 at org junit internal runners model ReflectiveCallable run ReflectiveCallable java 15 at org junit runners model FrameworkMethod invokeExplosively FrameworkMethod java 42 at org junit internal runners statements InvokeMethod evaluate InvokeMethod java 20 at org junit runners ParentRunner runLeaf ParentRunner java 263 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 68 at org junit runners BlockJUnit4ClassRunner runChild BlockJUnit4ClassRunner java 47 at org junit runners ParentRunner 3 run ParentRunner java 231 at org junit runners ParentRunner 1 schedule ParentRunner java 60 at org junit runners ParentRunner runChildren ParentRunner java 229 at org junit runners ParentRunner access 000 ParentRunner java 50 at org junit runners ParentRunner 2 evaluate ParentRunner java 222 at org junit runners ParentRunner run ParentRunner java 300 at org gradle api internal tasks testing junit JUnitTestClassExecuter runTestClass JUnitTestClassExecuter java 80 at org gradle api internal tasks testing junit JUnitTestClassExecuter execute JUnitTestClassExecuter java 47 at org gradle api internal tasks testing junit JUnitTestClassProcessor processTestClass JUnitTestClassProcessor java 69 at org gradle api internal tasks testing SuiteTestClassProcessor processTestClass SuiteTestClassProcessor java 49 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 57 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at java lang reflect Method invoke Method java 606 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 35 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 24 at org gradle messaging dispatch ContextClassLoaderDispatch dispatch ContextClassLoaderDispatch java 32 at org gradle messaging dispatch ProxyDispatchAdapter DispatchingInvocationHandler invoke ProxyDispatchAdapter java 93 at com sun proxy Proxy2 processTestClass Unknown Source at org gradle api internal tasks testing worker TestWorker processTestClass TestWorker java 103 at sun reflect NativeMethodAccessorImpl invoke0 Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 57 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 at java lang reflect Method invoke Method java 606 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 35 at org gradle messaging dispatch ReflectionDispatch dispatch ReflectionDispatch java 24 at org gradle messaging remote internal hub MessageHub Handler run MessageHub java 355 at org gradle internal concurrent DefaultExecutorFactory StoppableExecutorImpl 1 run DefaultExecutorFactory java 66 at java util concurrent ThreadPoolExecutor runWorker ThreadPoolExecutor java 1145 at java util concurrent ThreadPoolExecutor Worker run ThreadPoolExecutor java 615 at java lang Thread run Thread java 744','',RxJava,false,true,true
39257025,'Need help with composition of several observables','Observable String observable1 Observable Boolean observable2 Observable Void observable3 I need to to create observable3 that will produce values on every change of observable1 when observable2 last value is True Will appreciate any help','do you mean latest value of obs2 is true or last value Here are some options that might get you moving in the direction you want java import java util concurrent TimeUnit import rx Observable public class CombineLatestAndFilter public static void main String args Observable String observable1 Observable interval 1 TimeUnit MILLISECONDS map i value_ i Observable Boolean observable2 Observable interval 7 TimeUnit MILLISECONDS map i i 2 0 true false startWith false Solution A This works as long as you re okay if the last observable1 value is emitted when observable2 changes from false to true Observable String observable3a Observable combineLatest observable1 observable2 o1 o2 System out println o1 o1 o2 o2 return new Object o1 o2 poor excuse for a tuple filter oo Boolean oo 1 map oo String oo 0 Solution B This adds distinctUntilChanged so that it won t emit during the change from false true However this means it could also skip values from observable1 if duplicates are expected so it can only be used if the values are expected to be unique Observable String observable3b Observable combineLatest observable1 observable2 o1 o2 System out println o1 o1 o2 o2 return new Object o1 o2 poor excuse for a tuple distinctUntilChanged oo String oo 0 filter oo Boolean oo 1 map oo String oo 0 Solution C This gets more complicated by zipping observable1 with a range to index it so we can de dupe on the index number instead of the value in case we need to handle possible duplicate values and solution A above is not okay Observable Object observable1withIndex observable1 zipWith Observable range 0 Integer MAX_VALUE v i new Object v i Observable String observable3c Observable combineLatest observable1withIndex observable2 o1 o2 System out println o1 o1 0 index o1 1 o2 o2 return new Object o1 1 repetitive value o2 poor excuse for a tuple distinctUntilChanged oo oo 0 filter oo Boolean oo 2 map oo String oo 1 observable3a take 20 toBlocking forEach System out println observable3b take 20 toBlocking forEach System out println observable3c take 20 toBlocking forEach System out println @benjchristensen Thank you for your quick response This was very helpful I believe the solution A you ve suggested will suffice with solving my problem Great good luck',RxJava,false,false,false
39259531,'BufferWithSize backpressure','Added backpressure handling to OperatorBufferWithSize This was required because requesting 1 item a list from an OperatorBufferWithSize subscriber translates to requesting count n 1 skip items from upstream Includes unit tests that failed with 0 20 0 RC4','RxJava pull requests #1464 https netflixoss ci cloudbees com job RxJava pull requests 1464 SUCCESS This pull request looks good oops @zsxwing had already done this and didn t make it into 0 20 0 RC4 for some reason I notice that my PR doesn t do max and min value tests for overflow and to push through the unlimited case @zsxwing also has some useful performance optimizations by the looks of it too I ll close this PR',RxJava,true,false,false
